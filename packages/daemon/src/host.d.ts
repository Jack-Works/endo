export function makeHostMaker({ provide, provideController, cancelValue, formulateWorker, formulateHost, formulateGuest, formulateMarshalValue, formulateEval, formulateUnconfined, formulateBundle, formulateReadableBlob, formulateInvitation, getAllNetworkAddresses, makeMailbox, makeDirectoryNode, localNodeId, }: {
    provide: import("./types.js").Provide;
    provideController: (id: string) => import("./types.js").Controller<unknown>;
    cancelValue: (id: string, reason: Error) => Promise<void>;
    formulateWorker: (deferredTasks: DeferredTasks<WorkerDeferredTaskParams>) => import("./types.js").FormulateResult<import("./types.js").EndoWorker>;
    formulateHost: (endoId: string, networksDirectoryId: string, deferredTasks: DeferredTasks<AgentDeferredTaskParams>, specifiedWorkerId?: string | undefined) => import("./types.js").FormulateResult<EndoHost>;
    formulateGuest: (hostId: string, hostHandleId: string, deferredTasks: DeferredTasks<AgentDeferredTaskParams>) => import("./types.js").FormulateResult<EndoGuest>;
    formulateMarshalValue: (value: import("@endo/pass-style").Passable, deferredTasks: DeferredTasks<MarshalDeferredTaskParams>) => import("./types.js").FormulateResult<void>;
    formulateEval: (nameHubId: string, source: string, codeNames: string[], endowmentIdsOrPaths: (string | string[])[], deferredTasks: DeferredTasks<EvalDeferredTaskParams>, specifiedWorkerId?: string | undefined) => import("./types.js").FormulateResult<unknown>;
    formulateUnconfined: (hostAgentId: string, hostHandleId: string, specifier: string, deferredTasks: DeferredTasks<MakeCapletDeferredTaskParams>, specifiedWorkerId?: string | undefined, specifiedPowersId?: string | undefined) => import("./types.js").FormulateResult<unknown>;
    formulateBundle: (hostAgentId: string, hostHandleId: string, bundleId: string, deferredTasks: DeferredTasks<MakeCapletDeferredTaskParams>, specifiedWorkerId?: string | undefined, specifiedPowersId?: string | undefined) => import("./types.js").FormulateResult<unknown>;
    formulateReadableBlob: (readerRef: ERef<AsyncIterableIterator<string>>, deferredTasks: DeferredTasks<ReadableBlobDeferredTaskParams>) => import("./types.js").FormulateResult<import("@endo/far").FarRef<import("./types.js").EndoReadable>>;
    formulateInvitation: (hostAgentId: string, hostHandleId: string, guestName: string, deferredTasks: DeferredTasks<InvitationDeferredTaskParams>) => import("./types.js").FormulateResult<import("./types.js").Invitation>;
    getAllNetworkAddresses: (networksDirectoryId: string) => Promise<string[]>;
    makeMailbox: MakeMailbox;
    makeDirectoryNode: MakeDirectoryNode;
    localNodeId: string;
}): (hostId: string, handleId: string, storeId: string, inspectorId: string, mainWorkerId: string, endoId: string, networksDirectoryId: string, leastAuthorityId: string, platformNames: {
    [name: string]: string;
}, context: Context) => Promise<import("@endo/exo").Guarded<{
    /** @param {string} locator */
    followLocatorNameChanges: (locator: string) => import("@endo/eventual-send").FarRef<import("@endo/stream").Reader<import("./types.js").LocatorNameChange>>;
    followMessages: () => import("@endo/eventual-send").FarRef<import("@endo/stream").Reader<import("./types.js").StampedMessage>>;
    followNameChanges: () => import("@endo/eventual-send").FarRef<import("@endo/stream").Reader<import("./types.js").PetStoreNameChange>>;
    storeBlob(readerRef: ERef<AsyncIterableIterator<string>>, petName: string): Promise<import("@endo/far").FarRef<import("./types.js").EndoReadable>>;
    storeValue<T extends import("@endo/pass-style").Passable>(value: T, petName: string): Promise<void>;
    provideGuest(petName?: string | undefined, opts?: MakeHostOrGuestOptions | undefined): Promise<EndoGuest>;
    provideHost(petName?: string | undefined, opts?: MakeHostOrGuestOptions | undefined): Promise<EndoHost>;
    /** @type {DeferredTasks<InvitationDeferredTaskParams>} */
    makeDirectory(petName: string): Promise<import("./types.js").EndoDirectory>;
    provideWorker(petName: string): Promise<import("./types.js").EndoWorker>;
    evaluate(workerPetName: string | undefined, source: string, codeNames: string[], petNames: string[], resultName?: string | undefined): Promise<unknown>;
    makeUnconfined(workerName: string, specifier: string, powersName: string, resultName?: string | undefined): Promise<unknown>;
    makeBundle(workerPetName: string | undefined, bundleName: string, powersName: string, resultName?: string | undefined): Promise<unknown>;
    cancel(petName: string, reason: Error): Promise<void>;
    greeter(): Promise<import("./types.js").EndoGreeter>;
    gateway(): Promise<import("./types.js").EndoGateway>;
    getPeerInfo(): Promise<PeerInfo>;
    addPeerInfo(peerInfo: PeerInfo): Promise<void>;
    invite(guestName: string): Promise<import("./types.js").Invitation>;
    accept(invitationId: string, guestHandleId: string, guestName: string): Promise<void>;
    handle: () => {};
    listMessages: () => Promise<import("./types.js").StampedMessage[]>;
    resolve: (messageNumber: number, resolutionName: string) => Promise<void>;
    reject: (messageNumber: number, message?: string | undefined) => Promise<void>;
    adopt: (messageNumber: number, edgeName: string, petName: string) => Promise<void>;
    dismiss: (messageNumber: number) => Promise<void>;
    request: (recipientName: string, what: string, responseName: string) => Promise<unknown>;
    send: (recipientName: string, strings: string[], edgeNames: string[], petNames: string[]) => Promise<void>;
    deliver: (message: import("./types.js").EnvelopedMessage) => void;
    reverseIdentify(id: string): string[];
    has(...petNamePath: string[]): Promise<boolean>;
    identify(...petNamePath: string[]): Promise<string | undefined>;
    locate(...petNamePath: string[]): Promise<string | undefined>;
    reverseLocate(locator: string): Promise<string[]>;
    list(...petNamePath: string[]): Promise<string[]>;
    listIdentifiers(...petNamePath: string[]): Promise<string[]>;
    lookup(...petNamePath: string[]): Promise<unknown>;
    reverseLookup(value: unknown): string[];
    write(petNamePath: string[], id: string): Promise<void>;
    remove(...petNamePath: string[]): Promise<void>;
    move(fromPetName: string[], toPetName: string[]): Promise<void>;
    copy(fromPetName: string[], toPetName: string[]): Promise<void>;
}>>;
import type { WorkerDeferredTaskParams } from './types.js';
import type { DeferredTasks } from './types.js';
import type { AgentDeferredTaskParams } from './types.js';
import type { EndoHost } from './types.js';
import type { EndoGuest } from './types.js';
import type { MarshalDeferredTaskParams } from './types.js';
import type { EvalDeferredTaskParams } from './types.js';
import type { MakeCapletDeferredTaskParams } from './types.js';
import type { ERef } from '@endo/eventual-send';
import type { ReadableBlobDeferredTaskParams } from './types.js';
import type { InvitationDeferredTaskParams } from './types.js';
import type { MakeMailbox } from './types.js';
import type { MakeDirectoryNode } from './types.js';
import type { Context } from './types.js';
import type { MakeHostOrGuestOptions } from './types.js';
import type { PeerInfo } from './types.js';
//# sourceMappingURL=host.d.ts.map
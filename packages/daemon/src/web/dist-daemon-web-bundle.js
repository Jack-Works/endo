'use strict';
(() => {
  const functors = [
// === functors[0] ===
({   imports: $h‍_imports,   liveVar: $h‍_live,   onceVar: $h‍_once,   importMeta: $h‍____meta, }) => (function () {   $h‍_imports([]);   /* global process */
globalThis.process=  {
  // version is less than 10.12.0 for fs.mkdir recursive polyfill
  version: '0.0.0',
  env: {},
  cwd: ()=>  '/',
  // ignore handlers
  on: (event, handler)=>  {
    console.warn( `something attempted to set event "${event}" on process`,handler);
   },
  once: (event, handler)=>  {
    console.warn( `something attempted to set event "${event}" on process`,handler);
   }};
})()
,
// === functors[1] ===
({   imports: $h‍_imports,   liveVar: $h‍_live,   onceVar: $h‍_once,   importMeta: $h‍____meta, }) => (function () {   $h‍_imports([]);   /* global globalThis */
/* eslint-disable no-restricted-globals */

/**
 * commons.js
 * Declare shorthand functions. Sharing these declarations across modules
 * improves on consistency and minification. Unused declarations are
 * dropped by the tree shaking process.
 *
 * We capture these, not just for brevity, but for security. If any code
 * modifies Object to change what 'assign' points to, the Compartment shim
 * would be corrupted.
 */

// We cannot use globalThis as the local name since it would capture the
// lexical name.
const universalThis=  globalThis;$h‍_once.universalThis(universalThis);


const        {
  Array,
  Date,
  FinalizationRegistry,
  Float32Array,
  JSON,
  Map,
  Math,
  Number,
  Object,
  Promise,
  Proxy,
  Reflect,
  RegExp: FERAL_REG_EXP,
  Set,
  String,
  Symbol,
  WeakMap,
  WeakSet}=
    globalThis;$h‍_once.Array(Array);$h‍_once.Date(Date);$h‍_once.FinalizationRegistry(FinalizationRegistry);$h‍_once.Float32Array(Float32Array);$h‍_once.JSON(JSON);$h‍_once.Map(Map);$h‍_once.Math(Math);$h‍_once.Number(Number);$h‍_once.Object(Object);$h‍_once.Promise(Promise);$h‍_once.Proxy(Proxy);$h‍_once.Reflect(Reflect);$h‍_once.FERAL_REG_EXP(FERAL_REG_EXP);$h‍_once.Set(Set);$h‍_once.String(String);$h‍_once.Symbol(Symbol);$h‍_once.WeakMap(WeakMap);$h‍_once.WeakSet(WeakSet);

const        {
  // The feral Error constructor is safe for internal use, but must not be
  // revealed to post-lockdown code in any compartment including the start
  // compartment since in V8 at least it bears stack inspection capabilities.
  Error: FERAL_ERROR,
  RangeError,
  ReferenceError,
  SyntaxError,
  TypeError}=
    globalThis;$h‍_once.FERAL_ERROR(FERAL_ERROR);$h‍_once.RangeError(RangeError);$h‍_once.ReferenceError(ReferenceError);$h‍_once.SyntaxError(SyntaxError);$h‍_once.TypeError(TypeError);

const        {
  assign,
  create,
  defineProperties,
  entries,
  freeze,
  getOwnPropertyDescriptor,
  getOwnPropertyDescriptors,
  getOwnPropertyNames,
  getPrototypeOf,
  is,
  isFrozen,
  isSealed,
  isExtensible,
  keys,
  prototype: objectPrototype,
  seal,
  preventExtensions,
  setPrototypeOf,
  values,
  fromEntries}=
    Object;$h‍_once.assign(assign);$h‍_once.create(create);$h‍_once.defineProperties(defineProperties);$h‍_once.entries(entries);$h‍_once.freeze(freeze);$h‍_once.getOwnPropertyDescriptor(getOwnPropertyDescriptor);$h‍_once.getOwnPropertyDescriptors(getOwnPropertyDescriptors);$h‍_once.getOwnPropertyNames(getOwnPropertyNames);$h‍_once.getPrototypeOf(getPrototypeOf);$h‍_once.is(is);$h‍_once.isFrozen(isFrozen);$h‍_once.isSealed(isSealed);$h‍_once.isExtensible(isExtensible);$h‍_once.keys(keys);$h‍_once.objectPrototype(objectPrototype);$h‍_once.seal(seal);$h‍_once.preventExtensions(preventExtensions);$h‍_once.setPrototypeOf(setPrototypeOf);$h‍_once.values(values);$h‍_once.fromEntries(fromEntries);

const        {
  species: speciesSymbol,
  toStringTag: toStringTagSymbol,
  iterator: iteratorSymbol,
  matchAll: matchAllSymbol,
  unscopables: unscopablesSymbol,
  keyFor: symbolKeyFor,
  for: symbolFor}=
    Symbol;$h‍_once.speciesSymbol(speciesSymbol);$h‍_once.toStringTagSymbol(toStringTagSymbol);$h‍_once.iteratorSymbol(iteratorSymbol);$h‍_once.matchAllSymbol(matchAllSymbol);$h‍_once.unscopablesSymbol(unscopablesSymbol);$h‍_once.symbolKeyFor(symbolKeyFor);$h‍_once.symbolFor(symbolFor);

const        { isInteger}=   Number;$h‍_once.isInteger(isInteger);

const        { stringify: stringifyJson}=   JSON;

// Needed only for the Safari bug workaround below
$h‍_once.stringifyJson(stringifyJson);const{defineProperty:originalDefineProperty}=Object;

const        defineProperty=  (object, prop, descriptor)=>  {
  // We used to do the following, until we had to reopen Safari bug
  // https://bugs.webkit.org/show_bug.cgi?id=222538#c17
  // Once this is fixed, we may restore it.
  // // Object.defineProperty is allowed to fail silently so we use
  // // Object.defineProperties instead.
  // return defineProperties(object, { [prop]: descriptor });

  // Instead, to workaround the Safari bug
  const result=  originalDefineProperty(object, prop, descriptor);
  if( result!==  object) {
    // See https://github.com/endojs/endo/blob/master/packages/ses/error-codes/SES_DEFINE_PROPERTY_FAILED_SILENTLY.md
    throw TypeError(
       `Please report that the original defineProperty silently failed to set ${stringifyJson(
        String(prop))
        }. (SES_DEFINE_PROPERTY_FAILED_SILENTLY)`);

   }
  return result;
 };$h‍_once.defineProperty(defineProperty);

const        {
  apply,
  construct,
  get: reflectGet,
  getOwnPropertyDescriptor: reflectGetOwnPropertyDescriptor,
  has: reflectHas,
  isExtensible: reflectIsExtensible,
  ownKeys,
  preventExtensions: reflectPreventExtensions,
  set: reflectSet}=
    Reflect;$h‍_once.apply(apply);$h‍_once.construct(construct);$h‍_once.reflectGet(reflectGet);$h‍_once.reflectGetOwnPropertyDescriptor(reflectGetOwnPropertyDescriptor);$h‍_once.reflectHas(reflectHas);$h‍_once.reflectIsExtensible(reflectIsExtensible);$h‍_once.ownKeys(ownKeys);$h‍_once.reflectPreventExtensions(reflectPreventExtensions);$h‍_once.reflectSet(reflectSet);

const        { isArray, prototype: arrayPrototype}=   Array;$h‍_once.isArray(isArray);$h‍_once.arrayPrototype(arrayPrototype);
const        { prototype: mapPrototype}=   Map;$h‍_once.mapPrototype(mapPrototype);
const        { revocable: proxyRevocable}=   Proxy;$h‍_once.proxyRevocable(proxyRevocable);
const        { prototype: regexpPrototype}=   RegExp;$h‍_once.regexpPrototype(regexpPrototype);
const        { prototype: setPrototype}=   Set;$h‍_once.setPrototype(setPrototype);
const        { prototype: stringPrototype}=   String;$h‍_once.stringPrototype(stringPrototype);
const        { prototype: weakmapPrototype}=   WeakMap;$h‍_once.weakmapPrototype(weakmapPrototype);
const        { prototype: weaksetPrototype}=   WeakSet;$h‍_once.weaksetPrototype(weaksetPrototype);
const        { prototype: functionPrototype}=   Function;$h‍_once.functionPrototype(functionPrototype);
const        { prototype: promisePrototype}=   Promise;$h‍_once.promisePrototype(promisePrototype);

const        typedArrayPrototype=  getPrototypeOf(Uint8Array.prototype);$h‍_once.typedArrayPrototype(typedArrayPrototype);

const { bind}=   functionPrototype;

/**
 * uncurryThis()
 * Equivalent of: fn => (thisArg, ...args) => apply(fn, thisArg, args)
 *
 * See those reference for a complete explanation:
 * http://wiki.ecmascript.org/doku.php?id=conventions:safe_meta_programming
 * which only lives at
 * http://web.archive.org/web/20160805225710/http://wiki.ecmascript.org/doku.php?id=conventions:safe_meta_programming
 *
 * @type {<F extends (this: any, ...args: any[]) => any>(fn: F) => ((thisArg: ThisParameterType<F>, ...args: Parameters<F>) => ReturnType<F>)}
 */
const        uncurryThis=  bind.bind(bind.call); // eslint-disable-line @endo/no-polymorphic-call
$h‍_once.uncurryThis(uncurryThis);
const        objectHasOwnProperty=  uncurryThis(objectPrototype.hasOwnProperty);
//
$h‍_once.objectHasOwnProperty(objectHasOwnProperty);const arrayFilter=uncurryThis(arrayPrototype.filter);$h‍_once.arrayFilter(arrayFilter);
const        arrayForEach=  uncurryThis(arrayPrototype.forEach);$h‍_once.arrayForEach(arrayForEach);
const        arrayIncludes=  uncurryThis(arrayPrototype.includes);$h‍_once.arrayIncludes(arrayIncludes);
const        arrayJoin=  uncurryThis(arrayPrototype.join);
/** @type {<T, U>(thisArg: readonly T[], callbackfn: (value: T, index: number, array: T[]) => U, cbThisArg?: any) => U[]} */$h‍_once.arrayJoin(arrayJoin);
const        arrayMap=  /** @type {any} */  uncurryThis(arrayPrototype.map);$h‍_once.arrayMap(arrayMap);
const        arrayPop=  uncurryThis(arrayPrototype.pop);
/** @type {<T>(thisArg: T[], ...items: T[]) => number} */$h‍_once.arrayPop(arrayPop);
const        arrayPush=  uncurryThis(arrayPrototype.push);$h‍_once.arrayPush(arrayPush);
const        arraySlice=  uncurryThis(arrayPrototype.slice);$h‍_once.arraySlice(arraySlice);
const        arraySome=  uncurryThis(arrayPrototype.some);$h‍_once.arraySome(arraySome);
const        arraySort=  uncurryThis(arrayPrototype.sort);$h‍_once.arraySort(arraySort);
const        iterateArray=  uncurryThis(arrayPrototype[iteratorSymbol]);
//
$h‍_once.iterateArray(iterateArray);const mapSet=uncurryThis(mapPrototype.set);$h‍_once.mapSet(mapSet);
const        mapGet=  uncurryThis(mapPrototype.get);$h‍_once.mapGet(mapGet);
const        mapHas=  uncurryThis(mapPrototype.has);$h‍_once.mapHas(mapHas);
const        mapDelete=  uncurryThis(mapPrototype.delete);$h‍_once.mapDelete(mapDelete);
const        mapEntries=  uncurryThis(mapPrototype.entries);$h‍_once.mapEntries(mapEntries);
const        iterateMap=  uncurryThis(mapPrototype[iteratorSymbol]);
//
$h‍_once.iterateMap(iterateMap);const setAdd=uncurryThis(setPrototype.add);$h‍_once.setAdd(setAdd);
const        setDelete=  uncurryThis(setPrototype.delete);$h‍_once.setDelete(setDelete);
const        setForEach=  uncurryThis(setPrototype.forEach);$h‍_once.setForEach(setForEach);
const        setHas=  uncurryThis(setPrototype.has);$h‍_once.setHas(setHas);
const        iterateSet=  uncurryThis(setPrototype[iteratorSymbol]);
//
$h‍_once.iterateSet(iterateSet);const regexpTest=uncurryThis(regexpPrototype.test);$h‍_once.regexpTest(regexpTest);
const        regexpExec=  uncurryThis(regexpPrototype.exec);$h‍_once.regexpExec(regexpExec);
const        matchAllRegExp=  uncurryThis(regexpPrototype[matchAllSymbol]);
//
$h‍_once.matchAllRegExp(matchAllRegExp);const stringEndsWith=uncurryThis(stringPrototype.endsWith);$h‍_once.stringEndsWith(stringEndsWith);
const        stringIncludes=  uncurryThis(stringPrototype.includes);$h‍_once.stringIncludes(stringIncludes);
const        stringIndexOf=  uncurryThis(stringPrototype.indexOf);$h‍_once.stringIndexOf(stringIndexOf);
const        stringMatch=  uncurryThis(stringPrototype.match);
/**
 * @type { &
 *   ((thisArg: string, searchValue: { [Symbol.replace](string: string, replaceValue: string): string; }, replaceValue: string) => string) &
 *   ((thisArg: string, searchValue: { [Symbol.replace](string: string, replacer: (substring: string, ...args: any[]) => string): string; }, replacer: (substring: string, ...args: any[]) => string) => string)
 * }
 */$h‍_once.stringMatch(stringMatch);
const        stringReplace=  /** @type {any} */
  uncurryThis(stringPrototype.replace);$h‍_once.stringReplace(stringReplace);

const        stringSearch=  uncurryThis(stringPrototype.search);$h‍_once.stringSearch(stringSearch);
const        stringSlice=  uncurryThis(stringPrototype.slice);
/** @type {(thisArg: string, splitter: string | RegExp | { [Symbol.split](string: string, limit?: number): string[]; }, limit?: number) => string[]} */$h‍_once.stringSlice(stringSlice);
const        stringSplit=  uncurryThis(stringPrototype.split);$h‍_once.stringSplit(stringSplit);
const        stringStartsWith=  uncurryThis(stringPrototype.startsWith);$h‍_once.stringStartsWith(stringStartsWith);
const        iterateString=  uncurryThis(stringPrototype[iteratorSymbol]);
//
$h‍_once.iterateString(iterateString);const weakmapDelete=uncurryThis(weakmapPrototype.delete);
/** @type {<K extends {}, V>(thisArg: WeakMap<K, V>, ...args: Parameters<WeakMap<K,V>['get']>) => ReturnType<WeakMap<K,V>['get']>} */$h‍_once.weakmapDelete(weakmapDelete);
const        weakmapGet=  uncurryThis(weakmapPrototype.get);$h‍_once.weakmapGet(weakmapGet);
const        weakmapHas=  uncurryThis(weakmapPrototype.has);$h‍_once.weakmapHas(weakmapHas);
const        weakmapSet=  uncurryThis(weakmapPrototype.set);
//
$h‍_once.weakmapSet(weakmapSet);const weaksetAdd=uncurryThis(weaksetPrototype.add);$h‍_once.weaksetAdd(weaksetAdd);
const        weaksetHas=  uncurryThis(weaksetPrototype.has);
//
$h‍_once.weaksetHas(weaksetHas);const functionToString=uncurryThis(functionPrototype.toString);
//
$h‍_once.functionToString(functionToString);const{all}=Promise;
const        promiseAll=  (promises)=>apply(all, Promise, [promises]);$h‍_once.promiseAll(promiseAll);
const        promiseCatch=  uncurryThis(promisePrototype.catch);
/** @type {<T, TResult1 = T, TResult2 = never>(thisArg: T, onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null) => Promise<TResult1 | TResult2>} */$h‍_once.promiseCatch(promiseCatch);
const        promiseThen=  /** @type {any} */
  uncurryThis(promisePrototype.then);

//
$h‍_once.promiseThen(promiseThen);const finalizationRegistryRegister=
  FinalizationRegistry&&  uncurryThis(FinalizationRegistry.prototype.register);$h‍_once.finalizationRegistryRegister(finalizationRegistryRegister);
const        finalizationRegistryUnregister=
  FinalizationRegistry&&
  uncurryThis(FinalizationRegistry.prototype.unregister);

/**
 * getConstructorOf()
 * Return the constructor from an instance.
 *
 * @param {Function} fn
 */$h‍_once.finalizationRegistryUnregister(finalizationRegistryUnregister);
const        getConstructorOf=  (fn)=>
  reflectGet(getPrototypeOf(fn), 'constructor');

/**
 * immutableObject
 * An immutable (frozen) empty object that is safe to share.
 */$h‍_once.getConstructorOf(getConstructorOf);
const        immutableObject=  freeze(create(null));

/**
 * isObject tests whether a value is an object.
 * Today, this is equivalent to:
 *
 *   const isObject = value => {
 *     if (value === null) return false;
 *     const type = typeof value;
 *     return type === 'object' || type === 'function';
 *   };
 *
 * But this is not safe in the face of possible evolution of the language, for
 * example new types or semantics of records and tuples.
 * We use this implementation despite the unnecessary allocation implied by
 * attempting to box a primitive.
 *
 * @param {any} value
 */$h‍_once.immutableObject(immutableObject);
const        isObject=  (value)=>Object(value)===  value;

/**
 * isError tests whether an object inherits from the intrinsic
 * `Error.prototype`.
 * We capture the original error constructor as FERAL_ERROR to provide a clear
 * signal for reviewers that we are handling an object with excess authority,
 * like stack trace inspection, that we are carefully hiding from client code.
 * Checking instanceof happens to be safe, but to avoid uttering FERAL_ERROR
 * for such a trivial case outside commons.js, we provide a utility function.
 *
 * @param {any} value
 */$h‍_once.isObject(isObject);
const        isError=  (value)=>value instanceof FERAL_ERROR;

// The original unsafe untamed eval function, which must not escape.
// Sample at module initialization time, which is before lockdown can
// repair it.  Use it only to build powerless abstractions.
// eslint-disable-next-line no-eval
$h‍_once.isError(isError);const FERAL_EVAL=eval;

// The original unsafe untamed Function constructor, which must not escape.
// Sample at module initialization time, which is before lockdown can
// repair it.  Use it only to build powerless abstractions.
$h‍_once.FERAL_EVAL(FERAL_EVAL);const FERAL_FUNCTION=Function;$h‍_once.FERAL_FUNCTION(FERAL_FUNCTION);

const        noEvalEvaluate=  ()=>  {
  // See https://github.com/endojs/endo/blob/master/packages/ses/error-codes/SES_NO_EVAL.md
  throw TypeError('Cannot eval with evalTaming set to "noEval" (SES_NO_EVAL)');
 };$h‍_once.noEvalEvaluate(noEvalEvaluate);
})()
,
// === functors[2] ===
({   imports: $h‍_imports,   liveVar: $h‍_live,   onceVar: $h‍_once,   importMeta: $h‍____meta, }) => (function () {   let TypeError;$h‍_imports([["./commons.js", [["TypeError", [$h‍_a => (TypeError = $h‍_a)]]]]]);   

/** getThis returns globalThis in sloppy mode or undefined in strict mode. */
function getThis() {
  return this;
 }

if( getThis()) {
  // See https://github.com/endojs/endo/blob/master/packages/ses/error-codes/SES_NO_SLOPPY.md
  throw TypeError( `SES failed to initialize, sloppy mode (SES_NO_SLOPPY)`);
 }
})()
,
// === functors[3] ===
({   imports: $h‍_imports,   liveVar: $h‍_live,   onceVar: $h‍_once,   importMeta: $h‍____meta, }) => (function () {   $h‍_imports([]);   // @ts-check

// `@endo/env-options` needs to be imported quite early, and so should
// avoid importing from ses or anything that depends on ses.

// /////////////////////////////////////////////////////////////////////////////
// Prelude of cheap good - enough imitations of things we'd use or
// do differently if we could depend on ses

const { freeze}=   Object;
const { apply}=   Reflect;

// Should be equivalent to the one in ses' commons.js even though it
// uses the other technique.
const uncurryThis=
  (fn)=>
  (receiver, ...args)=>
    apply(fn, receiver, args);
const arrayPush=  uncurryThis(Array.prototype.push);

const q=  JSON.stringify;

const Fail=  (literals, ...args)=>  {
  let msg=  literals[0];
  for( let i=  0; i<  args.length; i+=  1) {
    msg=   `${msg}${args[i]}${literals[i+ 1] }`;
   }
  throw Error(msg);
 };

// end prelude
// /////////////////////////////////////////////////////////////////////////////

/**
 * `makeEnvironmentCaptor` provides a mechanism for getting environment
 * variables, if they are needed, and a way to catalog the names of all
 * the environment variables that were captured.
 *
 * @param {object} aGlobal
 */
const        makeEnvironmentCaptor=  (aGlobal)=>{
  const capturedEnvironmentOptionNames=  [];

  /**
   * Gets an environment option by name and returns the option value or the
   * given default.
   *
   * @param {string} optionName
   * @param {string} defaultSetting
   * @returns {string}
   */
  const getEnvironmentOption=  (optionName, defaultSetting)=>  {
    // eslint-disable-next-line @endo/no-polymorphic-call
    typeof optionName===  'string'||
      Fail `Environment option name ${q(optionName)} must be a string.`;
    // eslint-disable-next-line @endo/no-polymorphic-call
    typeof defaultSetting===  'string'||
      Fail `Environment option default setting ${q(
        defaultSetting)
        } must be a string.`;

    /** @type {string} */
    let setting=  defaultSetting;
    const globalProcess=  aGlobal.process;
    if( globalProcess&&  typeof globalProcess===  'object') {
      const globalEnv=  globalProcess.env;
      if( globalEnv&&  typeof globalEnv===  'object') {
        if( optionName in globalEnv) {
          arrayPush(capturedEnvironmentOptionNames, optionName);
          const optionValue=  globalEnv[optionName];
          // eslint-disable-next-line @endo/no-polymorphic-call
          typeof optionValue===  'string'||
            Fail `Environment option named ${q(
              optionName)
              }, if present, must have a corresponding string value, got ${q(
              optionValue)
              }`;
          setting=  optionValue;
         }
       }
     }
    return setting;
   };
  freeze(getEnvironmentOption);

  const getCapturedEnvironmentOptionNames=  ()=>  {
    return freeze([...capturedEnvironmentOptionNames]);
   };
  freeze(getCapturedEnvironmentOptionNames);

  return freeze({ getEnvironmentOption, getCapturedEnvironmentOptionNames});
 };$h‍_once.makeEnvironmentCaptor(makeEnvironmentCaptor);
freeze(makeEnvironmentCaptor);
})()
,
// === functors[4] ===
({   imports: $h‍_imports,   liveVar: $h‍_live,   onceVar: $h‍_once,   importMeta: $h‍____meta, }) => (function () {   $h‍_imports([["./src/env-options.js", []]]);   
})()
,
// === functors[5] ===
({   imports: $h‍_imports,   liveVar: $h‍_live,   onceVar: $h‍_once,   importMeta: $h‍____meta, }) => (function () {   let Set,String,isArray,arrayJoin,arraySlice,arraySort,arrayMap,keys,fromEntries,freeze,is,isError,setAdd,setHas,stringIncludes,stringStartsWith,stringifyJson,toStringTagSymbol;$h‍_imports([["../commons.js", [["Set", [$h‍_a => (Set = $h‍_a)]],["String", [$h‍_a => (String = $h‍_a)]],["isArray", [$h‍_a => (isArray = $h‍_a)]],["arrayJoin", [$h‍_a => (arrayJoin = $h‍_a)]],["arraySlice", [$h‍_a => (arraySlice = $h‍_a)]],["arraySort", [$h‍_a => (arraySort = $h‍_a)]],["arrayMap", [$h‍_a => (arrayMap = $h‍_a)]],["keys", [$h‍_a => (keys = $h‍_a)]],["fromEntries", [$h‍_a => (fromEntries = $h‍_a)]],["freeze", [$h‍_a => (freeze = $h‍_a)]],["is", [$h‍_a => (is = $h‍_a)]],["isError", [$h‍_a => (isError = $h‍_a)]],["setAdd", [$h‍_a => (setAdd = $h‍_a)]],["setHas", [$h‍_a => (setHas = $h‍_a)]],["stringIncludes", [$h‍_a => (stringIncludes = $h‍_a)]],["stringStartsWith", [$h‍_a => (stringStartsWith = $h‍_a)]],["stringifyJson", [$h‍_a => (stringifyJson = $h‍_a)]],["toStringTagSymbol", [$h‍_a => (toStringTagSymbol = $h‍_a)]]]]]);   






















/**
 * Joins English terms with commas and an optional conjunction.
 *
 * @param {(string | StringablePayload)[]} terms
 * @param {"and" | "or"} conjunction
 */
const        enJoin=  (terms, conjunction)=>  {
  if( terms.length===  0) {
    return '(none)';
   }else if( terms.length===  1) {
    return terms[0];
   }else if( terms.length===  2) {
    const [first, second]=  terms;
    return  `${first} ${conjunction} ${second}`;
   }else {
    return  `${arrayJoin(arraySlice(terms,0, -1), ', ') }, ${conjunction} ${
      terms[terms.length-  1]
     }`;
   }
 };

/**
 * Prepend the correct indefinite article onto a noun, typically a typeof
 * result, e.g., "an object" vs. "a number"
 *
 * @param {string} str The noun to prepend
 * @returns {string} The noun prepended with a/an
 */$h‍_once.enJoin(enJoin);
const an=  (str)=>{
  str=   `${str}`;
  if( str.length>=  1&&  stringIncludes('aeiouAEIOU', str[0])) {
    return  `an ${str}`;
   }
  return  `a ${str}`;
 };$h‍_once.an(an);
freeze(an);


/**
 * Like `JSON.stringify` but does not blow up if given a cycle or a bigint.
 * This is not
 * intended to be a serialization to support any useful unserialization,
 * or any programmatic use of the resulting string. The string is intended
 * *only* for showing a human under benign conditions, in order to be
 * informative enough for some
 * logging purposes. As such, this `bestEffortStringify` has an
 * imprecise specification and may change over time.
 *
 * The current `bestEffortStringify` possibly emits too many "seen"
 * markings: Not only for cycles, but also for repeated subtrees by
 * object identity.
 *
 * As a best effort only for diagnostic interpretation by humans,
 * `bestEffortStringify` also turns various cases that normal
 * `JSON.stringify` skips or errors on, like `undefined` or bigints,
 * into strings that convey their meaning. To distinguish this from
 * strings in the input, these synthesized strings always begin and
 * end with square brackets. To distinguish those strings from an
 * input string with square brackets, and input string that starts
 * with an open square bracket `[` is itself placed in square brackets.
 *
 * @param {any} payload
 * @param {(string|number)=} spaces
 * @returns {string}
 */
const bestEffortStringify=  (payload, spaces=  undefined)=>  {
  const seenSet=  new Set();
  const replacer=  (_, val)=>  {
    switch( typeof val){
      case 'object': {
        if( val===  null) {
          return null;
         }
        if( setHas(seenSet, val)) {
          return '[Seen]';
         }
        setAdd(seenSet, val);
        if( isError(val)) {
          return  `[${val.name}: ${val.message}]`;
         }
        if( toStringTagSymbol in val) {
          // For the built-ins that have or inherit a `Symbol.toStringTag`-named
          // property, most of them inherit the default `toString` method,
          // which will print in a similar manner: `"[object Foo]"` vs
          // `"[Foo]"`. The exceptions are
          //    * `Symbol.prototype`, `BigInt.prototype`, `String.prototype`
          //      which don't matter to us since we handle primitives
          //      separately and we don't care about primitive wrapper objects.
          //    * TODO
          //      `Date.prototype`, `TypedArray.prototype`.
          //      Hmmm, we probably should make special cases for these. We're
          //      not using these yet, so it's not urgent. But others will run
          //      into these.
          //
          // Once #2018 is closed, the only objects in our code that have or
          // inherit a `Symbol.toStringTag`-named property are remotables
          // or their remote presences.
          // This printing will do a good job for these without
          // violating abstraction layering. This behavior makes sense
          // purely in terms of JavaScript concepts. That's some of the
          // motivation for choosing that representation of remotables
          // and their remote presences in the first place.
          return  `[${val[toStringTagSymbol]}]`;
         }
        if( isArray(val)) {
          return val;
         }
        const names=  keys(val);
        if( names.length<  2) {
          return val;
         }
        let sorted=  true;
        for( let i=  1; i<  names.length; i+=  1) {
          if( names[i-  1]>=  names[i]) {
            sorted=  false;
            break;
           }
         }
        if( sorted) {
          return val;
         }
        arraySort(names);
        const entries=  arrayMap(names, (name)=>[name, val[name]]);
        return fromEntries(entries);
       }
      case 'function': {
        return  `[Function ${val.name|| '<anon>' }]`;
       }
      case 'string': {
        if( stringStartsWith(val, '[')) {
          return  `[${val}]`;
         }
        return val;
       }
      case 'undefined':
      case 'symbol': {
        return  `[${String(val)}]`;
       }
      case 'bigint': {
        return  `[${val}n]`;
       }
      case 'number': {
        if( is(val, NaN)) {
          return '[NaN]';
         }else if( val===  Infinity) {
          return '[Infinity]';
         }else if( val===  -Infinity) {
          return '[-Infinity]';
         }
        return val;
       }
      default: {
        return val;
       }}

   };
  try {
    return stringifyJson(payload, replacer, spaces);
   }catch( _err) {
    // Don't do anything more fancy here if there is any
    // chance that might throw, unless you surround that
    // with another try-catch-recovery. For example,
    // the caught thing might be a proxy or other exotic
    // object rather than an error. The proxy might throw
    // whenever it is possible for it to.
    return '[Something that failed to stringify]';
   }
 };$h‍_once.bestEffortStringify(bestEffortStringify);
freeze(bestEffortStringify);
})()
,
// === functors[6] ===
({   imports: $h‍_imports,   liveVar: $h‍_live,   onceVar: $h‍_once,   importMeta: $h‍____meta, }) => (function () {   $h‍_imports([]);   // @ts-check

/**
 * @callback BaseAssert
 * The `assert` function itself.
 *
 * @param {*} flag The truthy/falsy value
 * @param {Details=} optDetails The details to throw
 * @param {ErrorConstructor=} ErrorConstructor An optional alternate error
 * constructor to use.
 * @returns {asserts flag}
 */

/**
 * @typedef {object} AssertMakeErrorOptions
 * @property {string=} errorName
 */

/**
 * @callback AssertMakeError
 *
 * The `assert.error` method, recording details for the console.
 *
 * The optional `optDetails` can be a string.
 * @param {Details=} optDetails The details of what was asserted
 * @param {ErrorConstructor=} ErrorConstructor An optional alternate error
 * constructor to use.
 * @param {AssertMakeErrorOptions=} options
 * @returns {Error}
 */

/**
 * @callback AssertFail
 *
 * The `assert.fail` method.
 *
 * Fail an assertion, recording full details to the console and
 * raising an exception with a message in which `details` substitution values
 * have been redacted.
 *
 * The optional `optDetails` can be a string for backwards compatibility
 * with the nodejs assertion library.
 * @param {Details=} optDetails The details of what was asserted
 * @param {ErrorConstructor=} ErrorConstructor An optional alternate error
 * constructor to use.
 * @returns {never}
 */

/**
 * @callback AssertEqual
 * The `assert.equal` method
 *
 * Assert that two values must be `Object.is`.
 * @param {*} actual The value we received
 * @param {*} expected What we wanted
 * @param {Details=} optDetails The details to throw
 * @param {ErrorConstructor=} ErrorConstructor An optional alternate error
 * constructor to use.
 * @returns {void}
 */

// Type all the overloads of the assertTypeof function.
// There may eventually be a better way to do this, but
// thems the breaks with Typescript 4.0.
/**
 * @callback AssertTypeofBigint
 * @param {any} specimen
 * @param {'bigint'} typename
 * @param {Details=} optDetails
 * @returns {asserts specimen is bigint}
 */

/**
 * @callback AssertTypeofBoolean
 * @param {any} specimen
 * @param {'boolean'} typename
 * @param {Details=} optDetails
 * @returns {asserts specimen is boolean}
 */

/**
 * @callback AssertTypeofFunction
 * @param {any} specimen
 * @param {'function'} typename
 * @param {Details=} optDetails
 * @returns {asserts specimen is Function}
 */

/**
 * @callback AssertTypeofNumber
 * @param {any} specimen
 * @param {'number'} typename
 * @param {Details=} optDetails
 * @returns {asserts specimen is number}
 */

/**
 * @callback AssertTypeofObject
 * @param {any} specimen
 * @param {'object'} typename
 * @param {Details=} optDetails
 * @returns {asserts specimen is Record<any, any> | null}
 */

/**
 * @callback AssertTypeofString
 * @param {any} specimen
 * @param {'string'} typename
 * @param {Details=} optDetails
 * @returns {asserts specimen is string}
 */

/**
 * @callback AssertTypeofSymbol
 * @param {any} specimen
 * @param {'symbol'} typename
 * @param {Details=} optDetails
 * @returns {asserts specimen is symbol}
 */

/**
 * @callback AssertTypeofUndefined
 * @param {any} specimen
 * @param {'undefined'} typename
 * @param {Details=} optDetails
 * @returns {asserts specimen is undefined}
 */

/**
 * The `assert.typeof` method
 *
 * @typedef {AssertTypeofBigint & AssertTypeofBoolean & AssertTypeofFunction & AssertTypeofNumber & AssertTypeofObject & AssertTypeofString & AssertTypeofSymbol & AssertTypeofUndefined} AssertTypeof
 */

/**
 * @callback AssertString
 * The `assert.string` method.
 *
 * `assert.string(v)` is equivalent to `assert.typeof(v, 'string')`. We
 * special case this one because it is the most frequently used.
 *
 * Assert an expected typeof result.
 * @param {any} specimen The value to get the typeof
 * @param {Details=} optDetails The details to throw
 * @returns {asserts specimen is string}
 */

/**
 * @callback AssertNote
 * The `assert.note` method.
 *
 * Annotate an error with details, potentially to be used by an
 * augmented console such as the causal console of `console.js`, to
 * provide extra information associated with logged errors.
 *
 * @param {Error} error
 * @param {Details} detailsNote
 * @returns {void}
 */

// /////////////////////////////////////////////////////////////////////////////

/**
 * @typedef {{}} DetailsToken
 * A call to the `details` template literal makes and returns a fresh details
 * token, which is a frozen empty object associated with the arguments of that
 * `details` template literal expression.
 */

/**
 * @typedef {string | DetailsToken} Details
 * Either a plain string, or made by the `details` template literal tag.
 */

/**
 * @typedef {object} StringablePayload
 * Holds the payload passed to quote so that its printed form is visible.
 * @property {() => string} toString How to print the payload
 */

/**
 * To "declassify" and quote a substitution value used in a
 * ``` details`...` ``` template literal, enclose that substitution expression
 * in a call to `quote`. This makes the value appear quoted
 * (as if with `JSON.stringify`) in the message of the thrown error. The
 * payload itself is still passed unquoted to the console as it would be
 * without `quote`.
 *
 * For example, the following will reveal the expected sky color, but not the
 * actual incorrect sky color, in the thrown error's message:
 * ```js
 * sky.color === expectedColor || Fail`${sky.color} should be ${quote(expectedColor)}`;
 * ```
 *
 * // TODO Update SES-shim to new convention, where `details` is
 * // renamed to `X` rather than `d`.
 * The normal convention is to locally rename `details` to `d` and `quote` to `q`
 * like `const { details: d, quote: q } = assert;`, so the above example would then be
 * ```js
 * sky.color === expectedColor || Fail`${sky.color} should be ${q(expectedColor)}`;
 * ```
 *
 * @callback AssertQuote
 * @param {*} payload What to declassify
 * @param {(string|number)=} spaces
 * @returns {StringablePayload} The declassified payload
 */

/**
 * @callback Raise
 *
 * To make an `assert` which terminates some larger unit of computation
 * like a transaction, vat, or process, call `makeAssert` with a `Raise`
 * callback, where that callback actually performs that larger termination.
 * If possible, the callback should also report its `reason` parameter as
 * the alleged reason for the termination.
 *
 * @param {Error} reason
 */

/**
 * @callback MakeAssert
 *
 * Makes and returns an `assert` function object that shares the bookkeeping
 * state defined by this module with other `assert` function objects made by
 * `makeAssert`. This state is per-module-instance and is exposed by the
 * `loggedErrorHandler` above. We refer to `assert` as a "function object"
 * because it can be called directly as a function, but also has methods that
 * can be called.
 *
 * If `optRaise` is provided, the returned `assert` function object will call
 * `optRaise(reason)` before throwing the error. This enables `optRaise` to
 * engage in even more violent termination behavior, like terminating the vat,
 * that prevents execution from reaching the following throw. However, if
 * `optRaise` returns normally, which would be unusual, the throw following
 * `optRaise(reason)` would still happen.
 *
 * @param {Raise=} optRaise
 * @param {boolean=} unredacted
 * @returns {Assert}
 */

/**
 * @typedef {(template: TemplateStringsArray | string[], ...args: any) => DetailsToken} DetailsTag
 *
 * Use the `details` function as a template literal tag to create
 * informative error messages. The assertion functions take such messages
 * as optional arguments:
 * ```js
 * assert(sky.isBlue(), details`${sky.color} should be "blue"`);
 * ```
 * // TODO Update SES-shim to new convention, where `details` is
 * // renamed to `X` rather than `d`.
 * or following the normal convention to locally rename `details` to `d`
 * and `quote` to `q` like `const { details: d, quote: q } = assert;`:
 * ```js
 * assert(sky.isBlue(), d`${sky.color} should be "blue"`);
 * ```
 * However, note that in most cases it is preferable to instead use the `Fail`
 * template literal tag (which has the same input signature as `details`
 * but automatically creates and throws an error):
 * ```js
 * sky.isBlue() || Fail`${sky.color} should be "blue"`;
 * ```
 *
 * The details template tag returns a `DetailsToken` object that can print
 * itself with the formatted message in two ways.
 * It will report full details to the console, but
 * mask embedded substitution values with their typeof information in the thrown error
 * to prevent revealing secrets up the exceptional path. In the example
 * above, the thrown error may reveal only that `sky.color` is a string,
 * whereas the same diagnostic printed to the console reveals that the
 * sky was green. This masking can be disabled for an individual substitution value
 * using `quote`.
 *
 * The `raw` property of an input template array is ignored, so a simple
 * array of strings may be provided directly.
 */

/**
 * @typedef {(template: TemplateStringsArray | string[], ...args: any) => never} FailTag
 *
 * Use the `Fail` function as a template literal tag to efficiently
 * create and throw a `details`-style error only when a condition is not satisfied.
 * ```js
 * condition || Fail`...complaint...`;
 * ```
 * This avoids the overhead of creating usually-unnecessary errors like
 * ```js
 * assert(condition, details`...complaint...`);
 * ```
 * while improving readability over alternatives like
 * ```js
 * condition || assert.fail(details`...complaint...`);
 * ```
 *
 * However, due to current weakness in TypeScript, static reasoning
 * is less powerful with the `||` patterns than with an `assert` call.
 * Until/unless https://github.com/microsoft/TypeScript/issues/51426 is fixed,
 * for `||`-style assertions where this loss of static reasoning is a problem,
 * instead express the assertion as
 * ```js
 *   if (!condition) {
 *     Fail`...complaint...`;
 *   }
 * ```
 * or, if needed,
 * ```js
 *   if (!condition) {
 *     // `throw` is noop since `Fail` throws, but it improves static analysis
 *     throw Fail`...complaint...`;
 *   }
 * ```
 */

/**
 * assert that expr is truthy, with an optional details to describe
 * the assertion. It is a tagged template literal like
 * ```js
 * assert(expr, details`....`);`
 * ```
 *
 * The literal portions of the template are assumed non-sensitive, as
 * are the `typeof` types of the substitution values. These are
 * assembled into the thrown error message. The actual contents of the
 * substitution values are assumed sensitive, to be revealed to
 * the console only. We assume only the virtual platform's owner can read
 * what is written to the console, where the owner is in a privileged
 * position over computation running on that platform.
 *
 * The optional `optDetails` can be a string for backwards compatibility
 * with the nodejs assertion library.
 *
 * @typedef { BaseAssert & {
 *   typeof: AssertTypeof,
 *   error: AssertMakeError,
 *   fail: AssertFail,
 *   equal: AssertEqual,
 *   string: AssertString,
 *   note: AssertNote,
 *   details: DetailsTag,
 *   Fail: FailTag,
 *   quote: AssertQuote,
 *   bare: AssertQuote,
 *   makeAssert: MakeAssert,
 * } } Assert
 */

// /////////////////////////////////////////////////////////////////////////////

/**
 * @typedef {object} VirtualConsole
 * @property {Console['debug']} debug
 * @property {Console['log']} log
 * @property {Console['info']} info
 * @property {Console['warn']} warn
 * @property {Console['error']} error
 *
 * @property {Console['trace']} trace
 * @property {Console['dirxml']} dirxml
 * @property {Console['group']} group
 * @property {Console['groupCollapsed']} groupCollapsed
 *
 * @property {Console['assert']} assert
 * @property {Console['timeLog']} timeLog
 *
 * @property {Console['clear']} clear
 * @property {Console['count']} count
 * @property {Console['countReset']} countReset
 * @property {Console['dir']} dir
 * @property {Console['groupEnd']} groupEnd
 *
 * @property {Console['table']} table
 * @property {Console['time']} time
 * @property {Console['timeEnd']} timeEnd
 * @property {Console['timeStamp']} timeStamp
 */

/* This is deliberately *not* JSDoc, it is a regular comment.
 *
 * TODO: We'd like to add the following properties to the above
 * VirtualConsole, but they currently cause conflicts where
 * some Typescript implementations don't have these properties
 * on the Console type.
 *
 * @property {Console['profile']} profile
 * @property {Console['profileEnd']} profileEnd
 */

/**
 * @typedef {'debug' | 'log' | 'info' | 'warn' | 'error'} LogSeverity
 */

/**
 * @typedef ConsoleFilter
 * @property {(severity: LogSeverity) => boolean} canLog
 */

/**
 * @callback FilterConsole
 * @param {VirtualConsole} baseConsole
 * @param {ConsoleFilter} filter
 * @param {string=} topic
 * @returns {VirtualConsole}
 */
})()
,
// === functors[7] ===
({   imports: $h‍_imports,   liveVar: $h‍_live,   onceVar: $h‍_once,   importMeta: $h‍____meta, }) => (function () {   $h‍_imports([]);   // @ts-check

/**
 * @typedef {readonly any[]} LogArgs
 *
 * This is an array suitable to be used as arguments of a console
 * level message *after* the format string argument. It is the result of
 * a `details` template string and consists of alternating literal strings
 * and substitution values, starting with a literal string. At least that
 * first literal string is always present.
 */

/**
 * @callback NoteCallback
 *
 * @param {Error} error
 * @param {LogArgs} noteLogArgs
 * @returns {void}
 */

/**
 * @callback GetStackString
 * @param {Error} error
 * @returns {string=}
 */

/**
 * @typedef {object} LoggedErrorHandler
 *
 * Used to parameterize `makeCausalConsole` to give it access to potentially
 * hidden information to augment the logging of errors.
 *
 * @property {GetStackString} getStackString
 * @property {(error: Error) => string} tagError
 * @property {() => void} resetErrorTagNum for debugging purposes only
 * @property {(error: Error) => (LogArgs | undefined)} getMessageLogArgs
 * @property {(error: Error) => (LogArgs | undefined)} takeMessageLogArgs
 * @property {(error: Error, callback?: NoteCallback) => LogArgs[] } takeNoteLogArgsArray
 */

// /////////////////////////////////////////////////////////////////////////////

/**
 * @typedef {readonly [string, ...any[]]} LogRecord
 */

/**
 * @typedef {object} LoggingConsoleKit
 * @property {VirtualConsole} loggingConsole
 * @property {() => readonly LogRecord[]} takeLog
 */

/**
 * @typedef {object} MakeLoggingConsoleKitOptions
 * @property {boolean=} shouldResetForDebugging
 */

/**
 * @callback MakeLoggingConsoleKit
 *
 * A logging console just accumulates the contents of all whitelisted calls,
 * making them available to callers of `takeLog()`. Calling `takeLog()`
 * consumes these, so later calls to `takeLog()` will only provide a log of
 * calls that have happened since then.
 *
 * @param {LoggedErrorHandler} loggedErrorHandler
 * @param {MakeLoggingConsoleKitOptions=} options
 * @returns {LoggingConsoleKit}
 */

/**
 * @typedef {{ NOTE: 'ERROR_NOTE:', MESSAGE: 'ERROR_MESSAGE:' }} ErrorInfo
 */

/**
 * @typedef {ErrorInfo[keyof ErrorInfo]} ErrorInfoKind
 */

/**
 * @callback MakeCausalConsole
 *
 * Makes a causal console wrapper of a `baseConsole`, where the causal console
 * calls methods of the `loggedErrorHandler` to customize how it handles logged
 * errors.
 *
 * @param {VirtualConsole} baseConsole
 * @param {LoggedErrorHandler} loggedErrorHandler
 * @returns {VirtualConsole}
 */
})()
,
// === functors[8] ===
({   imports: $h‍_imports,   liveVar: $h‍_live,   onceVar: $h‍_once,   importMeta: $h‍____meta, }) => (function () {   $h‍_imports([["./internal-types.js", []]]);   





const { freeze}=   Object;
const { isSafeInteger}=   Number;

/**
 * @template Data
 * @typedef {object} DoublyLinkedCell
 * A cell of a doubly-linked ring, i.e., a doubly-linked circular list.
 * DoublyLinkedCells are not frozen, and so should be closely encapsulated by
 * any abstraction that uses them.
 * @property {DoublyLinkedCell<Data>} next
 * @property {DoublyLinkedCell<Data>} prev
 * @property {Data} data
 */

/**
 * Makes a new self-linked cell. There are two reasons to do so:
 *    * To make the head sigil of a new initially-empty doubly-linked ring.
 *    * To make a non-sigil cell to be `spliceAfter`ed.
 *
 * @template Data
 * @param {Data} data
 * @returns {DoublyLinkedCell<Data>}
 */
const makeSelfCell=  (data)=>{
  /** @type {Partial<DoublyLinkedCell<Data>>} */
  const incompleteCell=  {
    next: undefined,
    prev: undefined,
    data};

  const selfCell=  /** @type {DoublyLinkedCell<Data>} */  incompleteCell;
  selfCell.next=  selfCell;
  selfCell.prev=  selfCell;
  // Not frozen!
  return selfCell;
 };

/**
 * Splices a self-linked non-sigil cell into a ring after `prev`.
 * `prev` could be the head sigil, or it could be some other non-sigil
 * cell within a ring.
 *
 * @template Data
 * @param {DoublyLinkedCell<Data>} prev
 * @param {DoublyLinkedCell<Data>} selfCell
 */
const spliceAfter=  (prev, selfCell)=>  {
  if( prev===  selfCell) {
    throw TypeError('Cannot splice a cell into itself');
   }
  if( selfCell.next!==  selfCell||  selfCell.prev!==  selfCell) {
    throw TypeError('Expected self-linked cell');
   }
  const cell=  selfCell;
  // rename variable cause it isn't self-linked after this point.

  const next=  prev.next;
  cell.prev=  prev;
  cell.next=  next;
  prev.next=  cell;
  next.prev=  cell;
  // Not frozen!
  return cell;
 };

/**
 * @template Data
 * @param {DoublyLinkedCell<Data>} cell
 * No-op if the cell is self-linked.
 */
const spliceOut=  (cell)=>{
  const { prev, next}=   cell;
  prev.next=  next;
  next.prev=  prev;
  cell.prev=  cell;
  cell.next=  cell;
 };

/**
 * The LRUCacheMap is used within the implementation of `assert` and so
 * at a layer below SES or harden. Thus, we give it a `WeakMap`-like interface
 * rather than a `WeakMapStore`-like interface. To work before `lockdown`,
 * the implementation must use `freeze` manually, but still exhaustively.
 *
 * It implements the WeakMap interface, and holds its keys weakly.  Cached
 * values are only held while the key is held by the user and the key/value
 * bookkeeping cell has not been pushed off the end of the cache by `budget`
 * number of more recently referenced cells.  If the key is dropped by the user,
 * the value will no longer be held by the cache, but the bookkeeping cell
 * itself will stay in memory.
 *
 * @template {{}} K
 * @template {unknown} V
 * @param {number} keysBudget
 * @returns {WeakMap<K,V>}
 */
const        makeLRUCacheMap=  (keysBudget)=>{
  if( !isSafeInteger(keysBudget)||  keysBudget<  0) {
    throw TypeError('keysBudget must be a safe non-negative integer number');
   }
  /** @typedef {DoublyLinkedCell<WeakMap<K, V> | undefined>} LRUCacheCell */
  /** @type {WeakMap<K, LRUCacheCell>} */
  const keyToCell=  new WeakMap();
  let size=  0; // `size` must remain <= `keysBudget`
  // As a sigil, `head` uniquely is not in the `keyToCell` map.
  /** @type {LRUCacheCell} */
  const head=  makeSelfCell(undefined);

  const touchCell=  (key)=>{
    const cell=  keyToCell.get(key);
    if( cell===  undefined||  cell.data===  undefined) {
      // Either the key was GCed, or the cell was condemned.
      return undefined;
     }
    // Becomes most recently used
    spliceOut(cell);
    spliceAfter(head, cell);
    return cell;
   };

  /**
   * @param {K} key
   */
  const has=  (key)=>touchCell(key)!==  undefined;
  freeze(has);

  /**
   * @param {K} key
   */
  // UNTIL https://github.com/endojs/endo/issues/1514
  // Prefer: const get = key => touchCell(key)?.data?.get(key);
  const get=  (key)=>{
    const cell=  touchCell(key);
    return cell&&  cell.data&&  cell.data.get(key);
   };
  freeze(get);

  /**
   * @param {K} key
   * @param {V} value
   */
  const set=  (key, value)=>  {
    if( keysBudget<  1) {
      // eslint-disable-next-line no-use-before-define
      return lruCacheMap; // Implements WeakMap.set
     }

    let cell=  touchCell(key);
    if( cell===  undefined) {
      cell=  makeSelfCell(undefined);
      spliceAfter(head, cell); // start most recently used
     }
    if( !cell.data) {
      // Either a fresh cell or a reused condemned cell.
      size+=  1;
      // Add its data.
      cell.data=  new WeakMap();
      // Advertise the cell for this key.
      keyToCell.set(key, cell);
      while( size>  keysBudget) {
        const condemned=  head.prev;
        spliceOut(condemned); // Drop least recently used
        condemned.data=  undefined;
        size-=  1;
       }
     }

    // Update the data.
    cell.data.set(key, value);

    // eslint-disable-next-line no-use-before-define
    return lruCacheMap; // Implements WeakMap.set
   };
  freeze(set);

  // "delete" is a keyword.
  /**
   * @param {K} key
   */
  const deleteIt=  (key)=>{
    const cell=  keyToCell.get(key);
    if( cell===  undefined) {
      return false;
     }
    spliceOut(cell);
    keyToCell.delete(key);
    if( cell.data===  undefined) {
      // Already condemned.
      return false;
     }

    cell.data=  undefined;
    size-=  1;
    return true;
   };
  freeze(deleteIt);

  const lruCacheMap=  freeze({
    has,
    get,
    set,
    delete: deleteIt,
    [Symbol.toStringTag]: 'LRUCacheMap'});

  return lruCacheMap;
 };$h‍_once.makeLRUCacheMap(makeLRUCacheMap);
freeze(makeLRUCacheMap);

const defaultLoggedErrorsBudget=  1000;
const defaultArgsPerErrorBudget=  100;

/**
 * @param {number} [errorsBudget]
 * @param {number} [argsPerErrorBudget]
 */
const        makeNoteLogArgsArrayKit=  (
  errorsBudget=  defaultLoggedErrorsBudget,
  argsPerErrorBudget=  defaultArgsPerErrorBudget)=>
     {
  if( !isSafeInteger(argsPerErrorBudget)||  argsPerErrorBudget<  1) {
    throw TypeError(
      'argsPerErrorBudget must be a safe positive integer number');

   }

  /**
   * @type {WeakMap<Error, LogArgs[]>}
   *
   * Maps from an error to an array of log args, where each log args is
   * remembered as an annotation on that error. This can be used, for example,
   * to keep track of additional causes of the error. The elements of any
   * log args may include errors which are associated with further annotations.
   * An augmented console, like the causal console of `console.js`, could
   * then retrieve the graph of such annotations.
   */
  const noteLogArgsArrayMap=  makeLRUCacheMap(errorsBudget);

  /**
   * @param {Error} error
   * @param {LogArgs} logArgs
   */
  const addLogArgs=  (error, logArgs)=>  {
    const logArgsArray=  noteLogArgsArrayMap.get(error);
    if( logArgsArray!==  undefined) {
      if( logArgsArray.length>=  argsPerErrorBudget) {
        logArgsArray.shift();
       }
      logArgsArray.push(logArgs);
     }else {
      noteLogArgsArrayMap.set(error, [logArgs]);
     }
   };
  freeze(addLogArgs);

  /**
   * @param {Error} error
   * @returns {LogArgs[] | undefined}
   */
  const takeLogArgsArray=  (error)=>{
    const result=  noteLogArgsArrayMap.get(error);
    noteLogArgsArrayMap.delete(error);
    return result;
   };
  freeze(takeLogArgsArray);

  return freeze({
    addLogArgs,
    takeLogArgsArray});

 };$h‍_once.makeNoteLogArgsArrayKit(makeNoteLogArgsArrayKit);
freeze(makeNoteLogArgsArrayKit);
})()
,
// === functors[9] ===
({   imports: $h‍_imports,   liveVar: $h‍_live,   onceVar: $h‍_once,   importMeta: $h‍____meta, }) => (function () {   let RangeError,TypeError,WeakMap,arrayJoin,arrayMap,arrayPop,arrayPush,assign,freeze,globalThis,is,isError,regexpTest,stringIndexOf,stringReplace,stringSlice,stringStartsWith,weakmapDelete,weakmapGet,weakmapHas,weakmapSet,an,bestEffortStringify,makeNoteLogArgsArrayKit;$h‍_imports([["../commons.js", [["RangeError", [$h‍_a => (RangeError = $h‍_a)]],["TypeError", [$h‍_a => (TypeError = $h‍_a)]],["WeakMap", [$h‍_a => (WeakMap = $h‍_a)]],["arrayJoin", [$h‍_a => (arrayJoin = $h‍_a)]],["arrayMap", [$h‍_a => (arrayMap = $h‍_a)]],["arrayPop", [$h‍_a => (arrayPop = $h‍_a)]],["arrayPush", [$h‍_a => (arrayPush = $h‍_a)]],["assign", [$h‍_a => (assign = $h‍_a)]],["freeze", [$h‍_a => (freeze = $h‍_a)]],["globalThis", [$h‍_a => (globalThis = $h‍_a)]],["is", [$h‍_a => (is = $h‍_a)]],["isError", [$h‍_a => (isError = $h‍_a)]],["regexpTest", [$h‍_a => (regexpTest = $h‍_a)]],["stringIndexOf", [$h‍_a => (stringIndexOf = $h‍_a)]],["stringReplace", [$h‍_a => (stringReplace = $h‍_a)]],["stringSlice", [$h‍_a => (stringSlice = $h‍_a)]],["stringStartsWith", [$h‍_a => (stringStartsWith = $h‍_a)]],["weakmapDelete", [$h‍_a => (weakmapDelete = $h‍_a)]],["weakmapGet", [$h‍_a => (weakmapGet = $h‍_a)]],["weakmapHas", [$h‍_a => (weakmapHas = $h‍_a)]],["weakmapSet", [$h‍_a => (weakmapSet = $h‍_a)]]]],["./stringify-utils.js", [["an", [$h‍_a => (an = $h‍_a)]],["bestEffortStringify", [$h‍_a => (bestEffortStringify = $h‍_a)]]]],["./types.js", []],["./internal-types.js", []],["./note-log-args.js", [["makeNoteLogArgsArrayKit", [$h‍_a => (makeNoteLogArgsArrayKit = $h‍_a)]]]]]);   








































// For our internal debugging purposes, uncomment
// const internalDebugConsole = console;

// /////////////////////////////////////////////////////////////////////////////

/** @type {WeakMap<StringablePayload, any>} */
const declassifiers=  new WeakMap();

/** @type {AssertQuote} */
const quote=  (payload, spaces=  undefined)=>  {
  const result=  freeze({
    toString: freeze(()=>  bestEffortStringify(payload, spaces))});

  weakmapSet(declassifiers, result, payload);
  return result;
 };
freeze(quote);

const canBeBare=  freeze(/^[\w:-]( ?[\w:-])*$/);

/**
 * Embed a string directly into error details without wrapping punctuation.
 * To avoid injection attacks that exploit quoting confusion, this must NEVER
 * be used with data that is possibly attacker-controlled.
 * As a further safeguard, we fall back to quoting any input that is not a
 * string of sufficiently word-like parts separated by isolated spaces (rather
 * than throwing an exception, which could hide the original problem for which
 * explanatory details are being constructed---i.e., ``` assert.details`...` ```
 * should never be the source of a new exception, nor should an attempt to
 * render its output, although we _could_ instead decide to handle the latter
 * by inline replacement similar to that of `bestEffortStringify` for producing
 * rendered messages like `(an object) was tagged "[Unsafe bare string]"`).
 *
 * @type {AssertQuote}
 */
const bare=  (payload, spaces=  undefined)=>  {
  if( typeof payload!==  'string'||  !regexpTest(canBeBare, payload)) {
    return quote(payload, spaces);
   }
  const result=  freeze({
    toString: freeze(()=>  payload)});

  weakmapSet(declassifiers, result, payload);
  return result;
 };
freeze(bare);

// /////////////////////////////////////////////////////////////////////////////

/**
 * @typedef {object} HiddenDetails
 *
 * Captures the arguments passed to the `details` template string tag.
 *
 * @property {TemplateStringsArray | string[]} template
 * @property {any[]} args
 */

/**
 * @type {WeakMap<DetailsToken, HiddenDetails>}
 *
 * Maps from a details token which a `details` template literal returned
 * to a record of the contents of that template literal expression.
 */
const hiddenDetailsMap=  new WeakMap();

/**
 * @param {HiddenDetails} hiddenDetails
 * @returns {string}
 */
const getMessageString=  ({ template, args})=>   {
  const parts=  [template[0]];
  for( let i=  0; i<  args.length; i+=  1) {
    const arg=  args[i];
    let argStr;
    if( weakmapHas(declassifiers, arg)) {
      argStr=   `${arg}`;
     }else if( isError(arg)) {
      argStr=   `(${an(arg.name)})`;
     }else {
      argStr=   `(${an(typeof arg)})`;
     }
    arrayPush(parts, argStr, template[i+  1]);
   }
  return arrayJoin(parts, '');
 };

/**
 * Give detailsTokens a toString behavior. To minimize the overhead of
 * creating new detailsTokens, we do this with an
 * inherited `this` sensitive `toString` method, even though we normally
 * avoid `this` sensitivity. To protect the method from inappropriate
 * `this` application, it does something interesting only for objects
 * registered in `redactedDetails`, which should be exactly the detailsTokens.
 *
 * The printing behavior must not reveal anything redacted, so we just use
 * the same `getMessageString` we use to construct the redacted message
 * string for a thrown assertion error.
 */
const DetailsTokenProto=  freeze({
  toString() {
    const hiddenDetails=  weakmapGet(hiddenDetailsMap, this);
    if( hiddenDetails===  undefined) {
      return '[Not a DetailsToken]';
     }
    return getMessageString(hiddenDetails);
   }});

freeze(DetailsTokenProto.toString);

/**
 * Normally this is the function exported as `assert.details` and often
 * spelled `d`. However, if the `{errorTaming: 'unsafe'}` option is given to
 * `lockdown`, then `unredactedDetails` is used instead.
 *
 * There are some unconditional uses of `redactedDetails` in this module. All
 * of them should be uses where the template literal has no redacted
 * substitution values. In those cases, the two are equivalent.
 *
 * @type {DetailsTag}
 */
const redactedDetails=  (template, ...args)=>  {
  // Keep in mind that the vast majority of calls to `details` creates
  // a details token that is never used, so this path must remain as fast as
  // possible. Hence we store what we've got with little processing, postponing
  // all the work to happen only if needed, for example, if an assertion fails.
  const detailsToken=  freeze({ __proto__: DetailsTokenProto});
  weakmapSet(hiddenDetailsMap, detailsToken, { template, args});
  return detailsToken;
 };
freeze(redactedDetails);

/**
 * `unredactedDetails` is like `details` except that it does not redact
 * anything. It acts like `details` would act if all substitution values
 * were wrapped with the `quote` function above (the function normally
 * spelled `q`). If the `{errorTaming: 'unsafe'}` option is given to
 * `lockdown`, then the lockdown-shim arranges for the global `assert` to be
 * one whose `details` property is `unredactedDetails`.
 * This setting optimizes the debugging and testing experience at the price
 * of safety. `unredactedDetails` also sacrifices the speed of `details`,
 * which is usually fine in debugging and testing.
 *
 * @type {DetailsTag}
 */
const unredactedDetails=  (template, ...args)=>  {
  args=  arrayMap(args, (arg)=>
    weakmapHas(declassifiers, arg)?  arg:  quote(arg));

  return redactedDetails(template, ...args);
 };$h‍_once.unredactedDetails(unredactedDetails);
freeze(unredactedDetails);


/**
 * @param {HiddenDetails} hiddenDetails
 * @returns {LogArgs}
 */
const getLogArgs=  ({ template, args})=>   {
  const logArgs=  [template[0]];
  for( let i=  0; i<  args.length; i+=  1) {
    let arg=  args[i];
    if( weakmapHas(declassifiers, arg)) {
      arg=  weakmapGet(declassifiers, arg);
     }
    // Remove the extra spaces (since console.error puts them
    // between each cause).
    const priorWithoutSpace=  stringReplace(arrayPop(logArgs)||  '', / $/, '');
    if( priorWithoutSpace!==  '') {
      arrayPush(logArgs, priorWithoutSpace);
     }
    const nextWithoutSpace=  stringReplace(template[i+  1], /^ /, '');
    arrayPush(logArgs, arg, nextWithoutSpace);
   }
  if( logArgs[logArgs.length-  1]===  '') {
    arrayPop(logArgs);
   }
  return logArgs;
 };

/**
 * @type {WeakMap<Error, LogArgs>}
 *
 * Maps from an error object to the log args that are a more informative
 * alternative message for that error. When logging the error, these
 * log args should be preferred to `error.message`.
 */
const hiddenMessageLogArgs=  new WeakMap();

// So each error tag will be unique.
let errorTagNum=  0;

/**
 * @type {WeakMap<Error, string>}
 */
const errorTags=  new WeakMap();

/**
 * @param {Error} err
 * @param {string=} optErrorName
 * @returns {string}
 */
const tagError=  (err, optErrorName=  err.name)=>  {
  let errorTag=  weakmapGet(errorTags, err);
  if( errorTag!==  undefined) {
    return errorTag;
   }
  errorTagNum+=  1;
  errorTag=   `${optErrorName}#${errorTagNum}`;
  weakmapSet(errorTags, err, errorTag);
  return errorTag;
 };

/**
 * @type {AssertMakeError}
 */
const makeError=  (
  optDetails=  redactedDetails `Assert failed`,
  ErrorConstructor=  globalThis.Error,
  { errorName=  undefined}=   {})=>
     {
  if( typeof optDetails===  'string') {
    // If it is a string, use it as the literal part of the template so
    // it doesn't get quoted.
    optDetails=  redactedDetails([optDetails]);
   }
  const hiddenDetails=  weakmapGet(hiddenDetailsMap, optDetails);
  if( hiddenDetails===  undefined) {
    throw TypeError( `unrecognized details ${quote(optDetails)}`);
   }
  const messageString=  getMessageString(hiddenDetails);
  const error=  new ErrorConstructor(messageString);
  weakmapSet(hiddenMessageLogArgs, error, getLogArgs(hiddenDetails));
  if( errorName!==  undefined) {
    tagError(error, errorName);
   }
  // The next line is a particularly fruitful place to put a breakpoint.
  return error;
 };
freeze(makeError);

// /////////////////////////////////////////////////////////////////////////////

const { addLogArgs, takeLogArgsArray}=   makeNoteLogArgsArrayKit();

/**
 * @type {WeakMap<Error, NoteCallback[]>}
 *
 * An augmented console will normally only take the hidden noteArgs array once,
 * when it logs the error being annotated. Once that happens, further
 * annotations of that error should go to the console immediately. We arrange
 * that by accepting a note-callback function from the console as an optional
 * part of that taking operation. Normally there will only be at most one
 * callback per error, but that depends on console behavior which we should not
 * assume. We make this an array of callbacks so multiple registrations
 * are independent.
 */
const hiddenNoteCallbackArrays=  new WeakMap();

/** @type {AssertNote} */
const note=  (error, detailsNote)=>  {
  if( typeof detailsNote===  'string') {
    // If it is a string, use it as the literal part of the template so
    // it doesn't get quoted.
    detailsNote=  redactedDetails([detailsNote]);
   }
  const hiddenDetails=  weakmapGet(hiddenDetailsMap, detailsNote);
  if( hiddenDetails===  undefined) {
    throw TypeError( `unrecognized details ${quote(detailsNote)}`);
   }
  const logArgs=  getLogArgs(hiddenDetails);
  const callbacks=  weakmapGet(hiddenNoteCallbackArrays, error);
  if( callbacks!==  undefined) {
    for( const callback of callbacks) {
      callback(error, logArgs);
     }
   }else {
    addLogArgs(error, logArgs);
   }
 };
freeze(note);

/**
 * The unprivileged form that just uses the de facto `error.stack` property.
 * The start compartment normally has a privileged `globalThis.getStackString`
 * which should be preferred if present.
 *
 * @param {Error} error
 * @returns {string}
 */
const defaultGetStackString=  (error)=>{
  if( !('stack'in  error)) {
    return '';
   }
  const stackString=   `${error.stack}`;
  const pos=  stringIndexOf(stackString, '\n');
  if( stringStartsWith(stackString, ' ')||  pos===  -1) {
    return stackString;
   }
  return stringSlice(stackString, pos+  1); // exclude the initial newline
 };

/** @type {LoggedErrorHandler} */
const loggedErrorHandler=  {
  getStackString: globalThis.getStackString||  defaultGetStackString,
  tagError: (error)=>tagError(error),
  resetErrorTagNum: ()=>  {
    errorTagNum=  0;
   },
  getMessageLogArgs: (error)=>weakmapGet(hiddenMessageLogArgs, error),
  takeMessageLogArgs: (error)=>{
    const result=  weakmapGet(hiddenMessageLogArgs, error);
    weakmapDelete(hiddenMessageLogArgs, error);
    return result;
   },
  takeNoteLogArgsArray: (error, callback)=>  {
    const result=  takeLogArgsArray(error);
    if( callback!==  undefined) {
      const callbacks=  weakmapGet(hiddenNoteCallbackArrays, error);
      if( callbacks) {
        arrayPush(callbacks, callback);
       }else {
        weakmapSet(hiddenNoteCallbackArrays, error, [callback]);
       }
     }
    return result||  [];
   }};$h‍_once.loggedErrorHandler(loggedErrorHandler);

freeze(loggedErrorHandler);


// /////////////////////////////////////////////////////////////////////////////

/**
 * @type {MakeAssert}
 */
const makeAssert=  (optRaise=  undefined, unredacted=  false)=>  {
  const details=  unredacted?  unredactedDetails:  redactedDetails;
  const assertFailedDetails=  details `Check failed`;

  /** @type {AssertFail} */
  const fail=  (
    optDetails=  assertFailedDetails,
    ErrorConstructor=  globalThis.Error)=>
       {
    const reason=  makeError(optDetails, ErrorConstructor);
    if( optRaise!==  undefined) {
      optRaise(reason);
     }
    throw reason;
   };
  freeze(fail);

  /** @type {FailTag} */
  const Fail=  (template, ...args)=>  fail(details(template, ...args));

  // Don't freeze or export `baseAssert` until we add methods.
  // TODO If I change this from a `function` function to an arrow
  // function, I seem to get type errors from TypeScript. Why?
  /** @type {BaseAssert} */
  function baseAssert(
    flag,
    optDetails=  undefined,
    ErrorConstructor=  undefined)
    {
    flag||  fail(optDetails, ErrorConstructor);
   }

  /** @type {AssertEqual} */
  const equal=  (
    actual,
    expected,
    optDetails=  undefined,
    ErrorConstructor=  undefined)=>
       {
    is(actual, expected)||
      fail(
        optDetails||  details `Expected ${actual} is same as ${expected}`,
        ErrorConstructor||  RangeError);

   };
  freeze(equal);

  /** @type {AssertTypeof} */
  const assertTypeof=  (specimen, typename, optDetails)=>  {
    // This will safely fall through if typename is not a string,
    // which is what we want.
    // eslint-disable-next-line valid-typeof
    if( typeof specimen===  typename) {
      return;
     }
    typeof typename===  'string'||  Fail `${quote(typename)} must be a string`;

    if( optDetails===  undefined) {
      // Embed the type phrase without quotes.
      const typeWithDeterminer=  an(typename);
      optDetails=  details `${specimen} must be ${bare(typeWithDeterminer)}`;
     }
    fail(optDetails, TypeError);
   };
  freeze(assertTypeof);

  /** @type {AssertString} */
  const assertString=  (specimen, optDetails=  undefined)=>
    assertTypeof(specimen, 'string', optDetails);

  // Note that "assert === baseAssert"
  /** @type {Assert} */
  const assert=  assign(baseAssert, {
    error: makeError,
    fail,
    equal,
    typeof: assertTypeof,
    string: assertString,
    note,
    details,
    Fail,
    quote,
    bare,
    makeAssert});

  return freeze(assert);
 };$h‍_once.makeAssert(makeAssert);
freeze(makeAssert);


/** @type {Assert} */
const assert=  makeAssert();$h‍_once.assert(assert);
})()
,
// === functors[10] ===
({   imports: $h‍_imports,   liveVar: $h‍_live,   onceVar: $h‍_once,   importMeta: $h‍____meta, }) => (function () {   let Set,String,TypeError,WeakMap,WeakSet,globalThis,apply,arrayForEach,defineProperty,freeze,getOwnPropertyDescriptor,getOwnPropertyDescriptors,getPrototypeOf,isInteger,isObject,objectHasOwnProperty,ownKeys,preventExtensions,setAdd,setForEach,setHas,toStringTagSymbol,typedArrayPrototype,weakmapGet,weakmapSet,weaksetAdd,weaksetHas,assert;$h‍_imports([["./commons.js", [["Set", [$h‍_a => (Set = $h‍_a)]],["String", [$h‍_a => (String = $h‍_a)]],["TypeError", [$h‍_a => (TypeError = $h‍_a)]],["WeakMap", [$h‍_a => (WeakMap = $h‍_a)]],["WeakSet", [$h‍_a => (WeakSet = $h‍_a)]],["globalThis", [$h‍_a => (globalThis = $h‍_a)]],["apply", [$h‍_a => (apply = $h‍_a)]],["arrayForEach", [$h‍_a => (arrayForEach = $h‍_a)]],["defineProperty", [$h‍_a => (defineProperty = $h‍_a)]],["freeze", [$h‍_a => (freeze = $h‍_a)]],["getOwnPropertyDescriptor", [$h‍_a => (getOwnPropertyDescriptor = $h‍_a)]],["getOwnPropertyDescriptors", [$h‍_a => (getOwnPropertyDescriptors = $h‍_a)]],["getPrototypeOf", [$h‍_a => (getPrototypeOf = $h‍_a)]],["isInteger", [$h‍_a => (isInteger = $h‍_a)]],["isObject", [$h‍_a => (isObject = $h‍_a)]],["objectHasOwnProperty", [$h‍_a => (objectHasOwnProperty = $h‍_a)]],["ownKeys", [$h‍_a => (ownKeys = $h‍_a)]],["preventExtensions", [$h‍_a => (preventExtensions = $h‍_a)]],["setAdd", [$h‍_a => (setAdd = $h‍_a)]],["setForEach", [$h‍_a => (setForEach = $h‍_a)]],["setHas", [$h‍_a => (setHas = $h‍_a)]],["toStringTagSymbol", [$h‍_a => (toStringTagSymbol = $h‍_a)]],["typedArrayPrototype", [$h‍_a => (typedArrayPrototype = $h‍_a)]],["weakmapGet", [$h‍_a => (weakmapGet = $h‍_a)]],["weakmapSet", [$h‍_a => (weakmapSet = $h‍_a)]],["weaksetAdd", [$h‍_a => (weaksetAdd = $h‍_a)]],["weaksetHas", [$h‍_a => (weaksetHas = $h‍_a)]]]],["./error/assert.js", [["assert", [$h‍_a => (assert = $h‍_a)]]]]]);   





















































/**
 * @typedef {import('../types.js').Harden} Harden
 */

// Obtain the string tag accessor of of TypedArray so we can indirectly use the
// TypedArray brand check it employs.
const typedArrayToStringTag=  getOwnPropertyDescriptor(
  typedArrayPrototype,
  toStringTagSymbol);

assert(typedArrayToStringTag);
const getTypedArrayToStringTag=  typedArrayToStringTag.get;
assert(getTypedArrayToStringTag);

// Exported for tests.
/**
 * Duplicates packages/marshal/src/helpers/passStyle-helpers.js to avoid a dependency.
 *
 * @param {unknown} object
 */
const        isTypedArray=  (object)=>{
  // The object must pass a brand check or toStringTag will return undefined.
  const tag=  apply(getTypedArrayToStringTag, object, []);
  return tag!==  undefined;
 };

/**
 * Tests if a property key is an integer-valued canonical numeric index.
 * https://tc39.es/ecma262/#sec-canonicalnumericindexstring
 *
 * @param {string | symbol} propertyKey
 */$h‍_once.isTypedArray(isTypedArray);
const isCanonicalIntegerIndexString=  (propertyKey)=>{
  const n=  +String(propertyKey);
  return isInteger(n)&&  String(n)===  propertyKey;
 };

/**
 * @template T
 * @param {ArrayLike<T>} array
 */
const freezeTypedArray=  (array)=>{
  preventExtensions(array);

  // Downgrade writable expandos to readonly, even if non-configurable.
  // We get each descriptor individually rather than using
  // getOwnPropertyDescriptors in order to fail safe when encountering
  // an obscure GraalJS issue where getOwnPropertyDescriptor returns
  // undefined for a property that does exist.
  arrayForEach(ownKeys(array), (/** @type {string | symbol} */ name)=>  {
    const desc=  getOwnPropertyDescriptor(array, name);
    assert(desc);
    // TypedArrays are integer-indexed exotic objects, which define special
    // treatment for property names in canonical numeric form:
    // integers in range are permanently writable and non-configurable.
    // https://tc39.es/ecma262/#sec-integer-indexed-exotic-objects
    //
    // This is analogous to the data of a hardened Map or Set,
    // so we carve out this exceptional behavior but make all other
    // properties non-configurable.
    if( !isCanonicalIntegerIndexString(name)) {
      defineProperty(array, name, {
        ...desc,
        writable: false,
        configurable: false});

     }
   });
 };

/**
 * Create a `harden` function.
 *
 * @returns {Harden}
 */
const        makeHardener=  ()=>  {
  // Use a native hardener if possible.
  if( typeof globalThis.harden===  'function') {
    const safeHarden=  globalThis.harden;
    return safeHarden;
   }

  const hardened=  new WeakSet();

  const { harden}=   {
    /**
     * @template T
     * @param {T} root
     * @returns {T}
     */
    harden(root) {
      const toFreeze=  new Set();
      const paths=  new WeakMap();

      // If val is something we should be freezing but aren't yet,
      // add it to toFreeze.
      /**
       * @param {any} val
       * @param {string} [path]
       */
      function enqueue(val, path=  undefined) {
        if( !isObject(val)) {
          // ignore primitives
          return;
         }
        const type=  typeof val;
        if( type!==  'object'&&  type!==  'function') {
          // future proof: break until someone figures out what it should do
          throw TypeError( `Unexpected typeof: ${type}`);
         }
        if( weaksetHas(hardened, val)||  setHas(toFreeze, val)) {
          // Ignore if this is an exit, or we've already visited it
          return;
         }
        // console.warn(`adding ${val} to toFreeze`, val);
        setAdd(toFreeze, val);
        weakmapSet(paths, val, path);
       }

      /**
       * @param {any} obj
       */
      function freezeAndTraverse(obj) {
        // Now freeze the object to ensure reactive
        // objects such as proxies won't add properties
        // during traversal, before they get frozen.

        // Object are verified before being enqueued,
        // therefore this is a valid candidate.
        // Throws if this fails (strict mode).
        // Also throws if the object is an ArrayBuffer or any TypedArray.
        if( isTypedArray(obj)) {
          freezeTypedArray(obj);
         }else {
          freeze(obj);
         }

        // we rely upon certain commitments of Object.freeze and proxies here

        // get stable/immutable outbound links before a Proxy has a chance to do
        // something sneaky.
        const path=  weakmapGet(paths, obj)||  'unknown';
        const descs=  getOwnPropertyDescriptors(obj);
        const proto=  getPrototypeOf(obj);
        enqueue(proto,  `${path}.__proto__`);

        arrayForEach(ownKeys(descs), (/** @type {string | symbol} */ name)=>  {
          const pathname=   `${path}.${String(name)}`;
          // The 'name' may be a symbol, and TypeScript doesn't like us to
          // index arbitrary symbols on objects, so we pretend they're just
          // strings.
          const desc=  descs[/** @type {string} */  name];
          // getOwnPropertyDescriptors is guaranteed to return well-formed
          // descriptors, but they still inherit from Object.prototype. If
          // someone has poisoned Object.prototype to add 'value' or 'get'
          // properties, then a simple 'if ("value" in desc)' or 'desc.value'
          // test could be confused. We use hasOwnProperty to be sure about
          // whether 'value' is present or not, which tells us for sure that
          // this is a data property.
          if( objectHasOwnProperty(desc, 'value')) {
            enqueue(desc.value,  `${pathname}`);
           }else {
            enqueue(desc.get,  `${pathname}(get)`);
            enqueue(desc.set,  `${pathname}(set)`);
           }
         });
       }

      function dequeue() {
        // New values added before forEach() has finished will be visited.
        setForEach(toFreeze, freezeAndTraverse);
       }

      /** @param {any} value */
      function markHardened(value) {
        weaksetAdd(hardened, value);
       }

      function commit() {
        setForEach(toFreeze, markHardened);
       }

      enqueue(root);
      dequeue();
      // console.warn("toFreeze set:", toFreeze);
      commit();

      return root;
     }};


  return harden;
 };$h‍_once.makeHardener(makeHardener);
})()
,
// === functors[11] ===
({   imports: $h‍_imports,   liveVar: $h‍_live,   onceVar: $h‍_once,   importMeta: $h‍____meta, }) => (function () {   $h‍_imports([]);   /* eslint-disable no-restricted-globals */
/**
 * @file Exports {@code whitelist}, a recursively defined
 * JSON record enumerating all intrinsics and their properties
 * according to ECMA specs.
 *
 * @author JF Paradis
 * @author Mark S. Miller
 */

/* eslint max-lines: 0 */

/**
 * constantProperties
 * non-configurable, non-writable data properties of all global objects.
 * Must be powerless.
 * Maps from property name to the actual value
 */
const        constantProperties=  {
  // *** Value Properties of the Global Object

  Infinity,
  NaN,
  undefined};


/**
 * universalPropertyNames
 * Properties of all global objects.
 * Must be powerless.
 * Maps from property name to the intrinsic name in the whitelist.
 */$h‍_once.constantProperties(constantProperties);
const        universalPropertyNames=  {
  // *** Function Properties of the Global Object

  isFinite: 'isFinite',
  isNaN: 'isNaN',
  parseFloat: 'parseFloat',
  parseInt: 'parseInt',

  decodeURI: 'decodeURI',
  decodeURIComponent: 'decodeURIComponent',
  encodeURI: 'encodeURI',
  encodeURIComponent: 'encodeURIComponent',

  // *** Constructor Properties of the Global Object

  Array: 'Array',
  ArrayBuffer: 'ArrayBuffer',
  BigInt: 'BigInt',
  BigInt64Array: 'BigInt64Array',
  BigUint64Array: 'BigUint64Array',
  Boolean: 'Boolean',
  DataView: 'DataView',
  EvalError: 'EvalError',
  Float32Array: 'Float32Array',
  Float64Array: 'Float64Array',
  Int8Array: 'Int8Array',
  Int16Array: 'Int16Array',
  Int32Array: 'Int32Array',
  Map: 'Map',
  Number: 'Number',
  Object: 'Object',
  Promise: 'Promise',
  Proxy: 'Proxy',
  RangeError: 'RangeError',
  ReferenceError: 'ReferenceError',
  Set: 'Set',
  String: 'String',
  SyntaxError: 'SyntaxError',
  TypeError: 'TypeError',
  Uint8Array: 'Uint8Array',
  Uint8ClampedArray: 'Uint8ClampedArray',
  Uint16Array: 'Uint16Array',
  Uint32Array: 'Uint32Array',
  URIError: 'URIError',
  WeakMap: 'WeakMap',
  WeakSet: 'WeakSet',
  // https://github.com/tc39/proposal-iterator-helpers
  Iterator: 'Iterator',
  // https://github.com/tc39/proposal-async-iterator-helpers
  AsyncIterator: 'AsyncIterator',

  // *** Other Properties of the Global Object

  JSON: 'JSON',
  Reflect: 'Reflect',

  // *** Annex B

  escape: 'escape',
  unescape: 'unescape',

  // ESNext

  lockdown: 'lockdown',
  harden: 'harden',
  HandledPromise: 'HandledPromise'  // TODO: Until Promise.delegate (see below).
};

/**
 * initialGlobalPropertyNames
 * Those found only on the initial global, i.e., the global of the
 * start compartment, as well as any compartments created before lockdown.
 * These may provide much of the power provided by the original.
 * Maps from property name to the intrinsic name in the whitelist.
 */$h‍_once.universalPropertyNames(universalPropertyNames);
const        initialGlobalPropertyNames=  {
  // *** Constructor Properties of the Global Object

  Date: '%InitialDate%',
  Error: '%InitialError%',
  RegExp: '%InitialRegExp%',

  // Omit `Symbol`, because we want the original to appear on the
  // start compartment without passing through the whitelist mechanism, since
  // we want to preserve all its properties, even if we never heard of them.
  // Symbol: '%InitialSymbol%',

  // *** Other Properties of the Global Object

  Math: '%InitialMath%',

  // ESNext

  // From Error-stack proposal
  // Only on initial global. No corresponding
  // powerless form for other globals.
  getStackString: '%InitialGetStackString%'

  // TODO https://github.com/Agoric/SES-shim/issues/551
  // Need initial WeakRef and FinalizationGroup in
  // start compartment only.
};

/**
 * sharedGlobalPropertyNames
 * Those found only on the globals of new compartments created after lockdown,
 * which must therefore be powerless.
 * Maps from property name to the intrinsic name in the whitelist.
 */$h‍_once.initialGlobalPropertyNames(initialGlobalPropertyNames);
const        sharedGlobalPropertyNames=  {
  // *** Constructor Properties of the Global Object

  Date: '%SharedDate%',
  Error: '%SharedError%',
  RegExp: '%SharedRegExp%',
  Symbol: '%SharedSymbol%',

  // *** Other Properties of the Global Object

  Math: '%SharedMath%'};


/**
 * uniqueGlobalPropertyNames
 * Those made separately for each global, including the initial global
 * of the start compartment.
 * Maps from property name to the intrinsic name in the whitelist
 * (which is currently always the same).
 */$h‍_once.sharedGlobalPropertyNames(sharedGlobalPropertyNames);
const        uniqueGlobalPropertyNames=  {
  // *** Value Properties of the Global Object

  globalThis: '%UniqueGlobalThis%',

  // *** Function Properties of the Global Object

  eval: '%UniqueEval%',

  // *** Constructor Properties of the Global Object

  Function: '%UniqueFunction%',

  // *** Other Properties of the Global Object

  // ESNext

  Compartment: '%UniqueCompartment%'
  // According to current agreements, eventually the Realm constructor too.
  // 'Realm',
};

// All the "subclasses" of Error. These are collectively represented in the
// ECMAScript spec by the meta variable NativeError.
// TODO Add AggregateError https://github.com/Agoric/SES-shim/issues/550
$h‍_once.uniqueGlobalPropertyNames(uniqueGlobalPropertyNames);const NativeErrors=[
  EvalError,
  RangeError,
  ReferenceError,
  SyntaxError,
  TypeError,
  URIError];


/**
 * <p>Each JSON record enumerates the disposition of the properties on
 *    some corresponding intrinsic object.
 *
 * <p>All records are made of key-value pairs where the key
 *    is the property to process, and the value is the associated
 *    dispositions a.k.a. the "permit". Those permits can be:
 * <ul>
 * <li>The boolean value "false", in which case this property is
 *     blacklisted and simply removed. Properties not mentioned
 *     are also considered blacklisted and are removed.
 * <li>A string value equal to a primitive ("number", "string", etc),
 *     in which case the property is whitelisted if its value property
 *     is typeof the given type. For example, {@code "Infinity"} leads to
 *     "number" and property values that fail {@code typeof "number"}.
 *     are removed.
 * <li>A string value equal to an intinsic name ("ObjectPrototype",
 *     "Array", etc), in which case the property whitelisted if its
 *     value property is equal to the value of the corresponfing
 *     intrinsics. For example, {@code Map.prototype} leads to
 *     "MapPrototype" and the property is removed if its value is
 *     not equal to %MapPrototype%
 * <li>Another record, in which case this property is simply
 *     whitelisted and that next record represents the disposition of
 *     the object which is its value. For example, {@code "Object"}
 *     leads to another record explaining what properties {@code
 *     "Object"} may have and how each such property should be treated.
 *
 * <p>Notes:
 * <li>"[[Proto]]" is used to refer to the "[[Prototype]]" internal
 *     slot, which says which object this object inherits from.
 * <li>"--proto--" is used to refer to the "__proto__" property name,
 *     which is the name of an accessor property on Object.prototype.
 *     In practice, it is used to access the [[Proto]] internal slot,
 *     but is distinct from the internal slot itself. We use
 *     "--proto--" rather than "__proto__" below because "__proto__"
 *     in an object literal is special syntax rather than a normal
 *     property definition.
 * <li>"ObjectPrototype" is the default "[[Proto]]" (when not specified).
 * <li>Constants "fn" and "getter" are used to keep the structure DRY.
 * <li>Symbol properties are listed as follow:
 *     <li>Well-known symbols use the "@@name" form.
 *     <li>Registered symbols use the "RegisteredSymbol(key)" form.
 *     <li>Unique symbols use the "UniqueSymbol(description)" form.
 */

// Function Instances
$h‍_once.NativeErrors(NativeErrors);const FunctionInstance={
  '[[Proto]]': '%FunctionPrototype%',
  length: 'number',
  name: 'string'
  // Do not specify "prototype" here, since only Function instances that can
  // be used as a constructor have a prototype property. For constructors,
  // since prototype properties are instance-specific, we define it there.
};

// AsyncFunction Instances
$h‍_once.FunctionInstance(FunctionInstance);const AsyncFunctionInstance={
  // This property is not mentioned in ECMA 262, but is present in V8 and
  // necessary for lockdown to succeed.
  '[[Proto]]': '%AsyncFunctionPrototype%'};


// Aliases
$h‍_once.AsyncFunctionInstance(AsyncFunctionInstance);const fn=FunctionInstance;
const asyncFn=  AsyncFunctionInstance;

const getter=  {
  get: fn,
  set: 'undefined'};


// Possible but not encountered in the specs
// export const setter = {
//   get: 'undefined',
//   set: fn,
// };

const accessor=  {
  get: fn,
  set: fn};


const        isAccessorPermit=  (permit)=>{
  return permit===  getter||  permit===  accessor;
 };

// NativeError Object Structure
$h‍_once.isAccessorPermit(isAccessorPermit);function NativeError(prototype){
  return {
    // Properties of the NativeError Constructors
    '[[Proto]]': '%SharedError%',

    // NativeError.prototype
    prototype};

 }

function NativeErrorPrototype(constructor) {
  return {
    // Properties of the NativeError Prototype Objects
    '[[Proto]]': '%ErrorPrototype%',
    constructor,
    message: 'string',
    name: 'string',
    // Redundantly present only on v8. Safe to remove.
    toString: false,
    // Superfluously present in some versions of V8.
    // https://github.com/tc39/notes/blob/master/meetings/2021-10/oct-26.md#:~:text=However%2C%20Chrome%2093,and%20node%2016.11.
    cause: false};

 }

// The TypedArray Constructors
function TypedArray(prototype) {
  return {
    // Properties of the TypedArray Constructors
    '[[Proto]]': '%TypedArray%',
    BYTES_PER_ELEMENT: 'number',
    prototype};

 }

function TypedArrayPrototype(constructor) {
  return {
    // Properties of the TypedArray Prototype Objects
    '[[Proto]]': '%TypedArrayPrototype%',
    BYTES_PER_ELEMENT: 'number',
    constructor};

 }

// Without Math.random
const CommonMath=  {
  E: 'number',
  LN10: 'number',
  LN2: 'number',
  LOG10E: 'number',
  LOG2E: 'number',
  PI: 'number',
  SQRT1_2: 'number',
  SQRT2: 'number',
  '@@toStringTag': 'string',
  abs: fn,
  acos: fn,
  acosh: fn,
  asin: fn,
  asinh: fn,
  atan: fn,
  atanh: fn,
  atan2: fn,
  cbrt: fn,
  ceil: fn,
  clz32: fn,
  cos: fn,
  cosh: fn,
  exp: fn,
  expm1: fn,
  floor: fn,
  fround: fn,
  hypot: fn,
  imul: fn,
  log: fn,
  log1p: fn,
  log10: fn,
  log2: fn,
  max: fn,
  min: fn,
  pow: fn,
  round: fn,
  sign: fn,
  sin: fn,
  sinh: fn,
  sqrt: fn,
  tan: fn,
  tanh: fn,
  trunc: fn,
  // See https://github.com/Moddable-OpenSource/moddable/issues/523
  idiv: false,
  // See https://github.com/Moddable-OpenSource/moddable/issues/523
  idivmod: false,
  // See https://github.com/Moddable-OpenSource/moddable/issues/523
  imod: false,
  // See https://github.com/Moddable-OpenSource/moddable/issues/523
  imuldiv: false,
  // See https://github.com/Moddable-OpenSource/moddable/issues/523
  irem: false,
  // See https://github.com/Moddable-OpenSource/moddable/issues/523
  mod: false};


const        permitted=  {
  // ECMA https://tc39.es/ecma262

  // The intrinsics object has no prototype to avoid conflicts.
  '[[Proto]]': null,

  // %ThrowTypeError%
  '%ThrowTypeError%': fn,

  // *** The Global Object

  // *** Value Properties of the Global Object
  Infinity: 'number',
  NaN: 'number',
  undefined: 'undefined',

  // *** Function Properties of the Global Object

  // eval
  '%UniqueEval%': fn,
  isFinite: fn,
  isNaN: fn,
  parseFloat: fn,
  parseInt: fn,
  decodeURI: fn,
  decodeURIComponent: fn,
  encodeURI: fn,
  encodeURIComponent: fn,

  // *** Fundamental Objects

  Object: {
    // Properties of the Object Constructor
    '[[Proto]]': '%FunctionPrototype%',
    assign: fn,
    create: fn,
    defineProperties: fn,
    defineProperty: fn,
    entries: fn,
    freeze: fn,
    fromEntries: fn,
    getOwnPropertyDescriptor: fn,
    getOwnPropertyDescriptors: fn,
    getOwnPropertyNames: fn,
    getOwnPropertySymbols: fn,
    getPrototypeOf: fn,
    hasOwn: fn,
    is: fn,
    isExtensible: fn,
    isFrozen: fn,
    isSealed: fn,
    keys: fn,
    preventExtensions: fn,
    prototype: '%ObjectPrototype%',
    seal: fn,
    setPrototypeOf: fn,
    values: fn,
    // https://github.com/tc39/proposal-array-grouping
    groupBy: fn},


  '%ObjectPrototype%': {
    // Properties of the Object Prototype Object
    '[[Proto]]': null,
    constructor: 'Object',
    hasOwnProperty: fn,
    isPrototypeOf: fn,
    propertyIsEnumerable: fn,
    toLocaleString: fn,
    toString: fn,
    valueOf: fn,

    // Annex B: Additional Properties of the Object.prototype Object

    // See note in header about the difference between [[Proto]] and --proto--
    // special notations.
    '--proto--': accessor,
    __defineGetter__: fn,
    __defineSetter__: fn,
    __lookupGetter__: fn,
    __lookupSetter__: fn},


  '%UniqueFunction%': {
    // Properties of the Function Constructor
    '[[Proto]]': '%FunctionPrototype%',
    prototype: '%FunctionPrototype%'},


  '%InertFunction%': {
    '[[Proto]]': '%FunctionPrototype%',
    prototype: '%FunctionPrototype%'},


  '%FunctionPrototype%': {
    apply: fn,
    bind: fn,
    call: fn,
    constructor: '%InertFunction%',
    toString: fn,
    '@@hasInstance': fn,
    // proposed but not yet std. To be removed if there
    caller: false,
    // proposed but not yet std. To be removed if there
    arguments: false},


  Boolean: {
    // Properties of the Boolean Constructor
    '[[Proto]]': '%FunctionPrototype%',
    prototype: '%BooleanPrototype%'},


  '%BooleanPrototype%': {
    constructor: 'Boolean',
    toString: fn,
    valueOf: fn},


  '%SharedSymbol%': {
    // Properties of the Symbol Constructor
    '[[Proto]]': '%FunctionPrototype%',
    asyncDispose: 'symbol',
    asyncIterator: 'symbol',
    dispose: 'symbol',
    for: fn,
    hasInstance: 'symbol',
    isConcatSpreadable: 'symbol',
    iterator: 'symbol',
    keyFor: fn,
    match: 'symbol',
    matchAll: 'symbol',
    prototype: '%SymbolPrototype%',
    replace: 'symbol',
    search: 'symbol',
    species: 'symbol',
    split: 'symbol',
    toPrimitive: 'symbol',
    toStringTag: 'symbol',
    unscopables: 'symbol',
    // Seen at core-js https://github.com/zloirock/core-js#ecmascript-symbol
    useSimple: false,
    // Seen at core-js https://github.com/zloirock/core-js#ecmascript-symbol
    useSetter: false},


  '%SymbolPrototype%': {
    // Properties of the Symbol Prototype Object
    constructor: '%SharedSymbol%',
    description: getter,
    toString: fn,
    valueOf: fn,
    '@@toPrimitive': fn,
    '@@toStringTag': 'string'},


  '%InitialError%': {
    // Properties of the Error Constructor
    '[[Proto]]': '%FunctionPrototype%',
    prototype: '%ErrorPrototype%',
    // Non standard, v8 only, used by tap
    captureStackTrace: fn,
    // Non standard, v8 only, used by tap, tamed to accessor
    stackTraceLimit: accessor,
    // Non standard, v8 only, used by several, tamed to accessor
    prepareStackTrace: accessor},


  '%SharedError%': {
    // Properties of the Error Constructor
    '[[Proto]]': '%FunctionPrototype%',
    prototype: '%ErrorPrototype%',
    // Non standard, v8 only, used by tap
    captureStackTrace: fn,
    // Non standard, v8 only, used by tap, tamed to accessor
    stackTraceLimit: accessor,
    // Non standard, v8 only, used by several, tamed to accessor
    prepareStackTrace: accessor},


  '%ErrorPrototype%': {
    constructor: '%SharedError%',
    message: 'string',
    name: 'string',
    toString: fn,
    // proposed de-facto, assumed TODO
    // Seen on FF Nightly 88.0a1
    at: false,
    // Seen on FF and XS
    stack: accessor,
    // Superfluously present in some versions of V8.
    // https://github.com/tc39/notes/blob/master/meetings/2021-10/oct-26.md#:~:text=However%2C%20Chrome%2093,and%20node%2016.11.
    cause: false},


  // NativeError

  EvalError: NativeError('%EvalErrorPrototype%'),
  RangeError: NativeError('%RangeErrorPrototype%'),
  ReferenceError: NativeError('%ReferenceErrorPrototype%'),
  SyntaxError: NativeError('%SyntaxErrorPrototype%'),
  TypeError: NativeError('%TypeErrorPrototype%'),
  URIError: NativeError('%URIErrorPrototype%'),

  '%EvalErrorPrototype%': NativeErrorPrototype('EvalError'),
  '%RangeErrorPrototype%': NativeErrorPrototype('RangeError'),
  '%ReferenceErrorPrototype%': NativeErrorPrototype('ReferenceError'),
  '%SyntaxErrorPrototype%': NativeErrorPrototype('SyntaxError'),
  '%TypeErrorPrototype%': NativeErrorPrototype('TypeError'),
  '%URIErrorPrototype%': NativeErrorPrototype('URIError'),

  // *** Numbers and Dates

  Number: {
    // Properties of the Number Constructor
    '[[Proto]]': '%FunctionPrototype%',
    EPSILON: 'number',
    isFinite: fn,
    isInteger: fn,
    isNaN: fn,
    isSafeInteger: fn,
    MAX_SAFE_INTEGER: 'number',
    MAX_VALUE: 'number',
    MIN_SAFE_INTEGER: 'number',
    MIN_VALUE: 'number',
    NaN: 'number',
    NEGATIVE_INFINITY: 'number',
    parseFloat: fn,
    parseInt: fn,
    POSITIVE_INFINITY: 'number',
    prototype: '%NumberPrototype%'},


  '%NumberPrototype%': {
    // Properties of the Number Prototype Object
    constructor: 'Number',
    toExponential: fn,
    toFixed: fn,
    toLocaleString: fn,
    toPrecision: fn,
    toString: fn,
    valueOf: fn},


  BigInt: {
    // Properties of the BigInt Constructor
    '[[Proto]]': '%FunctionPrototype%',
    asIntN: fn,
    asUintN: fn,
    prototype: '%BigIntPrototype%',
    // See https://github.com/Moddable-OpenSource/moddable/issues/523
    bitLength: false,
    // See https://github.com/Moddable-OpenSource/moddable/issues/523
    fromArrayBuffer: false},


  '%BigIntPrototype%': {
    constructor: 'BigInt',
    toLocaleString: fn,
    toString: fn,
    valueOf: fn,
    '@@toStringTag': 'string'},


  '%InitialMath%': {
    ...CommonMath,
    // `%InitialMath%.random()` has the standard unsafe behavior
    random: fn},


  '%SharedMath%': {
    ...CommonMath,
    // `%SharedMath%.random()` is tamed to always throw
    random: fn},


  '%InitialDate%': {
    // Properties of the Date Constructor
    '[[Proto]]': '%FunctionPrototype%',
    now: fn,
    parse: fn,
    prototype: '%DatePrototype%',
    UTC: fn},


  '%SharedDate%': {
    // Properties of the Date Constructor
    '[[Proto]]': '%FunctionPrototype%',
    // `%SharedDate%.now()` is tamed to always throw
    now: fn,
    parse: fn,
    prototype: '%DatePrototype%',
    UTC: fn},


  '%DatePrototype%': {
    constructor: '%SharedDate%',
    getDate: fn,
    getDay: fn,
    getFullYear: fn,
    getHours: fn,
    getMilliseconds: fn,
    getMinutes: fn,
    getMonth: fn,
    getSeconds: fn,
    getTime: fn,
    getTimezoneOffset: fn,
    getUTCDate: fn,
    getUTCDay: fn,
    getUTCFullYear: fn,
    getUTCHours: fn,
    getUTCMilliseconds: fn,
    getUTCMinutes: fn,
    getUTCMonth: fn,
    getUTCSeconds: fn,
    setDate: fn,
    setFullYear: fn,
    setHours: fn,
    setMilliseconds: fn,
    setMinutes: fn,
    setMonth: fn,
    setSeconds: fn,
    setTime: fn,
    setUTCDate: fn,
    setUTCFullYear: fn,
    setUTCHours: fn,
    setUTCMilliseconds: fn,
    setUTCMinutes: fn,
    setUTCMonth: fn,
    setUTCSeconds: fn,
    toDateString: fn,
    toISOString: fn,
    toJSON: fn,
    toLocaleDateString: fn,
    toLocaleString: fn,
    toLocaleTimeString: fn,
    toString: fn,
    toTimeString: fn,
    toUTCString: fn,
    valueOf: fn,
    '@@toPrimitive': fn,

    // Annex B: Additional Properties of the Date.prototype Object
    getYear: fn,
    setYear: fn,
    toGMTString: fn},


  // Text Processing

  String: {
    // Properties of the String Constructor
    '[[Proto]]': '%FunctionPrototype%',
    fromCharCode: fn,
    fromCodePoint: fn,
    prototype: '%StringPrototype%',
    raw: fn,
    // See https://github.com/Moddable-OpenSource/moddable/issues/523
    fromArrayBuffer: false},


  '%StringPrototype%': {
    // Properties of the String Prototype Object
    length: 'number',
    at: fn,
    charAt: fn,
    charCodeAt: fn,
    codePointAt: fn,
    concat: fn,
    constructor: 'String',
    endsWith: fn,
    includes: fn,
    indexOf: fn,
    lastIndexOf: fn,
    localeCompare: fn,
    match: fn,
    matchAll: fn,
    normalize: fn,
    padEnd: fn,
    padStart: fn,
    repeat: fn,
    replace: fn,
    replaceAll: fn, // ES2021
    search: fn,
    slice: fn,
    split: fn,
    startsWith: fn,
    substring: fn,
    toLocaleLowerCase: fn,
    toLocaleUpperCase: fn,
    toLowerCase: fn,
    toString: fn,
    toUpperCase: fn,
    trim: fn,
    trimEnd: fn,
    trimStart: fn,
    valueOf: fn,
    '@@iterator': fn,

    // Annex B: Additional Properties of the String.prototype Object
    substr: fn,
    anchor: fn,
    big: fn,
    blink: fn,
    bold: fn,
    fixed: fn,
    fontcolor: fn,
    fontsize: fn,
    italics: fn,
    link: fn,
    small: fn,
    strike: fn,
    sub: fn,
    sup: fn,
    trimLeft: fn,
    trimRight: fn,
    // See https://github.com/Moddable-OpenSource/moddable/issues/523
    compare: false,
    // https://github.com/tc39/proposal-is-usv-string
    isWellFormed: fn,
    toWellFormed: fn,
    unicodeSets: fn},


  '%StringIteratorPrototype%': {
    '[[Proto]]': '%IteratorPrototype%',
    next: fn,
    '@@toStringTag': 'string'},


  '%InitialRegExp%': {
    // Properties of the RegExp Constructor
    '[[Proto]]': '%FunctionPrototype%',
    prototype: '%RegExpPrototype%',
    '@@species': getter,

    // The https://github.com/tc39/proposal-regexp-legacy-features
    // are all optional, unsafe, and omitted
    input: false,
    $_: false,
    lastMatch: false,
    '$&': false,
    lastParen: false,
    '$+': false,
    leftContext: false,
    '$`': false,
    rightContext: false,
    "$'": false,
    $1: false,
    $2: false,
    $3: false,
    $4: false,
    $5: false,
    $6: false,
    $7: false,
    $8: false,
    $9: false},


  '%SharedRegExp%': {
    // Properties of the RegExp Constructor
    '[[Proto]]': '%FunctionPrototype%',
    prototype: '%RegExpPrototype%',
    '@@species': getter},


  '%RegExpPrototype%': {
    // Properties of the RegExp Prototype Object
    constructor: '%SharedRegExp%',
    exec: fn,
    dotAll: getter,
    flags: getter,
    global: getter,
    hasIndices: getter,
    ignoreCase: getter,
    '@@match': fn,
    '@@matchAll': fn,
    multiline: getter,
    '@@replace': fn,
    '@@search': fn,
    source: getter,
    '@@split': fn,
    sticky: getter,
    test: fn,
    toString: fn,
    unicode: getter,
    unicodeSets: getter,

    // Annex B: Additional Properties of the RegExp.prototype Object
    compile: false  // UNSAFE and suppressed.
},

  '%RegExpStringIteratorPrototype%': {
    // The %RegExpStringIteratorPrototype% Object
    '[[Proto]]': '%IteratorPrototype%',
    next: fn,
    '@@toStringTag': 'string'},


  // Indexed Collections

  Array: {
    // Properties of the Array Constructor
    '[[Proto]]': '%FunctionPrototype%',
    from: fn,
    isArray: fn,
    of: fn,
    prototype: '%ArrayPrototype%',
    '@@species': getter,

    // Stage 3:
    // https://tc39.es/proposal-relative-indexing-method/
    at: fn,
    // https://tc39.es/proposal-array-from-async/
    fromAsync: fn},


  '%ArrayPrototype%': {
    // Properties of the Array Prototype Object
    at: fn,
    length: 'number',
    concat: fn,
    constructor: 'Array',
    copyWithin: fn,
    entries: fn,
    every: fn,
    fill: fn,
    filter: fn,
    find: fn,
    findIndex: fn,
    flat: fn,
    flatMap: fn,
    forEach: fn,
    includes: fn,
    indexOf: fn,
    join: fn,
    keys: fn,
    lastIndexOf: fn,
    map: fn,
    pop: fn,
    push: fn,
    reduce: fn,
    reduceRight: fn,
    reverse: fn,
    shift: fn,
    slice: fn,
    some: fn,
    sort: fn,
    splice: fn,
    toLocaleString: fn,
    toString: fn,
    unshift: fn,
    values: fn,
    '@@iterator': fn,
    '@@unscopables': {
      '[[Proto]]': null,
      copyWithin: 'boolean',
      entries: 'boolean',
      fill: 'boolean',
      find: 'boolean',
      findIndex: 'boolean',
      flat: 'boolean',
      flatMap: 'boolean',
      includes: 'boolean',
      keys: 'boolean',
      values: 'boolean',
      // Failed tc39 proposal
      // Seen on FF Nightly 88.0a1
      at: 'boolean',
      // See https://github.com/tc39/proposal-array-find-from-last
      findLast: 'boolean',
      findLastIndex: 'boolean',
      // https://github.com/tc39/proposal-change-array-by-copy
      toReversed: 'boolean',
      toSorted: 'boolean',
      toSpliced: 'boolean',
      with: 'boolean',
      // https://github.com/tc39/proposal-array-grouping
      group: 'boolean',
      groupToMap: 'boolean',
      groupBy: 'boolean'},

    // See https://github.com/tc39/proposal-array-find-from-last
    findLast: fn,
    findLastIndex: fn,
    // https://github.com/tc39/proposal-change-array-by-copy
    toReversed: fn,
    toSorted: fn,
    toSpliced: fn,
    with: fn,
    // https://github.com/tc39/proposal-array-grouping
    group: fn, // Not in proposal? Where?
    groupToMap: fn, // Not in proposal? Where?
    groupBy: fn},


  '%ArrayIteratorPrototype%': {
    // The %ArrayIteratorPrototype% Object
    '[[Proto]]': '%IteratorPrototype%',
    next: fn,
    '@@toStringTag': 'string'},


  // *** TypedArray Objects

  '%TypedArray%': {
    // Properties of the %TypedArray% Intrinsic Object
    '[[Proto]]': '%FunctionPrototype%',
    from: fn,
    of: fn,
    prototype: '%TypedArrayPrototype%',
    '@@species': getter},


  '%TypedArrayPrototype%': {
    at: fn,
    buffer: getter,
    byteLength: getter,
    byteOffset: getter,
    constructor: '%TypedArray%',
    copyWithin: fn,
    entries: fn,
    every: fn,
    fill: fn,
    filter: fn,
    find: fn,
    findIndex: fn,
    forEach: fn,
    includes: fn,
    indexOf: fn,
    join: fn,
    keys: fn,
    lastIndexOf: fn,
    length: getter,
    map: fn,
    reduce: fn,
    reduceRight: fn,
    reverse: fn,
    set: fn,
    slice: fn,
    some: fn,
    sort: fn,
    subarray: fn,
    toLocaleString: fn,
    toString: fn,
    values: fn,
    '@@iterator': fn,
    '@@toStringTag': getter,
    // See https://github.com/tc39/proposal-array-find-from-last
    findLast: fn,
    findLastIndex: fn,
    // https://github.com/tc39/proposal-change-array-by-copy
    toReversed: fn,
    toSorted: fn,
    with: fn},


  // The TypedArray Constructors

  BigInt64Array: TypedArray('%BigInt64ArrayPrototype%'),
  BigUint64Array: TypedArray('%BigUint64ArrayPrototype%'),
  Float32Array: TypedArray('%Float32ArrayPrototype%'),
  Float64Array: TypedArray('%Float64ArrayPrototype%'),
  Int16Array: TypedArray('%Int16ArrayPrototype%'),
  Int32Array: TypedArray('%Int32ArrayPrototype%'),
  Int8Array: TypedArray('%Int8ArrayPrototype%'),
  Uint16Array: TypedArray('%Uint16ArrayPrototype%'),
  Uint32Array: TypedArray('%Uint32ArrayPrototype%'),
  Uint8Array: TypedArray('%Uint8ArrayPrototype%'),
  Uint8ClampedArray: TypedArray('%Uint8ClampedArrayPrototype%'),

  '%BigInt64ArrayPrototype%': TypedArrayPrototype('BigInt64Array'),
  '%BigUint64ArrayPrototype%': TypedArrayPrototype('BigUint64Array'),
  '%Float32ArrayPrototype%': TypedArrayPrototype('Float32Array'),
  '%Float64ArrayPrototype%': TypedArrayPrototype('Float64Array'),
  '%Int16ArrayPrototype%': TypedArrayPrototype('Int16Array'),
  '%Int32ArrayPrototype%': TypedArrayPrototype('Int32Array'),
  '%Int8ArrayPrototype%': TypedArrayPrototype('Int8Array'),
  '%Uint16ArrayPrototype%': TypedArrayPrototype('Uint16Array'),
  '%Uint32ArrayPrototype%': TypedArrayPrototype('Uint32Array'),
  '%Uint8ArrayPrototype%': TypedArrayPrototype('Uint8Array'),
  '%Uint8ClampedArrayPrototype%': TypedArrayPrototype('Uint8ClampedArray'),

  // *** Keyed Collections

  Map: {
    // Properties of the Map Constructor
    '[[Proto]]': '%FunctionPrototype%',
    '@@species': getter,
    prototype: '%MapPrototype%',
    // https://github.com/tc39/proposal-array-grouping
    groupBy: fn},


  '%MapPrototype%': {
    clear: fn,
    constructor: 'Map',
    delete: fn,
    entries: fn,
    forEach: fn,
    get: fn,
    has: fn,
    keys: fn,
    set: fn,
    size: getter,
    values: fn,
    '@@iterator': fn,
    '@@toStringTag': 'string'},


  '%MapIteratorPrototype%': {
    // The %MapIteratorPrototype% Object
    '[[Proto]]': '%IteratorPrototype%',
    next: fn,
    '@@toStringTag': 'string'},


  Set: {
    // Properties of the Set Constructor
    '[[Proto]]': '%FunctionPrototype%',
    prototype: '%SetPrototype%',
    '@@species': getter},


  '%SetPrototype%': {
    add: fn,
    clear: fn,
    constructor: 'Set',
    delete: fn,
    entries: fn,
    forEach: fn,
    has: fn,
    keys: fn,
    size: getter,
    values: fn,
    '@@iterator': fn,
    '@@toStringTag': 'string'},


  '%SetIteratorPrototype%': {
    // The %SetIteratorPrototype% Object
    '[[Proto]]': '%IteratorPrototype%',
    next: fn,
    '@@toStringTag': 'string'},


  WeakMap: {
    // Properties of the WeakMap Constructor
    '[[Proto]]': '%FunctionPrototype%',
    prototype: '%WeakMapPrototype%'},


  '%WeakMapPrototype%': {
    constructor: 'WeakMap',
    delete: fn,
    get: fn,
    has: fn,
    set: fn,
    '@@toStringTag': 'string'},


  WeakSet: {
    // Properties of the WeakSet Constructor
    '[[Proto]]': '%FunctionPrototype%',
    prototype: '%WeakSetPrototype%'},


  '%WeakSetPrototype%': {
    add: fn,
    constructor: 'WeakSet',
    delete: fn,
    has: fn,
    '@@toStringTag': 'string'},


  // *** Structured Data

  ArrayBuffer: {
    // Properties of the ArrayBuffer Constructor
    '[[Proto]]': '%FunctionPrototype%',
    isView: fn,
    prototype: '%ArrayBufferPrototype%',
    '@@species': getter,
    // See https://github.com/Moddable-OpenSource/moddable/issues/523
    fromString: false,
    // See https://github.com/Moddable-OpenSource/moddable/issues/523
    fromBigInt: false},


  '%ArrayBufferPrototype%': {
    byteLength: getter,
    constructor: 'ArrayBuffer',
    slice: fn,
    '@@toStringTag': 'string',
    // See https://github.com/Moddable-OpenSource/moddable/issues/523
    concat: false,
    // See https://github.com/tc39/proposal-resizablearraybuffer
    transfer: fn,
    resize: fn,
    resizable: getter,
    maxByteLength: getter,
    // https://github.com/tc39/proposal-arraybuffer-transfer
    transferToFixedLength: fn,
    detached: getter},


  // SharedArrayBuffer Objects
  SharedArrayBuffer: false, // UNSAFE and purposely suppressed.
  '%SharedArrayBufferPrototype%': false, // UNSAFE and purposely suppressed.

  DataView: {
    // Properties of the DataView Constructor
    '[[Proto]]': '%FunctionPrototype%',
    BYTES_PER_ELEMENT: 'number', // Non std but undeletable on Safari.
    prototype: '%DataViewPrototype%'},


  '%DataViewPrototype%': {
    buffer: getter,
    byteLength: getter,
    byteOffset: getter,
    constructor: 'DataView',
    getBigInt64: fn,
    getBigUint64: fn,
    getFloat32: fn,
    getFloat64: fn,
    getInt8: fn,
    getInt16: fn,
    getInt32: fn,
    getUint8: fn,
    getUint16: fn,
    getUint32: fn,
    setBigInt64: fn,
    setBigUint64: fn,
    setFloat32: fn,
    setFloat64: fn,
    setInt8: fn,
    setInt16: fn,
    setInt32: fn,
    setUint8: fn,
    setUint16: fn,
    setUint32: fn,
    '@@toStringTag': 'string'},


  // Atomics
  Atomics: false, // UNSAFE and suppressed.

  JSON: {
    parse: fn,
    stringify: fn,
    '@@toStringTag': 'string',
    // https://github.com/tc39/proposal-json-parse-with-source/
    rawJSON: fn,
    isRawJSON: fn},


  // *** Control Abstraction Objects

  // https://github.com/tc39/proposal-iterator-helpers
  Iterator: {
    // Properties of the Iterator Constructor
    '[[Proto]]': '%FunctionPrototype%',
    prototype: '%IteratorPrototype%',
    from: fn},


  '%IteratorPrototype%': {
    // The %IteratorPrototype% Object
    '@@iterator': fn,
    // https://github.com/tc39/proposal-iterator-helpers
    constructor: 'Iterator',
    map: fn,
    filter: fn,
    take: fn,
    drop: fn,
    flatMap: fn,
    reduce: fn,
    toArray: fn,
    forEach: fn,
    some: fn,
    every: fn,
    find: fn,
    '@@toStringTag': 'string',
    // https://github.com/tc39/proposal-async-iterator-helpers
    toAsync: fn},


  // https://github.com/tc39/proposal-iterator-helpers
  '%WrapForValidIteratorPrototype%': {
    '[[Proto]]': '%IteratorPrototype%',
    next: fn,
    return: fn},


  // https://github.com/tc39/proposal-iterator-helpers
  '%IteratorHelperPrototype%': {
    '[[Proto]]': '%IteratorPrototype%',
    next: fn,
    return: fn,
    '@@toStringTag': 'string'},


  // https://github.com/tc39/proposal-async-iterator-helpers
  AsyncIterator: {
    // Properties of the Iterator Constructor
    '[[Proto]]': '%FunctionPrototype%',
    prototype: '%AsyncIteratorPrototype%',
    from: fn},


  '%AsyncIteratorPrototype%': {
    // The %AsyncIteratorPrototype% Object
    '@@asyncIterator': fn,
    // https://github.com/tc39/proposal-async-iterator-helpers
    constructor: 'AsyncIterator',
    map: fn,
    filter: fn,
    take: fn,
    drop: fn,
    flatMap: fn,
    reduce: fn,
    toArray: fn,
    forEach: fn,
    some: fn,
    every: fn,
    find: fn,
    '@@toStringTag': 'string'},


  // https://github.com/tc39/proposal-async-iterator-helpers
  '%WrapForValidAsyncIteratorPrototype%': {
    '[[Proto]]': '%AsyncIteratorPrototype%',
    next: fn,
    return: fn},


  // https://github.com/tc39/proposal-async-iterator-helpers
  '%AsyncIteratorHelperPrototype%': {
    '[[Proto]]': '%AsyncIteratorPrototype%',
    next: fn,
    return: fn,
    '@@toStringTag': 'string'},


  '%InertGeneratorFunction%': {
    // Properties of the GeneratorFunction Constructor
    '[[Proto]]': '%InertFunction%',
    prototype: '%Generator%'},


  '%Generator%': {
    // Properties of the GeneratorFunction Prototype Object
    '[[Proto]]': '%FunctionPrototype%',
    constructor: '%InertGeneratorFunction%',
    prototype: '%GeneratorPrototype%',
    '@@toStringTag': 'string'},


  '%InertAsyncGeneratorFunction%': {
    // Properties of the AsyncGeneratorFunction Constructor
    '[[Proto]]': '%InertFunction%',
    prototype: '%AsyncGenerator%'},


  '%AsyncGenerator%': {
    // Properties of the AsyncGeneratorFunction Prototype Object
    '[[Proto]]': '%FunctionPrototype%',
    constructor: '%InertAsyncGeneratorFunction%',
    prototype: '%AsyncGeneratorPrototype%',
    // length prop added here for React Native jsc-android
    // https://github.com/endojs/endo/issues/660
    // https://github.com/react-native-community/jsc-android-buildscripts/issues/181
    length: 'number',
    '@@toStringTag': 'string'},


  '%GeneratorPrototype%': {
    // Properties of the Generator Prototype Object
    '[[Proto]]': '%IteratorPrototype%',
    constructor: '%Generator%',
    next: fn,
    return: fn,
    throw: fn,
    '@@toStringTag': 'string'},


  '%AsyncGeneratorPrototype%': {
    // Properties of the AsyncGenerator Prototype Object
    '[[Proto]]': '%AsyncIteratorPrototype%',
    constructor: '%AsyncGenerator%',
    next: fn,
    return: fn,
    throw: fn,
    '@@toStringTag': 'string'},


  // TODO: To be replaced with Promise.delegate
  //
  // The HandledPromise global variable shimmed by `@agoric/eventual-send/shim`
  // implements an initial version of the eventual send specification at:
  // https://github.com/tc39/proposal-eventual-send
  //
  // We will likely change this to add a property to Promise called
  // Promise.delegate and put static methods on it, which will necessitate
  // another whitelist change to update to the current proposed standard.
  HandledPromise: {
    '[[Proto]]': 'Promise',
    applyFunction: fn,
    applyFunctionSendOnly: fn,
    applyMethod: fn,
    applyMethodSendOnly: fn,
    get: fn,
    getSendOnly: fn,
    prototype: '%PromisePrototype%',
    resolve: fn},


  Promise: {
    // Properties of the Promise Constructor
    '[[Proto]]': '%FunctionPrototype%',
    all: fn,
    allSettled: fn,
    // To transition from `false` to `fn` once we also have `AggregateError`
    // TODO https://github.com/Agoric/SES-shim/issues/550
    any: false, // ES2021
    prototype: '%PromisePrototype%',
    race: fn,
    reject: fn,
    resolve: fn,
    '@@species': getter},


  '%PromisePrototype%': {
    // Properties of the Promise Prototype Object
    catch: fn,
    constructor: 'Promise',
    finally: fn,
    then: fn,
    '@@toStringTag': 'string',
    // Non-standard, used in node to prevent async_hooks from breaking
    'UniqueSymbol(async_id_symbol)': accessor,
    'UniqueSymbol(trigger_async_id_symbol)': accessor,
    'UniqueSymbol(destroyed)': accessor},


  '%InertAsyncFunction%': {
    // Properties of the AsyncFunction Constructor
    '[[Proto]]': '%InertFunction%',
    prototype: '%AsyncFunctionPrototype%'},


  '%AsyncFunctionPrototype%': {
    // Properties of the AsyncFunction Prototype Object
    '[[Proto]]': '%FunctionPrototype%',
    constructor: '%InertAsyncFunction%',
    // length prop added here for React Native jsc-android
    // https://github.com/endojs/endo/issues/660
    // https://github.com/react-native-community/jsc-android-buildscripts/issues/181
    length: 'number',
    '@@toStringTag': 'string'},


  // Reflection

  Reflect: {
    // The Reflect Object
    // Not a function object.
    apply: fn,
    construct: fn,
    defineProperty: fn,
    deleteProperty: fn,
    get: fn,
    getOwnPropertyDescriptor: fn,
    getPrototypeOf: fn,
    has: fn,
    isExtensible: fn,
    ownKeys: fn,
    preventExtensions: fn,
    set: fn,
    setPrototypeOf: fn,
    '@@toStringTag': 'string'},


  Proxy: {
    // Properties of the Proxy Constructor
    '[[Proto]]': '%FunctionPrototype%',
    revocable: fn},


  // Appendix B

  // Annex B: Additional Properties of the Global Object

  escape: fn,
  unescape: fn,

  // Proposed

  '%UniqueCompartment%': {
    '[[Proto]]': '%FunctionPrototype%',
    prototype: '%CompartmentPrototype%',
    toString: fn},


  '%InertCompartment%': {
    '[[Proto]]': '%FunctionPrototype%',
    prototype: '%CompartmentPrototype%',
    toString: fn},


  '%CompartmentPrototype%': {
    constructor: '%InertCompartment%',
    evaluate: fn,
    globalThis: getter,
    name: getter,
    // Should this be proposed?
    toString: fn,
    import: asyncFn,
    load: asyncFn,
    importNow: fn,
    module: fn},


  lockdown: fn,
  harden: { ...fn, isFake: 'boolean'},

  '%InitialGetStackString%': fn};$h‍_once.permitted(permitted);
})()
,
// === functors[12] ===
({   imports: $h‍_imports,   liveVar: $h‍_live,   onceVar: $h‍_once,   importMeta: $h‍____meta, }) => (function () {   let TypeError,WeakSet,arrayFilter,create,defineProperty,entries,freeze,getOwnPropertyDescriptor,getOwnPropertyDescriptors,globalThis,is,isObject,objectHasOwnProperty,values,weaksetHas,constantProperties,sharedGlobalPropertyNames,universalPropertyNames,permitted;$h‍_imports([["./commons.js", [["TypeError", [$h‍_a => (TypeError = $h‍_a)]],["WeakSet", [$h‍_a => (WeakSet = $h‍_a)]],["arrayFilter", [$h‍_a => (arrayFilter = $h‍_a)]],["create", [$h‍_a => (create = $h‍_a)]],["defineProperty", [$h‍_a => (defineProperty = $h‍_a)]],["entries", [$h‍_a => (entries = $h‍_a)]],["freeze", [$h‍_a => (freeze = $h‍_a)]],["getOwnPropertyDescriptor", [$h‍_a => (getOwnPropertyDescriptor = $h‍_a)]],["getOwnPropertyDescriptors", [$h‍_a => (getOwnPropertyDescriptors = $h‍_a)]],["globalThis", [$h‍_a => (globalThis = $h‍_a)]],["is", [$h‍_a => (is = $h‍_a)]],["isObject", [$h‍_a => (isObject = $h‍_a)]],["objectHasOwnProperty", [$h‍_a => (objectHasOwnProperty = $h‍_a)]],["values", [$h‍_a => (values = $h‍_a)]],["weaksetHas", [$h‍_a => (weaksetHas = $h‍_a)]]]],["./permits.js", [["constantProperties", [$h‍_a => (constantProperties = $h‍_a)]],["sharedGlobalPropertyNames", [$h‍_a => (sharedGlobalPropertyNames = $h‍_a)]],["universalPropertyNames", [$h‍_a => (universalPropertyNames = $h‍_a)]],["permitted", [$h‍_a => (permitted = $h‍_a)]]]]]);   
























const isFunction=  (obj)=>typeof obj===  'function';

// Like defineProperty, but throws if it would modify an existing property.
// We use this to ensure that two conflicting attempts to define the same
// property throws, causing SES initialization to fail. Otherwise, a
// conflict between, for example, two of SES's internal whitelists might
// get masked as one overwrites the other. Accordingly, the thrown error
// complains of a "Conflicting definition".
function initProperty(obj, name, desc) {
  if( objectHasOwnProperty(obj, name)) {
    const preDesc=  getOwnPropertyDescriptor(obj, name);
    if(
      !preDesc||
      !is(preDesc.value, desc.value)||
      preDesc.get!==  desc.get||
      preDesc.set!==  desc.set||
      preDesc.writable!==  desc.writable||
      preDesc.enumerable!==  desc.enumerable||
      preDesc.configurable!==  desc.configurable)
      {
      throw TypeError( `Conflicting definitions of ${name}`);
     }
   }
  defineProperty(obj, name, desc);
 }

// Like defineProperties, but throws if it would modify an existing property.
// This ensures that the intrinsics added to the intrinsics collector object
// graph do not overlap.
function initProperties(obj, descs) {
  for( const [name, desc]of  entries(descs)) {
    initProperty(obj, name, desc);
   }
 }

// sampleGlobals creates an intrinsics object, suitable for
// interinsicsCollector.addIntrinsics, from the named properties of a global
// object.
function sampleGlobals(globalObject, newPropertyNames) {
  const newIntrinsics=  { __proto__: null};
  for( const [globalName, intrinsicName]of  entries(newPropertyNames)) {
    if( objectHasOwnProperty(globalObject, globalName)) {
      newIntrinsics[intrinsicName]=  globalObject[globalName];
     }
   }
  return newIntrinsics;
 }

const        makeIntrinsicsCollector=  ()=>  {
  /** @type {Record<any, any>} */
  const intrinsics=  create(null);
  let pseudoNatives;

  const addIntrinsics=  (newIntrinsics)=>{
    initProperties(intrinsics, getOwnPropertyDescriptors(newIntrinsics));
   };
  freeze(addIntrinsics);

  // For each intrinsic, if it has a `.prototype` property, use the
  // whitelist to find out the intrinsic name for that prototype and add it
  // to the intrinsics.
  const completePrototypes=  ()=>  {
    for( const [name, intrinsic]of  entries(intrinsics)) {
      if( !isObject(intrinsic)) {
        // eslint-disable-next-line no-continue
        continue;
       }
      if( !objectHasOwnProperty(intrinsic, 'prototype')) {
        // eslint-disable-next-line no-continue
        continue;
       }
      const permit=  permitted[name];
      if( typeof permit!==  'object') {
        throw TypeError( `Expected permit object at whitelist.${name}`);
       }
      const namePrototype=  permit.prototype;
      if( !namePrototype) {
        throw TypeError( `${name}.prototype property not whitelisted`);
       }
      if(
        typeof namePrototype!==  'string'||
        !objectHasOwnProperty(permitted, namePrototype))
        {
        throw TypeError( `Unrecognized ${name}.prototype whitelist entry`);
       }
      const intrinsicPrototype=  intrinsic.prototype;
      if( objectHasOwnProperty(intrinsics, namePrototype)) {
        if( intrinsics[namePrototype]!==  intrinsicPrototype) {
          throw TypeError( `Conflicting bindings of ${namePrototype}`);
         }
        // eslint-disable-next-line no-continue
        continue;
       }
      intrinsics[namePrototype]=  intrinsicPrototype;
     }
   };
  freeze(completePrototypes);

  const finalIntrinsics=  ()=>  {
    freeze(intrinsics);
    pseudoNatives=  new WeakSet(arrayFilter(values(intrinsics), isFunction));
    return intrinsics;
   };
  freeze(finalIntrinsics);

  const isPseudoNative=  (obj)=>{
    if( !pseudoNatives) {
      throw TypeError(
        'isPseudoNative can only be called after finalIntrinsics');

     }
    return weaksetHas(pseudoNatives, obj);
   };
  freeze(isPseudoNative);

  const intrinsicsCollector=  {
    addIntrinsics,
    completePrototypes,
    finalIntrinsics,
    isPseudoNative};

  freeze(intrinsicsCollector);

  addIntrinsics(constantProperties);
  addIntrinsics(sampleGlobals(globalThis, universalPropertyNames));

  return intrinsicsCollector;
 };

/**
 * getGlobalIntrinsics()
 * Doesn't tame, delete, or modify anything. Samples globalObject to create an
 * intrinsics record containing only the whitelisted global variables, listed
 * by the intrinsic names appropriate for new globals, i.e., the globals of
 * newly constructed compartments.
 *
 * WARNING:
 * If run before lockdown, the returned intrinsics record will carry the
 * *original* unsafe (feral, untamed) bindings of these global variables.
 *
 * @param {object} globalObject
 */$h‍_once.makeIntrinsicsCollector(makeIntrinsicsCollector);
const        getGlobalIntrinsics=  (globalObject)=>{
  const { addIntrinsics, finalIntrinsics}=   makeIntrinsicsCollector();

  addIntrinsics(sampleGlobals(globalObject, sharedGlobalPropertyNames));

  return finalIntrinsics();
 };$h‍_once.getGlobalIntrinsics(getGlobalIntrinsics);
})()
,
// === functors[13] ===
({   imports: $h‍_imports,   liveVar: $h‍_live,   onceVar: $h‍_once,   importMeta: $h‍____meta, }) => (function () {   let permitted,FunctionInstance,isAccessorPermit,Map,String,Symbol,TypeError,arrayFilter,arrayIncludes,arrayMap,entries,getOwnPropertyDescriptor,getPrototypeOf,isObject,mapGet,objectHasOwnProperty,ownKeys,symbolKeyFor;$h‍_imports([["./permits.js", [["permitted", [$h‍_a => (permitted = $h‍_a)]],["FunctionInstance", [$h‍_a => (FunctionInstance = $h‍_a)]],["isAccessorPermit", [$h‍_a => (isAccessorPermit = $h‍_a)]]]],["./commons.js", [["Map", [$h‍_a => (Map = $h‍_a)]],["String", [$h‍_a => (String = $h‍_a)]],["Symbol", [$h‍_a => (Symbol = $h‍_a)]],["TypeError", [$h‍_a => (TypeError = $h‍_a)]],["arrayFilter", [$h‍_a => (arrayFilter = $h‍_a)]],["arrayIncludes", [$h‍_a => (arrayIncludes = $h‍_a)]],["arrayMap", [$h‍_a => (arrayMap = $h‍_a)]],["entries", [$h‍_a => (entries = $h‍_a)]],["getOwnPropertyDescriptor", [$h‍_a => (getOwnPropertyDescriptor = $h‍_a)]],["getPrototypeOf", [$h‍_a => (getPrototypeOf = $h‍_a)]],["isObject", [$h‍_a => (isObject = $h‍_a)]],["mapGet", [$h‍_a => (mapGet = $h‍_a)]],["objectHasOwnProperty", [$h‍_a => (objectHasOwnProperty = $h‍_a)]],["ownKeys", [$h‍_a => (ownKeys = $h‍_a)]],["symbolKeyFor", [$h‍_a => (symbolKeyFor = $h‍_a)]]]]]);   































































/**
 * whitelistIntrinsics()
 * Removes all non-allowed properties found by recursively and
 * reflectively walking own property chains.
 *
 * @param {object} intrinsics
 * @param {(object) => void} markVirtualizedNativeFunction
 */
function                whitelistIntrinsics(
  intrinsics,
  markVirtualizedNativeFunction)
  {
  // These primitives are allowed allowed for permits.
  const primitives=  ['undefined', 'boolean', 'number', 'string', 'symbol'];

  // These symbols are allowed as well-known symbols
  const wellKnownSymbolNames=  new Map(
    Symbol?
        arrayMap(
          arrayFilter(
            entries(permitted['%SharedSymbol%']),
            ([name, permit])=>
              permit===  'symbol'&&  typeof Symbol[name]===  'symbol'),

          ([name])=>  [Symbol[name],  `@@${name}`]):

        []);


  /**
   * asStringPropertyName()
   *
   * @param {string} path
   * @param {string | symbol} prop
   */
  function asStringPropertyName(path, prop) {
    if( typeof prop===  'string') {
      return prop;
     }

    const wellKnownSymbol=  mapGet(wellKnownSymbolNames, prop);

    if( typeof prop===  'symbol') {
      if( wellKnownSymbol) {
        return wellKnownSymbol;
       }else {
        const registeredKey=  symbolKeyFor(prop);
        if( registeredKey!==  undefined) {
          return  `RegisteredSymbol(${registeredKey})`;
         }else {
          return  `Unique${String(prop)}`;
         }
       }
     }

    throw TypeError( `Unexpected property name type ${path} ${prop}`);
   }

  /*
   * visitPrototype()
   * Validate the object's [[prototype]] against a permit.
   */
  function visitPrototype(path, obj, protoName) {
    if( !isObject(obj)) {
      throw TypeError( `Object expected: ${path}, ${obj}, ${protoName}`);
     }
    const proto=  getPrototypeOf(obj);

    // Null prototype.
    if( proto===  null&&  protoName===  null) {
      return;
     }

    // Assert: protoName, if provided, is a string.
    if( protoName!==  undefined&&  typeof protoName!==  'string') {
      throw TypeError( `Malformed whitelist permit ${path}.__proto__`);
     }

    // If permit not specified, default to Object.prototype.
    if( proto===  intrinsics[protoName||  '%ObjectPrototype%']) {
      return;
     }

    // We can't clean [[prototype]], therefore abort.
    throw TypeError( `Unexpected intrinsic ${path}.__proto__ at ${protoName}`);
   }

  /*
   * isAllowedPropertyValue()
   * Whitelist a single property value against a permit.
   */
  function isAllowedPropertyValue(path, value, prop, permit) {
    if( typeof permit===  'object') {
      // eslint-disable-next-line no-use-before-define
      visitProperties(path, value, permit);
      // The property is allowed.
      return true;
     }

    if( permit===  false) {
      // A boolan 'false' permit specifies the removal of a property.
      // We require a more specific permit instead of allowing 'true'.
      return false;
     }

    if( typeof permit===  'string') {
      // A string permit can have one of two meanings:

      if( prop===  'prototype'||  prop===  'constructor') {
        // For prototype and constructor value properties, the permit
        // is the name of an intrinsic.
        // Assumption: prototype and constructor cannot be primitives.
        // Assert: the permit is the name of an intrinsic.
        // Assert: the property value is equal to that intrinsic.

        if( objectHasOwnProperty(intrinsics, permit)) {
          if( value!==  intrinsics[permit]) {
            throw TypeError( `Does not match whitelist ${path}`);
           }
          return true;
         }
       }else {
        // For all other properties, the permit is the name of a primitive.
        // Assert: the permit is the name of a primitive.
        // Assert: the property value type is equal to that primitive.

        // eslint-disable-next-line no-lonely-if
        if( arrayIncludes(primitives, permit)) {
          // eslint-disable-next-line valid-typeof
          if( typeof value!==  permit) {
            throw TypeError(
               `At ${path} expected ${permit} not ${typeof value}`);

           }
          return true;
         }
       }
     }

    throw TypeError( `Unexpected whitelist permit ${permit} at ${path}`);
   }

  /*
   * isAllowedProperty()
   * Check whether a single property is allowed.
   */
  function isAllowedProperty(path, obj, prop, permit) {
    const desc=  getOwnPropertyDescriptor(obj, prop);
    if( !desc) {
      throw TypeError( `Property ${prop} not found at ${path}`);
     }

    // Is this a value property?
    if( objectHasOwnProperty(desc, 'value')) {
      if( isAccessorPermit(permit)) {
        throw TypeError( `Accessor expected at ${path}`);
       }
      return isAllowedPropertyValue(path, desc.value, prop, permit);
     }
    if( !isAccessorPermit(permit)) {
      throw TypeError( `Accessor not expected at ${path}`);
     }
    return(
      isAllowedPropertyValue( `${path}<get>`,desc.get, prop, permit.get)&&
      isAllowedPropertyValue( `${path}<set>`,desc.set, prop, permit.set));

   }

  /*
   * getSubPermit()
   */
  function getSubPermit(obj, permit, prop) {
    const permitProp=  prop===  '__proto__'?  '--proto--':  prop;
    if( objectHasOwnProperty(permit, permitProp)) {
      return permit[permitProp];
     }

    if( typeof obj===  'function') {
      if( objectHasOwnProperty(FunctionInstance, permitProp)) {
        return FunctionInstance[permitProp];
       }
     }

    return undefined;
   }

  /*
   * visitProperties()
   * Visit all properties for a permit.
   */
  function visitProperties(path, obj, permit) {
    if( obj===  undefined||  obj===  null) {
      return;
     }

    const protoName=  permit['[[Proto]]'];
    visitPrototype(path, obj, protoName);

    if( typeof obj===  'function') {
      markVirtualizedNativeFunction(obj);
     }

    for( const prop of ownKeys(obj)) {
      const propString=  asStringPropertyName(path, prop);
      const subPath=   `${path}.${propString}`;
      const subPermit=  getSubPermit(obj, permit, propString);

      if( !subPermit||  !isAllowedProperty(subPath, obj, prop, subPermit)) {
        // Either the object lacks a permit or the object doesn't match the
        // permit.
        // If the permit is specifically false, not merely undefined,
        // this is a property we expect to see because we know it exists in
        // some environments and we have expressly decided to exclude it.
        // Any other disallowed property is one we have not audited and we log
        // that we are removing it so we know to look into it, as happens when
        // the language evolves new features to existing intrinsics.
        if( subPermit!==  false) {
          // This call to `console.warn` is intentional. It is not a vestige of
          // a debugging attempt. See the comment at top of file for an
          // explanation.
          // eslint-disable-next-line @endo/no-polymorphic-call
          console.warn( `Removing ${subPath}`);
         }
        try {
          delete obj[prop];
         }catch( err) {
          if( prop in obj) {
            if( typeof obj===  'function'&&  prop===  'prototype') {
              obj.prototype=  undefined;
              if( obj.prototype===  undefined) {
                // eslint-disable-next-line @endo/no-polymorphic-call
                console.warn( `Tolerating undeletable ${subPath} === undefined`);
                // eslint-disable-next-line no-continue
                continue;
               }
             }
            // eslint-disable-next-line @endo/no-polymorphic-call
            console.error( `failed to delete ${subPath}`,err);
           }else {
            // eslint-disable-next-line @endo/no-polymorphic-call
            console.error( `deleting ${subPath} threw`,err);
           }
          throw err;
         }
       }
     }
   }

  // Start path with 'intrinsics' to clarify that properties are not
  // removed from the global object by the whitelisting operation.
  visitProperties('intrinsics', intrinsics, permitted);
 }$h‍_once.default(     whitelistIntrinsics);
})()
,
// === functors[14] ===
({   imports: $h‍_imports,   liveVar: $h‍_live,   onceVar: $h‍_once,   importMeta: $h‍____meta, }) => (function () {   let FERAL_FUNCTION,SyntaxError,TypeError,defineProperties,getPrototypeOf,setPrototypeOf,freeze;$h‍_imports([["./commons.js", [["FERAL_FUNCTION", [$h‍_a => (FERAL_FUNCTION = $h‍_a)]],["SyntaxError", [$h‍_a => (SyntaxError = $h‍_a)]],["TypeError", [$h‍_a => (TypeError = $h‍_a)]],["defineProperties", [$h‍_a => (defineProperties = $h‍_a)]],["getPrototypeOf", [$h‍_a => (getPrototypeOf = $h‍_a)]],["setPrototypeOf", [$h‍_a => (setPrototypeOf = $h‍_a)]],["freeze", [$h‍_a => (freeze = $h‍_a)]]]]]);   









// This module replaces the original `Function` constructor, and the original
// `%GeneratorFunction%`, `%AsyncFunction%` and `%AsyncGeneratorFunction%`,
// with safe replacements that throw if invoked.
//
// These are all reachable via syntax, so it isn't sufficient to just
// replace global properties with safe versions. Our main goal is to prevent
// access to the `Function` constructor through these starting points.
//
// After modules block is done, the originals must no longer be reachable,
// unless a copy has been made, and functions can only be created by syntax
// (using eval) or by invoking a previously saved reference to the originals.
//
// Typically, this module will not be used directly, but via the
// [lockdown - shim] which handles all necessary repairs and taming in SES.
//
// Relation to ECMA specifications
//
// The taming of constructors really wants to be part of the standard, because
// new constructors may be added in the future, reachable from syntax, and this
// list must be updated to match.
//
// In addition, the standard needs to define four new intrinsics for the safe
// replacement functions. See [./permits-intrinsics.js].
//
// Adapted from SES/Caja
// Copyright (C) 2011 Google Inc.
// https://github.com/google/caja/blob/master/src/com/google/caja/ses/startSES.js
// https://github.com/google/caja/blob/master/src/com/google/caja/ses/repairES5.js

/**
 * tameFunctionConstructors()
 * This block replaces the original Function constructor, and the original
 * %GeneratorFunction% %AsyncFunction% and %AsyncGeneratorFunction%, with
 * safe replacements that throw if invoked.
 */
function                tameFunctionConstructors() {
  try {
    // Verify that the method is not callable.
    // eslint-disable-next-line @endo/no-polymorphic-call
    FERAL_FUNCTION.prototype.constructor('return 1');
   }catch( ignore) {
    // Throws, no need to patch.
    return freeze({});
   }

  const newIntrinsics=  {};

  /*
   * The process to repair constructors:
   * 1. Create an instance of the function by evaluating syntax
   * 2. Obtain the prototype from the instance
   * 3. Create a substitute tamed constructor
   * 4. Replace the original constructor with the tamed constructor
   * 5. Replace tamed constructor prototype property with the original one
   * 6. Replace its [[Prototype]] slot with the tamed constructor of Function
   */
  function repairFunction(name, intrinsicName, declaration) {
    let FunctionInstance;
    try {
      // eslint-disable-next-line no-eval, no-restricted-globals
      FunctionInstance=  (0, eval)(declaration);
     }catch( e) {
      if( e instanceof SyntaxError) {
        // Prevent failure on platforms where async and/or generators
        // are not supported.
        return;
       }
      // Re-throw
      throw e;
     }
    const FunctionPrototype=  getPrototypeOf(FunctionInstance);

    // Prevents the evaluation of source when calling constructor on the
    // prototype of functions.
    // eslint-disable-next-line func-names
    const InertConstructor=  function()  {
      throw TypeError(
        'Function.prototype.constructor is not a valid constructor.');

     };
    defineProperties(InertConstructor, {
      prototype: { value: FunctionPrototype},
      name: {
        value: name,
        writable: false,
        enumerable: false,
        configurable: true}});



    defineProperties(FunctionPrototype, {
      constructor: { value: InertConstructor}});


    // Reconstructs the inheritance among the new tamed constructors
    // to mirror the original specified in normal JS.
    if( InertConstructor!==  FERAL_FUNCTION.prototype.constructor) {
      setPrototypeOf(InertConstructor, FERAL_FUNCTION.prototype.constructor);
     }

    newIntrinsics[intrinsicName]=  InertConstructor;
   }

  // Here, the order of operation is important: Function needs to be repaired
  // first since the other repaired constructors need to inherit from the
  // tamed Function function constructor.

  repairFunction('Function', '%InertFunction%', '(function(){})');
  repairFunction(
    'GeneratorFunction',
    '%InertGeneratorFunction%',
    '(function*(){})');

  repairFunction(
    'AsyncFunction',
    '%InertAsyncFunction%',
    '(async function(){})');

  repairFunction(
    'AsyncGeneratorFunction',
    '%InertAsyncGeneratorFunction%',
    '(async function*(){})');


  return newIntrinsics;
 }$h‍_once.default(     tameFunctionConstructors);
})()
,
// === functors[15] ===
({   imports: $h‍_imports,   liveVar: $h‍_live,   onceVar: $h‍_once,   importMeta: $h‍____meta, }) => (function () {   let Date,TypeError,apply,construct,defineProperties;$h‍_imports([["./commons.js", [["Date", [$h‍_a => (Date = $h‍_a)]],["TypeError", [$h‍_a => (TypeError = $h‍_a)]],["apply", [$h‍_a => (apply = $h‍_a)]],["construct", [$h‍_a => (construct = $h‍_a)]],["defineProperties", [$h‍_a => (defineProperties = $h‍_a)]]]]]);   









function                tameDateConstructor(dateTaming=  'safe') {
  if( dateTaming!==  'safe'&&  dateTaming!==  'unsafe') {
    throw TypeError( `unrecognized dateTaming ${dateTaming}`);
   }
  const OriginalDate=  Date;
  const DatePrototype=  OriginalDate.prototype;

  // Use concise methods to obtain named functions without constructors.
  const tamedMethods=  {
    /**
     * `%SharedDate%.now()` throw a `TypeError` starting with "secure mode".
     * See https://github.com/endojs/endo/issues/910#issuecomment-1581855420
     */
    now() {
      throw TypeError('secure mode Calling %SharedDate%.now() throws');
     }};


  /**
   * Tame the Date constructor.
   * See https://github.com/endojs/endo/issues/910#issuecomment-1581855420
   *
   * Common behavior
   *   * `new Date(x)` coerces x into a number and then returns a Date
   *     for that number of millis since the epoch
   *   * `new Date(NaN)` returns a Date object which stringifies to
   *     'Invalid Date'
   *   * `new Date(undefined)` returns a Date object which stringifies to
   *     'Invalid Date'
   *
   * OriginalDate (normal standard) behavior preserved by
   * `%InitialDate%`.
   *   * `Date(anything)` gives a string with the current time
   *   * `new Date()` returns the current time, as a Date object
   *
   * `%SharedDate%` behavior
   *   * `Date(anything)` throws a TypeError starting with "secure mode"
   *   * `new Date()` throws a TypeError starting with "secure mode"
   *
   * @param {{powers?: string}} [opts]
   */
  const makeDateConstructor=  ({ powers=  'none'}=   {})=>  {
    let ResultDate;
    if( powers===  'original') {
      // eslint-disable-next-line no-shadow
      ResultDate=  function Date(...rest) {
        if( new.target===  undefined) {
          return apply(OriginalDate, undefined, rest);
         }
        return construct(OriginalDate, rest, new.target);
       };
     }else {
      // eslint-disable-next-line no-shadow
      ResultDate=  function Date(...rest) {
        if( new.target===  undefined) {
          throw TypeError(
            'secure mode Calling %SharedDate% constructor as a function throws');

         }
        if( rest.length===  0) {
          throw TypeError(
            'secure mode Calling new %SharedDate%() with no arguments throws');

         }
        return construct(OriginalDate, rest, new.target);
       };
     }

    defineProperties(ResultDate, {
      length: { value: 7},
      prototype: {
        value: DatePrototype,
        writable: false,
        enumerable: false,
        configurable: false},

      parse: {
        value: OriginalDate.parse,
        writable: true,
        enumerable: false,
        configurable: true},

      UTC: {
        value: OriginalDate.UTC,
        writable: true,
        enumerable: false,
        configurable: true}});


    return ResultDate;
   };
  const InitialDate=  makeDateConstructor({ powers: 'original'});
  const SharedDate=  makeDateConstructor({ powers: 'none'});

  defineProperties(InitialDate, {
    now: {
      value: OriginalDate.now,
      writable: true,
      enumerable: false,
      configurable: true}});


  defineProperties(SharedDate, {
    now: {
      value: tamedMethods.now,
      writable: true,
      enumerable: false,
      configurable: true}});



  defineProperties(DatePrototype, {
    constructor: { value: SharedDate}});


  return {
    '%InitialDate%': InitialDate,
    '%SharedDate%': SharedDate};

 }$h‍_once.default(     tameDateConstructor);
})()
,
// === functors[16] ===
({   imports: $h‍_imports,   liveVar: $h‍_live,   onceVar: $h‍_once,   importMeta: $h‍____meta, }) => (function () {   let Math,TypeError,create,getOwnPropertyDescriptors,objectPrototype;$h‍_imports([["./commons.js", [["Math", [$h‍_a => (Math = $h‍_a)]],["TypeError", [$h‍_a => (TypeError = $h‍_a)]],["create", [$h‍_a => (create = $h‍_a)]],["getOwnPropertyDescriptors", [$h‍_a => (getOwnPropertyDescriptors = $h‍_a)]],["objectPrototype", [$h‍_a => (objectPrototype = $h‍_a)]]]]]);   







function                tameMathObject(mathTaming=  'safe') {
  if( mathTaming!==  'safe'&&  mathTaming!==  'unsafe') {
    throw TypeError( `unrecognized mathTaming ${mathTaming}`);
   }
  const originalMath=  Math;
  const initialMath=  originalMath; // to follow the naming pattern

  const { random: _, ...otherDescriptors}=
    getOwnPropertyDescriptors(originalMath);

  // Use concise methods to obtain named functions without constructors.
  const tamedMethods=  {
    /**
     * `%SharedMath%.random()` throws a TypeError starting with "secure mode".
     * See https://github.com/endojs/endo/issues/910#issuecomment-1581855420
     */
    random() {
      throw TypeError('secure mode %SharedMath%.random() throws');
     }};


  const sharedMath=  create(objectPrototype, {
    ...otherDescriptors,
    random: {
      value: tamedMethods.random,
      writable: true,
      enumerable: false,
      configurable: true}});



  return {
    '%InitialMath%': initialMath,
    '%SharedMath%': sharedMath};

 }$h‍_once.default(     tameMathObject);
})()
,
// === functors[17] ===
({   imports: $h‍_imports,   liveVar: $h‍_live,   onceVar: $h‍_once,   importMeta: $h‍____meta, }) => (function () {   let FERAL_REG_EXP,TypeError,construct,defineProperties,getOwnPropertyDescriptor,speciesSymbol;$h‍_imports([["./commons.js", [["FERAL_REG_EXP", [$h‍_a => (FERAL_REG_EXP = $h‍_a)]],["TypeError", [$h‍_a => (TypeError = $h‍_a)]],["construct", [$h‍_a => (construct = $h‍_a)]],["defineProperties", [$h‍_a => (defineProperties = $h‍_a)]],["getOwnPropertyDescriptor", [$h‍_a => (getOwnPropertyDescriptor = $h‍_a)]],["speciesSymbol", [$h‍_a => (speciesSymbol = $h‍_a)]]]]]);   








function                tameRegExpConstructor(regExpTaming=  'safe') {
  if( regExpTaming!==  'safe'&&  regExpTaming!==  'unsafe') {
    throw TypeError( `unrecognized regExpTaming ${regExpTaming}`);
   }
  const RegExpPrototype=  FERAL_REG_EXP.prototype;

  const makeRegExpConstructor=  (_=  {})=>  {
    // RegExp has non-writable static properties we need to omit.
    /**
     * @param  {Parameters<typeof FERAL_REG_EXP>} rest
     */
    const ResultRegExp=  function RegExp(...rest) {
      if( new.target===  undefined) {
        return FERAL_REG_EXP(...rest);
       }
      return construct(FERAL_REG_EXP, rest, new.target);
     };

    const speciesDesc=  getOwnPropertyDescriptor(FERAL_REG_EXP, speciesSymbol);
    if( !speciesDesc) {
      throw TypeError('no RegExp[Symbol.species] descriptor');
     }

    defineProperties(ResultRegExp, {
      length: { value: 2},
      prototype: {
        value: RegExpPrototype,
        writable: false,
        enumerable: false,
        configurable: false},

      [speciesSymbol]: speciesDesc});

    return ResultRegExp;
   };

  const InitialRegExp=  makeRegExpConstructor();
  const SharedRegExp=  makeRegExpConstructor();

  if( regExpTaming!==  'unsafe') {
    // @ts-expect-error Deleted properties must be optional
    delete RegExpPrototype.compile;
   }
  defineProperties(RegExpPrototype, {
    constructor: { value: SharedRegExp}});


  return {
    '%InitialRegExp%': InitialRegExp,
    '%SharedRegExp%': SharedRegExp};

 }$h‍_once.default(     tameRegExpConstructor);
})()
,
// === functors[18] ===
({   imports: $h‍_imports,   liveVar: $h‍_live,   onceVar: $h‍_once,   importMeta: $h‍____meta, }) => (function () {   $h‍_imports([]);   /**
 * @file Exports {@code enablements}, a recursively defined
 * JSON record defining the optimum set of intrinsics properties
 * that need to be "repaired" before hardening is applied on
 * enviromments subject to the override mistake.
 *
 * @author JF Paradis
 * @author Mark S. Miller
 */

/**
 * <p>Because "repairing" replaces data properties with accessors, every
 * time a repaired property is accessed, the associated getter is invoked,
 * which degrades the runtime performance of all code executing in the
 * repaired enviromment, compared to the non-repaired case. In order
 * to maintain performance, we only repair the properties of objects
 * for which hardening causes a breakage of their normal intended usage.
 *
 * There are three unwanted cases:
 * <ul>
 * <li>Overriding properties on objects typically used as records,
 *     namely {@code "Object"} and {@code "Array"}. In the case of arrays,
 *     the situation is unintentional, a given program might not be aware
 *     that non-numerical properties are stored on the underlying object
 *     instance, not on the array. When an object is typically used as a
 *     map, we repair all of its prototype properties.
 * <li>Overriding properties on objects that provide defaults on their
 *     prototype and that programs typically set using an assignment, such as
 *     {@code "Error.prototype.message"} and {@code "Function.prototype.name"}
 *     (both default to "").
 * <li>Setting-up a prototype chain, where a constructor is set to extend
 *     another one. This is typically set by assignment, for example
 *     {@code "Child.prototype.constructor = Child"}, instead of invoking
 *     Object.defineProperty();
 *
 * <p>Each JSON record enumerates the disposition of the properties on
 * some corresponding intrinsic object.
 *
 * <p>For each such record, the values associated with its property
 * names can be:
 * <ul>
 * <li>true, in which case this property is simply repaired. The
 *     value associated with that property is not traversed. For
 *     example, {@code "Function.prototype.name"} leads to true,
 *     meaning that the {@code "name"} property of {@code
 *     "Function.prototype"} should be repaired (which is needed
 *     when inheriting from @code{Function} and setting the subclass's
 *     {@code "prototype.name"} property). If the property is
 *     already an accessor property, it is not repaired (because
 *     accessors are not subject to the override mistake).
 * <li>"*", in which case this property is not repaired but the
 *     value associated with that property are traversed and repaired.
 * <li>Another record, in which case this property is not repaired
 *     and that next record represents the disposition of the object
 *     which is its value. For example,{@code "FunctionPrototype"}
 *     leads to another record explaining which properties {@code
 *     Function.prototype} need to be repaired.
 */

/**
 * Minimal enablements when all the code is modern and known not to
 * step into the override mistake, except for the following pervasive
 * cases.
 */
const        minEnablements=  {
  '%ObjectPrototype%': {
    toString: true},


  '%FunctionPrototype%': {
    toString: true  // set by "rollup"
},

  '%ErrorPrototype%': {
    name: true  // set by "precond", "ava", "node-fetch"
}};


/**
 * Moderate enablements are usually good enough for legacy compat.
 */$h‍_once.minEnablements(minEnablements);
const        moderateEnablements=  {
  '%ObjectPrototype%': {
    toString: true,
    valueOf: true},


  '%ArrayPrototype%': {
    toString: true,
    push: true  // set by "Google Analytics"
},

  // Function.prototype has no 'prototype' property to enable.
  // Function instances have their own 'name' and 'length' properties
  // which are configurable and non-writable. Thus, they are already
  // non-assignable anyway.
  '%FunctionPrototype%': {
    constructor: true, // set by "regenerator-runtime"
    bind: true, // set by "underscore", "express"
    toString: true  // set by "rollup"
},

  '%ErrorPrototype%': {
    constructor: true, // set by "fast-json-patch", "node-fetch"
    message: true,
    name: true, // set by "precond", "ava", "node-fetch", "node 14"
    toString: true  // set by "bluebird"
},

  '%TypeErrorPrototype%': {
    constructor: true, // set by "readable-stream"
    message: true, // set by "tape"
    name: true  // set by "readable-stream", "node 14"
},

  '%SyntaxErrorPrototype%': {
    message: true, // to match TypeErrorPrototype.message
    name: true  // set by "node 14"
},

  '%RangeErrorPrototype%': {
    message: true, // to match TypeErrorPrototype.message
    name: true  // set by "node 14"
},

  '%URIErrorPrototype%': {
    message: true, // to match TypeErrorPrototype.message
    name: true  // set by "node 14"
},

  '%EvalErrorPrototype%': {
    message: true, // to match TypeErrorPrototype.message
    name: true  // set by "node 14"
},

  '%ReferenceErrorPrototype%': {
    message: true, // to match TypeErrorPrototype.message
    name: true  // set by "node 14"
},

  '%PromisePrototype%': {
    constructor: true  // set by "core-js"
},

  '%TypedArrayPrototype%': '*', // set by https://github.com/feross/buffer

  '%Generator%': {
    constructor: true,
    name: true,
    toString: true},


  '%IteratorPrototype%': {
    toString: true}};



/**
 * The 'severe' enablement are needed because of issues tracked at
 * https://github.com/endojs/endo/issues/576
 *
 * They are like the `moderate` enablements except for the entries below.
 */$h‍_once.moderateEnablements(moderateEnablements);
const        severeEnablements=  {
  ...moderateEnablements,

  /**
   * Rollup (as used at least by vega) and webpack
   * (as used at least by regenerator) both turn exports into assignments
   * to a big `exports` object that inherits directly from
   * `Object.prototype`. Some of the exported names we've seen include
   * `hasOwnProperty`, `constructor`, and `toString`. But the strategy used
   * by rollup and webpack potentionally turns any exported name
   * into an assignment rejected by the override mistake. That's why
   * the `severe` enablements takes the extreme step of enabling
   * everything on `Object.prototype`.
   *
   * In addition, code doing inheritance manually will often override
   * the `constructor` property on the new prototype by assignment. We've
   * seen this several times.
   *
   * The cost of enabling all these is that they create a miserable debugging
   * experience specifically on Node.
   * https://github.com/Agoric/agoric-sdk/issues/2324
   * explains how it confused the Node console.
   *
   * (TODO Reexamine the vscode situation. I think it may have improved
   * since the following paragraph was written.)
   *
   * The vscode debugger's object inspector shows the own data properties of
   * an object, which is typically what you want, but also shows both getter
   * and setter for every accessor property whether inherited or own.
   * With the `'*'` setting here, all the properties inherited from
   * `Object.prototype` are accessors, creating an unusable display as seen
   * at As explained at
   * https://github.com/endojs/endo/blob/master/packages/ses/lockdown-options.md#overridetaming-options
   * Open the triangles at the bottom of that section.
   */
  '%ObjectPrototype%': '*',

  /**
   * The widely used Buffer defined at https://github.com/feross/buffer
   * on initialization, manually creates the equivalent of a subclass of
   * `TypedArray`, which it then initializes by assignment. These assignments
   * include enough of the `TypeArray` methods that here, the `severe`
   * enablements just enable them all.
   */
  '%TypedArrayPrototype%': '*',

  /**
   * Needed to work with Immer before https://github.com/immerjs/immer/pull/914
   * is accepted.
   */
  '%MapPrototype%': '*',

  /**
   * Needed to work with Immer before https://github.com/immerjs/immer/pull/914
   * is accepted.
   */
  '%SetPrototype%': '*'};$h‍_once.severeEnablements(severeEnablements);
})()
,
// === functors[19] ===
({   imports: $h‍_imports,   liveVar: $h‍_live,   onceVar: $h‍_once,   importMeta: $h‍____meta, }) => (function () {   let Set,String,TypeError,arrayForEach,defineProperty,getOwnPropertyDescriptor,getOwnPropertyDescriptors,getOwnPropertyNames,isObject,objectHasOwnProperty,ownKeys,setHas,minEnablements,moderateEnablements,severeEnablements;$h‍_imports([["./commons.js", [["Set", [$h‍_a => (Set = $h‍_a)]],["String", [$h‍_a => (String = $h‍_a)]],["TypeError", [$h‍_a => (TypeError = $h‍_a)]],["arrayForEach", [$h‍_a => (arrayForEach = $h‍_a)]],["defineProperty", [$h‍_a => (defineProperty = $h‍_a)]],["getOwnPropertyDescriptor", [$h‍_a => (getOwnPropertyDescriptor = $h‍_a)]],["getOwnPropertyDescriptors", [$h‍_a => (getOwnPropertyDescriptors = $h‍_a)]],["getOwnPropertyNames", [$h‍_a => (getOwnPropertyNames = $h‍_a)]],["isObject", [$h‍_a => (isObject = $h‍_a)]],["objectHasOwnProperty", [$h‍_a => (objectHasOwnProperty = $h‍_a)]],["ownKeys", [$h‍_a => (ownKeys = $h‍_a)]],["setHas", [$h‍_a => (setHas = $h‍_a)]]]],["./enablements.js", [["minEnablements", [$h‍_a => (minEnablements = $h‍_a)]],["moderateEnablements", [$h‍_a => (moderateEnablements = $h‍_a)]],["severeEnablements", [$h‍_a => (severeEnablements = $h‍_a)]]]]]);   

























/**
 * For a special set of properties defined in the `enablement` whitelist,
 * `enablePropertyOverrides` ensures that the effect of freezing does not
 * suppress the ability to override these properties on derived objects by
 * simple assignment.
 *
 * Because of lack of sufficient foresight at the time, ES5 unfortunately
 * specified that a simple assignment to a non-existent property must fail if
 * it would override an non-writable data property of the same name in the
 * shadow of the prototype chain. In retrospect, this was a mistake, the
 * so-called "override mistake". But it is now too late and we must live with
 * the consequences.
 *
 * As a result, simply freezing an object to make it tamper proof has the
 * unfortunate side effect of breaking previously correct code that is
 * considered to have followed JS best practices, if this previous code used
 * assignment to override.
 *
 * For the enabled properties, `enablePropertyOverrides` effectively shims what
 * the assignment behavior would have been in the absence of the override
 * mistake. However, the shim produces an imperfect emulation. It shims the
 * behavior by turning these data properties into accessor properties, where
 * the accessor's getter and setter provide the desired behavior. For
 * non-reflective operations, the illusion is perfect. However, reflective
 * operations like `getOwnPropertyDescriptor` see the descriptor of an accessor
 * property rather than the descriptor of a data property. At the time of this
 * writing, this is the best we know how to do.
 *
 * To the getter of the accessor we add a property named
 * `'originalValue'` whose value is, as it says, the value that the
 * data property had before being converted to an accessor property. We add
 * this extra property to the getter for two reason:
 *
 * The harden algorithm walks the own properties reflectively, i.e., with
 * `getOwnPropertyDescriptor` semantics, rather than `[[Get]]` semantics. When
 * it sees an accessor property, it does not invoke the getter. Rather, it
 * proceeds to walk both the getter and setter as part of its transitive
 * traversal. Without this extra property, `enablePropertyOverrides` would have
 * hidden the original data property value from `harden`, which would be bad.
 * Instead, by exposing that value in an own data property on the getter,
 * `harden` finds and walks it anyway.
 *
 * We enable a form of cooperative emulation, giving reflective code an
 * opportunity to cooperate in upholding the illusion. When such cooperative
 * reflective code sees an accessor property, where the accessor's getter
 * has an `originalValue` property, it knows that the getter is
 * alleging that it is the result of the `enablePropertyOverrides` conversion
 * pattern, so it can decide to cooperatively "pretend" that it sees a data
 * property with that value.
 *
 * @param {Record<string, any>} intrinsics
 * @param {'min' | 'moderate' | 'severe'} overrideTaming
 * @param {Iterable<string | symbol>} [overrideDebug]
 */
function                enablePropertyOverrides(
  intrinsics,
  overrideTaming,
  overrideDebug=  [])
  {
  const debugProperties=  new Set(overrideDebug);
  function enable(path, obj, prop, desc) {
    if( 'value'in  desc&&  desc.configurable) {
      const { value}=   desc;

      function getter() {
        return value;
       }
      defineProperty(getter, 'originalValue', {
        value,
        writable: false,
        enumerable: false,
        configurable: false});


      const isDebug=  setHas(debugProperties, prop);

      function setter(newValue) {
        if( obj===  this) {
          throw TypeError(
             `Cannot assign to read only property '${String(
              prop)
              }' of '${path}'`);

         }
        if( objectHasOwnProperty(this, prop)) {
          this[prop]=  newValue;
         }else {
          if( isDebug) {
            // eslint-disable-next-line @endo/no-polymorphic-call
            console.error(TypeError( `Override property ${prop}`));
           }
          defineProperty(this, prop, {
            value: newValue,
            writable: true,
            enumerable: true,
            configurable: true});

         }
       }

      defineProperty(obj, prop, {
        get: getter,
        set: setter,
        enumerable: desc.enumerable,
        configurable: desc.configurable});

     }
   }

  function enableProperty(path, obj, prop) {
    const desc=  getOwnPropertyDescriptor(obj, prop);
    if( !desc) {
      return;
     }
    enable(path, obj, prop, desc);
   }

  function enableAllProperties(path, obj) {
    const descs=  getOwnPropertyDescriptors(obj);
    if( !descs) {
      return;
     }
    // TypeScript does not allow symbols to be used as indexes because it
    // cannot recokon types of symbolized properties.
    // @ts-ignore
    arrayForEach(ownKeys(descs), (prop)=>enable(path, obj, prop, descs[prop]));
   }

  function enableProperties(path, obj, plan) {
    for( const prop of getOwnPropertyNames(plan)) {
      const desc=  getOwnPropertyDescriptor(obj, prop);
      if( !desc||  desc.get||  desc.set) {
        // No not a value property, nothing to do.
        // eslint-disable-next-line no-continue
        continue;
       }

      // Plan has no symbol keys and we use getOwnPropertyNames()
      // so `prop` cannot only be a string, not a symbol. We coerce it in place
      // with `String(..)` anyway just as good hygiene, since these paths are just
      // for diagnostic purposes.
      const subPath=   `${path}.${String(prop)}`;
      const subPlan=  plan[prop];

      if( subPlan===  true) {
        enableProperty(subPath, obj, prop);
       }else if( subPlan===  '*') {
        enableAllProperties(subPath, desc.value);
       }else if( isObject(subPlan)) {
        enableProperties(subPath, desc.value, subPlan);
       }else {
        throw TypeError( `Unexpected override enablement plan ${subPath}`);
       }
     }
   }

  let plan;
  switch( overrideTaming){
    case 'min': {
      plan=  minEnablements;
      break;
     }
    case 'moderate': {
      plan=  moderateEnablements;
      break;
     }
    case 'severe': {
      plan=  severeEnablements;
      break;
     }
    default: {
      throw TypeError( `unrecognized overrideTaming ${overrideTaming}`);
     }}


  // Do the repair.
  enableProperties('root', intrinsics, plan);
 }$h‍_once.default(     enablePropertyOverrides);
})()
,
// === functors[20] ===
({   imports: $h‍_imports,   liveVar: $h‍_live,   onceVar: $h‍_once,   importMeta: $h‍____meta, }) => (function () {   let Number,String,TypeError,defineProperty,getOwnPropertyNames,isObject,regexpExec,assert;$h‍_imports([["./commons.js", [["Number", [$h‍_a => (Number = $h‍_a)]],["String", [$h‍_a => (String = $h‍_a)]],["TypeError", [$h‍_a => (TypeError = $h‍_a)]],["defineProperty", [$h‍_a => (defineProperty = $h‍_a)]],["getOwnPropertyNames", [$h‍_a => (getOwnPropertyNames = $h‍_a)]],["isObject", [$h‍_a => (isObject = $h‍_a)]],["regexpExec", [$h‍_a => (regexpExec = $h‍_a)]]]],["./error/assert.js", [["assert", [$h‍_a => (assert = $h‍_a)]]]]]);   










const { Fail, quote: q}=   assert;

const localePattern=  /^(\w*[a-z])Locale([A-Z]\w*)$/;

// Use concise methods to obtain named functions without constructor
// behavior or `.prototype` property.
const tamedMethods=  {
  // See https://tc39.es/ecma262/#sec-string.prototype.localecompare
  localeCompare(arg) {
    if( this===  null||  this===  undefined) {
      throw TypeError(
        'Cannot localeCompare with null or undefined "this" value');

     }
    const s=   `${this}`;
    const that=   `${arg}`;
    if( s<  that) {
      return -1;
     }
    if( s>  that) {
      return 1;
     }
    s===  that||  Fail `expected ${q(s)} and ${q(that)} to compare`;
    return 0;
   },

  toString() {
    return  `${this}`;
   }};


const nonLocaleCompare=  tamedMethods.localeCompare;
const numberToString=  tamedMethods.toString;

function                tameLocaleMethods(intrinsics, localeTaming=  'safe') {
  if( localeTaming!==  'safe'&&  localeTaming!==  'unsafe') {
    throw TypeError( `unrecognized localeTaming ${localeTaming}`);
   }
  if( localeTaming===  'unsafe') {
    return;
   }

  defineProperty(String.prototype, 'localeCompare', {
    value: nonLocaleCompare});


  for( const intrinsicName of getOwnPropertyNames(intrinsics)) {
    const intrinsic=  intrinsics[intrinsicName];
    if( isObject(intrinsic)) {
      for( const methodName of getOwnPropertyNames(intrinsic)) {
        const match=  regexpExec(localePattern, methodName);
        if( match) {
          typeof intrinsic[methodName]===  'function'||
            Fail `expected ${q(methodName)} to be a function`;
          const nonLocaleMethodName=   `${match[1]}${match[2]}`;
          const method=  intrinsic[nonLocaleMethodName];
          typeof method===  'function'||
            Fail `function ${q(nonLocaleMethodName)} not found`;
          defineProperty(intrinsic, methodName, { value: method});
         }
       }
     }
   }

  // Numbers are special because toString accepts a radix instead of ignoring
  // all of the arguments that we would otherwise forward.
  defineProperty(Number.prototype, 'toLocaleString', {
    value: numberToString});

 }$h‍_once.default(     tameLocaleMethods);
})()
,
// === functors[21] ===
({   imports: $h‍_imports,   liveVar: $h‍_live,   onceVar: $h‍_once,   importMeta: $h‍____meta, }) => (function () {   $h‍_imports([]);   /**
 * makeEvalFunction()
 * A safe version of the native eval function which relies on
 * the safety of safeEvaluate for confinement.
 *
 * @param {Function} safeEvaluate
 */
const        makeEvalFunction=  (safeEvaluate)=>{
  // We use the the concise method syntax to create an eval without a
  // [[Construct]] behavior (such that the invocation "new eval()" throws
  // TypeError: eval is not a constructor"), but which still accepts a
  // 'this' binding.
  const newEval=  {
    eval(source) {
      if( typeof source!==  'string') {
        // As per the runtime semantic of PerformEval [ECMAScript 18.2.1.1]:
        // If Type(source) is not String, return source.
        // TODO Recent proposals from Mike Samuel may change this non-string
        // rule. Track.
        return source;
       }
      return safeEvaluate(source);
     }}.
    eval;

  return newEval;
 };$h‍_once.makeEvalFunction(makeEvalFunction);
})()
,
// === functors[22] ===
({   imports: $h‍_imports,   liveVar: $h‍_live,   onceVar: $h‍_once,   importMeta: $h‍____meta, }) => (function () {   let FERAL_FUNCTION,arrayJoin,arrayPop,defineProperties,getPrototypeOf,assert;$h‍_imports([["./commons.js", [["FERAL_FUNCTION", [$h‍_a => (FERAL_FUNCTION = $h‍_a)]],["arrayJoin", [$h‍_a => (arrayJoin = $h‍_a)]],["arrayPop", [$h‍_a => (arrayPop = $h‍_a)]],["defineProperties", [$h‍_a => (defineProperties = $h‍_a)]],["getPrototypeOf", [$h‍_a => (getPrototypeOf = $h‍_a)]]]],["./error/assert.js", [["assert", [$h‍_a => (assert = $h‍_a)]]]]]);   








const { Fail}=   assert;

/*
 * makeFunctionConstructor()
 * A safe version of the native Function which relies on
 * the safety of safeEvaluate for confinement.
 */
const        makeFunctionConstructor=  (safeEvaluate)=>{
  // Define an unused parameter to ensure Function.length === 1
  const newFunction=  function Function(_body) {
    // Sanitize all parameters at the entry point.
    // eslint-disable-next-line prefer-rest-params
    const bodyText=   `${arrayPop(arguments)|| '' }`;
    // eslint-disable-next-line prefer-rest-params
    const parameters=   `${arrayJoin(arguments,',') }`;

    // Are parameters and bodyText valid code, or is someone
    // attempting an injection attack? This will throw a SyntaxError if:
    // - parameters doesn't parse as parameters
    // - bodyText doesn't parse as a function body
    // - either contain a call to super() or references a super property.
    //
    // It seems that XS may still be vulnerable to the attack explained at
    // https://github.com/tc39/ecma262/pull/2374#issuecomment-813769710
    // where `new Function('/*', '*/ ) {')` would incorrectly validate.
    // Before we worried about this, we check the parameters and bodyText
    // together in one call
    // ```js
    // new FERAL_FUNCTION(parameters, bodyTest);
    // ```
    // However, this check is vulnerable to that bug. Aside from that case,
    // all engines do seem to validate the parameters, taken by themselves,
    // correctly. And all engines do seem to validate the bodyText, taken
    // by itself correctly. So with the following two checks, SES builds a
    // correct safe `Function` constructor by composing two calls to an
    // original unsafe `Function` constructor that may suffer from this bug
    // but is otherwise correctly validating.
    //
    // eslint-disable-next-line no-new
    new FERAL_FUNCTION(parameters, '');
    // eslint-disable-next-line no-new
    new FERAL_FUNCTION(bodyText);

    // Safe to be combined. Defeat potential trailing comments.
    // TODO: since we create an anonymous function, the 'this' value
    // isn't bound to the global object as per specs, but set as undefined.
    const src=   `(function anonymous(${parameters}\n) {\n${bodyText}\n})`;
    return safeEvaluate(src);
   };

  defineProperties(newFunction, {
    // Ensure that any function created in any evaluator in a realm is an
    // instance of Function in any evaluator of the same realm.
    prototype: {
      value: FERAL_FUNCTION.prototype,
      writable: false,
      enumerable: false,
      configurable: false}});



  // Assert identity of Function.__proto__ accross all compartments
  getPrototypeOf(FERAL_FUNCTION)===  FERAL_FUNCTION.prototype||
    Fail `Function prototype is the same accross compartments`;
  getPrototypeOf(newFunction)===  FERAL_FUNCTION.prototype||
    Fail `Function constructor prototype is the same accross compartments`;

  return newFunction;
 };$h‍_once.makeFunctionConstructor(makeFunctionConstructor);
})()
,
// === functors[23] ===
({   imports: $h‍_imports,   liveVar: $h‍_live,   onceVar: $h‍_once,   importMeta: $h‍____meta, }) => (function () {   let TypeError,assign,create,defineProperty,entries,freeze,objectHasOwnProperty,unscopablesSymbol,makeEvalFunction,makeFunctionConstructor,constantProperties,universalPropertyNames;$h‍_imports([["./commons.js", [["TypeError", [$h‍_a => (TypeError = $h‍_a)]],["assign", [$h‍_a => (assign = $h‍_a)]],["create", [$h‍_a => (create = $h‍_a)]],["defineProperty", [$h‍_a => (defineProperty = $h‍_a)]],["entries", [$h‍_a => (entries = $h‍_a)]],["freeze", [$h‍_a => (freeze = $h‍_a)]],["objectHasOwnProperty", [$h‍_a => (objectHasOwnProperty = $h‍_a)]],["unscopablesSymbol", [$h‍_a => (unscopablesSymbol = $h‍_a)]]]],["./make-eval-function.js", [["makeEvalFunction", [$h‍_a => (makeEvalFunction = $h‍_a)]]]],["./make-function-constructor.js", [["makeFunctionConstructor", [$h‍_a => (makeFunctionConstructor = $h‍_a)]]]],["./permits.js", [["constantProperties", [$h‍_a => (constantProperties = $h‍_a)]],["universalPropertyNames", [$h‍_a => (universalPropertyNames = $h‍_a)]]]]]);   













/**
 * The host's ordinary global object is not provided by a `with` block, so
 * assigning to Symbol.unscopables has no effect.
 * Since this shim uses `with` blocks to create a confined lexical scope for
 * guest programs, we cannot emulate the proper behavior.
 * With this shim, assigning Symbol.unscopables causes the given lexical
 * names to fall through to the terminal scope proxy.
 * But, we can install this setter to prevent a program from proceding on
 * this false assumption.
 *
 * @param {object} globalObject
 */
const        setGlobalObjectSymbolUnscopables=  (globalObject)=>{
  defineProperty(
    globalObject,
    unscopablesSymbol,
    freeze(
      assign(create(null), {
        set: freeze(()=>  {
          throw TypeError(
             `Cannot set Symbol.unscopables of a Compartment's globalThis`);

         }),
        enumerable: false,
        configurable: false})));



 };

/**
 * setGlobalObjectConstantProperties()
 * Initializes a new global object using a process similar to ECMA specifications
 * (SetDefaultGlobalBindings). This process is split between this function and
 * `setGlobalObjectMutableProperties`.
 *
 * @param {object} globalObject
 */$h‍_once.setGlobalObjectSymbolUnscopables(setGlobalObjectSymbolUnscopables);
const        setGlobalObjectConstantProperties=  (globalObject)=>{
  for( const [name, constant]of  entries(constantProperties)) {
    defineProperty(globalObject, name, {
      value: constant,
      writable: false,
      enumerable: false,
      configurable: false});

   }
 };

/**
 * setGlobalObjectMutableProperties()
 * Create new global object using a process similar to ECMA specifications
 * (portions of SetRealmGlobalObject and SetDefaultGlobalBindings).
 * `newGlobalPropertyNames` should be either `initialGlobalPropertyNames` or
 * `sharedGlobalPropertyNames`.
 *
 * @param {object} globalObject
 * @param {object} param1
 * @param {object} param1.intrinsics
 * @param {object} param1.newGlobalPropertyNames
 * @param {Function} param1.makeCompartmentConstructor
 * @param {(object) => void} param1.markVirtualizedNativeFunction
 */$h‍_once.setGlobalObjectConstantProperties(setGlobalObjectConstantProperties);
const        setGlobalObjectMutableProperties=  (
  globalObject,
  {
    intrinsics,
    newGlobalPropertyNames,
    makeCompartmentConstructor,
    markVirtualizedNativeFunction})=>

     {
  for( const [name, intrinsicName]of  entries(universalPropertyNames)) {
    if( objectHasOwnProperty(intrinsics, intrinsicName)) {
      defineProperty(globalObject, name, {
        value: intrinsics[intrinsicName],
        writable: true,
        enumerable: false,
        configurable: true});

     }
   }

  for( const [name, intrinsicName]of  entries(newGlobalPropertyNames)) {
    if( objectHasOwnProperty(intrinsics, intrinsicName)) {
      defineProperty(globalObject, name, {
        value: intrinsics[intrinsicName],
        writable: true,
        enumerable: false,
        configurable: true});

     }
   }

  const perCompartmentGlobals=  {
    globalThis: globalObject};


  perCompartmentGlobals.Compartment=  makeCompartmentConstructor(
    makeCompartmentConstructor,
    intrinsics,
    markVirtualizedNativeFunction);


  // TODO These should still be tamed according to the whitelist before
  // being made available.
  for( const [name, value]of  entries(perCompartmentGlobals)) {
    defineProperty(globalObject, name, {
      value,
      writable: true,
      enumerable: false,
      configurable: true});

    if( typeof value===  'function') {
      markVirtualizedNativeFunction(value);
     }
   }
 };

/**
 * setGlobalObjectEvaluators()
 * Set the eval and the Function evaluator on the global object with given evalTaming policy.
 *
 * @param {object} globalObject
 * @param {Function} evaluator
 * @param {(object) => void} markVirtualizedNativeFunction
 */$h‍_once.setGlobalObjectMutableProperties(setGlobalObjectMutableProperties);
const        setGlobalObjectEvaluators=  (
  globalObject,
  evaluator,
  markVirtualizedNativeFunction)=>
     {
  {
    const f=  makeEvalFunction(evaluator);
    markVirtualizedNativeFunction(f);
    defineProperty(globalObject, 'eval', {
      value: f,
      writable: true,
      enumerable: false,
      configurable: true});

   }
  {
    const f=  makeFunctionConstructor(evaluator);
    markVirtualizedNativeFunction(f);
    defineProperty(globalObject, 'Function', {
      value: f,
      writable: true,
      enumerable: false,
      configurable: true});

   }
 };$h‍_once.setGlobalObjectEvaluators(setGlobalObjectEvaluators);
})()
,
// === functors[24] ===
({   imports: $h‍_imports,   liveVar: $h‍_live,   onceVar: $h‍_once,   importMeta: $h‍____meta, }) => (function () {   let Proxy,String,TypeError,ReferenceError,create,freeze,getOwnPropertyDescriptors,globalThis,immutableObject,assert;$h‍_imports([["./commons.js", [["Proxy", [$h‍_a => (Proxy = $h‍_a)]],["String", [$h‍_a => (String = $h‍_a)]],["TypeError", [$h‍_a => (TypeError = $h‍_a)]],["ReferenceError", [$h‍_a => (ReferenceError = $h‍_a)]],["create", [$h‍_a => (create = $h‍_a)]],["freeze", [$h‍_a => (freeze = $h‍_a)]],["getOwnPropertyDescriptors", [$h‍_a => (getOwnPropertyDescriptors = $h‍_a)]],["globalThis", [$h‍_a => (globalThis = $h‍_a)]],["immutableObject", [$h‍_a => (immutableObject = $h‍_a)]]]],["./error/assert.js", [["assert", [$h‍_a => (assert = $h‍_a)]]]]]);   












const { Fail, quote: q}=   assert;

/**
 * alwaysThrowHandler
 * This is an object that throws if any property is called. It's used as
 * a proxy handler which throws on any trap called.
 * It's made from a proxy with a get trap that throws. It's safe to
 * create one and share it between all Proxy handlers.
 */
const        alwaysThrowHandler=  new Proxy(
  immutableObject,
  freeze({
    get(_shadow, prop) {
      Fail `Please report unexpected scope handler trap: ${q(String(prop))}`;
     }}));



/*
 * scopeProxyHandlerProperties
 * scopeTerminatorHandler manages a strictScopeTerminator Proxy which serves as
 * the final scope boundary that will always return "undefined" in order
 * to prevent access to "start compartment globals".
 */$h‍_once.alwaysThrowHandler(alwaysThrowHandler);
const scopeProxyHandlerProperties=  {
  get(_shadow, _prop) {
    return undefined;
   },

  set(_shadow, prop, _value) {
    // We should only hit this if the has() hook returned true matches the v8
    // ReferenceError message "Uncaught ReferenceError: xyz is not defined"
    throw ReferenceError( `${String(prop)} is not defined`);
   },

  has(_shadow, prop) {
    // we must at least return true for all properties on the realm globalThis
    return prop in globalThis;
   },

  // note: this is likely a bug of safari
  // https://bugs.webkit.org/show_bug.cgi?id=195534
  getPrototypeOf(_shadow) {
    return null;
   },

  // See https://github.com/endojs/endo/issues/1510
  // TODO: report as bug to v8 or Chrome, and record issue link here.
  getOwnPropertyDescriptor(_shadow, prop) {
    // Coerce with `String` in case prop is a symbol.
    const quotedProp=  q(String(prop));
    // eslint-disable-next-line @endo/no-polymorphic-call
    console.warn(
       `getOwnPropertyDescriptor trap on scopeTerminatorHandler for ${quotedProp}`,
      TypeError().stack);

    return undefined;
   },

  // See https://github.com/endojs/endo/issues/1490
  // TODO Report bug to JSC or Safari
  ownKeys(_shadow) {
    return [];
   }};


// The scope handler's prototype is a proxy that throws if any trap other
// than get/set/has are run (like getOwnPropertyDescriptors, apply,
// getPrototypeOf).
const        strictScopeTerminatorHandler=  freeze(
  create(
    alwaysThrowHandler,
    getOwnPropertyDescriptors(scopeProxyHandlerProperties)));$h‍_once.strictScopeTerminatorHandler(strictScopeTerminatorHandler);



const        strictScopeTerminator=  new Proxy(
  immutableObject,
  strictScopeTerminatorHandler);$h‍_once.strictScopeTerminator(strictScopeTerminator);
})()
,
// === functors[25] ===
({   imports: $h‍_imports,   liveVar: $h‍_live,   onceVar: $h‍_once,   importMeta: $h‍____meta, }) => (function () {   let Proxy,create,freeze,getOwnPropertyDescriptors,immutableObject,reflectSet,strictScopeTerminatorHandler,alwaysThrowHandler;$h‍_imports([["./commons.js", [["Proxy", [$h‍_a => (Proxy = $h‍_a)]],["create", [$h‍_a => (create = $h‍_a)]],["freeze", [$h‍_a => (freeze = $h‍_a)]],["getOwnPropertyDescriptors", [$h‍_a => (getOwnPropertyDescriptors = $h‍_a)]],["immutableObject", [$h‍_a => (immutableObject = $h‍_a)]],["reflectSet", [$h‍_a => (reflectSet = $h‍_a)]]]],["./strict-scope-terminator.js", [["strictScopeTerminatorHandler", [$h‍_a => (strictScopeTerminatorHandler = $h‍_a)]],["alwaysThrowHandler", [$h‍_a => (alwaysThrowHandler = $h‍_a)]]]]]);   












/*
 * createSloppyGlobalsScopeTerminator()
 * strictScopeTerminatorHandler manages a scopeTerminator Proxy which serves as
 * the final scope boundary that will always return "undefined" in order
 * to prevent access to "start compartment globals". When "sloppyGlobalsMode"
 * is true, the Proxy will perform sets on the "globalObject".
 */
const        createSloppyGlobalsScopeTerminator=  (globalObject)=>{
  const scopeProxyHandlerProperties=  {
    // inherit scopeTerminator behavior
    ...strictScopeTerminatorHandler,

    // Redirect set properties to the globalObject.
    set(_shadow, prop, value) {
      return reflectSet(globalObject, prop, value);
     },

    // Always claim to have a potential property in order to be the recipient of a set
    has(_shadow, _prop) {
      return true;
     }};


  // The scope handler's prototype is a proxy that throws if any trap other
  // than get/set/has are run (like getOwnPropertyDescriptors, apply,
  // getPrototypeOf).
  const sloppyGlobalsScopeTerminatorHandler=  freeze(
    create(
      alwaysThrowHandler,
      getOwnPropertyDescriptors(scopeProxyHandlerProperties)));



  const sloppyGlobalsScopeTerminator=  new Proxy(
    immutableObject,
    sloppyGlobalsScopeTerminatorHandler);


  return sloppyGlobalsScopeTerminator;
 };$h‍_once.createSloppyGlobalsScopeTerminator(createSloppyGlobalsScopeTerminator);
freeze(createSloppyGlobalsScopeTerminator);
})()
,
// === functors[26] ===
({   imports: $h‍_imports,   liveVar: $h‍_live,   onceVar: $h‍_once,   importMeta: $h‍____meta, }) => (function () {   let FERAL_EVAL,create,defineProperties,freeze,assert;$h‍_imports([["./commons.js", [["FERAL_EVAL", [$h‍_a => (FERAL_EVAL = $h‍_a)]],["create", [$h‍_a => (create = $h‍_a)]],["defineProperties", [$h‍_a => (defineProperties = $h‍_a)]],["freeze", [$h‍_a => (freeze = $h‍_a)]]]],["./error/assert.js", [["assert", [$h‍_a => (assert = $h‍_a)]]]]]);   



const { Fail}=   assert;

// We attempt to frustrate stack bumping attacks on the safe evaluator
// (`make-safe-evaluator.js`).
// A stack bumping attack forces an API call to throw a stack overflow
// `RangeError` at an inopportune time.
// The attacker arranges for the stack to be sufficiently deep that the API
// consumes exactly enough stack frames to throw an exception.
//
// For the safe evaluator, an exception thrown between adding and then deleting
// `eval` on `evalScope` could leak the real `eval` to an attacker's lexical
// scope.
// This would be sufficiently disastrous that we guard against it twice.
// First, we delete `eval` from `evalScope` immediately before rendering it to
// the guest program's lexical scope.
//
// If the attacker manages to arrange for `eval` to throw an exception after we
// call `allowNextEvalToBeUnsafe` but before the guest program accesses `eval`,
// it would be able to access `eval` once more in its own code.
// Although they could do no harm with a direct `eval`, they would be able to
// escape to the true global scope with an indirect `eval`.
//
//   prepareStack(depth, () => {
//     (eval)('');
//   });
//   const unsafeEval = (eval);
//   const safeEval = (eval);
//   const realGlobal = unsafeEval('globalThis');
//
// To protect against that case, we also delete `eval` from the `evalScope` in
// a `finally` block surrounding the call to the safe evaluator.
// The only way to reach this case is if `eval` remains on `evalScope` due to
// an attack, so we assume that attack would have have invalided our isolation
// and revoke all future access to the evaluator.
//
// To defeat a stack bumping attack, we must use fewer stack frames to recover
// in that `finally` block than we used in the `try` block.
// We have no reliable guarantees about how many stack frames a block of
// JavaScript will consume.
// Function inlining, tail-call optimization, variations in the size of a stack
// frame, and block scopes may affect the depth of the stack.
// The only number of acceptable stack frames to use in the finally block is
// zero.
// We only use property assignment and deletion in the safe evaluator's
// `finally` block.
// We use `delete evalScope.eval` to withhold the evaluator.
// We assign an envelope object over `evalScopeKit.revoked` to revoke the
// evaluator.
//
// This is why we supply a meaningfully named function for
// `allowNextEvalToBeUnsafe` but do not provide a corresponding
// `revokeAccessToUnsafeEval` or even simply `revoke`.
// These recovery routines are expressed inline in the safe evaluator.

const        makeEvalScopeKit=  ()=>  {
  const evalScope=  create(null);
  const oneTimeEvalProperties=  freeze({
    eval: {
      get() {
        delete evalScope.eval;
        return FERAL_EVAL;
       },
      enumerable: false,
      configurable: true}});



  const evalScopeKit=  {
    evalScope,
    allowNextEvalToBeUnsafe() {
      const { revoked}=   evalScopeKit;
      if( revoked!==  null) {
        Fail `a handler did not reset allowNextEvalToBeUnsafe ${revoked.err}`;
       }
      // Allow next reference to eval produce the unsafe FERAL_EVAL.
      // We avoid defineProperty because it consumes an extra stack frame taming
      // its return value.
      defineProperties(evalScope, oneTimeEvalProperties);
     },
    /** @type {null | { err: any }} */
    revoked: null};


  return evalScopeKit;
 };$h‍_once.makeEvalScopeKit(makeEvalScopeKit);
})()
,
// === functors[27] ===
({   imports: $h‍_imports,   liveVar: $h‍_live,   onceVar: $h‍_once,   importMeta: $h‍____meta, }) => (function () {   let FERAL_REG_EXP,regexpExec,stringSlice;$h‍_imports([["./commons.js", [["FERAL_REG_EXP", [$h‍_a => (FERAL_REG_EXP = $h‍_a)]],["regexpExec", [$h‍_a => (regexpExec = $h‍_a)]],["stringSlice", [$h‍_a => (stringSlice = $h‍_a)]]]]]);   

// Captures a key and value of the form #key=value or @key=value
const sourceMetaEntryRegExp=
  '\\s*[@#]\\s*([a-zA-Z][a-zA-Z0-9]*)\\s*=\\s*([^\\s\\*]*)';
// Captures either a one-line or multi-line comment containing
// one #key=value or @key=value.
// Produces two pairs of capture groups, but the initial two may be undefined.
// On account of the mechanics of regular expressions, scanning from the end
// does not allow us to capture every pair, so getSourceURL must capture and
// trim until there are no matching comments.
const sourceMetaEntriesRegExp=  new FERAL_REG_EXP(
   `(?:\\s*//${sourceMetaEntryRegExp}|/\\*${sourceMetaEntryRegExp}\\s*\\*/)\\s*$`);


/**
 * @param {string} src
 */
const        getSourceURL=  (src)=>{
  let sourceURL=  '<unknown>';

  // Our regular expression matches the last one or two comments with key value
  // pairs at the end of the source, avoiding a scan over the entire length of
  // the string, but at the expense of being able to capture all the (key,
  // value) pair meta comments at the end of the source, which may include
  // sourceMapURL in addition to sourceURL.
  // So, we sublimate the comments out of the source until no source or no
  // comments remain.
  while( src.length>  0) {
    const match=  regexpExec(sourceMetaEntriesRegExp, src);
    if( match===  null) {
      break;
     }
    src=  stringSlice(src, 0, src.length-  match[0].length);

    // We skip $0 since it contains the entire match.
    // The match contains four capture groups,
    // two (key, value) pairs, the first of which
    // may be undefined.
    // On the off-chance someone put two sourceURL comments in their code with
    // different commenting conventions, the latter has precedence.
    if( match[3]===  'sourceURL') {
      sourceURL=  match[4];
     }else if( match[1]===  'sourceURL') {
      sourceURL=  match[2];
     }
   }

  return sourceURL;
 };$h‍_once.getSourceURL(getSourceURL);
})()
,
// === functors[28] ===
({   imports: $h‍_imports,   liveVar: $h‍_live,   onceVar: $h‍_once,   importMeta: $h‍____meta, }) => (function () {   let FERAL_REG_EXP,SyntaxError,stringReplace,stringSearch,stringSlice,stringSplit,freeze,getSourceURL;$h‍_imports([["./commons.js", [["FERAL_REG_EXP", [$h‍_a => (FERAL_REG_EXP = $h‍_a)]],["SyntaxError", [$h‍_a => (SyntaxError = $h‍_a)]],["stringReplace", [$h‍_a => (stringReplace = $h‍_a)]],["stringSearch", [$h‍_a => (stringSearch = $h‍_a)]],["stringSlice", [$h‍_a => (stringSlice = $h‍_a)]],["stringSplit", [$h‍_a => (stringSplit = $h‍_a)]],["freeze", [$h‍_a => (freeze = $h‍_a)]]]],["./get-source-url.js", [["getSourceURL", [$h‍_a => (getSourceURL = $h‍_a)]]]]]);   












/**
 * Find the first occurence of the given pattern and return
 * the location as the approximate line number.
 *
 * @param {string} src
 * @param {RegExp} pattern
 * @returns {number}
 */
function getLineNumber(src, pattern) {
  const index=  stringSearch(src, pattern);
  if( index<  0) {
    return -1;
   }

  // The importPattern incidentally captures an initial \n in
  // an attempt to reject a . prefix, so we need to offset
  // the line number in that case.
  const adjustment=  src[index]===  '\n'?  1:  0;

  return stringSplit(stringSlice(src, 0, index), '\n').length+  adjustment;
 }

// /////////////////////////////////////////////////////////////////////////////

const htmlCommentPattern=  new FERAL_REG_EXP( `(?:${'<'}!--|--${'>'})`,'g');

/**
 * Conservatively reject the source text if it may contain text that some
 * JavaScript parsers may treat as an html-like comment. To reject without
 * parsing, `rejectHtmlComments` will also reject some other text as well.
 *
 * https://www.ecma-international.org/ecma-262/9.0/index.html#sec-html-like-comments
 * explains that JavaScript parsers may or may not recognize html
 * comment tokens "<" immediately followed by "!--" and "--"
 * immediately followed by ">" in non-module source text, and treat
 * them as a kind of line comment. Since otherwise both of these can
 * appear in normal JavaScript source code as a sequence of operators,
 * we have the terrifying possibility of the same source code parsing
 * one way on one correct JavaScript implementation, and another way
 * on another.
 *
 * This shim takes the conservative strategy of just rejecting source
 * text that contains these strings anywhere. Note that this very
 * source file is written strangely to avoid mentioning these
 * character strings explicitly.
 *
 * We do not write the regexp in a straightforward way, so that an
 * apparennt html comment does not appear in this file. Thus, we avoid
 * rejection by the overly eager rejectDangerousSources.
 *
 * @param {string} src
 * @returns {string}
 */
const        rejectHtmlComments=  (src)=>{
  const lineNumber=  getLineNumber(src, htmlCommentPattern);
  if( lineNumber<  0) {
    return src;
   }
  const name=  getSourceURL(src);
  // See https://github.com/endojs/endo/blob/master/packages/ses/error-codes/SES_HTML_COMMENT_REJECTED.md
  throw SyntaxError(
     `Possible HTML comment rejected at ${name}:${lineNumber}. (SES_HTML_COMMENT_REJECTED)`);

 };

/**
 * An optional transform to place ahead of `rejectHtmlComments` to evade *that*
 * rejection. However, it may change the meaning of the program.
 *
 * This evasion replaces each alleged html comment with the space-separated
 * JavaScript operator sequence that it may mean, assuming that it appears
 * outside of a comment or literal string, in source code where the JS
 * parser makes no special case for html comments (like module source code).
 * In that case, this evasion preserves the meaning of the program, though it
 * does change the souce column numbers on each effected line.
 *
 * If the html comment appeared in a literal (a string literal, regexp literal,
 * or a template literal), then this evasion will change the meaning of the
 * program by changing the text of that literal.
 *
 * If the html comment appeared in a JavaScript comment, then this evasion does
 * not change the meaning of the program because it only changes the contents of
 * those comments.
 *
 * @param {string} src
 * @returns {string}
 */$h‍_once.rejectHtmlComments(rejectHtmlComments);
const        evadeHtmlCommentTest=  (src)=>{
  const replaceFn=  (match)=> match[0]===  '<'?  '< ! --':  '-- >';
  return stringReplace(src, htmlCommentPattern, replaceFn);
 };

// /////////////////////////////////////////////////////////////////////////////
$h‍_once.evadeHtmlCommentTest(evadeHtmlCommentTest);
const importPattern=  new FERAL_REG_EXP(
  '(^|[^.]|\\.\\.\\.)\\bimport(\\s*(?:\\(|/[/*]))',
  'g');


/**
 * Conservatively reject the source text if it may contain a dynamic
 * import expression. To reject without parsing, `rejectImportExpressions` will
 * also reject some other text as well.
 *
 * The proposed dynamic import expression is the only syntax currently
 * proposed, that can appear in non-module JavaScript code, that
 * enables direct access to the outside world that cannot be
 * suppressed or intercepted without parsing and rewriting. Instead,
 * this shim conservatively rejects any source text that seems to
 * contain such an expression. To do this safely without parsing, we
 * must also reject some valid programs, i.e., those containing
 * apparent import expressions in literal strings or comments.
 *
 * The current conservative rule looks for the identifier "import"
 * followed by either an open paren or something that looks like the
 * beginning of a comment. We assume that we do not need to worry
 * about html comment syntax because that was already rejected by
 * rejectHtmlComments.
 *
 * this \s *must* match all kinds of syntax-defined whitespace. If e.g.
 * U+2028 (LINE SEPARATOR) or U+2029 (PARAGRAPH SEPARATOR) is treated as
 * whitespace by the parser, but not matched by /\s/, then this would admit
 * an attack like: import\u2028('power.js') . We're trying to distinguish
 * something like that from something like importnotreally('power.js') which
 * is perfectly safe.
 *
 * @param {string} src
 * @returns {string}
 */
const        rejectImportExpressions=  (src)=>{
  const lineNumber=  getLineNumber(src, importPattern);
  if( lineNumber<  0) {
    return src;
   }
  const name=  getSourceURL(src);
  // See https://github.com/endojs/endo/blob/master/packages/ses/error-codes/SES_IMPORT_REJECTED.md
  throw SyntaxError(
     `Possible import expression rejected at ${name}:${lineNumber}. (SES_IMPORT_REJECTED)`);

 };

/**
 * An optional transform to place ahead of `rejectImportExpressions` to evade
 * *that* rejection. However, it may change the meaning of the program.
 *
 * This evasion replaces each suspicious `import` identifier with `__import__`.
 * If the alleged import expression appears in a JavaScript comment, this
 * evasion will not change the meaning of the program. If it appears in a
 * literal (string literal, regexp literal, or a template literal), then this
 * evasion will change the contents of that literal. If it appears as code
 * where it would be parsed as an expression, then it might or might not change
 * the meaning of the program, depending on the binding, if any, of the lexical
 * variable `__import__`.
 *
 * @param {string} src
 * @returns {string}
 */$h‍_once.rejectImportExpressions(rejectImportExpressions);
const        evadeImportExpressionTest=  (src)=>{
  const replaceFn=  (_, p1, p2)=>   `${p1}__import__${p2}`;
  return stringReplace(src, importPattern, replaceFn);
 };

// /////////////////////////////////////////////////////////////////////////////
$h‍_once.evadeImportExpressionTest(evadeImportExpressionTest);
const someDirectEvalPattern=  new FERAL_REG_EXP(
  '(^|[^.])\\beval(\\s*\\()',
  'g');


/**
 * Heuristically reject some text that seems to contain a direct eval
 * expression, with both false positives and false negavives. To reject without
 * parsing, `rejectSomeDirectEvalExpressions` may will also reject some other
 * text as well. It may also accept source text that contains a direct eval
 * written oddly, such as `(eval)(src)`. This false negative is not a security
 * vulnerability. Rather it is a compat hazard because it will execute as
 * an indirect eval under the SES-shim but as a direct eval on platforms that
 * support SES directly (like XS).
 *
 * The shim cannot correctly emulate a direct eval as explained at
 * https://github.com/Agoric/realms-shim/issues/12
 * If we did not reject direct eval syntax, we would
 * accidentally evaluate these with an emulation of indirect eval. To
 * prevent future compatibility problems, in shifting from use of the
 * shim to genuine platform support for the proposal, we should
 * instead statically reject code that seems to contain a direct eval
 * expression.
 *
 * As with the dynamic import expression, to avoid a full parse, we do
 * this approximately with a regexp, that will also reject strings
 * that appear safely in comments or strings. Unlike dynamic import,
 * if we miss some, this only creates future compat problems, not
 * security problems. Thus, we are only trying to catch innocent
 * occurrences, not malicious one. In particular, `(eval)(...)` is
 * direct eval syntax that would not be caught by the following regexp.
 *
 * Exported for unit tests.
 *
 * @param {string} src
 * @returns {string}
 */
const        rejectSomeDirectEvalExpressions=  (src)=>{
  const lineNumber=  getLineNumber(src, someDirectEvalPattern);
  if( lineNumber<  0) {
    return src;
   }
  const name=  getSourceURL(src);
  // See https://github.com/endojs/endo/blob/master/packages/ses/error-codes/SES_EVAL_REJECTED.md
  throw SyntaxError(
     `Possible direct eval expression rejected at ${name}:${lineNumber}. (SES_EVAL_REJECTED)`);

 };

// /////////////////////////////////////////////////////////////////////////////

/**
 * A transform that bundles together the transforms that must unconditionally
 * happen last in order to ensure safe evaluation without parsing.
 *
 * @param {string} source
 * @returns {string}
 */$h‍_once.rejectSomeDirectEvalExpressions(rejectSomeDirectEvalExpressions);
const        mandatoryTransforms=  (source)=>{
  source=  rejectHtmlComments(source);
  source=  rejectImportExpressions(source);
  return source;
 };

/**
 * Starting with `source`, apply each transform to the result of the
 * previous one, returning the result of the last transformation.
 *
 * @param {string} source
 * @param {((str: string) => string)[]} transforms
 * @returns {string}
 */$h‍_once.mandatoryTransforms(mandatoryTransforms);
const        applyTransforms=  (source, transforms)=>  {
  for( const transform of transforms) {
    source=  transform(source);
   }
  return source;
 };

// export all as a frozen object
$h‍_once.applyTransforms(applyTransforms);const transforms=freeze({
  rejectHtmlComments: freeze(rejectHtmlComments),
  evadeHtmlCommentTest: freeze(evadeHtmlCommentTest),
  rejectImportExpressions: freeze(rejectImportExpressions),
  evadeImportExpressionTest: freeze(evadeImportExpressionTest),
  rejectSomeDirectEvalExpressions: freeze(rejectSomeDirectEvalExpressions),
  mandatoryTransforms: freeze(mandatoryTransforms),
  applyTransforms: freeze(applyTransforms)});$h‍_once.transforms(transforms);
})()
,
// === functors[29] ===
({   imports: $h‍_imports,   liveVar: $h‍_live,   onceVar: $h‍_once,   importMeta: $h‍____meta, }) => (function () {   let arrayFilter,arrayIncludes,getOwnPropertyDescriptor,getOwnPropertyNames,objectHasOwnProperty,regexpTest;$h‍_imports([["./commons.js", [["arrayFilter", [$h‍_a => (arrayFilter = $h‍_a)]],["arrayIncludes", [$h‍_a => (arrayIncludes = $h‍_a)]],["getOwnPropertyDescriptor", [$h‍_a => (getOwnPropertyDescriptor = $h‍_a)]],["getOwnPropertyNames", [$h‍_a => (getOwnPropertyNames = $h‍_a)]],["objectHasOwnProperty", [$h‍_a => (objectHasOwnProperty = $h‍_a)]],["regexpTest", [$h‍_a => (regexpTest = $h‍_a)]]]]]);   








/**
 * keywords
 * In JavaScript you cannot use these reserved words as variables.
 * See 11.6.1 Identifier Names
 */
const keywords=  [
  // 11.6.2.1 Keywords
  'await',
  'break',
  'case',
  'catch',
  'class',
  'const',
  'continue',
  'debugger',
  'default',
  'delete',
  'do',
  'else',
  'export',
  'extends',
  'finally',
  'for',
  'function',
  'if',
  'import',
  'in',
  'instanceof',
  'new',
  'return',
  'super',
  'switch',
  'this',
  'throw',
  'try',
  'typeof',
  'var',
  'void',
  'while',
  'with',
  'yield',

  // Also reserved when parsing strict mode code
  'let',
  'static',

  // 11.6.2.2 Future Reserved Words
  'enum',

  // Also reserved when parsing strict mode code
  'implements',
  'package',
  'protected',
  'interface',
  'private',
  'public',

  // Reserved but not mentioned in specs
  'await',

  'null',
  'true',
  'false',

  'this',
  'arguments'];


/**
 * identifierPattern
 * Simplified validation of identifier names: may only contain alphanumeric
 * characters (or "$" or "_"), and may not start with a digit. This is safe
 * and does not reduces the compatibility of the shim. The motivation for
 * this limitation was to decrease the complexity of the implementation,
 * and to maintain a resonable level of performance.
 * Note: \w is equivalent [a-zA-Z_0-9]
 * See 11.6.1 Identifier Names
 */
const identifierPattern=  /^[a-zA-Z_$][\w$]*$/;

/**
 * isValidIdentifierName()
 * What variable names might it bring into scope? These include all
 * property names which can be variable names, including the names
 * of inherited properties. It excludes symbols and names which are
 * keywords. We drop symbols safely. Currently, this shim refuses
 * service if any of the names are keywords or keyword-like. This is
 * safe and only prevent performance optimization.
 *
 * @param {string} name
 */
const        isValidIdentifierName=  (name)=>{
  // Ensure we have a valid identifier. We use regexpTest rather than
  // /../.test() to guard against the case where RegExp has been poisoned.
  return(
    name!==  'eval'&&
    !arrayIncludes(keywords, name)&&
    regexpTest(identifierPattern, name));

 };

/*
 * isImmutableDataProperty
 */$h‍_once.isValidIdentifierName(isValidIdentifierName);

function isImmutableDataProperty(obj, name) {
  const desc=  getOwnPropertyDescriptor(obj, name);
  return(
    desc&&
    //
    // The getters will not have .writable, don't let the falsyness of
    // 'undefined' trick us: test with === false, not ! . However descriptors
    // inherit from the (potentially poisoned) global object, so we might see
    // extra properties which weren't really there. Accessor properties have
    // 'get/set/enumerable/configurable', while data properties have
    // 'value/writable/enumerable/configurable'.
    desc.configurable===  false&&
    desc.writable===  false&&
    //
    // Checks for data properties because they're the only ones we can
    // optimize (accessors are most likely non-constant). Descriptors can't
    // can't have accessors and value properties at the same time, therefore
    // this check is sufficient. Using explicit own property deal with the
    // case where Object.prototype has been poisoned.
    objectHasOwnProperty(desc, 'value'));

 }

/**
 * getScopeConstants()
 * What variable names might it bring into scope? These include all
 * property names which can be variable names, including the names
 * of inherited properties. It excludes symbols and names which are
 * keywords. We drop symbols safely. Currently, this shim refuses
 * service if any of the names are keywords or keyword-like. This is
 * safe and only prevent performance optimization.
 *
 * @param {object} globalObject
 * @param {object} moduleLexicals
 */
const        getScopeConstants=  (globalObject, moduleLexicals=  {})=>  {
  // getOwnPropertyNames() does ignore Symbols so we don't need to
  // filter them out.
  const globalObjectNames=  getOwnPropertyNames(globalObject);
  const moduleLexicalNames=  getOwnPropertyNames(moduleLexicals);

  // Collect all valid & immutable identifiers from the endowments.
  const moduleLexicalConstants=  arrayFilter(
    moduleLexicalNames,
    (name)=>
      isValidIdentifierName(name)&&
      isImmutableDataProperty(moduleLexicals, name));


  // Collect all valid & immutable identifiers from the global that
  // are also not present in the endowments (immutable or not).
  const globalObjectConstants=  arrayFilter(
    globalObjectNames,
    (name)=>
      // Can't define a constant: it would prevent a
      // lookup on the endowments.
      !arrayIncludes(moduleLexicalNames, name)&&
      isValidIdentifierName(name)&&
      isImmutableDataProperty(globalObject, name));


  return {
    globalObjectConstants,
    moduleLexicalConstants};

 };$h‍_once.getScopeConstants(getScopeConstants);
})()
,
// === functors[30] ===
({   imports: $h‍_imports,   liveVar: $h‍_live,   onceVar: $h‍_once,   importMeta: $h‍____meta, }) => (function () {   let FERAL_FUNCTION,arrayJoin,apply,getScopeConstants;$h‍_imports([["./commons.js", [["FERAL_FUNCTION", [$h‍_a => (FERAL_FUNCTION = $h‍_a)]],["arrayJoin", [$h‍_a => (arrayJoin = $h‍_a)]],["apply", [$h‍_a => (apply = $h‍_a)]]]],["./scope-constants.js", [["getScopeConstants", [$h‍_a => (getScopeConstants = $h‍_a)]]]]]);   




/**
 * buildOptimizer()
 * Given an array of identifiers, the optimizer returns a `const` declaration
 * destructuring `this.${name}`.
 *
 * @param {Array<string>} constants
 * @param {string} name
 */
function buildOptimizer(constants, name) {
  // No need to build an optimizer when there are no constants.
  if( constants.length===  0) return '';
  // Use 'this' to avoid going through the scope proxy, which is unnecessary
  // since the optimizer only needs references to the safe global.
  // Destructure the constants from the target scope object.
  return  `const {${arrayJoin(constants,',') }} = this.${name};`;
 }

/**
 * makeEvaluate()
 * Create an 'evaluate' function with the correct optimizer inserted.
 *
 * @param {object} context
 * @param {object} context.evalScope
 * @param {object} context.moduleLexicals
 * @param {object} context.globalObject
 * @param {object} context.scopeTerminator
 */
const        makeEvaluate=  (context)=>{
  const { globalObjectConstants, moduleLexicalConstants}=   getScopeConstants(
    context.globalObject,
    context.moduleLexicals);

  const globalObjectOptimizer=  buildOptimizer(
    globalObjectConstants,
    'globalObject');

  const moduleLexicalOptimizer=  buildOptimizer(
    moduleLexicalConstants,
    'moduleLexicals');


  // Create a function in sloppy mode, so that we can use 'with'. It returns
  // a function in strict mode that evaluates the provided code using direct
  // eval, and thus in strict mode in the same scope. We must be very careful
  // to not create new names in this scope

  // 1: we use multiple nested 'with' to catch all free variable names. The
  // `this` value of the outer sloppy function holds the different scope
  // layers, from inner to outer:
  //    a) `evalScope` which must release the `FERAL_EVAL` as 'eval' once for
  //       every invocation of the inner `evaluate` function in order to
  //       trigger direct eval. The direct eval semantics is what allows the
  //       evaluated code to lookup free variable names on the other scope
  //       objects and not in global scope.
  //    b) `moduleLexicals` which provide a way to introduce free variables
  //       that are not available on the globalObject.
  //    c) `globalObject` is the global scope object of the evaluator, aka the
  //       Compartment's `globalThis`.
  //    d) `scopeTerminator` is a proxy object which prevents free variable
  //       lookups to escape to the start compartment's global object.
  // 2: `optimizer`s catch constant variable names for speed.
  // 3: The inner strict `evaluate` function should be passed two parameters:
  //    a) its arguments[0] is the source to be directly evaluated.
  //    b) its 'this' is the this binding seen by the code being
  //       directly evaluated (the globalObject).

  // Notes:
  // - The `optimizer` strings only lookup values on the `globalObject` and
  //   `moduleLexicals` objects by construct. Keywords like 'function' are
  //   reserved and cannot be used as a variable, so they are excluded from the
  //   optimizer. Furthermore to prevent shadowing 'eval', while a valid
  //   identifier, that name is also explicitly excluded.
  // - when 'eval' is looked up in the `evalScope`, the powerful unsafe eval
  //   intrinsic is returned after automatically removing it from the
  //   `evalScope`. Any further reference to 'eval' in the evaluate string will
  //   get the tamed evaluator from the `globalObject`, if any.

  // TODO https://github.com/endojs/endo/issues/816
  // The optimizer currently runs under sloppy mode, and although we doubt that
  // there is any vulnerability introduced just by running the optimizer
  // sloppy, we are much more confident in the semantics of strict mode.
  // The `evaluate` function can be and is reused across multiple evaluations.
  // Since the optimizer should not be re-evaluated every time, it cannot be
  // inside the `evaluate` closure. While we could potentially nest an
  // intermediate layer of `() => {'use strict'; ${optimizers}; ...`, it
  // doesn't seem worth the overhead and complexity.
  const evaluateFactory=  FERAL_FUNCTION( `
    with (this.scopeTerminator) {
      with (this.globalObject) {
        with (this.moduleLexicals) {
          with (this.evalScope) {
            ${globalObjectOptimizer }
            ${moduleLexicalOptimizer }
            return function() {
              'use strict';
              return eval(arguments[0]);
            };
          }
        }
      }
    }
  `);

  return apply(evaluateFactory, context, []);
 };$h‍_once.makeEvaluate(makeEvaluate);
})()
,
// === functors[31] ===
({   imports: $h‍_imports,   liveVar: $h‍_live,   onceVar: $h‍_once,   importMeta: $h‍____meta, }) => (function () {   let apply,freeze,strictScopeTerminator,createSloppyGlobalsScopeTerminator,makeEvalScopeKit,applyTransforms,mandatoryTransforms,makeEvaluate,assert;$h‍_imports([["./commons.js", [["apply", [$h‍_a => (apply = $h‍_a)]],["freeze", [$h‍_a => (freeze = $h‍_a)]]]],["./strict-scope-terminator.js", [["strictScopeTerminator", [$h‍_a => (strictScopeTerminator = $h‍_a)]]]],["./sloppy-globals-scope-terminator.js", [["createSloppyGlobalsScopeTerminator", [$h‍_a => (createSloppyGlobalsScopeTerminator = $h‍_a)]]]],["./eval-scope.js", [["makeEvalScopeKit", [$h‍_a => (makeEvalScopeKit = $h‍_a)]]]],["./transforms.js", [["applyTransforms", [$h‍_a => (applyTransforms = $h‍_a)]],["mandatoryTransforms", [$h‍_a => (mandatoryTransforms = $h‍_a)]]]],["./make-evaluate.js", [["makeEvaluate", [$h‍_a => (makeEvaluate = $h‍_a)]]]],["./error/assert.js", [["assert", [$h‍_a => (assert = $h‍_a)]]]]]);   










const { Fail}=   assert;

/**
 * makeSafeEvaluator()
 * Build the low-level operation used by all evaluators:
 * eval(), Function(), Compartment.prototype.evaluate().
 *
 * @param {object} options
 * @param {object} options.globalObject
 * @param {object} [options.moduleLexicals]
 * @param {Array<import('./lockdown.js').Transform>} [options.globalTransforms]
 * @param {boolean} [options.sloppyGlobalsMode]
 */
const        makeSafeEvaluator=  ({
  globalObject,
  moduleLexicals=  {},
  globalTransforms=  [],
  sloppyGlobalsMode=  false})=>
      {
  const scopeTerminator=  sloppyGlobalsMode?
      createSloppyGlobalsScopeTerminator(globalObject):
      strictScopeTerminator;
  const evalScopeKit=  makeEvalScopeKit();
  const { evalScope}=   evalScopeKit;

  const evaluateContext=  freeze({
    evalScope,
    moduleLexicals,
    globalObject,
    scopeTerminator});


  // Defer creating the actual evaluator to first use.
  // Creating a compartment should be possible in no-eval environments
  // It also allows more global constants to be captured by the optimizer
  let evaluate;
  const provideEvaluate=  ()=>  {
    if( !evaluate) {
      evaluate=  makeEvaluate(evaluateContext);
     }
   };

  /**
   * @param {string} source
   * @param {object} [options]
   * @param {Array<import('./lockdown.js').Transform>} [options.localTransforms]
   */
  const safeEvaluate=  (source, options)=>  {
    const { localTransforms=  []}=   options||  {};
    provideEvaluate();

    // Execute the mandatory transforms last to ensure that any rewritten code
    // meets those mandatory requirements.
    source=  applyTransforms(source, [
      ...localTransforms,
      ...globalTransforms,
      mandatoryTransforms]);


    let err;
    try {
      // Allow next reference to eval produce the unsafe FERAL_EVAL.
      // eslint-disable-next-line @endo/no-polymorphic-call
      evalScopeKit.allowNextEvalToBeUnsafe();

      // Ensure that "this" resolves to the safe global.
      return apply(evaluate, globalObject, [source]);
     }catch( e) {
      // stash the child-code error in hopes of debugging the internal failure
      err=  e;
      throw e;
     }finally {
      const unsafeEvalWasStillExposed=( 'eval'in  evalScope);
      delete evalScope.eval;
      if( unsafeEvalWasStillExposed) {
        // Barring a defect in the SES shim, the evalScope should allow the
        // powerful, unsafe  `eval` to be used by `evaluate` exactly once, as the
        // very first name that it attempts to access from the lexical scope.
        // A defect in the SES shim could throw an exception after we set
        // `evalScope.eval` and before `evaluate` calls `eval` internally.
        // If we get here, SES is very broken.
        // This condition is one where this vat is now hopelessly confused, and
        // the vat as a whole should be aborted.
        // No further code should run.
        // All immediately reachable state should be abandoned.
        // However, that is not yet possible, so we at least prevent further
        // variable resolution via the scopeHandler, and throw an error with
        // diagnostic info including the thrown error if any from evaluating the
        // source code.
        evalScopeKit.revoked=  { err};
        // TODO A GOOD PLACE TO PANIC(), i.e., kill the vat incarnation.
        // See https://github.com/Agoric/SES-shim/issues/490
        Fail `handler did not reset allowNextEvalToBeUnsafe ${err}`;
       }
     }
   };

  return { safeEvaluate};
 };$h‍_once.makeSafeEvaluator(makeSafeEvaluator);
})()
,
// === functors[32] ===
({   imports: $h‍_imports,   liveVar: $h‍_live,   onceVar: $h‍_once,   importMeta: $h‍____meta, }) => (function () {   let WeakSet,defineProperty,freeze,functionPrototype,functionToString,stringEndsWith,weaksetAdd,weaksetHas;$h‍_imports([["./commons.js", [["WeakSet", [$h‍_a => (WeakSet = $h‍_a)]],["defineProperty", [$h‍_a => (defineProperty = $h‍_a)]],["freeze", [$h‍_a => (freeze = $h‍_a)]],["functionPrototype", [$h‍_a => (functionPrototype = $h‍_a)]],["functionToString", [$h‍_a => (functionToString = $h‍_a)]],["stringEndsWith", [$h‍_a => (stringEndsWith = $h‍_a)]],["weaksetAdd", [$h‍_a => (weaksetAdd = $h‍_a)]],["weaksetHas", [$h‍_a => (weaksetHas = $h‍_a)]]]]]);   










const nativeSuffix=  ') { [native code] }';

// Note: Top level mutable state. Does not make anything worse, since the
// patching of `Function.prototype.toString` is also globally stateful. We
// use this top level state so that multiple calls to `tameFunctionToString` are
// idempotent, rather than creating redundant indirections.
let markVirtualizedNativeFunction;

/**
 * Replace `Function.prototype.toString` with one that recognizes
 * shimmed functions as honorary native functions.
 */
const        tameFunctionToString=  ()=>  {
  if( markVirtualizedNativeFunction===  undefined) {
    const virtualizedNativeFunctions=  new WeakSet();

    const tamingMethods=  {
      toString() {
        const str=  functionToString(this);
        if(
          stringEndsWith(str, nativeSuffix)||
          !weaksetHas(virtualizedNativeFunctions, this))
          {
          return str;
         }
        return  `function ${this.name}() { [native code] }`;
       }};


    defineProperty(functionPrototype, 'toString', {
      value: tamingMethods.toString});


    markVirtualizedNativeFunction=  freeze((func)=>
      weaksetAdd(virtualizedNativeFunctions, func));

   }
  return markVirtualizedNativeFunction;
 };$h‍_once.tameFunctionToString(tameFunctionToString);
})()
,
// === functors[33] ===
({   imports: $h‍_imports,   liveVar: $h‍_live,   onceVar: $h‍_once,   importMeta: $h‍____meta, }) => (function () {   let TypeError,globalThis,getOwnPropertyDescriptor,defineProperty;$h‍_imports([["./commons.js", [["TypeError", [$h‍_a => (TypeError = $h‍_a)]],["globalThis", [$h‍_a => (globalThis = $h‍_a)]],["getOwnPropertyDescriptor", [$h‍_a => (getOwnPropertyDescriptor = $h‍_a)]],["defineProperty", [$h‍_a => (defineProperty = $h‍_a)]]]]]);Object.defineProperty(tameDomains, 'name', {value: "tameDomains"});$h‍_once.tameDomains(tameDomains);   








function        tameDomains(domainTaming=  'safe') {
  if( domainTaming!==  'safe'&&  domainTaming!==  'unsafe') {
    throw TypeError( `unrecognized domainTaming ${domainTaming}`);
   }

  if( domainTaming===  'unsafe') {
    return;
   }

  // Protect against the hazard presented by Node.js domains.
  if( typeof globalThis.process===  'object'&&  globalThis.process!==  null) {
    // Check whether domains were initialized.
    const domainDescriptor=  getOwnPropertyDescriptor(
      globalThis.process,
      'domain');

    if( domainDescriptor!==  undefined&&  domainDescriptor.get!==  undefined) {
      // The domain descriptor on Node.js initially has value: null, which
      // becomes a get, set pair after domains initialize.
      // See https://github.com/endojs/endo/blob/master/packages/ses/error-codes/SES_NO_DOMAINS.md
      throw TypeError(
         `SES failed to lockdown, Node.js domains have been initialized (SES_NO_DOMAINS)`);

     }
    // Prevent domains from initializing.
    // This is clunky because the exception thrown from the domains package does
    // not direct the user's gaze toward a knowledge base about the problem.
    // The domain module merely throws an exception when it attempts to define
    // the domain property of the process global during its initialization.
    // We have no better recourse because Node.js uses defineProperty too.
    defineProperty(globalThis.process, 'domain', {
      value: null,
      configurable: false,
      writable: false,
      enumerable: false});

   }
 }
})()
,
// === functors[34] ===
({   imports: $h‍_imports,   liveVar: $h‍_live,   onceVar: $h‍_once,   importMeta: $h‍____meta, }) => (function () {   let WeakSet,arrayFilter,arrayMap,arrayPush,defineProperty,freeze,fromEntries,isError,stringEndsWith,weaksetAdd,weaksetHas;$h‍_imports([["../commons.js", [["WeakSet", [$h‍_a => (WeakSet = $h‍_a)]],["arrayFilter", [$h‍_a => (arrayFilter = $h‍_a)]],["arrayMap", [$h‍_a => (arrayMap = $h‍_a)]],["arrayPush", [$h‍_a => (arrayPush = $h‍_a)]],["defineProperty", [$h‍_a => (defineProperty = $h‍_a)]],["freeze", [$h‍_a => (freeze = $h‍_a)]],["fromEntries", [$h‍_a => (fromEntries = $h‍_a)]],["isError", [$h‍_a => (isError = $h‍_a)]],["stringEndsWith", [$h‍_a => (stringEndsWith = $h‍_a)]],["weaksetAdd", [$h‍_a => (weaksetAdd = $h‍_a)]],["weaksetHas", [$h‍_a => (weaksetHas = $h‍_a)]]]],["./types.js", []],["./internal-types.js", []]]);   






















// For our internal debugging purposes, uncomment
// const internalDebugConsole = console;

// The whitelists of console methods, from:
// Whatwg "living standard" https://console.spec.whatwg.org/
// Node https://nodejs.org/dist/latest-v14.x/docs/api/console.html
// MDN https://developer.mozilla.org/en-US/docs/Web/API/Console_API
// TypeScript https://openstapps.gitlab.io/projectmanagement/interfaces/_node_modules__types_node_globals_d_.console.html
// Chrome https://developers.google.com/web/tools/chrome-devtools/console/api

// All console level methods have parameters (fmt?, ...args)
// where the argument sequence `fmt?, ...args` formats args according to
// fmt if fmt is a format string. Otherwise, it just renders them all as values
// separated by spaces.
// https://console.spec.whatwg.org/#formatter
// https://nodejs.org/docs/latest/api/util.html#util_util_format_format_args

// For the causal console, all occurrences of `fmt, ...args` or `...args` by
// itself must check for the presence of an error to ask the
// `loggedErrorHandler` to handle.
// In theory we should do a deep inspection to detect for example an array
// containing an error. We currently do not detect these and may never.

/** @typedef {keyof VirtualConsole | 'profile' | 'profileEnd'} ConsoleProps */

/** @type {readonly [ConsoleProps, LogSeverity | undefined][]} */
const consoleLevelMethods=  freeze([
  ['debug', 'debug'], // (fmt?, ...args) verbose level on Chrome
  ['log', 'log'], // (fmt?, ...args) info level on Chrome
  ['info', 'info'], // (fmt?, ...args)
  ['warn', 'warn'], // (fmt?, ...args)
  ['error', 'error'], // (fmt?, ...args)

  ['trace', 'log'], // (fmt?, ...args)
  ['dirxml', 'log'], // (fmt?, ...args)
  ['group', 'log'], // (fmt?, ...args)
  ['groupCollapsed', 'log']  // (fmt?, ...args)
]);

/** @type {readonly [ConsoleProps, LogSeverity | undefined][]} */
const consoleOtherMethods=  freeze([
  ['assert', 'error'], // (value, fmt?, ...args)
  ['timeLog', 'log'], // (label?, ...args) no fmt string

  // Insensitive to whether any argument is an error. All arguments can pass
  // thru to baseConsole as is.
  ['clear', undefined], // ()
  ['count', 'info'], // (label?)
  ['countReset', undefined], // (label?)
  ['dir', 'log'], // (item, options?)
  ['groupEnd', 'log'], // ()
  // In theory tabular data may be or contain an error. However, we currently
  // do not detect these and may never.
  ['table', 'log'], // (tabularData, properties?)
  ['time', 'info'], // (label?)
  ['timeEnd', 'info'], // (label?)

  // Node Inspector only, MDN, and TypeScript, but not whatwg
  ['profile', undefined], // (label?)
  ['profileEnd', undefined], // (label?)
  ['timeStamp', undefined]  // (label?)
]);

/** @type {readonly [ConsoleProps, LogSeverity | undefined][]} */
const        consoleWhitelist=  freeze([
  ...consoleLevelMethods,
  ...consoleOtherMethods]);


/**
 * consoleOmittedProperties is currently unused. I record and maintain it here
 * with the intention that it be treated like the `false` entries in the main
 * SES whitelist: that seeing these on the original console is expected, but
 * seeing anything else that's outside the whitelist is surprising and should
 * provide a diagnostic.
 *
 * const consoleOmittedProperties = freeze([
 *   'memory', // Chrome
 *   'exception', // FF, MDN
 *   '_ignoreErrors', // Node
 *   '_stderr', // Node
 *   '_stderrErrorHandler', // Node
 *   '_stdout', // Node
 *   '_stdoutErrorHandler', // Node
 *   '_times', // Node
 *   'context', // Chrome, Node
 *   'record', // Safari
 *   'recordEnd', // Safari
 *
 *   'screenshot', // Safari
 *   // Symbols
 *   '@@toStringTag', // Chrome: "Object", Safari: "Console"
 *   // A variety of other symbols also seen on Node
 * ]);
 */

// /////////////////////////////////////////////////////////////////////////////

/** @type {MakeLoggingConsoleKit} */$h‍_once.consoleWhitelist(consoleWhitelist);
const makeLoggingConsoleKit=  (
  loggedErrorHandler,
  { shouldResetForDebugging=  false}=   {})=>
     {
  if( shouldResetForDebugging) {
    // eslint-disable-next-line @endo/no-polymorphic-call
    loggedErrorHandler.resetErrorTagNum();
   }

  // Not frozen!
  let logArray=  [];

  const loggingConsole=  fromEntries(
    arrayMap(consoleWhitelist, ([name, _])=>  {
      // Use an arrow function so that it doesn't come with its own name in
      // its printed form. Instead, we're hoping that tooling uses only
      // the `.name` property set below.
      /**
       * @param {...any} args
       */
      const method=  (...args)=>  {
        arrayPush(logArray, [name, ...args]);
       };
      defineProperty(method, 'name', { value: name});
      return [name, freeze(method)];
     }));

  freeze(loggingConsole);

  const takeLog=  ()=>  {
    const result=  freeze(logArray);
    logArray=  [];
    return result;
   };
  freeze(takeLog);

  const typedLoggingConsole=  /** @type {VirtualConsole} */  loggingConsole;

  return freeze({ loggingConsole: typedLoggingConsole, takeLog});
 };$h‍_once.makeLoggingConsoleKit(makeLoggingConsoleKit);
freeze(makeLoggingConsoleKit);


// /////////////////////////////////////////////////////////////////////////////

/** @type {ErrorInfo} */
const ErrorInfo=  {
  NOTE: 'ERROR_NOTE:',
  MESSAGE: 'ERROR_MESSAGE:'};

freeze(ErrorInfo);

/** @type {MakeCausalConsole} */
const makeCausalConsole=  (baseConsole, loggedErrorHandler)=>  {
  const { getStackString, tagError, takeMessageLogArgs, takeNoteLogArgsArray}=
    loggedErrorHandler;

  /**
   * @param {ReadonlyArray<any>} logArgs
   * @param {Array<any>} subErrorsSink
   * @returns {any}
   */
  const extractErrorArgs=  (logArgs, subErrorsSink)=>  {
    const argTags=  arrayMap(logArgs, (arg)=>{
      if( isError(arg)) {
        arrayPush(subErrorsSink, arg);
        return  `(${tagError(arg)})`;
       }
      return arg;
     });
    return argTags;
   };

  /**
   * @param {LogSeverity} severity
   * @param {Error} error
   * @param {ErrorInfoKind} kind
   * @param {readonly any[]} logArgs
   * @param {Array<Error>} subErrorsSink
   */
  const logErrorInfo=  (severity, error, kind, logArgs, subErrorsSink)=>  {
    const errorTag=  tagError(error);
    const errorName=
      kind===  ErrorInfo.MESSAGE?   `${errorTag}:`:  `${errorTag} ${kind}`;
    const argTags=  extractErrorArgs(logArgs, subErrorsSink);
    // eslint-disable-next-line @endo/no-polymorphic-call
    baseConsole[severity](errorName, ...argTags);
   };

  /**
   * Logs the `subErrors` within a group name mentioning `optTag`.
   *
   * @param {LogSeverity} severity
   * @param {Error[]} subErrors
   * @param {string | undefined} optTag
   * @returns {void}
   */
  const logSubErrors=  (severity, subErrors, optTag=  undefined)=>  {
    if( subErrors.length===  0) {
      return;
     }
    if( subErrors.length===  1&&  optTag===  undefined) {
      // eslint-disable-next-line no-use-before-define
      logError(severity, subErrors[0]);
      return;
     }
    let label;
    if( subErrors.length===  1) {
      label=   `Nested error`;
     }else {
      label=   `Nested ${subErrors.length} errors`;
     }
    if( optTag!==  undefined) {
      label=   `${label} under ${optTag}`;
     }
    // eslint-disable-next-line @endo/no-polymorphic-call
    baseConsole.group(label);
    try {
      for( const subError of subErrors) {
        // eslint-disable-next-line no-use-before-define
        logError(severity, subError);
       }
     }finally {
      // eslint-disable-next-line @endo/no-polymorphic-call
      baseConsole.groupEnd();
     }
   };

  const errorsLogged=  new WeakSet();

  /** @type {(severity: LogSeverity) => NoteCallback} */
  const makeNoteCallback=  (severity)=>(error, noteLogArgs)=>  {
    const subErrors=  [];
    // Annotation arrived after the error has already been logged,
    // so just log the annotation immediately, rather than remembering it.
    logErrorInfo(severity, error, ErrorInfo.NOTE, noteLogArgs, subErrors);
    logSubErrors(severity, subErrors, tagError(error));
   };

  /**
   * @param {LogSeverity} severity
   * @param {Error} error
   */
  const logError=  (severity, error)=>  {
    if( weaksetHas(errorsLogged, error)) {
      return;
     }
    const errorTag=  tagError(error);
    weaksetAdd(errorsLogged, error);
    const subErrors=  [];
    const messageLogArgs=  takeMessageLogArgs(error);
    const noteLogArgsArray=  takeNoteLogArgsArray(
      error,
      makeNoteCallback(severity));

    // Show the error's most informative error message
    if( messageLogArgs===  undefined) {
      // If there is no message log args, then just show the message that
      // the error itself carries.
      // eslint-disable-next-line @endo/no-polymorphic-call
      baseConsole[severity]( `${errorTag}:`,error.message);
     }else {
      // If there is one, we take it to be strictly more informative than the
      // message string carried by the error, so show it *instead*.
      logErrorInfo(
        severity,
        error,
        ErrorInfo.MESSAGE,
        messageLogArgs,
        subErrors);

     }
    // After the message but before any other annotations, show the stack.
    let stackString=  getStackString(error);
    if(
      typeof stackString===  'string'&&
      stackString.length>=  1&&
      !stringEndsWith(stackString, '\n'))
      {
      stackString+=  '\n';
     }
    // eslint-disable-next-line @endo/no-polymorphic-call
    baseConsole[severity](stackString);
    // Show the other annotations on error
    for( const noteLogArgs of noteLogArgsArray) {
      logErrorInfo(severity, error, ErrorInfo.NOTE, noteLogArgs, subErrors);
     }
    // explain all the errors seen in the messages already emitted.
    logSubErrors(severity, subErrors, errorTag);
   };

  const levelMethods=  arrayMap(consoleLevelMethods, ([level, _])=>  {
    /**
     * @param {...any} logArgs
     */
    const levelMethod=  (...logArgs)=>  {
      const subErrors=  [];
      const argTags=  extractErrorArgs(logArgs, subErrors);
      // eslint-disable-next-line @endo/no-polymorphic-call
      baseConsole[level](...argTags);
      // @ts-expect-error ConsoleProp vs LogSeverity mismatch
      logSubErrors(level, subErrors);
     };
    defineProperty(levelMethod, 'name', { value: level});
    return [level, freeze(levelMethod)];
   });
  const otherMethodNames=  arrayFilter(
    consoleOtherMethods,
    ([name, _])=>  name in baseConsole);

  const otherMethods=  arrayMap(otherMethodNames, ([name, _])=>  {
    /**
     * @param {...any} args
     */
    const otherMethod=  (...args)=>  {
      // @ts-ignore
      // eslint-disable-next-line @endo/no-polymorphic-call
      baseConsole[name](...args);
      return undefined;
     };
    defineProperty(otherMethod, 'name', { value: name});
    return [name, freeze(otherMethod)];
   });

  const causalConsole=  fromEntries([...levelMethods, ...otherMethods]);
  return (/** @type {VirtualConsole} */ freeze(causalConsole));
 };$h‍_once.makeCausalConsole(makeCausalConsole);
freeze(makeCausalConsole);


// /////////////////////////////////////////////////////////////////////////////

/** @type {FilterConsole} */
const filterConsole=  (baseConsole, filter, _topic=  undefined)=>  {
  // TODO do something with optional topic string
  const whitelist=  arrayFilter(
    consoleWhitelist,
    ([name, _])=>  name in baseConsole);

  const methods=  arrayMap(whitelist, ([name, severity])=>  {
    /**
     * @param {...any} args
     */
    const method=  (...args)=>  {
      // eslint-disable-next-line @endo/no-polymorphic-call
      if( severity===  undefined||  filter.canLog(severity)) {
        // @ts-ignore
        // eslint-disable-next-line @endo/no-polymorphic-call
        baseConsole[name](...args);
       }
     };
    return [name, freeze(method)];
   });
  const filteringConsole=  fromEntries(methods);
  return (/** @type {VirtualConsole} */ freeze(filteringConsole));
 };$h‍_once.filterConsole(filterConsole);
freeze(filterConsole);
})()
,
// === functors[35] ===
({   imports: $h‍_imports,   liveVar: $h‍_live,   onceVar: $h‍_once,   importMeta: $h‍____meta, }) => (function () {   let FinalizationRegistry,Map,mapGet,mapDelete,WeakMap,mapSet,finalizationRegistryRegister,weakmapSet,weakmapGet,mapEntries,mapHas;$h‍_imports([["../commons.js", [["FinalizationRegistry", [$h‍_a => (FinalizationRegistry = $h‍_a)]],["Map", [$h‍_a => (Map = $h‍_a)]],["mapGet", [$h‍_a => (mapGet = $h‍_a)]],["mapDelete", [$h‍_a => (mapDelete = $h‍_a)]],["WeakMap", [$h‍_a => (WeakMap = $h‍_a)]],["mapSet", [$h‍_a => (mapSet = $h‍_a)]],["finalizationRegistryRegister", [$h‍_a => (finalizationRegistryRegister = $h‍_a)]],["weakmapSet", [$h‍_a => (weakmapSet = $h‍_a)]],["weakmapGet", [$h‍_a => (weakmapGet = $h‍_a)]],["mapEntries", [$h‍_a => (mapEntries = $h‍_a)]],["mapHas", [$h‍_a => (mapHas = $h‍_a)]]]]]);   














/**
 * Create rejection-tracking machinery compatible with Node.js and browsers.
 *
 * Note that modern browsers *prevent* access to the 'unhandledrejection' and
 * 'rejectionhandled' events needed:
 * - in cross-origin mode, like when served from file://
 * - in the browser console (interactively typed-in code)
 * - in the debugger
 *
 * Then, they just look like: `Uncaught (in promise) Error: ...` and don't
 * implement the machinery.
 *
 * The solution is to serve your web page from an http:// or https:// web server
 * and execute actual code.
 *
 * @param {(reason: unknown) => void} reportReason report the reason for an
 * unhandled rejection.
 */
const        makeRejectionHandlers=  (reportReason)=>{
  if( FinalizationRegistry===  undefined) {
    return undefined;
   }

  /** @typedef {number} ReasonId */
  let lastReasonId=  0;

  /** @type {Map<ReasonId, unknown>} */
  const idToReason=  new Map();

  /** @type {(() => void) | undefined} */
  let cancelChecking;

  const removeReasonId=  (reasonId)=>{
    mapDelete(idToReason, reasonId);
    if( cancelChecking&&  idToReason.size===  0) {
      // No more unhandled rejections to check, just cancel the check.
      cancelChecking();
      cancelChecking=  undefined;
     }
   };

  /** @type {WeakMap<Promise, ReasonId>} */
  const promiseToReasonId=  new WeakMap();

  /**
   * Clean up and report the reason for a GCed unhandled rejection.
   *
   * @param {ReasonId} heldReasonId
   */
  const finalizeDroppedPromise=  (heldReasonId)=>{
    if( mapHas(idToReason, heldReasonId)) {
      const reason=  mapGet(idToReason, heldReasonId);
      removeReasonId(heldReasonId);
      reportReason(reason);
     }
   };

  /** @type {FinalizationRegistry<ReasonId>} */
  const promiseToReason=  new FinalizationRegistry(finalizeDroppedPromise);

  /**
   * Track a rejected promise and its corresponding reason if there is no
   * rejection handler synchronously attached.
   *
   * @param {unknown} reason
   * @param {Promise} pr
   */
  const unhandledRejectionHandler=  (reason, pr)=>  {
    lastReasonId+=  1;
    const reasonId=  lastReasonId;

    // Update bookkeeping.
    mapSet(idToReason, reasonId, reason);
    weakmapSet(promiseToReasonId, pr, reasonId);
    finalizationRegistryRegister(promiseToReason, pr, reasonId, pr);
   };

  /**
   * Deal with the addition of a handler to a previously rejected promise.
   *
   * Just remove it from our list.  Let the FinalizationRegistry or
   * processTermination report any GCed unhandled rejected promises.
   *
   * @param {Promise} pr
   */
  const rejectionHandledHandler=  (pr)=>{
    const reasonId=  weakmapGet(promiseToReasonId, pr);
    removeReasonId(reasonId);
   };

  /**
   * Report all the unhandled rejections, now that we are abruptly terminating
   * the agent cluster.
   */
  const processTerminationHandler=  ()=>  {
    for( const [reasonId, reason]of  mapEntries(idToReason)) {
      removeReasonId(reasonId);
      reportReason(reason);
     }
   };

  return {
    rejectionHandledHandler,
    unhandledRejectionHandler,
    processTerminationHandler};

 };$h‍_once.makeRejectionHandlers(makeRejectionHandlers);
})()
,
// === functors[36] ===
({   imports: $h‍_imports,   liveVar: $h‍_live,   onceVar: $h‍_once,   importMeta: $h‍____meta, }) => (function () {   let TypeError,globalThis,defaultHandler,makeCausalConsole,makeRejectionHandlers;$h‍_imports([["../commons.js", [["TypeError", [$h‍_a => (TypeError = $h‍_a)]],["globalThis", [$h‍_a => (globalThis = $h‍_a)]]]],["./assert.js", [["loggedErrorHandler", [$h‍_a => (defaultHandler = $h‍_a)]]]],["./console.js", [["makeCausalConsole", [$h‍_a => (makeCausalConsole = $h‍_a)]]]],["./unhandled-rejection.js", [["makeRejectionHandlers", [$h‍_a => (makeRejectionHandlers = $h‍_a)]]]],["./types.js", []],["./internal-types.js", []]]);   








// eslint-disable-next-line no-restricted-globals
const originalConsole=  console;

/**
 * Wrap console unless suppressed.
 * At the moment, the console is considered a host power in the start
 * compartment, and not a primordial. Hence it is absent from the whilelist
 * and bypasses the intrinsicsCollector.
 *
 * @param {"safe" | "unsafe"} consoleTaming
 * @param {"platform" | "exit" | "abort" | "report" | "none"} [errorTrapping]
 * @param {"report" | "none"} [unhandledRejectionTrapping]
 * @param {GetStackString=} optGetStackString
 */
const        tameConsole=  (
  consoleTaming=  'safe',
  errorTrapping=  'platform',
  unhandledRejectionTrapping=  'report',
  optGetStackString=  undefined)=>
     {
  if( consoleTaming!==  'safe'&&  consoleTaming!==  'unsafe') {
    throw TypeError( `unrecognized consoleTaming ${consoleTaming}`);
   }

  let loggedErrorHandler;
  if( optGetStackString===  undefined) {
    loggedErrorHandler=  defaultHandler;
   }else {
    loggedErrorHandler=  {
      ...defaultHandler,
      getStackString: optGetStackString};

   }
  const ourConsole=
    consoleTaming===  'unsafe'?
        originalConsole:
        makeCausalConsole(originalConsole, loggedErrorHandler);

  // Attach platform-specific error traps such that any error that gets thrown
  // at top-of-turn (the bottom of stack) will get logged by our causal
  // console, revealing the diagnostic information associated with the error,
  // including the stack from when the error was created.

  // In the following Node.js and web browser cases, `process` and `window` are
  // spelled as `globalThis` properties to avoid the overweaning gaze of
  // Parcel, which dutifully installs an unnecessary `process` shim if we ever
  // utter that. That unnecessary shim forces the whole bundle into sloppy mode,
  // which in turn breaks SES's strict mode invariant.

  // Disable the polymorphic check for the rest of this file.  It's too noisy
  // when dealing with platform APIs.
  /* eslint-disable @endo/no-polymorphic-call */

  // Node.js
  if( errorTrapping!==  'none'&&  globalThis.process!==  undefined) {
    globalThis.process.on('uncaughtException', (error)=>{
      // causalConsole is born frozen so not vulnerable to method tampering.
      ourConsole.error(error);
      if( errorTrapping===  'platform'||  errorTrapping===  'exit') {
        globalThis.process.exit(globalThis.process.exitCode||  -1);
       }else if( errorTrapping===  'abort') {
        globalThis.process.abort();
       }
     });
   }

  if(
    unhandledRejectionTrapping!==  'none'&&
    globalThis.process!==  undefined)
    {
    const handleRejection=  (reason)=>{
      // 'platform' and 'report' just log the reason.
      ourConsole.error('SES_UNHANDLED_REJECTION:', reason);
     };
    // Maybe track unhandled promise rejections.
    const h=  makeRejectionHandlers(handleRejection);
    if( h) {
      // Rejection handlers are supported.
      globalThis.process.on('unhandledRejection', h.unhandledRejectionHandler);
      globalThis.process.on('rejectionHandled', h.rejectionHandledHandler);
      globalThis.process.on('exit', h.processTerminationHandler);
     }
   }

  // Browser
  if(
    errorTrapping!==  'none'&&
    globalThis.window!==  undefined&&
    globalThis.window.addEventListener!==  undefined)
    {
    globalThis.window.addEventListener('error', (event)=>{
      event.preventDefault();
      // 'platform' and 'report' just log the reason.
      ourConsole.error(event.error);
      if( errorTrapping===  'exit'||  errorTrapping===  'abort') {
        globalThis.window.location.href=   `about:blank`;
       }
     });
   }

  if(
    unhandledRejectionTrapping!==  'none'&&
    globalThis.window!==  undefined&&
    globalThis.window.addEventListener!==  undefined)
    {
    const handleRejection=  (reason)=>{
      ourConsole.error('SES_UNHANDLED_REJECTION:', reason);
     };

    const h=  makeRejectionHandlers(handleRejection);
    if( h) {
      // Rejection handlers are supported.
      globalThis.window.addEventListener('unhandledrejection', (event)=>{
        event.preventDefault();
        h.unhandledRejectionHandler(event.reason, event.promise);
       });

      globalThis.window.addEventListener('rejectionhandled', (event)=>{
        event.preventDefault();
        h.rejectionHandledHandler(event.promise);
       });

      globalThis.window.addEventListener('beforeunload', (_event)=>{
        h.processTerminationHandler();
       });
     }
   }
  /* eslint-enable @endo/no-polymorphic-call */

  return { console: ourConsole};
 };$h‍_once.tameConsole(tameConsole);
})()
,
// === functors[37] ===
({   imports: $h‍_imports,   liveVar: $h‍_live,   onceVar: $h‍_once,   importMeta: $h‍____meta, }) => (function () {   let WeakMap,WeakSet,apply,arrayFilter,arrayJoin,arrayMap,arraySlice,create,defineProperties,fromEntries,reflectSet,regexpExec,regexpTest,weakmapGet,weakmapSet,weaksetAdd,weaksetHas;$h‍_imports([["../commons.js", [["WeakMap", [$h‍_a => (WeakMap = $h‍_a)]],["WeakSet", [$h‍_a => (WeakSet = $h‍_a)]],["apply", [$h‍_a => (apply = $h‍_a)]],["arrayFilter", [$h‍_a => (arrayFilter = $h‍_a)]],["arrayJoin", [$h‍_a => (arrayJoin = $h‍_a)]],["arrayMap", [$h‍_a => (arrayMap = $h‍_a)]],["arraySlice", [$h‍_a => (arraySlice = $h‍_a)]],["create", [$h‍_a => (create = $h‍_a)]],["defineProperties", [$h‍_a => (defineProperties = $h‍_a)]],["fromEntries", [$h‍_a => (fromEntries = $h‍_a)]],["reflectSet", [$h‍_a => (reflectSet = $h‍_a)]],["regexpExec", [$h‍_a => (regexpExec = $h‍_a)]],["regexpTest", [$h‍_a => (regexpTest = $h‍_a)]],["weakmapGet", [$h‍_a => (weakmapGet = $h‍_a)]],["weakmapSet", [$h‍_a => (weakmapSet = $h‍_a)]],["weaksetAdd", [$h‍_a => (weaksetAdd = $h‍_a)]],["weaksetHas", [$h‍_a => (weaksetHas = $h‍_a)]]]]]);   



















// Whitelist names from https://v8.dev/docs/stack-trace-api
// Whitelisting only the names used by error-stack-shim/src/v8StackFrames
// callSiteToFrame to shim the error stack proposal.
const safeV8CallSiteMethodNames=  [
  // suppress 'getThis' definitely
  'getTypeName',
  // suppress 'getFunction' definitely
  'getFunctionName',
  'getMethodName',
  'getFileName',
  'getLineNumber',
  'getColumnNumber',
  'getEvalOrigin',
  'isToplevel',
  'isEval',
  'isNative',
  'isConstructor',
  'isAsync',
  // suppress 'isPromiseAll' for now
  // suppress 'getPromiseIndex' for now

  // Additional names found by experiment, absent from
  // https://v8.dev/docs/stack-trace-api
  'getPosition',
  'getScriptNameOrSourceURL',

  'toString'  // TODO replace to use only whitelisted info
];

// TODO this is a ridiculously expensive way to attenuate callsites.
// Before that matters, we should switch to a reasonable representation.
const safeV8CallSiteFacet=  (callSite)=>{
  const methodEntry=  (name)=>{
    const method=  callSite[name];
    return [name, ()=>  apply(method, callSite, [])];
   };
  const o=  fromEntries(arrayMap(safeV8CallSiteMethodNames, methodEntry));
  return create(o, {});
 };

const safeV8SST=  (sst)=>arrayMap(sst, safeV8CallSiteFacet);

// If it has `/node_modules/` anywhere in it, on Node it is likely
// to be a dependent package of the current package, and so to
// be an infrastructure frame to be dropped from concise stack traces.
const FILENAME_NODE_DEPENDENTS_CENSOR=  /\/node_modules\//;

// If it begins with `internal/` or `node:internal` then it is likely
// part of the node infrustructre itself, to be dropped from concise
// stack traces.
const FILENAME_NODE_INTERNALS_CENSOR=  /^(?:node:)?internal\//;

// Frames within the `assert.js` package should be dropped from
// concise stack traces, as these are just steps towards creating the
// error object in question.
const FILENAME_ASSERT_CENSOR=  /\/packages\/ses\/src\/error\/assert.js$/;

// Frames within the `eventual-send` shim should be dropped so that concise
// deep stacks omit the internals of the eventual-sending mechanism causing
// asynchronous messages to be sent.
// Note that the eventual-send package will move from agoric-sdk to
// Endo, so this rule will be of general interest.
const FILENAME_EVENTUAL_SEND_CENSOR=  /\/packages\/eventual-send\/src\//;

// Any stack frame whose `fileName` matches any of these censor patterns
// will be omitted from concise stacks.
// TODO Enable users to configure FILENAME_CENSORS via `lockdown` options.
const FILENAME_CENSORS=  [
  FILENAME_NODE_DEPENDENTS_CENSOR,
  FILENAME_NODE_INTERNALS_CENSOR,
  FILENAME_ASSERT_CENSOR,
  FILENAME_EVENTUAL_SEND_CENSOR];


// Should a stack frame with this as its fileName be included in a concise
// stack trace?
// Exported only so it can be unit tested.
// TODO Move so that it applies not just to v8.
const        filterFileName=  (fileName)=>{
  if( !fileName) {
    // Stack frames with no fileName should appear in concise stack traces.
    return true;
   }
  for( const filter of FILENAME_CENSORS) {
    if( regexpTest(filter, fileName)) {
      return false;
     }
   }
  return true;
 };

// The ad-hoc rule of the current pattern is that any likely-file-path or
// likely url-path prefix, ending in a `/.../` should get dropped.
// Anything to the left of the likely path text is kept.
// Everything to the right of `/.../` is kept. Thus
// `'Object.bar (/vat-v1/.../eventual-send/test/test-deep-send.js:13:21)'`
// simplifies to
// `'Object.bar (eventual-send/test/test-deep-send.js:13:21)'`.
//
// See thread starting at
// https://github.com/Agoric/agoric-sdk/issues/2326#issuecomment-773020389
$h‍_once.filterFileName(filterFileName);const CALLSITE_ELLIPSES_PATTERN=/^((?:.*[( ])?)[:/\w_-]*\/\.\.\.\/(.+)$/;

// The ad-hoc rule of the current pattern is that any likely-file-path or
// likely url-path prefix, ending in a `/` and prior to `package/` should get
// dropped.
// Anything to the left of the likely path prefix text is kept. `package/` and
// everything to its right is kept. Thus
// `'Object.bar (/Users/markmiller/src/ongithub/agoric/agoric-sdk/packages/eventual-send/test/test-deep-send.js:13:21)'`
// simplifies to
// `'Object.bar (packages/eventual-send/test/test-deep-send.js:13:21)'`.
// Note that `/packages/` is a convention for monorepos encouraged by
// lerna.
const CALLSITE_PACKAGES_PATTERN=  /^((?:.*[( ])?)[:/\w_-]*\/(packages\/.+)$/;

// The use of these callSite patterns below assumes that any match will bind
// capture groups containing the parts of the original string we want
// to keep. The parts outside those capture groups will be dropped from concise
// stacks.
// TODO Enable users to configure CALLSITE_PATTERNS via `lockdown` options.
const CALLSITE_PATTERNS=  [
  CALLSITE_ELLIPSES_PATTERN,
  CALLSITE_PACKAGES_PATTERN];


// For a stack frame that should be included in a concise stack trace, if
// `callSiteString` is the original stringified stack frame, return the
// possibly-shorter stringified stack frame that should be shown instead.
// Exported only so it can be unit tested.
// TODO Move so that it applies not just to v8.
const        shortenCallSiteString=  (callSiteString)=>{
  for( const filter of CALLSITE_PATTERNS) {
    const match=  regexpExec(filter, callSiteString);
    if( match) {
      return arrayJoin(arraySlice(match, 1), '');
     }
   }
  return callSiteString;
 };$h‍_once.shortenCallSiteString(shortenCallSiteString);

const        tameV8ErrorConstructor=  (
  OriginalError,
  InitialError,
  errorTaming,
  stackFiltering)=>
     {
  // TODO: Proper CallSite types
  /** @typedef {{}} CallSite */

  const originalCaptureStackTrace=  OriginalError.captureStackTrace;

  // const callSiteFilter = _callSite => true;
  const callSiteFilter=  (callSite)=>{
    if( stackFiltering===  'verbose') {
      return true;
     }
    // eslint-disable-next-line @endo/no-polymorphic-call
    return filterFileName(callSite.getFileName());
   };

  const callSiteStringifier=  (callSite)=>{
    let callSiteString=   `${callSite}`;
    if( stackFiltering===  'concise') {
      callSiteString=  shortenCallSiteString(callSiteString);
     }
    return  `\n  at ${callSiteString}`;
   };

  const stackStringFromSST=  (_error, sst)=>
    arrayJoin(
      arrayMap(arrayFilter(sst, callSiteFilter), callSiteStringifier),
      '');


  /**
   * @typedef {object} StructuredStackInfo
   * @property {CallSite[]} callSites
   * @property {undefined} [stackString]
   */

  /**
   * @typedef {object} ParsedStackInfo
   * @property {undefined} [callSites]
   * @property {string} stackString
   */

  // Mapping from error instance to the stack for that instance.
  // The stack info is either the structured stack trace
  // or the generated tamed stack string
  /** @type {WeakMap<Error, ParsedStackInfo | StructuredStackInfo>} */
  const stackInfos=  new WeakMap();

  // Use concise methods to obtain named functions without constructors.
  const tamedMethods=  {
    // The optional `optFn` argument is for cutting off the bottom of
    // the stack --- for capturing the stack only above the topmost
    // call to that function. Since this isn't the "real" captureStackTrace
    // but instead calls the real one, if no other cutoff is provided,
    // we cut this one off.
    captureStackTrace(error, optFn=  tamedMethods.captureStackTrace) {
      if( typeof originalCaptureStackTrace===  'function') {
        // OriginalError.captureStackTrace is only on v8
        apply(originalCaptureStackTrace, OriginalError, [error, optFn]);
        return;
       }
      reflectSet(error, 'stack', '');
     },
    // Shim of proposed special power, to reside by default only
    // in the start compartment, for getting the stack traceback
    // string associated with an error.
    // See https://tc39.es/proposal-error-stacks/
    getStackString(error) {
      let stackInfo=  weakmapGet(stackInfos, error);

      if( stackInfo===  undefined) {
        // The following will call `prepareStackTrace()` synchronously
        // which will populate stackInfos
        // eslint-disable-next-line no-void
        void error.stack;
        stackInfo=  weakmapGet(stackInfos, error);
        if( !stackInfo) {
          stackInfo=  { stackString: ''};
          weakmapSet(stackInfos, error, stackInfo);
         }
       }

      // prepareStackTrace() may generate the stackString
      // if errorTaming === 'unsafe'

      if( stackInfo.stackString!==  undefined) {
        return stackInfo.stackString;
       }

      const stackString=  stackStringFromSST(error, stackInfo.callSites);
      weakmapSet(stackInfos, error, { stackString});

      return stackString;
     },
    prepareStackTrace(error, sst) {
      if( errorTaming===  'unsafe') {
        const stackString=  stackStringFromSST(error, sst);
        weakmapSet(stackInfos, error, { stackString});
        return  `${error}${stackString}`;
       }else {
        weakmapSet(stackInfos, error, { callSites: sst});
        return '';
       }
     }};


  // A prepareFn is a prepareStackTrace function.
  // An sst is a `structuredStackTrace`, which is an array of
  // callsites.
  // A user prepareFn is a prepareFn defined by a client of this API,
  // and provided by assigning to `Error.prepareStackTrace`.
  // A user prepareFn should only receive an attenuated sst, which
  // is an array of attenuated callsites.
  // A system prepareFn is the prepareFn created by this module to
  // be installed on the real `Error` constructor, to receive
  // an original sst, i.e., an array of unattenuated callsites.
  // An input prepareFn is a function the user assigns to
  // `Error.prepareStackTrace`, which might be a user prepareFn or
  // a system prepareFn previously obtained by reading
  // `Error.prepareStackTrace`.

  const defaultPrepareFn=  tamedMethods.prepareStackTrace;

  OriginalError.prepareStackTrace=  defaultPrepareFn;

  // A weakset branding some functions as system prepareFns, all of which
  // must be defined by this module, since they can receive an
  // unattenuated sst.
  const systemPrepareFnSet=  new WeakSet([defaultPrepareFn]);

  const systemPrepareFnFor=  (inputPrepareFn)=>{
    if( weaksetHas(systemPrepareFnSet, inputPrepareFn)) {
      return inputPrepareFn;
     }
    // Use concise methods to obtain named functions without constructors.
    const systemMethods=  {
      prepareStackTrace(error, sst) {
        weakmapSet(stackInfos, error, { callSites: sst});
        return inputPrepareFn(error, safeV8SST(sst));
       }};

    weaksetAdd(systemPrepareFnSet, systemMethods.prepareStackTrace);
    return systemMethods.prepareStackTrace;
   };

  // Note `stackTraceLimit` accessor already defined by
  // tame-error-constructor.js
  defineProperties(InitialError, {
    captureStackTrace: {
      value: tamedMethods.captureStackTrace,
      writable: true,
      enumerable: false,
      configurable: true},

    prepareStackTrace: {
      get() {
        return OriginalError.prepareStackTrace;
       },
      set(inputPrepareStackTraceFn) {
        if( typeof inputPrepareStackTraceFn===  'function') {
          const systemPrepareFn=  systemPrepareFnFor(inputPrepareStackTraceFn);
          OriginalError.prepareStackTrace=  systemPrepareFn;
         }else {
          OriginalError.prepareStackTrace=  defaultPrepareFn;
         }
       },
      enumerable: false,
      configurable: true}});



  return tamedMethods.getStackString;
 };$h‍_once.tameV8ErrorConstructor(tameV8ErrorConstructor);
})()
,
// === functors[38] ===
({   imports: $h‍_imports,   liveVar: $h‍_live,   onceVar: $h‍_once,   importMeta: $h‍____meta, }) => (function () {   let FERAL_ERROR,TypeError,apply,construct,defineProperties,setPrototypeOf,getOwnPropertyDescriptor,defineProperty,NativeErrors,tameV8ErrorConstructor;$h‍_imports([["../commons.js", [["FERAL_ERROR", [$h‍_a => (FERAL_ERROR = $h‍_a)]],["TypeError", [$h‍_a => (TypeError = $h‍_a)]],["apply", [$h‍_a => (apply = $h‍_a)]],["construct", [$h‍_a => (construct = $h‍_a)]],["defineProperties", [$h‍_a => (defineProperties = $h‍_a)]],["setPrototypeOf", [$h‍_a => (setPrototypeOf = $h‍_a)]],["getOwnPropertyDescriptor", [$h‍_a => (getOwnPropertyDescriptor = $h‍_a)]],["defineProperty", [$h‍_a => (defineProperty = $h‍_a)]]]],["../permits.js", [["NativeErrors", [$h‍_a => (NativeErrors = $h‍_a)]]]],["./tame-v8-error-constructor.js", [["tameV8ErrorConstructor", [$h‍_a => (tameV8ErrorConstructor = $h‍_a)]]]]]);   












// Present on at least FF and XS. Proposed by Error-proposal. The original
// is dangerous, so tameErrorConstructor replaces it with a safe one.
// We grab the original here before it gets replaced.
const stackDesc=  getOwnPropertyDescriptor(FERAL_ERROR.prototype, 'stack');
const stackGetter=  stackDesc&&  stackDesc.get;

// Use concise methods to obtain named functions without constructors.
const tamedMethods=  {
  getStackString(error) {
    if( typeof stackGetter===  'function') {
      return apply(stackGetter, error, []);
     }else if( 'stack'in  error) {
      // The fallback is to just use the de facto `error.stack` if present
      return  `${error.stack}`;
     }
    return '';
   }};


function                tameErrorConstructor(
  errorTaming=  'safe',
  stackFiltering=  'concise')
  {
  if( errorTaming!==  'safe'&&  errorTaming!==  'unsafe') {
    throw TypeError( `unrecognized errorTaming ${errorTaming}`);
   }
  if( stackFiltering!==  'concise'&&  stackFiltering!==  'verbose') {
    throw TypeError( `unrecognized stackFiltering ${stackFiltering}`);
   }
  const ErrorPrototype=  FERAL_ERROR.prototype;

  const platform=
    typeof FERAL_ERROR.captureStackTrace===  'function'?  'v8':  'unknown';
  const { captureStackTrace: originalCaptureStackTrace}=   FERAL_ERROR;

  const makeErrorConstructor=  (_=  {})=>  {
    // eslint-disable-next-line no-shadow
    const ResultError=  function Error(...rest) {
      let error;
      if( new.target===  undefined) {
        error=  apply(FERAL_ERROR, this, rest);
       }else {
        error=  construct(FERAL_ERROR, rest, new.target);
       }
      if( platform===  'v8') {
        // TODO Likely expensive!
        apply(originalCaptureStackTrace, FERAL_ERROR, [error, ResultError]);
       }
      return error;
     };
    defineProperties(ResultError, {
      length: { value: 1},
      prototype: {
        value: ErrorPrototype,
        writable: false,
        enumerable: false,
        configurable: false}});


    return ResultError;
   };
  const InitialError=  makeErrorConstructor({ powers: 'original'});
  const SharedError=  makeErrorConstructor({ powers: 'none'});
  defineProperties(ErrorPrototype, {
    constructor: { value: SharedError}});


  for( const NativeError of NativeErrors) {
    setPrototypeOf(NativeError, SharedError);
   }

  // https://v8.dev/docs/stack-trace-api#compatibility advises that
  // programmers can "always" set `Error.stackTraceLimit`
  // even on non-v8 platforms. On non-v8
  // it will have no effect, but this advice only makes sense
  // if the assignment itself does not fail, which it would
  // if `Error` were naively frozen. Hence, we add setters that
  // accept but ignore the assignment on non-v8 platforms.
  defineProperties(InitialError, {
    stackTraceLimit: {
      get() {
        if( typeof FERAL_ERROR.stackTraceLimit===  'number') {
          // FERAL_ERROR.stackTraceLimit is only on v8
          return FERAL_ERROR.stackTraceLimit;
         }
        return undefined;
       },
      set(newLimit) {
        if( typeof newLimit!==  'number') {
          // silently do nothing. This behavior doesn't precisely
          // emulate v8 edge-case behavior. But given the purpose
          // of this emulation, having edge cases err towards
          // harmless seems the safer option.
          return;
         }
        if( typeof FERAL_ERROR.stackTraceLimit===  'number') {
          // FERAL_ERROR.stackTraceLimit is only on v8
          FERAL_ERROR.stackTraceLimit=  newLimit;
          // We place the useless return on the next line to ensure
          // that anything we place after the if in the future only
          // happens if the then-case does not.
          // eslint-disable-next-line no-useless-return
          return;
         }
       },
      // WTF on v8 stackTraceLimit is enumerable
      enumerable: false,
      configurable: true}});



  // The default SharedError much be completely powerless even on v8,
  // so the lenient `stackTraceLimit` accessor does nothing on all
  // platforms.
  defineProperties(SharedError, {
    stackTraceLimit: {
      get() {
        return undefined;
       },
      set(_newLimit) {
        // do nothing
       },
      enumerable: false,
      configurable: true}});



  if( platform===  'v8') {
    // `SharedError.prepareStackTrace`, if it exists, must also be
    // powerless. However, from what we've heard, depd expects to be able to
    // assign to it without the assignment throwing. It is normally a function
    // that returns a stack string to be magically added to error objects.
    // However, as long as we're adding a lenient standin, we may as well
    // accommodate any who expect to get a function they can call and get
    // a string back. This prepareStackTrace is a do-nothing function that
    // always returns the empty string.
    defineProperties(SharedError, {
      prepareStackTrace: {
        get() {
          return ()=>  '';
         },
        set(_prepareFn) {
          // do nothing
         },
        enumerable: false,
        configurable: true},

      captureStackTrace: {
        value: (errorish, _constructorOpt)=>  {
          defineProperty(errorish, 'stack', {
            value: ''});

         },
        writable: false,
        enumerable: false,
        configurable: true}});


   }

  let initialGetStackString=  tamedMethods.getStackString;
  if( platform===  'v8') {
    initialGetStackString=  tameV8ErrorConstructor(
      FERAL_ERROR,
      InitialError,
      errorTaming,
      stackFiltering);

   }else if( errorTaming===  'unsafe') {
    // v8 has too much magic around their 'stack' own property for it to
    // coexist cleanly with this accessor. So only install it on non-v8

    // Error.prototype.stack property as proposed at
    // https://tc39.es/proposal-error-stacks/
    // with the fix proposed at
    // https://github.com/tc39/proposal-error-stacks/issues/46
    // On others, this still protects from the override mistake,
    // essentially like enable-property-overrides.js would
    // once this accessor property itself is frozen, as will happen
    // later during lockdown.
    //
    // However, there is here a change from the intent in the current
    // state of the proposal. If experience tells us whether this change
    // is a good idea, we should modify the proposal accordingly. There is
    // much code in the world that assumes `error.stack` is a string. So
    // where the proposal accommodates secure operation by making the
    // property optional, we instead accommodate secure operation by
    // having the secure form always return only the stable part, the
    // stringified error instance, and omitting all the frame information
    // rather than omitting the property.
    defineProperties(ErrorPrototype, {
      stack: {
        get() {
          return initialGetStackString(this);
         },
        set(newValue) {
          defineProperties(this, {
            stack: {
              value: newValue,
              writable: true,
              enumerable: true,
              configurable: true}});


         }}});


   }else {
    // v8 has too much magic around their 'stack' own property for it to
    // coexist cleanly with this accessor. So only install it on non-v8
    defineProperties(ErrorPrototype, {
      stack: {
        get() {
          // https://github.com/tc39/proposal-error-stacks/issues/46
          // allows this to not add an unpleasant newline. Otherwise
          // we should fix this.
          return  `${this}`;
         },
        set(newValue) {
          defineProperties(this, {
            stack: {
              value: newValue,
              writable: true,
              enumerable: true,
              configurable: true}});


         }}});


   }

  return {
    '%InitialGetStackString%': initialGetStackString,
    '%InitialError%': InitialError,
    '%SharedError%': SharedError};

 }$h‍_once.default(     tameErrorConstructor);
})()
,
// === functors[39] ===
({   imports: $h‍_imports,   liveVar: $h‍_live,   onceVar: $h‍_once,   importMeta: $h‍____meta, }) => (function () {   let ReferenceError,TypeError,Map,Set,arrayJoin,arrayMap,arrayPush,create,freeze,mapGet,mapHas,mapSet,setAdd,promiseCatch,promiseThen,values,weakmapGet,assert;$h‍_imports([["./commons.js", [["ReferenceError", [$h‍_a => (ReferenceError = $h‍_a)]],["TypeError", [$h‍_a => (TypeError = $h‍_a)]],["Map", [$h‍_a => (Map = $h‍_a)]],["Set", [$h‍_a => (Set = $h‍_a)]],["arrayJoin", [$h‍_a => (arrayJoin = $h‍_a)]],["arrayMap", [$h‍_a => (arrayMap = $h‍_a)]],["arrayPush", [$h‍_a => (arrayPush = $h‍_a)]],["create", [$h‍_a => (create = $h‍_a)]],["freeze", [$h‍_a => (freeze = $h‍_a)]],["mapGet", [$h‍_a => (mapGet = $h‍_a)]],["mapHas", [$h‍_a => (mapHas = $h‍_a)]],["mapSet", [$h‍_a => (mapSet = $h‍_a)]],["setAdd", [$h‍_a => (setAdd = $h‍_a)]],["promiseCatch", [$h‍_a => (promiseCatch = $h‍_a)]],["promiseThen", [$h‍_a => (promiseThen = $h‍_a)]],["values", [$h‍_a => (values = $h‍_a)]],["weakmapGet", [$h‍_a => (weakmapGet = $h‍_a)]]]],["./error/assert.js", [["assert", [$h‍_a => (assert = $h‍_a)]]]]]);   




























const { Fail, details: d, quote: q}=   assert;

const noop=  ()=>  { };

// `makeAlias` constructs compartment specifier tuples for the `aliases`
// private field of compartments.
// These aliases allow a compartment to alias an internal module specifier to a
// module specifier in an external compartment, and also to create internal
// aliases.
// Both are facilitated by the moduleMap Compartment constructor option.
const        makeAlias=  (compartment, specifier)=>
  freeze({
    compartment,
    specifier});


// `resolveAll` pre-computes resolutions of all imports within the compartment
// in which a module was loaded.
$h‍_once.makeAlias(makeAlias);const resolveAll=(imports,resolveHook,fullReferrerSpecifier)=>{
  const resolvedImports=  create(null);
  for( const importSpecifier of imports) {
    const fullSpecifier=  resolveHook(importSpecifier, fullReferrerSpecifier);
    resolvedImports[importSpecifier]=  fullSpecifier;
   }
  return freeze(resolvedImports);
 };

const loadRecord=  (
  compartmentPrivateFields,
  moduleAliases,
  compartment,
  moduleSpecifier,
  staticModuleRecord,
  pendingJobs,
  moduleLoads,
  errors,
  importMeta)=>
     {
  const { resolveHook, moduleRecords}=   weakmapGet(
    compartmentPrivateFields,
    compartment);


  // resolve all imports relative to this referrer module.
  const resolvedImports=  resolveAll(
    staticModuleRecord.imports,
    resolveHook,
    moduleSpecifier);

  const moduleRecord=  freeze({
    compartment,
    staticModuleRecord,
    moduleSpecifier,
    resolvedImports,
    importMeta});


  // Enqueue jobs to load this module's shallow dependencies.
  for( const fullSpecifier of values(resolvedImports)) {
    // Behold: recursion.
    // eslint-disable-next-line no-use-before-define
    const dependencyLoaded=  memoizedLoadWithErrorAnnotation(
      compartmentPrivateFields,
      moduleAliases,
      compartment,
      fullSpecifier,
      pendingJobs,
      moduleLoads,
      errors);

    setAdd(
      pendingJobs,
      promiseThen(dependencyLoaded, noop, (error)=>{
        arrayPush(errors, error);
       }));

   }

  // Memoize.
  mapSet(moduleRecords, moduleSpecifier, moduleRecord);
  return moduleRecord;
 };

const loadWithoutErrorAnnotation=  async(
  compartmentPrivateFields,
  moduleAliases,
  compartment,
  moduleSpecifier,
  pendingJobs,
  moduleLoads,
  errors)=>
     {
  const { importHook, moduleMap, moduleMapHook, moduleRecords}=   weakmapGet(
    compartmentPrivateFields,
    compartment);


  // Follow moduleMap, or moduleMapHook if present.
  let aliasNamespace=  moduleMap[moduleSpecifier];
  if( aliasNamespace===  undefined&&  moduleMapHook!==  undefined) {
    aliasNamespace=  moduleMapHook(moduleSpecifier);
   }
  if( typeof aliasNamespace===  'string') {
    // eslint-disable-next-line @endo/no-polymorphic-call
    assert.fail(
      d `Cannot map module ${q(moduleSpecifier)} to ${q(
        aliasNamespace)
        } in parent compartment, not yet implemented`,
      TypeError);

   }else if( aliasNamespace!==  undefined) {
    const alias=  weakmapGet(moduleAliases, aliasNamespace);
    if( alias===  undefined) {
      // eslint-disable-next-line @endo/no-polymorphic-call
      assert.fail(
        d `Cannot map module ${q(
          moduleSpecifier)
          } because the value is not a module exports namespace, or is from another realm`,
        ReferenceError);

     }
    // Behold: recursion.
    // eslint-disable-next-line no-use-before-define
    const aliasRecord=  await memoizedLoadWithErrorAnnotation(
      compartmentPrivateFields,
      moduleAliases,
      alias.compartment,
      alias.specifier,
      pendingJobs,
      moduleLoads,
      errors);

    mapSet(moduleRecords, moduleSpecifier, aliasRecord);
    return aliasRecord;
   }

  if( mapHas(moduleRecords, moduleSpecifier)) {
    return mapGet(moduleRecords, moduleSpecifier);
   }

  const staticModuleRecord=  await importHook(moduleSpecifier);

  if( staticModuleRecord===  null||  typeof staticModuleRecord!==  'object') {
    Fail `importHook must return a promise for an object, for module ${q(
      moduleSpecifier)
      } in compartment ${q(compartment.name)}`;
   }

  // check if record is a RedirectStaticModuleInterface
  if( staticModuleRecord.specifier!==  undefined) {
    // check if this redirect with an explicit record
    if( staticModuleRecord.record!==  undefined) {
      // ensure expected record shape
      if( staticModuleRecord.compartment!==  undefined) {
        throw TypeError(
          'Cannot redirect to an explicit record with a specified compartment');

       }
      const {
        compartment: aliasCompartment=  compartment,
        specifier: aliasSpecifier=  moduleSpecifier,
        record: aliasModuleRecord,
        importMeta}=
          staticModuleRecord;

      const aliasRecord=  loadRecord(
        compartmentPrivateFields,
        moduleAliases,
        aliasCompartment,
        aliasSpecifier,
        aliasModuleRecord,
        pendingJobs,
        moduleLoads,
        errors,
        importMeta);

      mapSet(moduleRecords, moduleSpecifier, aliasRecord);
      return aliasRecord;
     }

    // check if this redirect with an explicit compartment
    if( staticModuleRecord.compartment!==  undefined) {
      // ensure expected record shape
      if( staticModuleRecord.importMeta!==  undefined) {
        throw TypeError(
          'Cannot redirect to an implicit record with a specified importMeta');

       }
      // Behold: recursion.
      // eslint-disable-next-line no-use-before-define
      const aliasRecord=  await memoizedLoadWithErrorAnnotation(
        compartmentPrivateFields,
        moduleAliases,
        staticModuleRecord.compartment,
        staticModuleRecord.specifier,
        pendingJobs,
        moduleLoads,
        errors);

      mapSet(moduleRecords, moduleSpecifier, aliasRecord);
      return aliasRecord;
     }

    throw TypeError('Unnexpected RedirectStaticModuleInterface record shape');
   }

  return loadRecord(
    compartmentPrivateFields,
    moduleAliases,
    compartment,
    moduleSpecifier,
    staticModuleRecord,
    pendingJobs,
    moduleLoads,
    errors);

 };

const memoizedLoadWithErrorAnnotation=  async(
  compartmentPrivateFields,
  moduleAliases,
  compartment,
  moduleSpecifier,
  pendingJobs,
  moduleLoads,
  errors)=>
     {
  const { name: compartmentName}=   weakmapGet(
    compartmentPrivateFields,
    compartment);


  // Prevent data-lock from recursion into branches visited in dependent loads.
  let compartmentLoading=  mapGet(moduleLoads, compartment);
  if( compartmentLoading===  undefined) {
    compartmentLoading=  new Map();
    mapSet(moduleLoads, compartment, compartmentLoading);
   }
  let moduleLoading=  mapGet(compartmentLoading, moduleSpecifier);
  if( moduleLoading!==  undefined) {
    return moduleLoading;
   }

  moduleLoading=  promiseCatch(
    loadWithoutErrorAnnotation(
      compartmentPrivateFields,
      moduleAliases,
      compartment,
      moduleSpecifier,
      pendingJobs,
      moduleLoads,
      errors),

    (error)=>{
      // eslint-disable-next-line @endo/no-polymorphic-call
      assert.note(
        error,
        d `${error.message}, loading ${q(moduleSpecifier)} in compartment ${q(
          compartmentName)
          }`);

      throw error;
     });


  mapSet(compartmentLoading, moduleSpecifier, moduleLoading);

  return moduleLoading;
 };

/*
 * `load` asynchronously gathers the `StaticModuleRecord`s for a module and its
 * transitive dependencies.
 * The module records refer to each other by a reference to the dependency's
 * compartment and the specifier of the module within its own compartment.
 * This graph is then ready to be synchronously linked and executed.
 */
const        load=  async(
  compartmentPrivateFields,
  moduleAliases,
  compartment,
  moduleSpecifier)=>
     {
  const { name: compartmentName}=   weakmapGet(
    compartmentPrivateFields,
    compartment);


  /** @type {Set<Promise<undefined>>} */
  const pendingJobs=  new Set();
  /** @type {Map<object, Map<string, Promise<Record<any, any>>>>} */
  const moduleLoads=  new Map();
  /** @type {Array<Error>} */
  const errors=  [];

  const dependencyLoaded=  memoizedLoadWithErrorAnnotation(
    compartmentPrivateFields,
    moduleAliases,
    compartment,
    moduleSpecifier,
    pendingJobs,
    moduleLoads,
    errors);

  setAdd(
    pendingJobs,
    promiseThen(dependencyLoaded, noop, (error)=>{
      arrayPush(errors, error);
     }));


  // Drain pending jobs queue.
  // Each job is a promise for undefined, regardless of success or failure.
  // Before we add a job to the queue, we catch any error and push it into the
  // `errors` accumulator.
  for( const job of pendingJobs) {
    // eslint-disable-next-line no-await-in-loop
    await job;
   }

  // Throw an aggregate error if there were any errors.
  if( errors.length>  0) {
    throw TypeError(
       `Failed to load module ${q(moduleSpecifier)} in package ${q(
        compartmentName)
        } (${errors.length} underlying failures: ${arrayJoin(
        arrayMap(errors, (error)=>error.message),
        ', ')
        }`);

   }
 };$h‍_once.load(load);
})()
,
// === functors[40] ===
({   imports: $h‍_imports,   liveVar: $h‍_live,   onceVar: $h‍_once,   importMeta: $h‍____meta, }) => (function () {   let makeAlias,Proxy,TypeError,create,freeze,mapGet,mapHas,mapSet,ownKeys,reflectGet,reflectGetOwnPropertyDescriptor,reflectHas,reflectIsExtensible,reflectPreventExtensions,weakmapSet,assert;$h‍_imports([["./module-load.js", [["makeAlias", [$h‍_a => (makeAlias = $h‍_a)]]]],["./commons.js", [["Proxy", [$h‍_a => (Proxy = $h‍_a)]],["TypeError", [$h‍_a => (TypeError = $h‍_a)]],["create", [$h‍_a => (create = $h‍_a)]],["freeze", [$h‍_a => (freeze = $h‍_a)]],["mapGet", [$h‍_a => (mapGet = $h‍_a)]],["mapHas", [$h‍_a => (mapHas = $h‍_a)]],["mapSet", [$h‍_a => (mapSet = $h‍_a)]],["ownKeys", [$h‍_a => (ownKeys = $h‍_a)]],["reflectGet", [$h‍_a => (reflectGet = $h‍_a)]],["reflectGetOwnPropertyDescriptor", [$h‍_a => (reflectGetOwnPropertyDescriptor = $h‍_a)]],["reflectHas", [$h‍_a => (reflectHas = $h‍_a)]],["reflectIsExtensible", [$h‍_a => (reflectIsExtensible = $h‍_a)]],["reflectPreventExtensions", [$h‍_a => (reflectPreventExtensions = $h‍_a)]],["weakmapSet", [$h‍_a => (weakmapSet = $h‍_a)]]]],["./error/assert.js", [["assert", [$h‍_a => (assert = $h‍_a)]]]]]);   






























const { quote: q}=   assert;

// `deferExports` creates a module's exports proxy, proxied exports, and
// activator.
// A `Compartment` can create a module for any module specifier, regardless of
// whether it is loadable or executable, and use that object as a token that
// can be fed into another compartment's module map.
// Only after the specified module has been analyzed is it possible for the
// module namespace proxy to behave properly, so it throws exceptions until
// after the compartment has begun executing the module.
// The module instance must freeze the proxied exports and activate the exports
// proxy before executing the module.
//
// The module exports proxy's behavior differs from the ECMAScript 262
// specification for "module namespace exotic objects" only in that according
// to the specification value property descriptors have a non-writable "value"
// and this implementation models all properties with accessors.
//
// https://tc39.es/ecma262/#sec-module-namespace-exotic-objects
//
const        deferExports=  ()=>  {
  let active=  false;
  const proxiedExports=  create(null);
  return freeze({
    activate() {
      active=  true;
     },
    proxiedExports,
    exportsProxy: new Proxy(proxiedExports, {
      get(_target, name, receiver) {
        if( !active) {
          throw TypeError(
             `Cannot get property ${q(
              name)
              } of module exports namespace, the module has not yet begun to execute`);

         }
        return reflectGet(proxiedExports, name, receiver);
       },
      set(_target, name, _value) {
        throw TypeError(
           `Cannot set property ${q(name)} of module exports namespace`);

       },
      has(_target, name) {
        if( !active) {
          throw TypeError(
             `Cannot check property ${q(
              name)
              }, the module has not yet begun to execute`);

         }
        return reflectHas(proxiedExports, name);
       },
      deleteProperty(_target, name) {
        throw TypeError(
           `Cannot delete property ${q(name)}s of module exports namespace`);

       },
      ownKeys(_target) {
        if( !active) {
          throw TypeError(
            'Cannot enumerate keys, the module has not yet begun to execute');

         }
        return ownKeys(proxiedExports);
       },
      getOwnPropertyDescriptor(_target, name) {
        if( !active) {
          throw TypeError(
             `Cannot get own property descriptor ${q(
              name)
              }, the module has not yet begun to execute`);

         }
        return reflectGetOwnPropertyDescriptor(proxiedExports, name);
       },
      preventExtensions(_target) {
        if( !active) {
          throw TypeError(
            'Cannot prevent extensions of module exports namespace, the module has not yet begun to execute');

         }
        return reflectPreventExtensions(proxiedExports);
       },
      isExtensible() {
        if( !active) {
          throw TypeError(
            'Cannot check extensibility of module exports namespace, the module has not yet begun to execute');

         }
        return reflectIsExtensible(proxiedExports);
       },
      getPrototypeOf(_target) {
        return null;
       },
      setPrototypeOf(_target, _proto) {
        throw TypeError('Cannot set prototype of module exports namespace');
       },
      defineProperty(_target, name, _descriptor) {
        throw TypeError(
           `Cannot define property ${q(name)} of module exports namespace`);

       },
      apply(_target, _thisArg, _args) {
        throw TypeError(
          'Cannot call module exports namespace, it is not a function');

       },
      construct(_target, _args) {
        throw TypeError(
          'Cannot construct module exports namespace, it is not a constructor');

       }})});


 };

// `getDeferredExports` memoizes the creation of a deferred module exports
// namespace proxy for any abritrary full specifier in a compartment.
// It also records the compartment and specifier affiliated with that module
// exports namespace proxy so it can be used as an alias into another
// compartment when threaded through a compartment's `moduleMap` argument.
$h‍_once.deferExports(deferExports);const getDeferredExports=(
  compartment,
  compartmentPrivateFields,
  moduleAliases,
  specifier)=>
     {
  const { deferredExports}=   compartmentPrivateFields;
  if( !mapHas(deferredExports, specifier)) {
    const deferred=  deferExports();
    weakmapSet(
      moduleAliases,
      deferred.exportsProxy,
      makeAlias(compartment, specifier));

    mapSet(deferredExports, specifier, deferred);
   }
  return mapGet(deferredExports, specifier);
 };$h‍_once.getDeferredExports(getDeferredExports);
})()
,
// === functors[41] ===
({   imports: $h‍_imports,   liveVar: $h‍_live,   onceVar: $h‍_once,   importMeta: $h‍____meta, }) => (function () {   let TypeError,arrayPush,create,getOwnPropertyDescriptors,evadeHtmlCommentTest,evadeImportExpressionTest,rejectSomeDirectEvalExpressions,makeSafeEvaluator;$h‍_imports([["./commons.js", [["TypeError", [$h‍_a => (TypeError = $h‍_a)]],["arrayPush", [$h‍_a => (arrayPush = $h‍_a)]],["create", [$h‍_a => (create = $h‍_a)]],["getOwnPropertyDescriptors", [$h‍_a => (getOwnPropertyDescriptors = $h‍_a)]]]],["./transforms.js", [["evadeHtmlCommentTest", [$h‍_a => (evadeHtmlCommentTest = $h‍_a)]],["evadeImportExpressionTest", [$h‍_a => (evadeImportExpressionTest = $h‍_a)]],["rejectSomeDirectEvalExpressions", [$h‍_a => (rejectSomeDirectEvalExpressions = $h‍_a)]]]],["./make-safe-evaluator.js", [["makeSafeEvaluator", [$h‍_a => (makeSafeEvaluator = $h‍_a)]]]]]);   













const        provideCompartmentEvaluator=  (compartmentFields, options)=>  {
  const { sloppyGlobalsMode=  false, __moduleShimLexicals__=  undefined}=
    options;

  let safeEvaluate;

  if( __moduleShimLexicals__===  undefined&&  !sloppyGlobalsMode) {
    ({ safeEvaluate}=   compartmentFields);
   }else {
    // The scope proxy or global lexicals are different from the
    // shared evaluator so we need to build a new one

    let { globalTransforms}=   compartmentFields;
    const { globalObject}=   compartmentFields;

    let moduleLexicals;
    if( __moduleShimLexicals__!==  undefined) {
      // When using `evaluate` for ESM modules, as should only occur from the
      // module-shim's module-instance.js, we do not reveal the SES-shim's
      // module-to-program translation, as this is not standardizable behavior.
      // However, the `localTransforms` will come from the `__shimTransforms__`
      // Compartment option in this case, which is a non-standardizable escape
      // hatch so programs designed specifically for the SES-shim
      // implementation may opt-in to use the same transforms for `evaluate`
      // and `import`, at the expense of being tightly coupled to SES-shim.
      globalTransforms=  undefined;

      moduleLexicals=  create(
        null,
        getOwnPropertyDescriptors(__moduleShimLexicals__));

     }

    ({ safeEvaluate}=   makeSafeEvaluator({
      globalObject,
      moduleLexicals,
      globalTransforms,
      sloppyGlobalsMode}));

   }

  return { safeEvaluate};
 };$h‍_once.provideCompartmentEvaluator(provideCompartmentEvaluator);

const        compartmentEvaluate=  (compartmentFields, source, options)=>  {
  // Perform this check first to avoid unnecessary sanitizing.
  // TODO Maybe relax string check and coerce instead:
  // https://github.com/tc39/proposal-dynamic-code-brand-checks
  if( typeof source!==  'string') {
    throw TypeError('first argument of evaluate() must be a string');
   }

  // Extract options, and shallow-clone transforms.
  const {
    transforms=  [],
    __evadeHtmlCommentTest__=  false,
    __evadeImportExpressionTest__=  false,
    __rejectSomeDirectEvalExpressions__=  true  // Note default on
}=    options;
  const localTransforms=  [...transforms];
  if( __evadeHtmlCommentTest__===  true) {
    arrayPush(localTransforms, evadeHtmlCommentTest);
   }
  if( __evadeImportExpressionTest__===  true) {
    arrayPush(localTransforms, evadeImportExpressionTest);
   }
  if( __rejectSomeDirectEvalExpressions__===  true) {
    arrayPush(localTransforms, rejectSomeDirectEvalExpressions);
   }

  const { safeEvaluate}=   provideCompartmentEvaluator(
    compartmentFields,
    options);


  return safeEvaluate(source, {
    localTransforms});

 };$h‍_once.compartmentEvaluate(compartmentEvaluate);
})()
,
// === functors[42] ===
({   imports: $h‍_imports,   liveVar: $h‍_live,   onceVar: $h‍_once,   importMeta: $h‍____meta, }) => (function () {   let assert,getDeferredExports,ReferenceError,SyntaxError,TypeError,arrayForEach,arrayIncludes,arrayPush,arraySome,arraySort,create,defineProperty,entries,freeze,isArray,keys,mapGet,weakmapGet,reflectHas,assign,compartmentEvaluate;$h‍_imports([["./error/assert.js", [["assert", [$h‍_a => (assert = $h‍_a)]]]],["./module-proxy.js", [["getDeferredExports", [$h‍_a => (getDeferredExports = $h‍_a)]]]],["./commons.js", [["ReferenceError", [$h‍_a => (ReferenceError = $h‍_a)]],["SyntaxError", [$h‍_a => (SyntaxError = $h‍_a)]],["TypeError", [$h‍_a => (TypeError = $h‍_a)]],["arrayForEach", [$h‍_a => (arrayForEach = $h‍_a)]],["arrayIncludes", [$h‍_a => (arrayIncludes = $h‍_a)]],["arrayPush", [$h‍_a => (arrayPush = $h‍_a)]],["arraySome", [$h‍_a => (arraySome = $h‍_a)]],["arraySort", [$h‍_a => (arraySort = $h‍_a)]],["create", [$h‍_a => (create = $h‍_a)]],["defineProperty", [$h‍_a => (defineProperty = $h‍_a)]],["entries", [$h‍_a => (entries = $h‍_a)]],["freeze", [$h‍_a => (freeze = $h‍_a)]],["isArray", [$h‍_a => (isArray = $h‍_a)]],["keys", [$h‍_a => (keys = $h‍_a)]],["mapGet", [$h‍_a => (mapGet = $h‍_a)]],["weakmapGet", [$h‍_a => (weakmapGet = $h‍_a)]],["reflectHas", [$h‍_a => (reflectHas = $h‍_a)]],["assign", [$h‍_a => (assign = $h‍_a)]]]],["./compartment-evaluate.js", [["compartmentEvaluate", [$h‍_a => (compartmentEvaluate = $h‍_a)]]]]]);   























const { quote: q}=   assert;

const        makeThirdPartyModuleInstance=  (
  compartmentPrivateFields,
  staticModuleRecord,
  compartment,
  moduleAliases,
  moduleSpecifier,
  resolvedImports)=>
     {
  const { exportsProxy, proxiedExports, activate}=   getDeferredExports(
    compartment,
    weakmapGet(compartmentPrivateFields, compartment),
    moduleAliases,
    moduleSpecifier);


  const notifiers=  create(null);

  if( staticModuleRecord.exports) {
    if(
      !isArray(staticModuleRecord.exports)||
      arraySome(staticModuleRecord.exports, (name)=>typeof name!==  'string'))
      {
      throw TypeError(
         `SES third-party static module record "exports" property must be an array of strings for module ${moduleSpecifier}`);

     }
    arrayForEach(staticModuleRecord.exports, (name)=>{
      let value=  proxiedExports[name];
      const updaters=  [];

      const get=  ()=>  value;

      const set=  (newValue)=>{
        value=  newValue;
        for( const updater of updaters) {
          updater(newValue);
         }
       };

      defineProperty(proxiedExports, name, {
        get,
        set,
        enumerable: true,
        configurable: false});


      notifiers[name]=  (update)=>{
        arrayPush(updaters, update);
        update(value);
       };
     });
    // This is enough to support import * from cjs - the '*' field doesn't need to be in exports nor proxiedExports because import will only ever access it via notifiers
    notifiers['*']=  (update)=>{
      update(proxiedExports);
     };
   }

  const localState=  {
    activated: false};

  return freeze({
    notifiers,
    exportsProxy,
    execute() {
      if( reflectHas(localState, 'errorFromExecute')) {
        throw localState.errorFromExecute;
       }
      if( !localState.activated) {
        activate();
        localState.activated=  true;
        try {
          // eslint-disable-next-line @endo/no-polymorphic-call
          staticModuleRecord.execute(
            proxiedExports,
            compartment,
            resolvedImports);

         }catch( err) {
          localState.errorFromExecute=  err;
          throw err;
         }
       }
     }});

 };

// `makeModuleInstance` takes a module's compartment record, the live import
// namespace, and a global object; and produces a module instance.
// The module instance carries the proxied module exports namespace (the
// "exports"), notifiers to update the module's internal import namespace, and
// an idempotent execute function.
// The module exports namespace is a proxy to the proxied exports namespace
// that the execution of the module instance populates.
$h‍_once.makeThirdPartyModuleInstance(makeThirdPartyModuleInstance);const makeModuleInstance=(
  privateFields,
  moduleAliases,
  moduleRecord,
  importedInstances)=>
     {
  const {
    compartment,
    moduleSpecifier,
    staticModuleRecord,
    importMeta: moduleRecordMeta}=
      moduleRecord;
  const {
    reexports: exportAlls=  [],
    __syncModuleProgram__: functorSource,
    __fixedExportMap__: fixedExportMap=  {},
    __liveExportMap__: liveExportMap=  {},
    __reexportMap__: reexportMap=  {},
    __needsImportMeta__: needsImportMeta=  false,
    __syncModuleFunctor__}=
      staticModuleRecord;

  const compartmentFields=  weakmapGet(privateFields, compartment);

  const { __shimTransforms__, importMetaHook}=   compartmentFields;

  const { exportsProxy, proxiedExports, activate}=   getDeferredExports(
    compartment,
    compartmentFields,
    moduleAliases,
    moduleSpecifier);


  // {_exportName_: getter} module exports namespace
  // object (eventually proxied).
  const exportsProps=  create(null);

  // {_localName_: accessor} proxy traps for moduleLexicals and live bindings.
  // The moduleLexicals object is frozen and the corresponding properties of
  // moduleLexicals must be immutable, so we copy the descriptors.
  const moduleLexicals=  create(null);

  // {_localName_: init(initValue) -> initValue} used by the
  // rewritten code to initialize exported fixed bindings.
  const onceVar=  create(null);

  // {_localName_: update(newValue)} used by the rewritten code to
  // both initialize and update live bindings.
  const liveVar=  create(null);

  const importMeta=  create(null);
  if( moduleRecordMeta) {
    assign(importMeta, moduleRecordMeta);
   }
  if( needsImportMeta&&  importMetaHook) {
    importMetaHook(moduleSpecifier, importMeta);
   }

  // {_localName_: [{get, set, notify}]} used to merge all the export updaters.
  const localGetNotify=  create(null);

  // {[importName: string]: notify(update(newValue))} Used by code that imports
  // one of this module's exports, so that their update function will
  // be notified when this binding is initialized or updated.
  const notifiers=  create(null);

  arrayForEach(entries(fixedExportMap), ([fixedExportName, [localName]])=>  {
    let fixedGetNotify=  localGetNotify[localName];
    if( !fixedGetNotify) {
      // fixed binding state
      let value;
      let tdz=  true;
      /** @type {null | Array<(value: any) => void>} */
      let optUpdaters=  [];

      // tdz sensitive getter
      const get=  ()=>  {
        if( tdz) {
          throw ReferenceError( `binding ${q(localName)} not yet initialized`);
         }
        return value;
       };

      // leave tdz once
      const init=  freeze((initValue)=>{
        // init with initValue of a declared const binding, and return
        // it.
        if( !tdz) {
          throw TypeError(
             `Internal: binding ${q(localName)} already initialized`);

         }
        value=  initValue;
        const updaters=  optUpdaters;
        optUpdaters=  null;
        tdz=  false;
        for( const updater of updaters||  []) {
          updater(initValue);
         }
        return initValue;
       });

      // If still tdz, register update for notification later.
      // Otherwise, update now.
      const notify=  (updater)=>{
        if( updater===  init) {
          // Prevent recursion.
          return;
         }
        if( tdz) {
          arrayPush(optUpdaters||  [], updater);
         }else {
          updater(value);
         }
       };

      // Need these for additional exports of the local variable.
      fixedGetNotify=  {
        get,
        notify};

      localGetNotify[localName]=  fixedGetNotify;
      onceVar[localName]=  init;
     }

    exportsProps[fixedExportName]=  {
      get: fixedGetNotify.get,
      set: undefined,
      enumerable: true,
      configurable: false};


    notifiers[fixedExportName]=  fixedGetNotify.notify;
   });

  arrayForEach(
    entries(liveExportMap),
    ([liveExportName, [localName, setProxyTrap]])=>  {
      let liveGetNotify=  localGetNotify[localName];
      if( !liveGetNotify) {
        // live binding state
        let value;
        let tdz=  true;
        const updaters=  [];

        // tdz sensitive getter
        const get=  ()=>  {
          if( tdz) {
            throw ReferenceError(
               `binding ${q(liveExportName)} not yet initialized`);

           }
          return value;
         };

        // This must be usable locally for the translation of initializing
        // a declared local live binding variable.
        //
        // For reexported variable, this is also an update function to
        // register for notification with the downstream import, which we
        // must assume to be live. Thus, it can be called independent of
        // tdz but always leaves tdz. Such reexporting creates a tree of
        // bindings. This lets the tree be hooked up even if the imported
        // module instance isn't initialized yet, as may happen in cycles.
        const update=  freeze((newValue)=>{
          value=  newValue;
          tdz=  false;
          for( const updater of updaters) {
            updater(newValue);
           }
         });

        // tdz sensitive setter
        const set=  (newValue)=>{
          if( tdz) {
            throw ReferenceError( `binding ${q(localName)} not yet initialized`);
           }
          value=  newValue;
          for( const updater of updaters) {
            updater(newValue);
           }
         };

        // Always register the updater function.
        // If not in tdz, also update now.
        const notify=  (updater)=>{
          if( updater===  update) {
            // Prevent recursion.
            return;
           }
          arrayPush(updaters, updater);
          if( !tdz) {
            updater(value);
           }
         };

        liveGetNotify=  {
          get,
          notify};


        localGetNotify[localName]=  liveGetNotify;
        if( setProxyTrap) {
          defineProperty(moduleLexicals, localName, {
            get,
            set,
            enumerable: true,
            configurable: false});

         }
        liveVar[localName]=  update;
       }

      exportsProps[liveExportName]=  {
        get: liveGetNotify.get,
        set: undefined,
        enumerable: true,
        configurable: false};


      notifiers[liveExportName]=  liveGetNotify.notify;
     });


  const notifyStar=  (update)=>{
    update(proxiedExports);
   };
  notifiers['*']=  notifyStar;

  // Per the calling convention for the moduleFunctor generated from
  // an ESM, the `imports` function gets called once up front
  // to populate or arrange the population of imports and reexports.
  // The generated code produces an `updateRecord`: the means for
  // the linker to update the imports and exports of the module.
  // The updateRecord must conform to moduleAnalysis.imports
  // updateRecord = Map<specifier, importUpdaters>
  // importUpdaters = Map<importName, [update(newValue)*]>
  function imports(updateRecord) {
    // By the time imports is called, the importedInstances should already be
    // initialized with module instances that satisfy
    // imports.
    // importedInstances = Map[_specifier_, { notifiers, module, execute }]
    // notifiers = { [importName: string]: notify(update(newValue))}

    // export * cannot export default.
    const candidateAll=  create(null);
    candidateAll.default=  false;
    for( const [specifier, importUpdaters]of  updateRecord) {
      const instance=  mapGet(importedInstances, specifier);
      // The module instance object is an internal literal, does not bind this,
      // and never revealed outside the SES shim.
      // There are two instantiation sites for instances and they are both in
      // this module.
      // eslint-disable-next-line @endo/no-polymorphic-call
      instance.execute(); // bottom up cycle tolerant
      const { notifiers: importNotifiers}=   instance;
      for( const [importName, updaters]of  importUpdaters) {
        const importNotify=  importNotifiers[importName];
        if( !importNotify) {
          throw SyntaxError(
             `The requested module '${specifier}' does not provide an export named '${importName}'`);

         }
        for( const updater of updaters) {
          importNotify(updater);
         }
       }
      if( arrayIncludes(exportAlls, specifier)) {
        // Make all these imports candidates.
        // Note names don't change in reexporting all
        for( const [importAndExportName, importNotify]of  entries(
          importNotifiers))
           {
          if( candidateAll[importAndExportName]===  undefined) {
            candidateAll[importAndExportName]=  importNotify;
           }else {
            // Already a candidate: remove ambiguity.
            candidateAll[importAndExportName]=  false;
           }
         }
       }
      if( reexportMap[specifier]) {
        // Make named reexports candidates too.
        for( const [localName, exportedName]of  reexportMap[specifier]) {
          candidateAll[exportedName]=  importNotifiers[localName];
         }
       }
     }

    for( const [exportName, notify]of  entries(candidateAll)) {
      if( !notifiers[exportName]&&  notify!==  false) {
        notifiers[exportName]=  notify;

        // exported live binding state
        let value;
        const update=  (newValue)=> value=  newValue;
        notify(update);
        exportsProps[exportName]=  {
          get() {
            return value;
           },
          set: undefined,
          enumerable: true,
          configurable: false};

       }
     }

    // Sort the module exports namespace as per spec.
    // The module exports namespace will be wrapped in a module namespace
    // exports proxy which will serve as a "module exports namespace exotic
    // object".
    // Sorting properties is not generally reliable because some properties may
    // be symbols, and symbols do not have an inherent relative order, but
    // since all properties of the exports namespace must be keyed by a string
    // and the string must correspond to a valid identifier, sorting these
    // properties works for this specific case.
    arrayForEach(arraySort(keys(exportsProps)), (k)=>
      defineProperty(proxiedExports, k, exportsProps[k]));


    freeze(proxiedExports);
    activate();
   }

  let optFunctor;
  if( __syncModuleFunctor__!==  undefined) {
    optFunctor=  __syncModuleFunctor__;
   }else {
    optFunctor=  compartmentEvaluate(compartmentFields, functorSource, {
      globalObject: compartment.globalThis,
      transforms: __shimTransforms__,
      __moduleShimLexicals__: moduleLexicals});

   }
  let didThrow=  false;
  let thrownError;
  function execute() {
    if( optFunctor) {
      // uninitialized
      const functor=  optFunctor;
      optFunctor=  null;
      // initializing - call with `this` of `undefined`.
      try {
        functor(
          freeze({
            imports: freeze(imports),
            onceVar: freeze(onceVar),
            liveVar: freeze(liveVar),
            importMeta}));


       }catch( e) {
        didThrow=  true;
        thrownError=  e;
       }
      // initialized
     }
    if( didThrow) {
      throw thrownError;
     }
   }

  return freeze({
    notifiers,
    exportsProxy,
    execute});

 };$h‍_once.makeModuleInstance(makeModuleInstance);
})()
,
// === functors[43] ===
({   imports: $h‍_imports,   liveVar: $h‍_live,   onceVar: $h‍_once,   importMeta: $h‍____meta, }) => (function () {   let assert,makeModuleInstance,makeThirdPartyModuleInstance,Map,ReferenceError,TypeError,entries,isArray,isObject,mapGet,mapHas,mapSet,weakmapGet;$h‍_imports([["./error/assert.js", [["assert", [$h‍_a => (assert = $h‍_a)]]]],["./module-instance.js", [["makeModuleInstance", [$h‍_a => (makeModuleInstance = $h‍_a)]],["makeThirdPartyModuleInstance", [$h‍_a => (makeThirdPartyModuleInstance = $h‍_a)]]]],["./commons.js", [["Map", [$h‍_a => (Map = $h‍_a)]],["ReferenceError", [$h‍_a => (ReferenceError = $h‍_a)]],["TypeError", [$h‍_a => (TypeError = $h‍_a)]],["entries", [$h‍_a => (entries = $h‍_a)]],["isArray", [$h‍_a => (isArray = $h‍_a)]],["isObject", [$h‍_a => (isObject = $h‍_a)]],["mapGet", [$h‍_a => (mapGet = $h‍_a)]],["mapHas", [$h‍_a => (mapHas = $h‍_a)]],["mapSet", [$h‍_a => (mapSet = $h‍_a)]],["weakmapGet", [$h‍_a => (weakmapGet = $h‍_a)]]]]]);   



























const { Fail, quote: q}=   assert;

// `link` creates `ModuleInstances` and `ModuleNamespaces` for a module and its
// transitive dependencies and connects their imports and exports.
// After linking, the resulting working set is ready to be executed.
// The linker only concerns itself with module namespaces that are objects with
// property descriptors for their exports, which the Compartment proxies with
// the actual `ModuleNamespace`.
const        link=  (
  compartmentPrivateFields,
  moduleAliases,
  compartment,
  moduleSpecifier)=>
     {
  const { name: compartmentName, moduleRecords}=   weakmapGet(
    compartmentPrivateFields,
    compartment);


  const moduleRecord=  mapGet(moduleRecords, moduleSpecifier);
  if( moduleRecord===  undefined) {
    throw ReferenceError(
       `Missing link to module ${q(moduleSpecifier)} from compartment ${q(
        compartmentName)
        }`);

   }

  // Mutual recursion so there's no confusion about which
  // compartment is in context: the module record may be in another
  // compartment, denoted by moduleRecord.compartment.
  // eslint-disable-next-line no-use-before-define
  return instantiate(compartmentPrivateFields, moduleAliases, moduleRecord);
 };$h‍_once.link(link);

function isPrecompiled(staticModuleRecord) {
  return typeof staticModuleRecord.__syncModuleProgram__===  'string';
 }

function validatePrecompiledStaticModuleRecord(
  staticModuleRecord,
  moduleSpecifier)
  {
  const { __fixedExportMap__, __liveExportMap__}=   staticModuleRecord;
  isObject(__fixedExportMap__)||
    Fail `Property '__fixedExportMap__' of a precompiled module record must be an object, got ${q(
      __fixedExportMap__)
      }, for module ${q(moduleSpecifier)}`;
  isObject(__liveExportMap__)||
    Fail `Property '__liveExportMap__' of a precompiled module record must be an object, got ${q(
      __liveExportMap__)
      }, for module ${q(moduleSpecifier)}`;
 }

function isThirdParty(staticModuleRecord) {
  return typeof staticModuleRecord.execute===  'function';
 }

function validateThirdPartyStaticModuleRecord(
  staticModuleRecord,
  moduleSpecifier)
  {
  const { exports}=   staticModuleRecord;
  isArray(exports)||
    Fail `Property 'exports' of a third-party static module record must be an array, got ${q(
      exports)
      }, for module ${q(moduleSpecifier)}`;
 }

function validateStaticModuleRecord(staticModuleRecord, moduleSpecifier) {
  isObject(staticModuleRecord)||
    Fail `Static module records must be of type object, got ${q(
      staticModuleRecord)
      }, for module ${q(moduleSpecifier)}`;
  const { imports, exports, reexports=  []}=   staticModuleRecord;
  isArray(imports)||
    Fail `Property 'imports' of a static module record must be an array, got ${q(
      imports)
      }, for module ${q(moduleSpecifier)}`;
  isArray(exports)||
    Fail `Property 'exports' of a precompiled module record must be an array, got ${q(
      exports)
      }, for module ${q(moduleSpecifier)}`;
  isArray(reexports)||
    Fail `Property 'reexports' of a precompiled module record must be an array if present, got ${q(
      reexports)
      }, for module ${q(moduleSpecifier)}`;
 }

const        instantiate=  (
  compartmentPrivateFields,
  moduleAliases,
  moduleRecord)=>
     {
  const { compartment, moduleSpecifier, resolvedImports, staticModuleRecord}=
    moduleRecord;
  const { instances}=   weakmapGet(compartmentPrivateFields, compartment);

  // Memoize.
  if( mapHas(instances, moduleSpecifier)) {
    return mapGet(instances, moduleSpecifier);
   }

  validateStaticModuleRecord(staticModuleRecord, moduleSpecifier);

  const importedInstances=  new Map();
  let moduleInstance;
  if( isPrecompiled(staticModuleRecord)) {
    validatePrecompiledStaticModuleRecord(staticModuleRecord, moduleSpecifier);
    moduleInstance=  makeModuleInstance(
      compartmentPrivateFields,
      moduleAliases,
      moduleRecord,
      importedInstances);

   }else if( isThirdParty(staticModuleRecord)) {
    validateThirdPartyStaticModuleRecord(staticModuleRecord, moduleSpecifier);
    moduleInstance=  makeThirdPartyModuleInstance(
      compartmentPrivateFields,
      staticModuleRecord,
      compartment,
      moduleAliases,
      moduleSpecifier,
      resolvedImports);

   }else {
    throw TypeError(
       `importHook must return a static module record, got ${q(
        staticModuleRecord)
        }`);

   }

  // Memoize.
  mapSet(instances, moduleSpecifier, moduleInstance);

  // Link dependency modules.
  for( const [importSpecifier, resolvedSpecifier]of  entries(resolvedImports)) {
    const importedInstance=  link(
      compartmentPrivateFields,
      moduleAliases,
      compartment,
      resolvedSpecifier);

    mapSet(importedInstances, importSpecifier, importedInstance);
   }

  return moduleInstance;
 };$h‍_once.instantiate(instantiate);
})()
,
// === functors[44] ===
({   imports: $h‍_imports,   liveVar: $h‍_live,   onceVar: $h‍_once,   importMeta: $h‍____meta, }) => (function () {   let Map,ReferenceError,TypeError,WeakMap,assign,defineProperties,entries,promiseThen,weakmapGet,weakmapSet,setGlobalObjectSymbolUnscopables,setGlobalObjectConstantProperties,setGlobalObjectMutableProperties,setGlobalObjectEvaluators,sharedGlobalPropertyNames,load,link,getDeferredExports,assert,compartmentEvaluate,makeSafeEvaluator;$h‍_imports([["./commons.js", [["Map", [$h‍_a => (Map = $h‍_a)]],["ReferenceError", [$h‍_a => (ReferenceError = $h‍_a)]],["TypeError", [$h‍_a => (TypeError = $h‍_a)]],["WeakMap", [$h‍_a => (WeakMap = $h‍_a)]],["assign", [$h‍_a => (assign = $h‍_a)]],["defineProperties", [$h‍_a => (defineProperties = $h‍_a)]],["entries", [$h‍_a => (entries = $h‍_a)]],["promiseThen", [$h‍_a => (promiseThen = $h‍_a)]],["weakmapGet", [$h‍_a => (weakmapGet = $h‍_a)]],["weakmapSet", [$h‍_a => (weakmapSet = $h‍_a)]]]],["./global-object.js", [["setGlobalObjectSymbolUnscopables", [$h‍_a => (setGlobalObjectSymbolUnscopables = $h‍_a)]],["setGlobalObjectConstantProperties", [$h‍_a => (setGlobalObjectConstantProperties = $h‍_a)]],["setGlobalObjectMutableProperties", [$h‍_a => (setGlobalObjectMutableProperties = $h‍_a)]],["setGlobalObjectEvaluators", [$h‍_a => (setGlobalObjectEvaluators = $h‍_a)]]]],["./permits.js", [["sharedGlobalPropertyNames", [$h‍_a => (sharedGlobalPropertyNames = $h‍_a)]]]],["./module-load.js", [["load", [$h‍_a => (load = $h‍_a)]]]],["./module-link.js", [["link", [$h‍_a => (link = $h‍_a)]]]],["./module-proxy.js", [["getDeferredExports", [$h‍_a => (getDeferredExports = $h‍_a)]]]],["./error/assert.js", [["assert", [$h‍_a => (assert = $h‍_a)]]]],["./compartment-evaluate.js", [["compartmentEvaluate", [$h‍_a => (compartmentEvaluate = $h‍_a)]]]],["./make-safe-evaluator.js", [["makeSafeEvaluator", [$h‍_a => (makeSafeEvaluator = $h‍_a)]]]]]);   





























const { quote: q}=   assert;

// moduleAliases associates every public module exports namespace with its
// corresponding compartment and specifier so they can be used to link modules
// across compartments.
// The mechanism to thread an alias is to use the compartment.module function
// to obtain the exports namespace of a foreign module and pass it into another
// compartment's moduleMap constructor option.
const moduleAliases=  new WeakMap();

// privateFields captures the private state for each compartment.
const privateFields=  new WeakMap();

// Compartments do not need an importHook or resolveHook to be useful
// as a vessel for evaluating programs.
// However, any method that operates the module system will throw an exception
// if these hooks are not available.
const assertModuleHooks=  (compartment)=>{
  const { importHook, resolveHook}=   weakmapGet(privateFields, compartment);
  if( typeof importHook!==  'function'||  typeof resolveHook!==  'function') {
    throw TypeError(
      'Compartment must be constructed with an importHook and a resolveHook for it to be able to load modules');

   }
 };

const        InertCompartment=  function Compartment(
  _endowments=  {},
  _modules=  {},
  _options=  {})
  {
  throw TypeError(
    'Compartment.prototype.constructor is not a valid constructor.');

 };

/**
 * @param {Compartment} compartment
 * @param {string} specifier
 */$h‍_once.InertCompartment(InertCompartment);
const compartmentImportNow=  (compartment, specifier)=>  {
  const { execute, exportsProxy}=   link(
    privateFields,
    moduleAliases,
    compartment,
    specifier);

  execute();
  return exportsProxy;
 };

const        CompartmentPrototype=  {
  constructor: InertCompartment,

  get globalThis() {
    return weakmapGet(privateFields, this).globalObject;
   },

  get name() {
    return weakmapGet(privateFields, this).name;
   },

  /**
   * @param {string} source is a JavaScript program grammar construction.
   * @param {object} [options]
   * @param {Array<import('./lockdown-shim').Transform>} [options.transforms]
   * @param {boolean} [options.sloppyGlobalsMode]
   * @param {object} [options.__moduleShimLexicals__]
   * @param {boolean} [options.__evadeHtmlCommentTest__]
   * @param {boolean} [options.__evadeImportExpressionTest__]
   * @param {boolean} [options.__rejectSomeDirectEvalExpressions__]
   */
  evaluate(source, options=  {}) {
    const compartmentFields=  weakmapGet(privateFields, this);
    return compartmentEvaluate(compartmentFields, source, options);
   },

  toString() {
    return '[object Compartment]';
   },

  module(specifier) {
    if( typeof specifier!==  'string') {
      throw TypeError('first argument of module() must be a string');
     }

    assertModuleHooks(this);

    const { exportsProxy}=   getDeferredExports(
      this,
      weakmapGet(privateFields, this),
      moduleAliases,
      specifier);


    return exportsProxy;
   },

        async import(specifier){
    if( typeof specifier!==  'string') {
      throw TypeError('first argument of import() must be a string');
     }

    assertModuleHooks(this);

    return promiseThen(
      load(privateFields, moduleAliases, this, specifier),
      ()=>  {
        // The namespace box is a contentious design and likely to be a breaking
        // change in an appropriately numbered future version.
        const namespace=  compartmentImportNow(
          /** @type {Compartment} */  this,
          specifier);

        return { namespace};
       });

   },

        async load(specifier){
    if( typeof specifier!==  'string') {
      throw TypeError('first argument of load() must be a string');
     }

    assertModuleHooks(this);

    return load(privateFields, moduleAliases, this, specifier);
   },

  importNow(specifier) {
    if( typeof specifier!==  'string') {
      throw TypeError('first argument of importNow() must be a string');
     }

    assertModuleHooks(this);

    return compartmentImportNow(/** @type {Compartment} */  this,  specifier);
   }};$h‍_once.CompartmentPrototype(CompartmentPrototype);


defineProperties(InertCompartment, {
  prototype: { value: CompartmentPrototype}});


/**
 * @callback MakeCompartmentConstructor
 * @param {MakeCompartmentConstructor} targetMakeCompartmentConstructor
 * @param {Record<string, any>} intrinsics
 * @param {(object: object) => void} markVirtualizedNativeFunction
 * @returns {Compartment['constructor']}
 */

/** @type {MakeCompartmentConstructor} */
const        makeCompartmentConstructor=  (
  targetMakeCompartmentConstructor,
  intrinsics,
  markVirtualizedNativeFunction)=>
     {
  function Compartment(endowments=  {}, moduleMap=  {}, options=  {}) {
    if( new.target===  undefined) {
      throw TypeError(
        "Class constructor Compartment cannot be invoked without 'new'");

     }

    // Extract options, and shallow-clone transforms.
    const {
      name=  '<unknown>',
      transforms=  [],
      __shimTransforms__=  [],
      resolveHook,
      importHook,
      moduleMapHook,
      importMetaHook}=
        options;
    const globalTransforms=  [...transforms, ...__shimTransforms__];

    // Map<FullSpecifier, ModuleCompartmentRecord>
    const moduleRecords=  new Map();
    // Map<FullSpecifier, ModuleInstance>
    const instances=  new Map();
    // Map<FullSpecifier, {ExportsProxy, ProxiedExports, activate()}>
    const deferredExports=  new Map();

    // Validate given moduleMap.
    // The module map gets translated on-demand in module-load.js and the
    // moduleMap can be invalid in ways that cannot be detected in the
    // constructor, but these checks allow us to throw early for a better
    // developer experience.
    for( const [specifier, aliasNamespace]of  entries(moduleMap||  {})) {
      if( typeof aliasNamespace===  'string') {
        // TODO implement parent module record retrieval.
        throw TypeError(
           `Cannot map module ${q(specifier)} to ${q(
            aliasNamespace)
            } in parent compartment`);

       }else if( weakmapGet(moduleAliases, aliasNamespace)===  undefined) {
        // TODO create and link a synthetic module instance from the given
        // namespace object.
        throw ReferenceError(
           `Cannot map module ${q(
            specifier)
            } because it has no known compartment in this realm`);

       }
     }

    const globalObject=  {};

    setGlobalObjectSymbolUnscopables(globalObject);

    // We must initialize all constant properties first because
    // `makeSafeEvaluator` may use them to create optimized bindings
    // in the evaluator.
    // TODO: consider merging into a single initialization if internal
    // evaluator is no longer eagerly created
    setGlobalObjectConstantProperties(globalObject);

    const { safeEvaluate}=   makeSafeEvaluator({
      globalObject,
      globalTransforms,
      sloppyGlobalsMode: false});


    setGlobalObjectMutableProperties(globalObject, {
      intrinsics,
      newGlobalPropertyNames: sharedGlobalPropertyNames,
      makeCompartmentConstructor: targetMakeCompartmentConstructor,
      markVirtualizedNativeFunction});


    // TODO: maybe add evalTaming to the Compartment constructor 3rd options?
    setGlobalObjectEvaluators(
      globalObject,
      safeEvaluate,
      markVirtualizedNativeFunction);


    assign(globalObject, endowments);

    weakmapSet(privateFields, this, {
      name:  `${name}`,
      globalTransforms,
      globalObject,
      safeEvaluate,
      resolveHook,
      importHook,
      moduleMap,
      moduleMapHook,
      importMetaHook,
      moduleRecords,
      __shimTransforms__,
      deferredExports,
      instances});

   }

  Compartment.prototype=  CompartmentPrototype;

  return Compartment;
 };$h‍_once.makeCompartmentConstructor(makeCompartmentConstructor);
})()
,
// === functors[45] ===
({   imports: $h‍_imports,   liveVar: $h‍_live,   onceVar: $h‍_once,   importMeta: $h‍____meta, }) => (function () {   let FERAL_FUNCTION,Float32Array,Map,Set,String,getOwnPropertyDescriptor,getPrototypeOf,iterateArray,iterateMap,iterateSet,iterateString,matchAllRegExp,matchAllSymbol,regexpPrototype,globalThis,InertCompartment;$h‍_imports([["./commons.js", [["FERAL_FUNCTION", [$h‍_a => (FERAL_FUNCTION = $h‍_a)]],["Float32Array", [$h‍_a => (Float32Array = $h‍_a)]],["Map", [$h‍_a => (Map = $h‍_a)]],["Set", [$h‍_a => (Set = $h‍_a)]],["String", [$h‍_a => (String = $h‍_a)]],["getOwnPropertyDescriptor", [$h‍_a => (getOwnPropertyDescriptor = $h‍_a)]],["getPrototypeOf", [$h‍_a => (getPrototypeOf = $h‍_a)]],["iterateArray", [$h‍_a => (iterateArray = $h‍_a)]],["iterateMap", [$h‍_a => (iterateMap = $h‍_a)]],["iterateSet", [$h‍_a => (iterateSet = $h‍_a)]],["iterateString", [$h‍_a => (iterateString = $h‍_a)]],["matchAllRegExp", [$h‍_a => (matchAllRegExp = $h‍_a)]],["matchAllSymbol", [$h‍_a => (matchAllSymbol = $h‍_a)]],["regexpPrototype", [$h‍_a => (regexpPrototype = $h‍_a)]],["globalThis", [$h‍_a => (globalThis = $h‍_a)]]]],["./compartment.js", [["InertCompartment", [$h‍_a => (InertCompartment = $h‍_a)]]]]]);   


















/**
 * Object.getConstructorOf()
 * Helper function to improve readability, similar to Object.getPrototypeOf().
 *
 * @param {object} obj
 */
function getConstructorOf(obj) {
  return getPrototypeOf(obj).constructor;
 }

// getAnonymousIntrinsics uses a utility function to construct an arguments
// object, since it cannot have one of its own and also be a const export.
function makeArguments() {
  // eslint-disable-next-line prefer-rest-params
  return arguments;
 }

/**
 * getAnonymousIntrinsics()
 * Get the intrinsics not otherwise reachable by named own property
 * traversal from the global object.
 *
 * @returns {object}
 */
const        getAnonymousIntrinsics=  ()=>  {
  const InertFunction=  FERAL_FUNCTION.prototype.constructor;

  // 9.2.4.1 %ThrowTypeError%

  const argsCalleeDesc=  getOwnPropertyDescriptor(makeArguments(), 'callee');
  const ThrowTypeError=  argsCalleeDesc&&  argsCalleeDesc.get;

  // 21.1.5.2 The %StringIteratorPrototype% Object

  // eslint-disable-next-line no-new-wrappers
  const StringIteratorObject=  iterateString(new String());
  const StringIteratorPrototype=  getPrototypeOf(StringIteratorObject);

  // 21.2.7.1 The %RegExpStringIteratorPrototype% Object
  const RegExpStringIterator=
    regexpPrototype[matchAllSymbol]&&  matchAllRegExp(/./);
  const RegExpStringIteratorPrototype=
    RegExpStringIterator&&  getPrototypeOf(RegExpStringIterator);

  // 22.1.5.2 The %ArrayIteratorPrototype% Object

  // eslint-disable-next-line no-array-constructor
  const ArrayIteratorObject=  iterateArray([]);
  const ArrayIteratorPrototype=  getPrototypeOf(ArrayIteratorObject);

  // 22.2.1 The %TypedArray% Intrinsic Object

  const TypedArray=  getPrototypeOf(Float32Array);

  // 23.1.5.2 The %MapIteratorPrototype% Object

  const MapIteratorObject=  iterateMap(new Map());
  const MapIteratorPrototype=  getPrototypeOf(MapIteratorObject);

  // 23.2.5.2 The %SetIteratorPrototype% Object

  const SetIteratorObject=  iterateSet(new Set());
  const SetIteratorPrototype=  getPrototypeOf(SetIteratorObject);

  // 25.1.2 The %IteratorPrototype% Object

  const IteratorPrototype=  getPrototypeOf(ArrayIteratorPrototype);

  // 25.2.1 The GeneratorFunction Constructor

  // eslint-disable-next-line no-empty-function
  function* GeneratorFunctionInstance() { }
  const GeneratorFunction=  getConstructorOf(GeneratorFunctionInstance);

  // 25.2.3 Properties of the GeneratorFunction Prototype Object

  const Generator=  GeneratorFunction.prototype;

  // 25.3.1 The AsyncGeneratorFunction Constructor

  // eslint-disable-next-line no-empty-function
  async function* AsyncGeneratorFunctionInstance() { }
  const AsyncGeneratorFunction=  getConstructorOf(
    AsyncGeneratorFunctionInstance);


  // 25.3.2.2 AsyncGeneratorFunction.prototype
  const AsyncGenerator=  AsyncGeneratorFunction.prototype;
  // 25.5.1 Properties of the AsyncGenerator Prototype Object
  const AsyncGeneratorPrototype=  AsyncGenerator.prototype;
  const AsyncIteratorPrototype=  getPrototypeOf(AsyncGeneratorPrototype);

  // 25.7.1 The AsyncFunction Constructor

  // eslint-disable-next-line no-empty-function
  async function AsyncFunctionInstance() { }
  const AsyncFunction=  getConstructorOf(AsyncFunctionInstance);

  const intrinsics=  {
    '%InertFunction%': InertFunction,
    '%ArrayIteratorPrototype%': ArrayIteratorPrototype,
    '%InertAsyncFunction%': AsyncFunction,
    '%AsyncGenerator%': AsyncGenerator,
    '%InertAsyncGeneratorFunction%': AsyncGeneratorFunction,
    '%AsyncGeneratorPrototype%': AsyncGeneratorPrototype,
    '%AsyncIteratorPrototype%': AsyncIteratorPrototype,
    '%Generator%': Generator,
    '%InertGeneratorFunction%': GeneratorFunction,
    '%IteratorPrototype%': IteratorPrototype,
    '%MapIteratorPrototype%': MapIteratorPrototype,
    '%RegExpStringIteratorPrototype%': RegExpStringIteratorPrototype,
    '%SetIteratorPrototype%': SetIteratorPrototype,
    '%StringIteratorPrototype%': StringIteratorPrototype,
    '%ThrowTypeError%': ThrowTypeError,
    '%TypedArray%': TypedArray,
    '%InertCompartment%': InertCompartment};


  if( globalThis.Iterator) {
    intrinsics['%IteratorHelperPrototype%']=  getPrototypeOf(
      // eslint-disable-next-line @endo/no-polymorphic-call
      globalThis.Iterator.from([]).take(0));

    intrinsics['%WrapForValidIteratorPrototype%']=  getPrototypeOf(
      // eslint-disable-next-line @endo/no-polymorphic-call
      globalThis.Iterator.from({ next() { }}));

   }

  if( globalThis.AsyncIterator) {
    intrinsics['%AsyncIteratorHelperPrototype%']=  getPrototypeOf(
      // eslint-disable-next-line @endo/no-polymorphic-call
      globalThis.AsyncIterator.from([]).take(0));

    intrinsics['%WrapForValidAsyncIteratorPrototype%']=  getPrototypeOf(
      // eslint-disable-next-line @endo/no-polymorphic-call
      globalThis.AsyncIterator.from({ next() { }}));

   }

  return intrinsics;
 };$h‍_once.getAnonymousIntrinsics(getAnonymousIntrinsics);
})()
,
// === functors[46] ===
({   imports: $h‍_imports,   liveVar: $h‍_live,   onceVar: $h‍_once,   importMeta: $h‍____meta, }) => (function () {   let TypeError,freeze;$h‍_imports([["./commons.js", [["TypeError", [$h‍_a => (TypeError = $h‍_a)]],["freeze", [$h‍_a => (freeze = $h‍_a)]]]]]);   


const        tameHarden=  (safeHarden, hardenTaming)=>  {
  if( hardenTaming!==  'safe'&&  hardenTaming!==  'unsafe') {
    throw TypeError( `unrecognized fakeHardenOption ${hardenTaming}`);
   }

  if( hardenTaming===  'safe') {
    return safeHarden;
   }

  // In on the joke
  Object.isExtensible=  ()=>  false;
  Object.isFrozen=  ()=>  true;
  Object.isSealed=  ()=>  true;
  Reflect.isExtensible=  ()=>  false;

  if( safeHarden.isFake) {
    // The "safe" hardener is already a fake hardener.
    // Just use it.
    return safeHarden;
   }

  const fakeHarden=  (arg)=>arg;
  fakeHarden.isFake=  true;
  return freeze(fakeHarden);
 };$h‍_once.tameHarden(tameHarden);
freeze(tameHarden);
})()
,
// === functors[47] ===
({   imports: $h‍_imports,   liveVar: $h‍_live,   onceVar: $h‍_once,   importMeta: $h‍____meta, }) => (function () {   let Symbol,entries,fromEntries,getOwnPropertyDescriptors,defineProperties,arrayMap;$h‍_imports([["./commons.js", [["Symbol", [$h‍_a => (Symbol = $h‍_a)]],["entries", [$h‍_a => (entries = $h‍_a)]],["fromEntries", [$h‍_a => (fromEntries = $h‍_a)]],["getOwnPropertyDescriptors", [$h‍_a => (getOwnPropertyDescriptors = $h‍_a)]],["defineProperties", [$h‍_a => (defineProperties = $h‍_a)]],["arrayMap", [$h‍_a => (arrayMap = $h‍_a)]]]]]);   








/**
 * This taming provides a tamed alternative to the original `Symbol` constructor
 * that starts off identical, except that all its properties are "temporarily"
 * configurable. The original `Symbol` constructor remains unmodified on
 * the start compartment's global. The tamed alternative is used as the shared
 * `Symbol` constructor on constructed compartments.
 *
 * Starting these properties as configurable assumes two succeeding phases of
 * processing: A whitelisting phase, that
 * removes all properties not on the whitelist (which requires them to be
 * configurable) and a global hardening step that freezes all primordials,
 * returning these properties to their expected non-configurable status.
 *
 * The ses shim is constructed to eventually enable vetted shims to run between
 * repair and global hardening. However, such vetted shims would normally
 * run in the start compartment, which continues to use the original unmodified
 * `Symbol`, so they should not normally be affected by the temporary
 * configurability of these properties.
 *
 * Note that the spec refers to the global `Symbol` function as the
 * ["Symbol Constructor"](https://tc39.es/ecma262/multipage/fundamental-objects.html#sec-symbol-constructor)
 * even though it has a call behavior (can be called as a function) and does not
 * not have a construct behavior (cannot be called with `new`). Accordingly,
 * to tame it, we must replace it with a function without a construct
 * behavior.
 */
const        tameSymbolConstructor=  ()=>  {
  const OriginalSymbol=  Symbol;
  const SymbolPrototype=  OriginalSymbol.prototype;

  const SharedSymbol=  {
    Symbol(description) {
      return OriginalSymbol(description);
     }}.
    Symbol;

  defineProperties(SymbolPrototype, {
    constructor: {
      value: SharedSymbol
      // leave other `constructor` attributes as is
}});


  const originalDescsEntries=  entries(
    getOwnPropertyDescriptors(OriginalSymbol));

  const descs=  fromEntries(
    arrayMap(originalDescsEntries, ([name, desc])=>  [
      name,
      { ...desc, configurable: true}]));


  defineProperties(SharedSymbol, descs);

  return { '%SharedSymbol%': SharedSymbol};
 };$h‍_once.tameSymbolConstructor(tameSymbolConstructor);
})()
,
// === functors[48] ===
({   imports: $h‍_imports,   liveVar: $h‍_live,   onceVar: $h‍_once,   importMeta: $h‍____meta, }) => (function () {   let makeEnvironmentCaptor,FERAL_FUNCTION,FERAL_EVAL,TypeError,arrayFilter,globalThis,is,ownKeys,stringSplit,noEvalEvaluate,makeHardener,makeIntrinsicsCollector,whitelistIntrinsics,tameFunctionConstructors,tameDateConstructor,tameMathObject,tameRegExpConstructor,enablePropertyOverrides,tameLocaleMethods,setGlobalObjectConstantProperties,setGlobalObjectMutableProperties,setGlobalObjectEvaluators,makeSafeEvaluator,initialGlobalPropertyNames,tameFunctionToString,tameDomains,tameConsole,tameErrorConstructor,assert,makeAssert,getAnonymousIntrinsics,makeCompartmentConstructor,tameHarden,tameSymbolConstructor;$h‍_imports([["@endo/env-options", [["makeEnvironmentCaptor", [$h‍_a => (makeEnvironmentCaptor = $h‍_a)]]]],["./commons.js", [["FERAL_FUNCTION", [$h‍_a => (FERAL_FUNCTION = $h‍_a)]],["FERAL_EVAL", [$h‍_a => (FERAL_EVAL = $h‍_a)]],["TypeError", [$h‍_a => (TypeError = $h‍_a)]],["arrayFilter", [$h‍_a => (arrayFilter = $h‍_a)]],["globalThis", [$h‍_a => (globalThis = $h‍_a)]],["is", [$h‍_a => (is = $h‍_a)]],["ownKeys", [$h‍_a => (ownKeys = $h‍_a)]],["stringSplit", [$h‍_a => (stringSplit = $h‍_a)]],["noEvalEvaluate", [$h‍_a => (noEvalEvaluate = $h‍_a)]]]],["./make-hardener.js", [["makeHardener", [$h‍_a => (makeHardener = $h‍_a)]]]],["./intrinsics.js", [["makeIntrinsicsCollector", [$h‍_a => (makeIntrinsicsCollector = $h‍_a)]]]],["./permits-intrinsics.js", [["default", [$h‍_a => (whitelistIntrinsics = $h‍_a)]]]],["./tame-function-constructors.js", [["default", [$h‍_a => (tameFunctionConstructors = $h‍_a)]]]],["./tame-date-constructor.js", [["default", [$h‍_a => (tameDateConstructor = $h‍_a)]]]],["./tame-math-object.js", [["default", [$h‍_a => (tameMathObject = $h‍_a)]]]],["./tame-regexp-constructor.js", [["default", [$h‍_a => (tameRegExpConstructor = $h‍_a)]]]],["./enable-property-overrides.js", [["default", [$h‍_a => (enablePropertyOverrides = $h‍_a)]]]],["./tame-locale-methods.js", [["default", [$h‍_a => (tameLocaleMethods = $h‍_a)]]]],["./global-object.js", [["setGlobalObjectConstantProperties", [$h‍_a => (setGlobalObjectConstantProperties = $h‍_a)]],["setGlobalObjectMutableProperties", [$h‍_a => (setGlobalObjectMutableProperties = $h‍_a)]],["setGlobalObjectEvaluators", [$h‍_a => (setGlobalObjectEvaluators = $h‍_a)]]]],["./make-safe-evaluator.js", [["makeSafeEvaluator", [$h‍_a => (makeSafeEvaluator = $h‍_a)]]]],["./permits.js", [["initialGlobalPropertyNames", [$h‍_a => (initialGlobalPropertyNames = $h‍_a)]]]],["./tame-function-tostring.js", [["tameFunctionToString", [$h‍_a => (tameFunctionToString = $h‍_a)]]]],["./tame-domains.js", [["tameDomains", [$h‍_a => (tameDomains = $h‍_a)]]]],["./error/tame-console.js", [["tameConsole", [$h‍_a => (tameConsole = $h‍_a)]]]],["./error/tame-error-constructor.js", [["default", [$h‍_a => (tameErrorConstructor = $h‍_a)]]]],["./error/assert.js", [["assert", [$h‍_a => (assert = $h‍_a)]],["makeAssert", [$h‍_a => (makeAssert = $h‍_a)]]]],["./get-anonymous-intrinsics.js", [["getAnonymousIntrinsics", [$h‍_a => (getAnonymousIntrinsics = $h‍_a)]]]],["./compartment.js", [["makeCompartmentConstructor", [$h‍_a => (makeCompartmentConstructor = $h‍_a)]]]],["./tame-harden.js", [["tameHarden", [$h‍_a => (tameHarden = $h‍_a)]]]],["./tame-symbol-constructor.js", [["tameSymbolConstructor", [$h‍_a => (tameSymbolConstructor = $h‍_a)]]]]]);   






















































/** @typedef {import('../types.js').LockdownOptions} LockdownOptions */

const { Fail, details: d, quote: q}=   assert;

/** @type {Error=} */
let priorRepairIntrinsics;

/** @type {Error=} */
let priorHardenIntrinsics;

// Build a harden() with an empty fringe.
// Gate it on lockdown.
/**
 * @template T
 * @param {T} ref
 * @returns {T}
 */
const safeHarden=  makeHardener();

/**
 * @callback Transform
 * @param {string} source
 * @returns {string}
 */

/**
 * @callback CompartmentConstructor
 * @param {object} endowments
 * @param {object} moduleMap
 * @param {object} [options]
 * @param {Array<Transform>} [options.transforms]
 * @param {Array<Transform>} [options.__shimTransforms__]
 */

// TODO https://github.com/endojs/endo/issues/814
// Lockdown currently allows multiple calls provided that the specified options
// of every call agree.  With experience, we have observed that lockdown should
// only ever need to be called once and that simplifying lockdown will improve
// the quality of audits.

const assertDirectEvalAvailable=  ()=>  {
  let allowed=  false;
  try {
    allowed=  FERAL_FUNCTION(
      'eval',
      'SES_changed',
       `\
        eval("SES_changed = true");
        return SES_changed;
      `)(
      FERAL_EVAL, false);
    // If we get here and SES_changed stayed false, that means the eval was sloppy
    // and indirect, which generally creates a new global.
    // We are going to throw an exception for failing to initialize SES, but
    // good neighbors clean up.
    if( !allowed) {
      delete globalThis.SES_changed;
     }
   }catch( _error) {
    // We reach here if eval is outright forbidden by a Content Security Policy.
    // We allow this for SES usage that delegates the responsibility to isolate
    // guest code to production code generation.
    allowed=  true;
   }
  if( !allowed) {
    // See https://github.com/endojs/endo/blob/master/packages/ses/error-codes/SES_DIRECT_EVAL.md
    throw TypeError(
       `SES cannot initialize unless 'eval' is the original intrinsic 'eval', suitable for direct-eval (dynamically scoped eval) (SES_DIRECT_EVAL)`);

   }
 };

/**
 * @param {LockdownOptions} [options]
 */
const        repairIntrinsics=  (options=  {})=>  {
  // First time, absent options default to 'safe'.
  // Subsequent times, absent options default to first options.
  // Thus, all present options must agree with first options.
  // Reconstructing `option` here also ensures that it is a well
  // behaved record, with only own data properties.
  //
  // The `overrideTaming` is not a safety issue. Rather it is a tradeoff
  // between code compatibility, which is better with the `'moderate'`
  // setting, and tool compatibility, which is better with the `'min'`
  // setting. See
  // https://github.com/Agoric/SES-shim/blob/master/packages/ses/README.md#enabling-override-by-assignment)
  // for an explanation of when to use which.
  //
  // The `stackFiltering` is not a safety issue. Rather it is a tradeoff
  // between relevance and completeness of the stack frames shown on the
  // console. Setting`stackFiltering` to `'verbose'` applies no filters, providing
  // the raw stack frames that can be quite versbose. Setting
  // `stackFrameFiltering` to`'concise'` limits the display to the stack frame
  // information most likely to be relevant, eliminating distracting frames
  // such as those from the infrastructure. However, the bug you're trying to
  // track down might be in the infrastrure, in which case the `'verbose'` setting
  // is useful. See
  // [`stackFiltering` options](https://github.com/Agoric/SES-shim/blob/master/packages/ses/lockdown-options.md#stackfiltering-options)
  // for an explanation.

  const { getEnvironmentOption: getenv}=   makeEnvironmentCaptor(globalThis);

  const {
    errorTaming=  getenv('LOCKDOWN_ERROR_TAMING', 'safe'),
    errorTrapping=  getenv('LOCKDOWN_ERROR_TRAPPING', 'platform'),
    unhandledRejectionTrapping=  getenv(
      'LOCKDOWN_UNHANDLED_REJECTION_TRAPPING',
      'report'),

    regExpTaming=  getenv('LOCKDOWN_REGEXP_TAMING', 'safe'),
    localeTaming=  getenv('LOCKDOWN_LOCALE_TAMING', 'safe'),
    consoleTaming=  getenv('LOCKDOWN_CONSOLE_TAMING', 'safe'),
    overrideTaming=  getenv('LOCKDOWN_OVERRIDE_TAMING', 'moderate'),
    stackFiltering=  getenv('LOCKDOWN_STACK_FILTERING', 'concise'),
    domainTaming=  getenv('LOCKDOWN_DOMAIN_TAMING', 'safe'),
    evalTaming=  getenv('LOCKDOWN_EVAL_TAMING', 'safeEval'),
    overrideDebug=  arrayFilter(
      stringSplit(getenv('LOCKDOWN_OVERRIDE_DEBUG', ''), ','),
      /** @param {string} debugName */
      (debugName)=>debugName!==  ''),

    __hardenTaming__=  getenv('LOCKDOWN_HARDEN_TAMING', 'safe'),
    dateTaming=  'safe', // deprecated
    mathTaming=  'safe', // deprecated
    ...extraOptions}=
      options;

  evalTaming===  'unsafeEval'||
    evalTaming===  'safeEval'||
    evalTaming===  'noEval'||
    Fail `lockdown(): non supported option evalTaming: ${q(evalTaming)}`;

  // Assert that only supported options were passed.
  // Use Reflect.ownKeys to reject symbol-named properties as well.
  const extraOptionsNames=  ownKeys(extraOptions);
  extraOptionsNames.length===  0||
    Fail `lockdown(): non supported option ${q(extraOptionsNames)}`;

  priorRepairIntrinsics===  undefined||
    // eslint-disable-next-line @endo/no-polymorphic-call
    assert.fail(
      d `Already locked down at ${priorRepairIntrinsics} (SES_ALREADY_LOCKED_DOWN)`,
      TypeError);

  // See https://github.com/endojs/endo/blob/master/packages/ses/error-codes/SES_ALREADY_LOCKED_DOWN.md
  priorRepairIntrinsics=  TypeError('Prior lockdown (SES_ALREADY_LOCKED_DOWN)');
  // Tease V8 to generate the stack string and release the closures the stack
  // trace retained:
  priorRepairIntrinsics.stack;

  assertDirectEvalAvailable();

  /**
   * Because of packagers and bundlers, etc, multiple invocations of lockdown
   * might happen in separate instantiations of the source of this module.
   * In that case, each one sees its own `firstOptions` variable, so the test
   * above will not detect that lockdown has already happened. We
   * unreliably test some telltale signs that lockdown has run, to avoid
   * trying to lock down a locked down environment. Although the test is
   * unreliable, this is consistent with the SES threat model. SES provides
   * security only if it runs first in a given realm, or if everything that
   * runs before it is SES-aware and cooperative. Neither SES nor anything
   * can protect itself from corrupting code that runs first. For these
   * purposes, code that turns a realm into something that passes these
   * tests without actually locking down counts as corrupting code.
   *
   * The specifics of what this tests for may change over time, but it
   * should be consistent with any setting of the lockdown options.
   */
  const seemsToBeLockedDown=  ()=>  {
    return(
      globalThis.Function.prototype.constructor!==  globalThis.Function&&
      // @ts-ignore harden is absent on globalThis type def.
      typeof globalThis.harden===  'function'&&
      // @ts-ignore lockdown is absent on globalThis type def.
      typeof globalThis.lockdown===  'function'&&
      globalThis.Date.prototype.constructor!==  globalThis.Date&&
      typeof globalThis.Date.now===  'function'&&
      // @ts-ignore does not recognize that Date constructor is a special
      // Function.
      // eslint-disable-next-line @endo/no-polymorphic-call
      is(globalThis.Date.prototype.constructor.now(), NaN));

   };

  if( seemsToBeLockedDown()) {
    // See https://github.com/endojs/endo/blob/master/packages/ses/error-codes/SES_MULTIPLE_INSTANCES.md
    throw TypeError(
       `Already locked down but not by this SES instance (SES_MULTIPLE_INSTANCES)`);

   }

  /**
   * 1. TAME powers & gather intrinsics first.
   */

  tameDomains(domainTaming);

  // Replace Function.prototype.toString with one that recognizes
  // shimmed functions as honorary native functions.
  const markVirtualizedNativeFunction=  tameFunctionToString();

  const { addIntrinsics, completePrototypes, finalIntrinsics}=
    makeIntrinsicsCollector();

  const tamedHarden=  tameHarden(safeHarden, __hardenTaming__);
  addIntrinsics({ harden: tamedHarden});

  addIntrinsics(tameFunctionConstructors());

  addIntrinsics(tameDateConstructor(dateTaming));
  addIntrinsics(tameErrorConstructor(errorTaming, stackFiltering));
  addIntrinsics(tameMathObject(mathTaming));
  addIntrinsics(tameRegExpConstructor(regExpTaming));
  addIntrinsics(tameSymbolConstructor());

  addIntrinsics(getAnonymousIntrinsics());

  completePrototypes();

  const intrinsics=  finalIntrinsics();

  /**
   * Wrap console unless suppressed.
   * At the moment, the console is considered a host power in the start
   * compartment, and not a primordial. Hence it is absent from the whilelist
   * and bypasses the intrinsicsCollector.
   *
   * @type {((error: any) => string | undefined) | undefined}
   */
  let optGetStackString;
  if( errorTaming!==  'unsafe') {
    optGetStackString=  intrinsics['%InitialGetStackString%'];
   }
  const consoleRecord=  tameConsole(
    consoleTaming,
    errorTrapping,
    unhandledRejectionTrapping,
    optGetStackString);

  globalThis.console=  /** @type {Console} */  consoleRecord.console;

  // @ts-ignore assert is absent on globalThis type def.
  if( errorTaming===  'unsafe'&&  globalThis.assert===  assert) {
    // If errorTaming is 'unsafe' we replace the global assert with
    // one whose `details` template literal tag does not redact
    // unmarked substitution values. IOW, it blabs information that
    // was supposed to be secret from callers, as an aid to debugging
    // at a further cost in safety.
    // @ts-ignore assert is absent on globalThis type def.
    globalThis.assert=  makeAssert(undefined, true);
   }

  // Replace *Locale* methods with their non-locale equivalents
  tameLocaleMethods(intrinsics, localeTaming);

  /**
   * 2. WHITELIST to standardize the environment.
   */

  // Remove non-standard properties.
  // All remaining function encountered during whitelisting are
  // branded as honorary native functions.
  whitelistIntrinsics(intrinsics, markVirtualizedNativeFunction);

  // Initialize the powerful initial global, i.e., the global of the
  // start compartment, from the intrinsics.

  setGlobalObjectConstantProperties(globalThis);

  setGlobalObjectMutableProperties(globalThis, {
    intrinsics,
    newGlobalPropertyNames: initialGlobalPropertyNames,
    makeCompartmentConstructor,
    markVirtualizedNativeFunction});


  if( evalTaming===  'noEval') {
    setGlobalObjectEvaluators(
      globalThis,
      noEvalEvaluate,
      markVirtualizedNativeFunction);

   }else if( evalTaming===  'safeEval') {
    const { safeEvaluate}=   makeSafeEvaluator({ globalObject: globalThis});
    setGlobalObjectEvaluators(
      globalThis,
      safeEvaluate,
      markVirtualizedNativeFunction);

   }else if( evalTaming===  'unsafeEval') {
    // Leave eval function and Function constructor of the initial compartment in-tact.
    // Other compartments will not have access to these evaluators unless a guest program
    // escapes containment.
   }

  /**
   * 3. HARDEN to share the intrinsics.
   *
   * We define hardenIntrinsics here so that options are in scope, but return
   * it to the caller because we intend to eventually allow vetted shims to run
   * between repairs and the hardening of intrinsics and so we can benchmark
   * repair separately from hardening.
   */

  const hardenIntrinsics=  ()=>  {
    priorHardenIntrinsics===  undefined||
      // eslint-disable-next-line @endo/no-polymorphic-call
      assert.fail(
        d `Already locked down at ${priorHardenIntrinsics} (SES_ALREADY_LOCKED_DOWN)`,
        TypeError);

    // See https://github.com/endojs/endo/blob/master/packages/ses/error-codes/SES_ALREADY_LOCKED_DOWN.md
    priorHardenIntrinsics=  TypeError(
      'Prior lockdown (SES_ALREADY_LOCKED_DOWN)');

    // Tease V8 to generate the stack string and release the closures the stack
    // trace retained:
    priorHardenIntrinsics.stack;

    // Circumvent the override mistake.
    // TODO consider moving this to the end of the repair phase, and
    // therefore before vetted shims rather than afterwards. It is not
    // clear yet which is better.
    // @ts-ignore enablePropertyOverrides does its own input validation
    enablePropertyOverrides(intrinsics, overrideTaming, overrideDebug);

    // Finally register and optionally freeze all the intrinsics. This
    // must be the operation that modifies the intrinsics.
    tamedHarden(intrinsics);

    return tamedHarden;
   };

  return hardenIntrinsics;
 };$h‍_once.repairIntrinsics(repairIntrinsics);
})()
,
// === functors[49] ===
({   imports: $h‍_imports,   liveVar: $h‍_live,   onceVar: $h‍_once,   importMeta: $h‍____meta, }) => (function () {   let globalThis,repairIntrinsics;$h‍_imports([["./assert-sloppy-mode.js", []],["./commons.js", [["globalThis", [$h‍_a => (globalThis = $h‍_a)]]]],["./lockdown.js", [["repairIntrinsics", [$h‍_a => (repairIntrinsics = $h‍_a)]]]]]);   








/**
 * @param {import('./lockdown.js').LockdownOptions} options
 */
globalThis.lockdown=  (options)=>{
  const hardenIntrinsics=  repairIntrinsics(options);
  globalThis.harden=  hardenIntrinsics();
 };

/**
 * @param {import('./lockdown.js').LockdownOptions} options
 */
globalThis.repairIntrinsics=  (options)=>{
  const hardenIntrinsics=  repairIntrinsics(options);
  // Reveal hardenIntrinsics after repairs.
  globalThis.hardenIntrinsics=  ()=>  {
    // Reveal harden after hardenIntrinsics.
    // Harden is dangerous before hardenIntrinsics because hardening just
    // about anything will inadvertently render intrinsics irreparable.
    // Also, for modules that must work both before or after lockdown (code
    // that is portable between JS and SES), the existence of harden in global
    // scope signals whether such code should attempt to use harden in the
    // defense of its own API.
    // @ts-ignore harden not yet recognized on globalThis.
    globalThis.harden=  hardenIntrinsics();
   };
 };
})()
,
// === functors[50] ===
({   imports: $h‍_imports,   liveVar: $h‍_live,   onceVar: $h‍_once,   importMeta: $h‍____meta, }) => (function () {   let globalThis,makeCompartmentConstructor,tameFunctionToString,getGlobalIntrinsics;$h‍_imports([["./commons.js", [["globalThis", [$h‍_a => (globalThis = $h‍_a)]]]],["./compartment.js", [["makeCompartmentConstructor", [$h‍_a => (makeCompartmentConstructor = $h‍_a)]]]],["./tame-function-tostring.js", [["tameFunctionToString", [$h‍_a => (tameFunctionToString = $h‍_a)]]]],["./intrinsics.js", [["getGlobalIntrinsics", [$h‍_a => (getGlobalIntrinsics = $h‍_a)]]]]]);   






const markVirtualizedNativeFunction=  tameFunctionToString();

// @ts-ignore Compartment is definitely on globalThis.
globalThis.Compartment=  makeCompartmentConstructor(
  makeCompartmentConstructor,
  getGlobalIntrinsics(globalThis),
  markVirtualizedNativeFunction);
})()
,
// === functors[51] ===
({   imports: $h‍_imports,   liveVar: $h‍_live,   onceVar: $h‍_once,   importMeta: $h‍____meta, }) => (function () {   let globalThis,assert;$h‍_imports([["./commons.js", [["globalThis", [$h‍_a => (globalThis = $h‍_a)]]]],["./error/assert.js", [["assert", [$h‍_a => (assert = $h‍_a)]]]]]);   


globalThis.assert=  assert;
})()
,
// === functors[52] ===
({   imports: $h‍_imports,   liveVar: $h‍_live,   onceVar: $h‍_once,   importMeta: $h‍____meta, }) => (function () {   $h‍_imports([["./src/lockdown-shim.js", []],["./src/compartment-shim.js", []],["./src/assert-shim.js", []]]);   
})()
,
// === functors[53] ===
({   imports: $h‍_imports,   liveVar: $h‍_live,   onceVar: $h‍_once,   importMeta: $h‍____meta, }) => (function () {   $h‍_imports([]);   /*
Initial version authored by Brian Kim:
https://github.com/nodejs/node/issues/17469#issuecomment-685216777

This is free and unencumbered software released into the public domain.

Anyone is free to copy, modify, publish, use, compile, sell, or
distribute this software, either in source code form or as a compiled
binary, for any purpose, commercial or non-commercial, and by any
means.

In jurisdictions that recognize copyright laws, the author or authors
of this software dedicate any and all copyright interest in the
software to the public domain. We make this dedication for the benefit
of the public at large and to the detriment of our heirs and
successors. We intend this dedication to be an overt act of
relinquishment in perpetuity of all present and future rights to this
software under copyright law.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.

For more information, please refer to <http://unlicense.org/>
*/

const isObject=  (value)=>Object(value)===  value;

/**
 * @template [T=any]
 * @typedef {object} Deferred
 * @property {(value?: import("./types.js").ERef<T> ) => void} resolve
 * @property {(err?: any ) => void} reject
 */

/**
 * @typedef { never
 *  | {settled: false, deferreds: Set<Deferred>}
 *  | {settled: true, deferreds?: undefined}
 * } PromiseMemoRecord
 */

// Keys are the values passed to race, values are a record of data containing a
// set of deferreds and whether the value has settled.
/** @type {WeakMap<object, PromiseMemoRecord>} */
const knownPromises=  new WeakMap();

/**
 * @param {PromiseMemoRecord | undefined} record
 * @returns {Set<Deferred>}
 */
const markSettled=  (record)=>{
  if( !record||  record.settled) {
    return new Set();
   }

  const { deferreds}=   record;
  Object.assign(record, {
    deferreds: undefined,
    settled: true});

  Object.freeze(record);
  return deferreds;
 };

/**
 *
 * @param {any} value
 * @returns {PromiseMemoRecord}
 */
const getMemoRecord=  (value)=>{
  if( !isObject(value)) {
    // If the contender is a primitive, attempting to use it as a key in the
    // weakmap would throw an error. Luckily, it is safe to call
    // `Promise.resolve(contender).then` on a primitive value multiple times
    // because the promise fulfills immediately. So we fake a settled record.
    return harden({ settled: true});
   }

  let record=  knownPromises.get(value);

  if( !record) {
    record=  { deferreds: new Set(), settled: false};
    knownPromises.set(value, record);
    // This call to `then` happens once for the lifetime of the value.
    Promise.resolve(value).then(
      (val)=>{
        for( const { resolve}of   markSettled(record)) {
          resolve(val);
         }
       },
      (err)=>{
        for( const { reject}of   markSettled(record)) {
          reject(err);
         }
       });

   }
  return record;
 };

const { race}=   {
  /**
   * Creates a Promise that is resolved or rejected when any of the provided Promises are resolved
   * or rejected.
   *
   * Unlike `Promise.race` it cleans up after itself so a non-resolved value doesn't hold onto
   * the result promise.
   *
   * @template T
   * @template {PromiseConstructor} [P=PromiseConstructor]
   * @this {P}
   * @param {Iterable<T>} values An iterable of Promises.
   * @returns {Promise<Awaited<T>>} A new Promise.
   */
  race(values) {
    let deferred;
    /** @type {T[]} */
    const cachedValues=  [];
    const C=  this;
    const result=  new C((resolve, reject)=>  {
      deferred=  { resolve, reject};
      for( const value of values) {
        cachedValues.push(value);
        const { settled, deferreds}=   getMemoRecord(value);
        if( settled) {
          // If the contender is settled (including primitives), it is safe
          // to call `Promise.resolve(value).then` on it.
          C.resolve(value).then(resolve, reject);
         }else {
          deferreds.add(deferred);
         }
       }
     });

    // The finally callback executes when any value settles, preventing any of
    // the unresolved values from retaining a reference to the resolved value.
    return result.finally(()=>  {
      for( const value of cachedValues) {
        const { deferreds}=   getMemoRecord(value);
        if( deferreds) {
          deferreds.delete(deferred);
         }
       }
     });
   }};$h‍_once.race(race);
})()
,
// === functors[54] ===
({   imports: $h‍_imports,   liveVar: $h‍_live,   onceVar: $h‍_once,   importMeta: $h‍____meta, }) => (function () {   let memoRace;$h‍_imports([["./src/memo-race.js", [["memoRace", [$h‍_a => (memoRace = $h‍_a)]]]]]);   

// Unconditionally replace with a non-leaking version
Promise.race=  memoRace;
})()
,
// === functors[55] ===
({   imports: $h‍_imports,   liveVar: $h‍_live,   onceVar: $h‍_once,   importMeta: $h‍____meta, }) => (function () {   $h‍_imports([]);   /* global globalThis */

// The post lockdown thunk.
const{default:$c‍_default}={default:()=>{
  // Even on non-v8, we tame the start compartment's Error constructor so
  // this assignment is not rejected, even if it does nothing.
  Error.stackTraceLimit=  Infinity;

  harden(TextEncoder);
  harden(TextDecoder);
  harden(globalThis.URL); // Absent only on XSnap
  harden(globalThis.Base64); // Present only on XSnap
 }};$h‍_once.default($c‍_default);
})()
,
// === functors[56] ===
({   imports: $h‍_imports,   liveVar: $h‍_live,   onceVar: $h‍_once,   importMeta: $h‍____meta, }) => (function () {   let postLockdown;$h‍_imports([["ses", []],["./post.js", [["default", [$h‍_a => (postLockdown = $h‍_a)]]]]]);   









const rawLockdown=  globalThis.lockdown;

/** @type {typeof rawLockdown} */
const        lockdown=  (defaultOptions)=>{
  // For testing under Ava, and also sometimes for testing and debugging in
  // general, when safety is not needed, you perhaps want to use
  // packages/SwingSet/tools/install-ses-debug.js instead of this one.
  // If you're using a prepare-test-env-ava.js, it is probably already doing that
  // for you.

  // The `@endo/init` package exists so the "main" of production code
  // can start with the following import or its equivalent.
  // ```js
  // import '@endo/init';
  // ```
  // But production code must also be tested. Normal ocap discipline of passing
  // explicit arguments into the `lockdown`
  // call would require an awkward structuring of start modules, since
  // the `init` module calls `lockdown` during its initialization,
  // before any explicit code in the start module gets to run. Even if other code
  // does get to run first, the `lockdown` call in this module happens during
  // module initialization, before it can legitimately receive parameters by
  // explicit parameter passing.
  //
  // Instead, for now, `init` violates normal ocap discipline by feature
  // testing global state for a passed "parameter". This is something that a
  // module can but normally should not do, during initialization or otherwise.
  // Initialization is often awkward.
  //
  // The `init` module tests, first,
  // for a JavaScript global named `LOCKDOWN_OPTIONS`, and second, for an
  // environment
  // variable named `LOCKDOWN_OPTIONS`. If either is present, its value should be
  // a JSON encoding of the options bag to pass to the `lockdown` call. If so,
  // then `init` calls `lockdown` with those options. If there is no such
  // feature, `init` calls `lockdown` with appropriate settings for
  // production use.

  let optionsString;
  if( typeof LOCKDOWN_OPTIONS===  'string') {
    optionsString=  LOCKDOWN_OPTIONS;
    console.warn(
       `'@endo/lockdown' sniffed and found a 'LOCKDOWN_OPTIONS' global variable\n`);

   }else if(
    typeof process===  'object'&&
    typeof process.env.LOCKDOWN_OPTIONS===  'string')
    {
    optionsString=  process.env.LOCKDOWN_OPTIONS;
    console.warn(
       `'@endo/lockdown' sniffed and found a 'LOCKDOWN_OPTIONS' environment variable\n`);

   }

  if( typeof optionsString===  'string') {
    let options;
    try {
      options=  JSON.parse(optionsString);
     }catch( err) {
      console.error('Environment variable LOCKDOWN_OPTIONS must be JSON', err);
      throw err;
     }
    if( typeof options!==  'object'||  Array.isArray(options)) {
      const err=  TypeError(
        'Environment variable LOCKDOWN_OPTIONS must be a JSON object');

      console.error('', err, options);
      throw err;
     }
    rawLockdown({
      ...options,
      // See comment on domainTaming below.
      domainTaming: 'unsafe'});

   }else if( defaultOptions) {
    rawLockdown({
      ...defaultOptions,
      // See comment on domainTaming below.
      domainTaming: 'unsafe'});

   }else {
    rawLockdown({
      // The default `{errorTaming: 'safe'}` setting, if possible, redacts the
      // stack trace info from the error instances, so that it is not available
      // merely by saying `errorInstance.stack`. However, some tools
      // will look for the stack there and become much less useful if it is
      // missing. In production, the settings in this file need to preserve
      // security, so the 'unsafe' setting below MUST always be commented out
      // except during private development.
      //
      // NOTE TO REVIEWERS: If you see the following line *not* commented out,
      // this may be a development accident that MUST be fixed before merging.
      //
      // errorTaming: 'unsafe',
      //
      //
      // The default `{stackFiltering: 'concise'}` setting usually makes for a
      // better debugging experience, by severely reducing the noisy distractions
      // of the normal verbose stack traces. Which is why we comment
      // out the `'verbose'` setting is commented out below. However, some
      // tools look for the full filename that it expects in order
      // to fetch the source text for diagnostics,
      //
      // Another reason for not commenting it out: The cause
      // of the bug may be anywhere, so the `'noise'` thrown out by the default
      // `'concise'` setting may also contain the signal you need. To see it,
      // uncomment out the following line. But please do not commit it in that
      // state.
      //
      // NOTE TO REVIEWERS: If you see the following line *not* commented out,
      // this may be a development accident that MUST be fixed before merging.
      //
      // stackFiltering: 'verbose',
      //
      //
      // The default `{overrideTaming: 'moderate'}` setting does not hurt the
      // debugging experience much. But it will introduce noise into, for example,
      // the vscode debugger's object inspector. During debug and test, if you can
      // avoid legacy code that needs the `'moderate'` setting, then the `'min'`
      // setting reduces debugging noise yet further, by turning fewer inherited
      // properties into accessors.
      //
      // NOTE TO REVIEWERS: If you see the following line *not* commented out,
      // this may be a development accident that MUST be fixed before merging.
      //
      // overrideTaming: 'min',
      //
      //
      // The default `{consoleTaming: 'safe'}` setting usually makes for a
      // better debugging experience, by wrapping the original `console` with
      // the SES replacement `console` that provides more information about
      // errors, expecially those thrown by the `assert` system. However,
      // in case the SES `console` is getting in the way, we provide the
      // `'unsafe'` option for leaving the original `console` in place.
      //
      // NOTE TO REVIEWERS: If you see the following line *not* commented out,
      // this may be a development accident that MUST be fixed before merging.
      //
      // consoleTaming: 'unsafe',

      // Domain taming causes lockdown to throw an error if the Node.js domain
      // module has already been loaded, and causes loading the domain module
      // to throw an error if it is pulled into the working set later.
      // This is because domains may add domain properties to promises and other
      // callbacks and that these domain objects provide a means to escape
      // containment.
      // However, our platform still depends on systems like standardthings/esm
      // which ultimately pull in domains.
      // For now, we are resigned to leave this hole open, knowing that all
      // contract code will be run under XS to avoid this vulnerability.
      domainTaming: 'unsafe'});

   }

  // We are now in the "Start Compartment". Our global has all the same
  // powerful things it had before, but the primordials have changed to make
  // them safe to use in the arguments of API calls we make into more limited
  // compartments

  // 'Compartment', 'assert', and 'harden' are now present in our global scope.
  postLockdown();
 };$h‍_once.lockdown(lockdown);

globalThis.lockdown=  lockdown;
})()
,
// === functors[57] ===
({   imports: $h‍_imports,   liveVar: $h‍_live,   onceVar: $h‍_once,   importMeta: $h‍____meta, }) => (function () {   $h‍_imports([["./pre.js", []]]);   

lockdown();
})()
,
// === functors[58] ===
(function (require, exports, module, __filename, __dirname) { /*! https://mths.be/punycode v1.4.1 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports = typeof exports == 'object' && exports &&
		!exports.nodeType && exports;
	var freeModule = typeof module == 'object' && module &&
		!module.nodeType && module;
	var freeGlobal = typeof global == 'object' && global;
	if (
		freeGlobal.global === freeGlobal ||
		freeGlobal.window === freeGlobal ||
		freeGlobal.self === freeGlobal
	) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw new RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * https://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(input) {
		return mapDomain(input, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
	function toASCII(input) {
		return mapDomain(input, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.4.1',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		typeof define == 'function' &&
		typeof define.amd == 'object' &&
		define.amd
	) {
		define('punycode', function() {
			return punycode;
		});
	} else if (freeExports && freeModule) {
		if (module.exports == freeExports) {
			// in Node.js, io.js, or RingoJS v0.8.0+
			freeModule.exports = punycode;
		} else {
			// in Narwhal or RingoJS v0.7.0-
			for (key in punycode) {
				punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
			}
		}
	} else {
		// in Rhino or a web browser
		root.punycode = punycode;
	}

}(this));
 //*/
})
//# sourceURL=file:///home/xyz/Development/endo/packages/daemon/node_modules/punycode/punycode.js
,
// === functors[59] ===
(function (require, exports, module, __filename, __dirname) { 'use strict';

/* eslint complexity: [2, 18], max-statements: [2, 33] */
module.exports = function hasSymbols() {
	if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') { return false; }
	if (typeof Symbol.iterator === 'symbol') { return true; }

	var obj = {};
	var sym = Symbol('test');
	var symObj = Object(sym);
	if (typeof sym === 'string') { return false; }

	if (Object.prototype.toString.call(sym) !== '[object Symbol]') { return false; }
	if (Object.prototype.toString.call(symObj) !== '[object Symbol]') { return false; }

	// temp disabled per https://github.com/ljharb/object.assign/issues/17
	// if (sym instanceof Symbol) { return false; }
	// temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
	// if (!(symObj instanceof Symbol)) { return false; }

	// if (typeof Symbol.prototype.toString !== 'function') { return false; }
	// if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }

	var symVal = 42;
	obj[sym] = symVal;
	for (sym in obj) { return false; } // eslint-disable-line no-restricted-syntax, no-unreachable-loop
	if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) { return false; }

	if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) { return false; }

	var syms = Object.getOwnPropertySymbols(obj);
	if (syms.length !== 1 || syms[0] !== sym) { return false; }

	if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) { return false; }

	if (typeof Object.getOwnPropertyDescriptor === 'function') {
		var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
		if (descriptor.value !== symVal || descriptor.enumerable !== true) { return false; }
	}

	return true;
};
 //*/
})
//# sourceURL=file:///home/xyz/Development/endo/node_modules/has-symbols/shams.js
,
// === functors[60] ===
(function (require, exports, module, __filename, __dirname) { 'use strict';

var origSymbol = typeof Symbol !== 'undefined' && Symbol;
var hasSymbolSham = require('./shams');

module.exports = function hasNativeSymbols() {
	if (typeof origSymbol !== 'function') { return false; }
	if (typeof Symbol !== 'function') { return false; }
	if (typeof origSymbol('foo') !== 'symbol') { return false; }
	if (typeof Symbol('bar') !== 'symbol') { return false; }

	return hasSymbolSham();
};
 //*/
})
//# sourceURL=file:///home/xyz/Development/endo/node_modules/has-symbols/index.js
,
// === functors[61] ===
(function (require, exports, module, __filename, __dirname) { 'use strict';

/* eslint no-invalid-this: 1 */

var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
var slice = Array.prototype.slice;
var toStr = Object.prototype.toString;
var funcType = '[object Function]';

module.exports = function bind(that) {
    var target = this;
    if (typeof target !== 'function' || toStr.call(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slice.call(arguments, 1);

    var bound;
    var binder = function () {
        if (this instanceof bound) {
            var result = target.apply(
                this,
                args.concat(slice.call(arguments))
            );
            if (Object(result) === result) {
                return result;
            }
            return this;
        } else {
            return target.apply(
                that,
                args.concat(slice.call(arguments))
            );
        }
    };

    var boundLength = Math.max(0, target.length - args.length);
    var boundArgs = [];
    for (var i = 0; i < boundLength; i++) {
        boundArgs.push('$' + i);
    }

    bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this,arguments); }')(binder);

    if (target.prototype) {
        var Empty = function Empty() {};
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
    }

    return bound;
};
 //*/
})
//# sourceURL=file:///home/xyz/Development/endo/node_modules/function-bind/implementation.js
,
// === functors[62] ===
(function (require, exports, module, __filename, __dirname) { 'use strict';

var implementation = require('./implementation');

module.exports = Function.prototype.bind || implementation;
 //*/
})
//# sourceURL=file:///home/xyz/Development/endo/node_modules/function-bind/index.js
,
// === functors[63] ===
(function (require, exports, module, __filename, __dirname) { 'use strict';

var bind = require('function-bind');

module.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);
 //*/
})
//# sourceURL=file:///home/xyz/Development/endo/node_modules/has/src/index.js
,
// === functors[64] ===
(function (require, exports, module, __filename, __dirname) { 'use strict';

var undefined;

var $SyntaxError = SyntaxError;
var $Function = Function;
var $TypeError = TypeError;

// eslint-disable-next-line consistent-return
var getEvalledConstructor = function (expressionSyntax) {
	try {
		return $Function('"use strict"; return (' + expressionSyntax + ').constructor;')();
	} catch (e) {}
};

var $gOPD = Object.getOwnPropertyDescriptor;
if ($gOPD) {
	try {
		$gOPD({}, '');
	} catch (e) {
		$gOPD = null; // this is IE 8, which has a broken gOPD
	}
}

var throwTypeError = function () {
	throw new $TypeError();
};
var ThrowTypeError = $gOPD
	? (function () {
		try {
			// eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
			arguments.callee; // IE 8 does not throw here
			return throwTypeError;
		} catch (calleeThrows) {
			try {
				// IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
				return $gOPD(arguments, 'callee').get;
			} catch (gOPDthrows) {
				return throwTypeError;
			}
		}
	}())
	: throwTypeError;

var hasSymbols = require('has-symbols')();

var getProto = Object.getPrototypeOf || function (x) { return x.__proto__; }; // eslint-disable-line no-proto

var needsEval = {};

var TypedArray = typeof Uint8Array === 'undefined' ? undefined : getProto(Uint8Array);

var INTRINSICS = {
	'%AggregateError%': typeof AggregateError === 'undefined' ? undefined : AggregateError,
	'%Array%': Array,
	'%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer,
	'%ArrayIteratorPrototype%': hasSymbols ? getProto([][Symbol.iterator]()) : undefined,
	'%AsyncFromSyncIteratorPrototype%': undefined,
	'%AsyncFunction%': needsEval,
	'%AsyncGenerator%': needsEval,
	'%AsyncGeneratorFunction%': needsEval,
	'%AsyncIteratorPrototype%': needsEval,
	'%Atomics%': typeof Atomics === 'undefined' ? undefined : Atomics,
	'%BigInt%': typeof BigInt === 'undefined' ? undefined : BigInt,
	'%BigInt64Array%': typeof BigInt64Array === 'undefined' ? undefined : BigInt64Array,
	'%BigUint64Array%': typeof BigUint64Array === 'undefined' ? undefined : BigUint64Array,
	'%Boolean%': Boolean,
	'%DataView%': typeof DataView === 'undefined' ? undefined : DataView,
	'%Date%': Date,
	'%decodeURI%': decodeURI,
	'%decodeURIComponent%': decodeURIComponent,
	'%encodeURI%': encodeURI,
	'%encodeURIComponent%': encodeURIComponent,
	'%Error%': Error,
	'%eval%': eval, // eslint-disable-line no-eval
	'%EvalError%': EvalError,
	'%Float32Array%': typeof Float32Array === 'undefined' ? undefined : Float32Array,
	'%Float64Array%': typeof Float64Array === 'undefined' ? undefined : Float64Array,
	'%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined : FinalizationRegistry,
	'%Function%': $Function,
	'%GeneratorFunction%': needsEval,
	'%Int8Array%': typeof Int8Array === 'undefined' ? undefined : Int8Array,
	'%Int16Array%': typeof Int16Array === 'undefined' ? undefined : Int16Array,
	'%Int32Array%': typeof Int32Array === 'undefined' ? undefined : Int32Array,
	'%isFinite%': isFinite,
	'%isNaN%': isNaN,
	'%IteratorPrototype%': hasSymbols ? getProto(getProto([][Symbol.iterator]())) : undefined,
	'%JSON%': typeof JSON === 'object' ? JSON : undefined,
	'%Map%': typeof Map === 'undefined' ? undefined : Map,
	'%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols ? undefined : getProto(new Map()[Symbol.iterator]()),
	'%Math%': Math,
	'%Number%': Number,
	'%Object%': Object,
	'%parseFloat%': parseFloat,
	'%parseInt%': parseInt,
	'%Promise%': typeof Promise === 'undefined' ? undefined : Promise,
	'%Proxy%': typeof Proxy === 'undefined' ? undefined : Proxy,
	'%RangeError%': RangeError,
	'%ReferenceError%': ReferenceError,
	'%Reflect%': typeof Reflect === 'undefined' ? undefined : Reflect,
	'%RegExp%': RegExp,
	'%Set%': typeof Set === 'undefined' ? undefined : Set,
	'%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols ? undefined : getProto(new Set()[Symbol.iterator]()),
	'%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer,
	'%String%': String,
	'%StringIteratorPrototype%': hasSymbols ? getProto(''[Symbol.iterator]()) : undefined,
	'%Symbol%': hasSymbols ? Symbol : undefined,
	'%SyntaxError%': $SyntaxError,
	'%ThrowTypeError%': ThrowTypeError,
	'%TypedArray%': TypedArray,
	'%TypeError%': $TypeError,
	'%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array,
	'%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray,
	'%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array,
	'%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array,
	'%URIError%': URIError,
	'%WeakMap%': typeof WeakMap === 'undefined' ? undefined : WeakMap,
	'%WeakRef%': typeof WeakRef === 'undefined' ? undefined : WeakRef,
	'%WeakSet%': typeof WeakSet === 'undefined' ? undefined : WeakSet
};

try {
	null.error; // eslint-disable-line no-unused-expressions
} catch (e) {
	// https://github.com/tc39/proposal-shadowrealm/pull/384#issuecomment-1364264229
	var errorProto = getProto(getProto(e));
	INTRINSICS['%Error.prototype%'] = errorProto;
}

var doEval = function doEval(name) {
	var value;
	if (name === '%AsyncFunction%') {
		value = getEvalledConstructor('async function () {}');
	} else if (name === '%GeneratorFunction%') {
		value = getEvalledConstructor('function* () {}');
	} else if (name === '%AsyncGeneratorFunction%') {
		value = getEvalledConstructor('async function* () {}');
	} else if (name === '%AsyncGenerator%') {
		var fn = doEval('%AsyncGeneratorFunction%');
		if (fn) {
			value = fn.prototype;
		}
	} else if (name === '%AsyncIteratorPrototype%') {
		var gen = doEval('%AsyncGenerator%');
		if (gen) {
			value = getProto(gen.prototype);
		}
	}

	INTRINSICS[name] = value;

	return value;
};

var LEGACY_ALIASES = {
	'%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],
	'%ArrayPrototype%': ['Array', 'prototype'],
	'%ArrayProto_entries%': ['Array', 'prototype', 'entries'],
	'%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],
	'%ArrayProto_keys%': ['Array', 'prototype', 'keys'],
	'%ArrayProto_values%': ['Array', 'prototype', 'values'],
	'%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],
	'%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],
	'%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],
	'%BooleanPrototype%': ['Boolean', 'prototype'],
	'%DataViewPrototype%': ['DataView', 'prototype'],
	'%DatePrototype%': ['Date', 'prototype'],
	'%ErrorPrototype%': ['Error', 'prototype'],
	'%EvalErrorPrototype%': ['EvalError', 'prototype'],
	'%Float32ArrayPrototype%': ['Float32Array', 'prototype'],
	'%Float64ArrayPrototype%': ['Float64Array', 'prototype'],
	'%FunctionPrototype%': ['Function', 'prototype'],
	'%Generator%': ['GeneratorFunction', 'prototype'],
	'%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],
	'%Int8ArrayPrototype%': ['Int8Array', 'prototype'],
	'%Int16ArrayPrototype%': ['Int16Array', 'prototype'],
	'%Int32ArrayPrototype%': ['Int32Array', 'prototype'],
	'%JSONParse%': ['JSON', 'parse'],
	'%JSONStringify%': ['JSON', 'stringify'],
	'%MapPrototype%': ['Map', 'prototype'],
	'%NumberPrototype%': ['Number', 'prototype'],
	'%ObjectPrototype%': ['Object', 'prototype'],
	'%ObjProto_toString%': ['Object', 'prototype', 'toString'],
	'%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],
	'%PromisePrototype%': ['Promise', 'prototype'],
	'%PromiseProto_then%': ['Promise', 'prototype', 'then'],
	'%Promise_all%': ['Promise', 'all'],
	'%Promise_reject%': ['Promise', 'reject'],
	'%Promise_resolve%': ['Promise', 'resolve'],
	'%RangeErrorPrototype%': ['RangeError', 'prototype'],
	'%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],
	'%RegExpPrototype%': ['RegExp', 'prototype'],
	'%SetPrototype%': ['Set', 'prototype'],
	'%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],
	'%StringPrototype%': ['String', 'prototype'],
	'%SymbolPrototype%': ['Symbol', 'prototype'],
	'%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],
	'%TypedArrayPrototype%': ['TypedArray', 'prototype'],
	'%TypeErrorPrototype%': ['TypeError', 'prototype'],
	'%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],
	'%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],
	'%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],
	'%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],
	'%URIErrorPrototype%': ['URIError', 'prototype'],
	'%WeakMapPrototype%': ['WeakMap', 'prototype'],
	'%WeakSetPrototype%': ['WeakSet', 'prototype']
};

var bind = require('function-bind');
var hasOwn = require('has');
var $concat = bind.call(Function.call, Array.prototype.concat);
var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
var $replace = bind.call(Function.call, String.prototype.replace);
var $strSlice = bind.call(Function.call, String.prototype.slice);
var $exec = bind.call(Function.call, RegExp.prototype.exec);

/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */
var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var reEscapeChar = /\\(\\)?/g; /** Used to match backslashes in property paths. */
var stringToPath = function stringToPath(string) {
	var first = $strSlice(string, 0, 1);
	var last = $strSlice(string, -1);
	if (first === '%' && last !== '%') {
		throw new $SyntaxError('invalid intrinsic syntax, expected closing `%`');
	} else if (last === '%' && first !== '%') {
		throw new $SyntaxError('invalid intrinsic syntax, expected opening `%`');
	}
	var result = [];
	$replace(string, rePropName, function (match, number, quote, subString) {
		result[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;
	});
	return result;
};
/* end adaptation */

var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
	var intrinsicName = name;
	var alias;
	if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
		alias = LEGACY_ALIASES[intrinsicName];
		intrinsicName = '%' + alias[0] + '%';
	}

	if (hasOwn(INTRINSICS, intrinsicName)) {
		var value = INTRINSICS[intrinsicName];
		if (value === needsEval) {
			value = doEval(intrinsicName);
		}
		if (typeof value === 'undefined' && !allowMissing) {
			throw new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
		}

		return {
			alias: alias,
			name: intrinsicName,
			value: value
		};
	}

	throw new $SyntaxError('intrinsic ' + name + ' does not exist!');
};

module.exports = function GetIntrinsic(name, allowMissing) {
	if (typeof name !== 'string' || name.length === 0) {
		throw new $TypeError('intrinsic name must be a non-empty string');
	}
	if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
		throw new $TypeError('"allowMissing" argument must be a boolean');
	}

	if ($exec(/^%?[^%]*%?$/, name) === null) {
		throw new $SyntaxError('`%` may not be present anywhere but at the beginning and end of the intrinsic name');
	}
	var parts = stringToPath(name);
	var intrinsicBaseName = parts.length > 0 ? parts[0] : '';

	var intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);
	var intrinsicRealName = intrinsic.name;
	var value = intrinsic.value;
	var skipFurtherCaching = false;

	var alias = intrinsic.alias;
	if (alias) {
		intrinsicBaseName = alias[0];
		$spliceApply(parts, $concat([0, 1], alias));
	}

	for (var i = 1, isOwn = true; i < parts.length; i += 1) {
		var part = parts[i];
		var first = $strSlice(part, 0, 1);
		var last = $strSlice(part, -1);
		if (
			(
				(first === '"' || first === "'" || first === '`')
				|| (last === '"' || last === "'" || last === '`')
			)
			&& first !== last
		) {
			throw new $SyntaxError('property names with quotes must have matching quotes');
		}
		if (part === 'constructor' || !isOwn) {
			skipFurtherCaching = true;
		}

		intrinsicBaseName += '.' + part;
		intrinsicRealName = '%' + intrinsicBaseName + '%';

		if (hasOwn(INTRINSICS, intrinsicRealName)) {
			value = INTRINSICS[intrinsicRealName];
		} else if (value != null) {
			if (!(part in value)) {
				if (!allowMissing) {
					throw new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');
				}
				return void undefined;
			}
			if ($gOPD && (i + 1) >= parts.length) {
				var desc = $gOPD(value, part);
				isOwn = !!desc;

				// By convention, when a data property is converted to an accessor
				// property to emulate a data property that does not suffer from
				// the override mistake, that accessor's getter is marked with
				// an `originalValue` property. Here, when we detect this, we
				// uphold the illusion by pretending to see that original data
				// property, i.e., returning the value rather than the getter
				// itself.
				if (isOwn && 'get' in desc && !('originalValue' in desc.get)) {
					value = desc.get;
				} else {
					value = value[part];
				}
			} else {
				isOwn = hasOwn(value, part);
				value = value[part];
			}

			if (isOwn && !skipFurtherCaching) {
				INTRINSICS[intrinsicRealName] = value;
			}
		}
	}
	return value;
};
 //*/
})
//# sourceURL=file:///home/xyz/Development/endo/node_modules/get-intrinsic/index.js
,
// === functors[65] ===
(function (require, exports, module, __filename, __dirname) { 'use strict';

var bind = require('function-bind');
var GetIntrinsic = require('get-intrinsic');

var $apply = GetIntrinsic('%Function.prototype.apply%');
var $call = GetIntrinsic('%Function.prototype.call%');
var $reflectApply = GetIntrinsic('%Reflect.apply%', true) || bind.call($call, $apply);

var $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%', true);
var $defineProperty = GetIntrinsic('%Object.defineProperty%', true);
var $max = GetIntrinsic('%Math.max%');

if ($defineProperty) {
	try {
		$defineProperty({}, 'a', { value: 1 });
	} catch (e) {
		// IE 8 has a broken defineProperty
		$defineProperty = null;
	}
}

module.exports = function callBind(originalFunction) {
	var func = $reflectApply(bind, $call, arguments);
	if ($gOPD && $defineProperty) {
		var desc = $gOPD(func, 'length');
		if (desc.configurable) {
			// original length, plus the receiver, minus any additional arguments (after the receiver)
			$defineProperty(
				func,
				'length',
				{ value: 1 + $max(0, originalFunction.length - (arguments.length - 1)) }
			);
		}
	}
	return func;
};

var applyBind = function applyBind() {
	return $reflectApply(bind, $apply, arguments);
};

if ($defineProperty) {
	$defineProperty(module.exports, 'apply', { value: applyBind });
} else {
	module.exports.apply = applyBind;
}
 //*/
})
//# sourceURL=file:///home/xyz/Development/endo/node_modules/call-bind/index.js
,
// === functors[66] ===
(function (require, exports, module, __filename, __dirname) { 'use strict';

var GetIntrinsic = require('get-intrinsic');

var callBind = require('./');

var $indexOf = callBind(GetIntrinsic('String.prototype.indexOf'));

module.exports = function callBoundIntrinsic(name, allowMissing) {
	var intrinsic = GetIntrinsic(name, !!allowMissing);
	if (typeof intrinsic === 'function' && $indexOf(name, '.prototype.') > -1) {
		return callBind(intrinsic);
	}
	return intrinsic;
};
 //*/
})
//# sourceURL=file:///home/xyz/Development/endo/node_modules/call-bind/callBound.js
,
// === functors[67] ===
(function (require, exports, module, __filename, __dirname) { 'use strict';

var hasSymbols = require('has-symbols/shams');

module.exports = function hasToStringTagShams() {
	return hasSymbols() && !!Symbol.toStringTag;
};
 //*/
})
//# sourceURL=file:///home/xyz/Development/endo/node_modules/has-tostringtag/shams.js
,
// === functors[68] ===
(function (require, exports, module, __filename, __dirname) { 'use strict';

var hasToStringTag = require('has-tostringtag/shams')();
var callBound = require('call-bind/callBound');

var $toString = callBound('Object.prototype.toString');

var isStandardArguments = function isArguments(value) {
	if (hasToStringTag && value && typeof value === 'object' && Symbol.toStringTag in value) {
		return false;
	}
	return $toString(value) === '[object Arguments]';
};

var isLegacyArguments = function isArguments(value) {
	if (isStandardArguments(value)) {
		return true;
	}
	return value !== null &&
		typeof value === 'object' &&
		typeof value.length === 'number' &&
		value.length >= 0 &&
		$toString(value) !== '[object Array]' &&
		$toString(value.callee) === '[object Function]';
};

var supportsStandardArguments = (function () {
	return isStandardArguments(arguments);
}());

isStandardArguments.isLegacyArguments = isLegacyArguments; // for tests

module.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;
 //*/
})
//# sourceURL=file:///home/xyz/Development/endo/node_modules/is-arguments/index.js
,
// === functors[69] ===
(function (require, exports, module, __filename, __dirname) { 'use strict';

var toStr = Object.prototype.toString;
var fnToStr = Function.prototype.toString;
var isFnRegex = /^\s*(?:function)?\*/;
var hasToStringTag = require('has-tostringtag/shams')();
var getProto = Object.getPrototypeOf;
var getGeneratorFunc = function () { // eslint-disable-line consistent-return
	if (!hasToStringTag) {
		return false;
	}
	try {
		return Function('return function*() {}')();
	} catch (e) {
	}
};
var GeneratorFunction;

module.exports = function isGeneratorFunction(fn) {
	if (typeof fn !== 'function') {
		return false;
	}
	if (isFnRegex.test(fnToStr.call(fn))) {
		return true;
	}
	if (!hasToStringTag) {
		var str = toStr.call(fn);
		return str === '[object GeneratorFunction]';
	}
	if (!getProto) {
		return false;
	}
	if (typeof GeneratorFunction === 'undefined') {
		var generatorFunc = getGeneratorFunc();
		GeneratorFunction = generatorFunc ? getProto(generatorFunc) : false;
	}
	return getProto(fn) === GeneratorFunction;
};
 //*/
})
//# sourceURL=file:///home/xyz/Development/endo/node_modules/is-generator-function/index.js
,
// === functors[70] ===
(function (require, exports, module, __filename, __dirname) { 'use strict';

var fnToStr = Function.prototype.toString;
var reflectApply = typeof Reflect === 'object' && Reflect !== null && Reflect.apply;
var badArrayLike;
var isCallableMarker;
if (typeof reflectApply === 'function' && typeof Object.defineProperty === 'function') {
	try {
		badArrayLike = Object.defineProperty({}, 'length', {
			get: function () {
				throw isCallableMarker;
			}
		});
		isCallableMarker = {};
		// eslint-disable-next-line no-throw-literal
		reflectApply(function () { throw 42; }, null, badArrayLike);
	} catch (_) {
		if (_ !== isCallableMarker) {
			reflectApply = null;
		}
	}
} else {
	reflectApply = null;
}

var constructorRegex = /^\s*class\b/;
var isES6ClassFn = function isES6ClassFunction(value) {
	try {
		var fnStr = fnToStr.call(value);
		return constructorRegex.test(fnStr);
	} catch (e) {
		return false; // not a function
	}
};

var tryFunctionObject = function tryFunctionToStr(value) {
	try {
		if (isES6ClassFn(value)) { return false; }
		fnToStr.call(value);
		return true;
	} catch (e) {
		return false;
	}
};
var toStr = Object.prototype.toString;
var objectClass = '[object Object]';
var fnClass = '[object Function]';
var genClass = '[object GeneratorFunction]';
var ddaClass = '[object HTMLAllCollection]'; // IE 11
var ddaClass2 = '[object HTML document.all class]';
var ddaClass3 = '[object HTMLCollection]'; // IE 9-10
var hasToStringTag = typeof Symbol === 'function' && !!Symbol.toStringTag; // better: use `has-tostringtag`

var isIE68 = !(0 in [,]); // eslint-disable-line no-sparse-arrays, comma-spacing

var isDDA = function isDocumentDotAll() { return false; };
if (typeof document === 'object') {
	// Firefox 3 canonicalizes DDA to undefined when it's not accessed directly
	var all = document.all;
	if (toStr.call(all) === toStr.call(document.all)) {
		isDDA = function isDocumentDotAll(value) {
			/* globals document: false */
			// in IE 6-8, typeof document.all is "object" and it's truthy
			if ((isIE68 || !value) && (typeof value === 'undefined' || typeof value === 'object')) {
				try {
					var str = toStr.call(value);
					return (
						str === ddaClass
						|| str === ddaClass2
						|| str === ddaClass3 // opera 12.16
						|| str === objectClass // IE 6-8
					) && value('') == null; // eslint-disable-line eqeqeq
				} catch (e) { /**/ }
			}
			return false;
		};
	}
}

module.exports = reflectApply
	? function isCallable(value) {
		if (isDDA(value)) { return true; }
		if (!value) { return false; }
		if (typeof value !== 'function' && typeof value !== 'object') { return false; }
		try {
			reflectApply(value, null, badArrayLike);
		} catch (e) {
			if (e !== isCallableMarker) { return false; }
		}
		return !isES6ClassFn(value) && tryFunctionObject(value);
	}
	: function isCallable(value) {
		if (isDDA(value)) { return true; }
		if (!value) { return false; }
		if (typeof value !== 'function' && typeof value !== 'object') { return false; }
		if (hasToStringTag) { return tryFunctionObject(value); }
		if (isES6ClassFn(value)) { return false; }
		var strClass = toStr.call(value);
		if (strClass !== fnClass && strClass !== genClass && !(/^\[object HTML/).test(strClass)) { return false; }
		return tryFunctionObject(value);
	};
 //*/
})
//# sourceURL=file:///home/xyz/Development/endo/node_modules/is-callable/index.js
,
// === functors[71] ===
(function (require, exports, module, __filename, __dirname) { 'use strict';

var isCallable = require('is-callable');

var toStr = Object.prototype.toString;
var hasOwnProperty = Object.prototype.hasOwnProperty;

var forEachArray = function forEachArray(array, iterator, receiver) {
    for (var i = 0, len = array.length; i < len; i++) {
        if (hasOwnProperty.call(array, i)) {
            if (receiver == null) {
                iterator(array[i], i, array);
            } else {
                iterator.call(receiver, array[i], i, array);
            }
        }
    }
};

var forEachString = function forEachString(string, iterator, receiver) {
    for (var i = 0, len = string.length; i < len; i++) {
        // no such thing as a sparse string.
        if (receiver == null) {
            iterator(string.charAt(i), i, string);
        } else {
            iterator.call(receiver, string.charAt(i), i, string);
        }
    }
};

var forEachObject = function forEachObject(object, iterator, receiver) {
    for (var k in object) {
        if (hasOwnProperty.call(object, k)) {
            if (receiver == null) {
                iterator(object[k], k, object);
            } else {
                iterator.call(receiver, object[k], k, object);
            }
        }
    }
};

var forEach = function forEach(list, iterator, thisArg) {
    if (!isCallable(iterator)) {
        throw new TypeError('iterator must be a function');
    }

    var receiver;
    if (arguments.length >= 3) {
        receiver = thisArg;
    }

    if (toStr.call(list) === '[object Array]') {
        forEachArray(list, iterator, receiver);
    } else if (typeof list === 'string') {
        forEachString(list, iterator, receiver);
    } else {
        forEachObject(list, iterator, receiver);
    }
};

module.exports = forEach;
 //*/
})
//# sourceURL=file:///home/xyz/Development/endo/node_modules/for-each/index.js
,
// === functors[72] ===
(function (require, exports, module, __filename, __dirname) { 'use strict';

var possibleNames = [
	'BigInt64Array',
	'BigUint64Array',
	'Float32Array',
	'Float64Array',
	'Int16Array',
	'Int32Array',
	'Int8Array',
	'Uint16Array',
	'Uint32Array',
	'Uint8Array',
	'Uint8ClampedArray'
];

var g = typeof globalThis === 'undefined' ? global : globalThis;

module.exports = function availableTypedArrays() {
	var out = [];
	for (var i = 0; i < possibleNames.length; i++) {
		if (typeof g[possibleNames[i]] === 'function') {
			out[out.length] = possibleNames[i];
		}
	}
	return out;
};
 //*/
})
//# sourceURL=file:///home/xyz/Development/endo/node_modules/available-typed-arrays/index.js
,
// === functors[73] ===
(function (require, exports, module, __filename, __dirname) { 'use strict';

var GetIntrinsic = require('get-intrinsic');

var $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%', true);

if ($gOPD) {
	try {
		$gOPD([], 'length');
	} catch (e) {
		// IE 8 has a broken gOPD
		$gOPD = null;
	}
}

module.exports = $gOPD;
 //*/
})
//# sourceURL=file:///home/xyz/Development/endo/node_modules/gopd/index.js
,
// === functors[74] ===
(function (require, exports, module, __filename, __dirname) { 'use strict';

var forEach = require('for-each');
var availableTypedArrays = require('available-typed-arrays');
var callBound = require('call-bind/callBound');

var $toString = callBound('Object.prototype.toString');
var hasToStringTag = require('has-tostringtag/shams')();
var gOPD = require('gopd');

var g = typeof globalThis === 'undefined' ? global : globalThis;
var typedArrays = availableTypedArrays();

var $indexOf = callBound('Array.prototype.indexOf', true) || function indexOf(array, value) {
	for (var i = 0; i < array.length; i += 1) {
		if (array[i] === value) {
			return i;
		}
	}
	return -1;
};
var $slice = callBound('String.prototype.slice');
var toStrTags = {};
var getPrototypeOf = Object.getPrototypeOf; // require('getprototypeof');
if (hasToStringTag && gOPD && getPrototypeOf) {
	forEach(typedArrays, function (typedArray) {
		var arr = new g[typedArray]();
		if (Symbol.toStringTag in arr) {
			var proto = getPrototypeOf(arr);
			var descriptor = gOPD(proto, Symbol.toStringTag);
			if (!descriptor) {
				var superProto = getPrototypeOf(proto);
				descriptor = gOPD(superProto, Symbol.toStringTag);
			}
			toStrTags[typedArray] = descriptor.get;
		}
	});
}

var tryTypedArrays = function tryAllTypedArrays(value) {
	var anyTrue = false;
	forEach(toStrTags, function (getter, typedArray) {
		if (!anyTrue) {
			try {
				anyTrue = getter.call(value) === typedArray;
			} catch (e) { /**/ }
		}
	});
	return anyTrue;
};

module.exports = function isTypedArray(value) {
	if (!value || typeof value !== 'object') { return false; }
	if (!hasToStringTag || !(Symbol.toStringTag in value)) {
		var tag = $slice($toString(value), 8, -1);
		return $indexOf(typedArrays, tag) > -1;
	}
	if (!gOPD) { return false; }
	return tryTypedArrays(value);
};
 //*/
})
//# sourceURL=file:///home/xyz/Development/endo/node_modules/is-typed-array/index.js
,
// === functors[75] ===
(function (require, exports, module, __filename, __dirname) { 'use strict';

var forEach = require('for-each');
var availableTypedArrays = require('available-typed-arrays');
var callBound = require('call-bind/callBound');
var gOPD = require('gopd');

var $toString = callBound('Object.prototype.toString');
var hasToStringTag = require('has-tostringtag/shams')();

var g = typeof globalThis === 'undefined' ? global : globalThis;
var typedArrays = availableTypedArrays();

var $slice = callBound('String.prototype.slice');
var toStrTags = {};
var getPrototypeOf = Object.getPrototypeOf; // require('getprototypeof');
if (hasToStringTag && gOPD && getPrototypeOf) {
	forEach(typedArrays, function (typedArray) {
		if (typeof g[typedArray] === 'function') {
			var arr = new g[typedArray]();
			if (Symbol.toStringTag in arr) {
				var proto = getPrototypeOf(arr);
				var descriptor = gOPD(proto, Symbol.toStringTag);
				if (!descriptor) {
					var superProto = getPrototypeOf(proto);
					descriptor = gOPD(superProto, Symbol.toStringTag);
				}
				toStrTags[typedArray] = descriptor.get;
			}
		}
	});
}

var tryTypedArrays = function tryAllTypedArrays(value) {
	var foundName = false;
	forEach(toStrTags, function (getter, typedArray) {
		if (!foundName) {
			try {
				var name = getter.call(value);
				if (name === typedArray) {
					foundName = name;
				}
			} catch (e) {}
		}
	});
	return foundName;
};

var isTypedArray = require('is-typed-array');

module.exports = function whichTypedArray(value) {
	if (!isTypedArray(value)) { return false; }
	if (!hasToStringTag || !(Symbol.toStringTag in value)) { return $slice($toString(value), 8, -1); }
	return tryTypedArrays(value);
};
 //*/
})
//# sourceURL=file:///home/xyz/Development/endo/node_modules/which-typed-array/index.js
,
// === functors[76] ===
(function (require, exports, module, __filename, __dirname) { // Currently in sync with Node.js lib/internal/util/types.js
// https://github.com/nodejs/node/commit/112cc7c27551254aa2b17098fb774867f05ed0d9

'use strict';

var isArgumentsObject = require('is-arguments');
var isGeneratorFunction = require('is-generator-function');
var whichTypedArray = require('which-typed-array');
var isTypedArray = require('is-typed-array');

function uncurryThis(f) {
  return f.call.bind(f);
}

var BigIntSupported = typeof BigInt !== 'undefined';
var SymbolSupported = typeof Symbol !== 'undefined';

var ObjectToString = uncurryThis(Object.prototype.toString);

var numberValue = uncurryThis(Number.prototype.valueOf);
var stringValue = uncurryThis(String.prototype.valueOf);
var booleanValue = uncurryThis(Boolean.prototype.valueOf);

if (BigIntSupported) {
  var bigIntValue = uncurryThis(BigInt.prototype.valueOf);
}

if (SymbolSupported) {
  var symbolValue = uncurryThis(Symbol.prototype.valueOf);
}

function checkBoxedPrimitive(value, prototypeValueOf) {
  if (typeof value !== 'object') {
    return false;
  }
  try {
    prototypeValueOf(value);
    return true;
  } catch(e) {
    return false;
  }
}

exports.isArgumentsObject = isArgumentsObject;
exports.isGeneratorFunction = isGeneratorFunction;
exports.isTypedArray = isTypedArray;

// Taken from here and modified for better browser support
// https://github.com/sindresorhus/p-is-promise/blob/cda35a513bda03f977ad5cde3a079d237e82d7ef/index.js
function isPromise(input) {
	return (
		(
			typeof Promise !== 'undefined' &&
			input instanceof Promise
		) ||
		(
			input !== null &&
			typeof input === 'object' &&
			typeof input.then === 'function' &&
			typeof input.catch === 'function'
		)
	);
}
exports.isPromise = isPromise;

function isArrayBufferView(value) {
  if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) {
    return ArrayBuffer.isView(value);
  }

  return (
    isTypedArray(value) ||
    isDataView(value)
  );
}
exports.isArrayBufferView = isArrayBufferView;


function isUint8Array(value) {
  return whichTypedArray(value) === 'Uint8Array';
}
exports.isUint8Array = isUint8Array;

function isUint8ClampedArray(value) {
  return whichTypedArray(value) === 'Uint8ClampedArray';
}
exports.isUint8ClampedArray = isUint8ClampedArray;

function isUint16Array(value) {
  return whichTypedArray(value) === 'Uint16Array';
}
exports.isUint16Array = isUint16Array;

function isUint32Array(value) {
  return whichTypedArray(value) === 'Uint32Array';
}
exports.isUint32Array = isUint32Array;

function isInt8Array(value) {
  return whichTypedArray(value) === 'Int8Array';
}
exports.isInt8Array = isInt8Array;

function isInt16Array(value) {
  return whichTypedArray(value) === 'Int16Array';
}
exports.isInt16Array = isInt16Array;

function isInt32Array(value) {
  return whichTypedArray(value) === 'Int32Array';
}
exports.isInt32Array = isInt32Array;

function isFloat32Array(value) {
  return whichTypedArray(value) === 'Float32Array';
}
exports.isFloat32Array = isFloat32Array;

function isFloat64Array(value) {
  return whichTypedArray(value) === 'Float64Array';
}
exports.isFloat64Array = isFloat64Array;

function isBigInt64Array(value) {
  return whichTypedArray(value) === 'BigInt64Array';
}
exports.isBigInt64Array = isBigInt64Array;

function isBigUint64Array(value) {
  return whichTypedArray(value) === 'BigUint64Array';
}
exports.isBigUint64Array = isBigUint64Array;

function isMapToString(value) {
  return ObjectToString(value) === '[object Map]';
}
isMapToString.working = (
  typeof Map !== 'undefined' &&
  isMapToString(new Map())
);

function isMap(value) {
  if (typeof Map === 'undefined') {
    return false;
  }

  return isMapToString.working
    ? isMapToString(value)
    : value instanceof Map;
}
exports.isMap = isMap;

function isSetToString(value) {
  return ObjectToString(value) === '[object Set]';
}
isSetToString.working = (
  typeof Set !== 'undefined' &&
  isSetToString(new Set())
);
function isSet(value) {
  if (typeof Set === 'undefined') {
    return false;
  }

  return isSetToString.working
    ? isSetToString(value)
    : value instanceof Set;
}
exports.isSet = isSet;

function isWeakMapToString(value) {
  return ObjectToString(value) === '[object WeakMap]';
}
isWeakMapToString.working = (
  typeof WeakMap !== 'undefined' &&
  isWeakMapToString(new WeakMap())
);
function isWeakMap(value) {
  if (typeof WeakMap === 'undefined') {
    return false;
  }

  return isWeakMapToString.working
    ? isWeakMapToString(value)
    : value instanceof WeakMap;
}
exports.isWeakMap = isWeakMap;

function isWeakSetToString(value) {
  return ObjectToString(value) === '[object WeakSet]';
}
isWeakSetToString.working = (
  typeof WeakSet !== 'undefined' &&
  isWeakSetToString(new WeakSet())
);
function isWeakSet(value) {
  return isWeakSetToString(value);
}
exports.isWeakSet = isWeakSet;

function isArrayBufferToString(value) {
  return ObjectToString(value) === '[object ArrayBuffer]';
}
isArrayBufferToString.working = (
  typeof ArrayBuffer !== 'undefined' &&
  isArrayBufferToString(new ArrayBuffer())
);
function isArrayBuffer(value) {
  if (typeof ArrayBuffer === 'undefined') {
    return false;
  }

  return isArrayBufferToString.working
    ? isArrayBufferToString(value)
    : value instanceof ArrayBuffer;
}
exports.isArrayBuffer = isArrayBuffer;

function isDataViewToString(value) {
  return ObjectToString(value) === '[object DataView]';
}
isDataViewToString.working = (
  typeof ArrayBuffer !== 'undefined' &&
  typeof DataView !== 'undefined' &&
  isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1))
);
function isDataView(value) {
  if (typeof DataView === 'undefined') {
    return false;
  }

  return isDataViewToString.working
    ? isDataViewToString(value)
    : value instanceof DataView;
}
exports.isDataView = isDataView;

// Store a copy of SharedArrayBuffer in case it's deleted elsewhere
var SharedArrayBufferCopy = typeof SharedArrayBuffer !== 'undefined' ? SharedArrayBuffer : undefined;
function isSharedArrayBufferToString(value) {
  return ObjectToString(value) === '[object SharedArrayBuffer]';
}
function isSharedArrayBuffer(value) {
  if (typeof SharedArrayBufferCopy === 'undefined') {
    return false;
  }

  if (typeof isSharedArrayBufferToString.working === 'undefined') {
    isSharedArrayBufferToString.working = isSharedArrayBufferToString(new SharedArrayBufferCopy());
  }

  return isSharedArrayBufferToString.working
    ? isSharedArrayBufferToString(value)
    : value instanceof SharedArrayBufferCopy;
}
exports.isSharedArrayBuffer = isSharedArrayBuffer;

function isAsyncFunction(value) {
  return ObjectToString(value) === '[object AsyncFunction]';
}
exports.isAsyncFunction = isAsyncFunction;

function isMapIterator(value) {
  return ObjectToString(value) === '[object Map Iterator]';
}
exports.isMapIterator = isMapIterator;

function isSetIterator(value) {
  return ObjectToString(value) === '[object Set Iterator]';
}
exports.isSetIterator = isSetIterator;

function isGeneratorObject(value) {
  return ObjectToString(value) === '[object Generator]';
}
exports.isGeneratorObject = isGeneratorObject;

function isWebAssemblyCompiledModule(value) {
  return ObjectToString(value) === '[object WebAssembly.Module]';
}
exports.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;

function isNumberObject(value) {
  return checkBoxedPrimitive(value, numberValue);
}
exports.isNumberObject = isNumberObject;

function isStringObject(value) {
  return checkBoxedPrimitive(value, stringValue);
}
exports.isStringObject = isStringObject;

function isBooleanObject(value) {
  return checkBoxedPrimitive(value, booleanValue);
}
exports.isBooleanObject = isBooleanObject;

function isBigIntObject(value) {
  return BigIntSupported && checkBoxedPrimitive(value, bigIntValue);
}
exports.isBigIntObject = isBigIntObject;

function isSymbolObject(value) {
  return SymbolSupported && checkBoxedPrimitive(value, symbolValue);
}
exports.isSymbolObject = isSymbolObject;

function isBoxedPrimitive(value) {
  return (
    isNumberObject(value) ||
    isStringObject(value) ||
    isBooleanObject(value) ||
    isBigIntObject(value) ||
    isSymbolObject(value)
  );
}
exports.isBoxedPrimitive = isBoxedPrimitive;

function isAnyArrayBuffer(value) {
  return typeof Uint8Array !== 'undefined' && (
    isArrayBuffer(value) ||
    isSharedArrayBuffer(value)
  );
}
exports.isAnyArrayBuffer = isAnyArrayBuffer;

['isProxy', 'isExternal', 'isModuleNamespaceObject'].forEach(function(method) {
  Object.defineProperty(exports, method, {
    enumerable: false,
    value: function() {
      throw new Error(method + ' is not supported in userland');
    }
  });
});
 //*/
})
//# sourceURL=file:///home/xyz/Development/endo/node_modules/util/support/types.js
,
// === functors[77] ===
(function (require, exports, module, __filename, __dirname) { module.exports = function isBuffer(arg) {
  return arg instanceof Buffer;
}
 //*/
})
//# sourceURL=file:///home/xyz/Development/endo/node_modules/util/support/isBuffer.js
,
// === functors[78] ===
(function (require, exports, module, __filename, __dirname) { if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      })
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      var TempCtor = function () {}
      TempCtor.prototype = superCtor.prototype
      ctor.prototype = new TempCtor()
      ctor.prototype.constructor = ctor
    }
  }
}
 //*/
})
//# sourceURL=file:///home/xyz/Development/endo/node_modules/inherits/inherits_browser.js
,
// === functors[79] ===
(function (require, exports, module, __filename, __dirname) { try {
  var util = require('util');
  /* istanbul ignore next */
  if (typeof util.inherits !== 'function') throw '';
  module.exports = util.inherits;
} catch (e) {
  /* istanbul ignore next */
  module.exports = require('./inherits_browser.js');
}
 //*/
})
//# sourceURL=file:///home/xyz/Development/endo/node_modules/inherits/inherits.js
,
// === functors[80] ===
(function (require, exports, module, __filename, __dirname) { // Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors ||
  function getOwnPropertyDescriptors(obj) {
    var keys = Object.keys(obj);
    var descriptors = {};
    for (var i = 0; i < keys.length; i++) {
      descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
    }
    return descriptors;
  };

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  if (typeof process !== 'undefined' && process.noDeprecation === true) {
    return fn;
  }

  // Allow for deprecating things in the process of starting up.
  if (typeof process === 'undefined') {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnvRegex = /^$/;

if (process.env.NODE_DEBUG) {
  var debugEnv = process.env.NODE_DEBUG;
  debugEnv = debugEnv.replace(/[|\\{}()[\]^$+?.]/g, '\\$&')
    .replace(/\*/g, '.*')
    .replace(/,/g, '$|^')
    .toUpperCase();
  debugEnvRegex = new RegExp('^' + debugEnv + '$', 'i');
}
exports.debuglog = function(set) {
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (debugEnvRegex.test(set)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').slice(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.slice(1, -1);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
exports.types = require('./support/types');

function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;
exports.types.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;
exports.types.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;
exports.types.isNativeError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

var kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;

exports.promisify = function promisify(original) {
  if (typeof original !== 'function')
    throw new TypeError('The "original" argument must be of type Function');

  if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
    var fn = original[kCustomPromisifiedSymbol];
    if (typeof fn !== 'function') {
      throw new TypeError('The "util.promisify.custom" argument must be of type Function');
    }
    Object.defineProperty(fn, kCustomPromisifiedSymbol, {
      value: fn, enumerable: false, writable: false, configurable: true
    });
    return fn;
  }

  function fn() {
    var promiseResolve, promiseReject;
    var promise = new Promise(function (resolve, reject) {
      promiseResolve = resolve;
      promiseReject = reject;
    });

    var args = [];
    for (var i = 0; i < arguments.length; i++) {
      args.push(arguments[i]);
    }
    args.push(function (err, value) {
      if (err) {
        promiseReject(err);
      } else {
        promiseResolve(value);
      }
    });

    try {
      original.apply(this, args);
    } catch (err) {
      promiseReject(err);
    }

    return promise;
  }

  Object.setPrototypeOf(fn, Object.getPrototypeOf(original));

  if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {
    value: fn, enumerable: false, writable: false, configurable: true
  });
  return Object.defineProperties(
    fn,
    getOwnPropertyDescriptors(original)
  );
}

exports.promisify.custom = kCustomPromisifiedSymbol

function callbackifyOnRejected(reason, cb) {
  // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).
  // Because `null` is a special error value in callbacks which means "no error
  // occurred", we error-wrap so the callback consumer can distinguish between
  // "the promise rejected with null" or "the promise fulfilled with undefined".
  if (!reason) {
    var newReason = new Error('Promise was rejected with a falsy value');
    newReason.reason = reason;
    reason = newReason;
  }
  return cb(reason);
}

function callbackify(original) {
  if (typeof original !== 'function') {
    throw new TypeError('The "original" argument must be of type Function');
  }

  // We DO NOT return the promise as it gives the user a false sense that
  // the promise is actually somehow related to the callback's execution
  // and that the callback throwing will reject the promise.
  function callbackified() {
    var args = [];
    for (var i = 0; i < arguments.length; i++) {
      args.push(arguments[i]);
    }

    var maybeCb = args.pop();
    if (typeof maybeCb !== 'function') {
      throw new TypeError('The last argument must be of type Function');
    }
    var self = this;
    var cb = function() {
      return maybeCb.apply(self, arguments);
    };
    // In true node style we process the callback on `nextTick` with all the
    // implications (stack, `uncaughtException`, `async_hooks`)
    original.apply(this, args)
      .then(function(ret) { process.nextTick(cb.bind(null, null, ret)) },
            function(rej) { process.nextTick(callbackifyOnRejected.bind(null, rej, cb)) });
  }

  Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
  Object.defineProperties(callbackified,
                          getOwnPropertyDescriptors(original));
  return callbackified;
}
exports.callbackify = callbackify;
 //*/
})
//# sourceURL=file:///home/xyz/Development/endo/node_modules/util/util.js
,
// === functors[81] ===
(function (require, exports, module, __filename, __dirname) { module.exports = require('util').inspect;
 //*/
})
//# sourceURL=file:///home/xyz/Development/endo/node_modules/object-inspect/util.inspect.js
,
// === functors[82] ===
(function (require, exports, module, __filename, __dirname) { var hasMap = typeof Map === 'function' && Map.prototype;
var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, 'size') : null;
var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === 'function' ? mapSizeDescriptor.get : null;
var mapForEach = hasMap && Map.prototype.forEach;
var hasSet = typeof Set === 'function' && Set.prototype;
var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, 'size') : null;
var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === 'function' ? setSizeDescriptor.get : null;
var setForEach = hasSet && Set.prototype.forEach;
var hasWeakMap = typeof WeakMap === 'function' && WeakMap.prototype;
var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
var hasWeakSet = typeof WeakSet === 'function' && WeakSet.prototype;
var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
var hasWeakRef = typeof WeakRef === 'function' && WeakRef.prototype;
var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
var booleanValueOf = Boolean.prototype.valueOf;
var objectToString = Object.prototype.toString;
var functionToString = Function.prototype.toString;
var $match = String.prototype.match;
var $slice = String.prototype.slice;
var $replace = String.prototype.replace;
var $toUpperCase = String.prototype.toUpperCase;
var $toLowerCase = String.prototype.toLowerCase;
var $test = RegExp.prototype.test;
var $concat = Array.prototype.concat;
var $join = Array.prototype.join;
var $arrSlice = Array.prototype.slice;
var $floor = Math.floor;
var bigIntValueOf = typeof BigInt === 'function' ? BigInt.prototype.valueOf : null;
var gOPS = Object.getOwnPropertySymbols;
var symToString = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? Symbol.prototype.toString : null;
var hasShammedSymbols = typeof Symbol === 'function' && typeof Symbol.iterator === 'object';
// ie, `has-tostringtag/shams
var toStringTag = typeof Symbol === 'function' && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? 'object' : 'symbol')
    ? Symbol.toStringTag
    : null;
var isEnumerable = Object.prototype.propertyIsEnumerable;

var gPO = (typeof Reflect === 'function' ? Reflect.getPrototypeOf : Object.getPrototypeOf) || (
    [].__proto__ === Array.prototype // eslint-disable-line no-proto
        ? function (O) {
            return O.__proto__; // eslint-disable-line no-proto
        }
        : null
);

function addNumericSeparator(num, str) {
    if (
        num === Infinity
        || num === -Infinity
        || num !== num
        || (num && num > -1000 && num < 1000)
        || $test.call(/e/, str)
    ) {
        return str;
    }
    var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
    if (typeof num === 'number') {
        var int = num < 0 ? -$floor(-num) : $floor(num); // trunc(num)
        if (int !== num) {
            var intStr = String(int);
            var dec = $slice.call(str, intStr.length + 1);
            return $replace.call(intStr, sepRegex, '$&_') + '.' + $replace.call($replace.call(dec, /([0-9]{3})/g, '$&_'), /_$/, '');
        }
    }
    return $replace.call(str, sepRegex, '$&_');
}

var utilInspect = require('./util.inspect');
var inspectCustom = utilInspect.custom;
var inspectSymbol = isSymbol(inspectCustom) ? inspectCustom : null;

module.exports = function inspect_(obj, options, depth, seen) {
    var opts = options || {};

    if (has(opts, 'quoteStyle') && (opts.quoteStyle !== 'single' && opts.quoteStyle !== 'double')) {
        throw new TypeError('option "quoteStyle" must be "single" or "double"');
    }
    if (
        has(opts, 'maxStringLength') && (typeof opts.maxStringLength === 'number'
            ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity
            : opts.maxStringLength !== null
        )
    ) {
        throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
    }
    var customInspect = has(opts, 'customInspect') ? opts.customInspect : true;
    if (typeof customInspect !== 'boolean' && customInspect !== 'symbol') {
        throw new TypeError('option "customInspect", if provided, must be `true`, `false`, or `\'symbol\'`');
    }

    if (
        has(opts, 'indent')
        && opts.indent !== null
        && opts.indent !== '\t'
        && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)
    ) {
        throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
    }
    if (has(opts, 'numericSeparator') && typeof opts.numericSeparator !== 'boolean') {
        throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
    }
    var numericSeparator = opts.numericSeparator;

    if (typeof obj === 'undefined') {
        return 'undefined';
    }
    if (obj === null) {
        return 'null';
    }
    if (typeof obj === 'boolean') {
        return obj ? 'true' : 'false';
    }

    if (typeof obj === 'string') {
        return inspectString(obj, opts);
    }
    if (typeof obj === 'number') {
        if (obj === 0) {
            return Infinity / obj > 0 ? '0' : '-0';
        }
        var str = String(obj);
        return numericSeparator ? addNumericSeparator(obj, str) : str;
    }
    if (typeof obj === 'bigint') {
        var bigIntStr = String(obj) + 'n';
        return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
    }

    var maxDepth = typeof opts.depth === 'undefined' ? 5 : opts.depth;
    if (typeof depth === 'undefined') { depth = 0; }
    if (depth >= maxDepth && maxDepth > 0 && typeof obj === 'object') {
        return isArray(obj) ? '[Array]' : '[Object]';
    }

    var indent = getIndent(opts, depth);

    if (typeof seen === 'undefined') {
        seen = [];
    } else if (indexOf(seen, obj) >= 0) {
        return '[Circular]';
    }

    function inspect(value, from, noIndent) {
        if (from) {
            seen = $arrSlice.call(seen);
            seen.push(from);
        }
        if (noIndent) {
            var newOpts = {
                depth: opts.depth
            };
            if (has(opts, 'quoteStyle')) {
                newOpts.quoteStyle = opts.quoteStyle;
            }
            return inspect_(value, newOpts, depth + 1, seen);
        }
        return inspect_(value, opts, depth + 1, seen);
    }

    if (typeof obj === 'function' && !isRegExp(obj)) { // in older engines, regexes are callable
        var name = nameOf(obj);
        var keys = arrObjKeys(obj, inspect);
        return '[Function' + (name ? ': ' + name : ' (anonymous)') + ']' + (keys.length > 0 ? ' { ' + $join.call(keys, ', ') + ' }' : '');
    }
    if (isSymbol(obj)) {
        var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, '$1') : symToString.call(obj);
        return typeof obj === 'object' && !hasShammedSymbols ? markBoxed(symString) : symString;
    }
    if (isElement(obj)) {
        var s = '<' + $toLowerCase.call(String(obj.nodeName));
        var attrs = obj.attributes || [];
        for (var i = 0; i < attrs.length; i++) {
            s += ' ' + attrs[i].name + '=' + wrapQuotes(quote(attrs[i].value), 'double', opts);
        }
        s += '>';
        if (obj.childNodes && obj.childNodes.length) { s += '...'; }
        s += '</' + $toLowerCase.call(String(obj.nodeName)) + '>';
        return s;
    }
    if (isArray(obj)) {
        if (obj.length === 0) { return '[]'; }
        var xs = arrObjKeys(obj, inspect);
        if (indent && !singleLineValues(xs)) {
            return '[' + indentedJoin(xs, indent) + ']';
        }
        return '[ ' + $join.call(xs, ', ') + ' ]';
    }
    if (isError(obj)) {
        var parts = arrObjKeys(obj, inspect);
        if (!('cause' in Error.prototype) && 'cause' in obj && !isEnumerable.call(obj, 'cause')) {
            return '{ [' + String(obj) + '] ' + $join.call($concat.call('[cause]: ' + inspect(obj.cause), parts), ', ') + ' }';
        }
        if (parts.length === 0) { return '[' + String(obj) + ']'; }
        return '{ [' + String(obj) + '] ' + $join.call(parts, ', ') + ' }';
    }
    if (typeof obj === 'object' && customInspect) {
        if (inspectSymbol && typeof obj[inspectSymbol] === 'function' && utilInspect) {
            return utilInspect(obj, { depth: maxDepth - depth });
        } else if (customInspect !== 'symbol' && typeof obj.inspect === 'function') {
            return obj.inspect();
        }
    }
    if (isMap(obj)) {
        var mapParts = [];
        if (mapForEach) {
            mapForEach.call(obj, function (value, key) {
                mapParts.push(inspect(key, obj, true) + ' => ' + inspect(value, obj));
            });
        }
        return collectionOf('Map', mapSize.call(obj), mapParts, indent);
    }
    if (isSet(obj)) {
        var setParts = [];
        if (setForEach) {
            setForEach.call(obj, function (value) {
                setParts.push(inspect(value, obj));
            });
        }
        return collectionOf('Set', setSize.call(obj), setParts, indent);
    }
    if (isWeakMap(obj)) {
        return weakCollectionOf('WeakMap');
    }
    if (isWeakSet(obj)) {
        return weakCollectionOf('WeakSet');
    }
    if (isWeakRef(obj)) {
        return weakCollectionOf('WeakRef');
    }
    if (isNumber(obj)) {
        return markBoxed(inspect(Number(obj)));
    }
    if (isBigInt(obj)) {
        return markBoxed(inspect(bigIntValueOf.call(obj)));
    }
    if (isBoolean(obj)) {
        return markBoxed(booleanValueOf.call(obj));
    }
    if (isString(obj)) {
        return markBoxed(inspect(String(obj)));
    }
    if (!isDate(obj) && !isRegExp(obj)) {
        var ys = arrObjKeys(obj, inspect);
        var isPlainObject = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
        var protoTag = obj instanceof Object ? '' : 'null prototype';
        var stringTag = !isPlainObject && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? 'Object' : '';
        var constructorTag = isPlainObject || typeof obj.constructor !== 'function' ? '' : obj.constructor.name ? obj.constructor.name + ' ' : '';
        var tag = constructorTag + (stringTag || protoTag ? '[' + $join.call($concat.call([], stringTag || [], protoTag || []), ': ') + '] ' : '');
        if (ys.length === 0) { return tag + '{}'; }
        if (indent) {
            return tag + '{' + indentedJoin(ys, indent) + '}';
        }
        return tag + '{ ' + $join.call(ys, ', ') + ' }';
    }
    return String(obj);
};

function wrapQuotes(s, defaultStyle, opts) {
    var quoteChar = (opts.quoteStyle || defaultStyle) === 'double' ? '"' : "'";
    return quoteChar + s + quoteChar;
}

function quote(s) {
    return $replace.call(String(s), /"/g, '&quot;');
}

function isArray(obj) { return toStr(obj) === '[object Array]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
function isDate(obj) { return toStr(obj) === '[object Date]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
function isRegExp(obj) { return toStr(obj) === '[object RegExp]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
function isError(obj) { return toStr(obj) === '[object Error]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
function isString(obj) { return toStr(obj) === '[object String]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
function isNumber(obj) { return toStr(obj) === '[object Number]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
function isBoolean(obj) { return toStr(obj) === '[object Boolean]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }

// Symbol and BigInt do have Symbol.toStringTag by spec, so that can't be used to eliminate false positives
function isSymbol(obj) {
    if (hasShammedSymbols) {
        return obj && typeof obj === 'object' && obj instanceof Symbol;
    }
    if (typeof obj === 'symbol') {
        return true;
    }
    if (!obj || typeof obj !== 'object' || !symToString) {
        return false;
    }
    try {
        symToString.call(obj);
        return true;
    } catch (e) {}
    return false;
}

function isBigInt(obj) {
    if (!obj || typeof obj !== 'object' || !bigIntValueOf) {
        return false;
    }
    try {
        bigIntValueOf.call(obj);
        return true;
    } catch (e) {}
    return false;
}

var hasOwn = Object.prototype.hasOwnProperty || function (key) { return key in this; };
function has(obj, key) {
    return hasOwn.call(obj, key);
}

function toStr(obj) {
    return objectToString.call(obj);
}

function nameOf(f) {
    if (f.name) { return f.name; }
    var m = $match.call(functionToString.call(f), /^function\s*([\w$]+)/);
    if (m) { return m[1]; }
    return null;
}

function indexOf(xs, x) {
    if (xs.indexOf) { return xs.indexOf(x); }
    for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x) { return i; }
    }
    return -1;
}

function isMap(x) {
    if (!mapSize || !x || typeof x !== 'object') {
        return false;
    }
    try {
        mapSize.call(x);
        try {
            setSize.call(x);
        } catch (s) {
            return true;
        }
        return x instanceof Map; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
}

function isWeakMap(x) {
    if (!weakMapHas || !x || typeof x !== 'object') {
        return false;
    }
    try {
        weakMapHas.call(x, weakMapHas);
        try {
            weakSetHas.call(x, weakSetHas);
        } catch (s) {
            return true;
        }
        return x instanceof WeakMap; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
}

function isWeakRef(x) {
    if (!weakRefDeref || !x || typeof x !== 'object') {
        return false;
    }
    try {
        weakRefDeref.call(x);
        return true;
    } catch (e) {}
    return false;
}

function isSet(x) {
    if (!setSize || !x || typeof x !== 'object') {
        return false;
    }
    try {
        setSize.call(x);
        try {
            mapSize.call(x);
        } catch (m) {
            return true;
        }
        return x instanceof Set; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
}

function isWeakSet(x) {
    if (!weakSetHas || !x || typeof x !== 'object') {
        return false;
    }
    try {
        weakSetHas.call(x, weakSetHas);
        try {
            weakMapHas.call(x, weakMapHas);
        } catch (s) {
            return true;
        }
        return x instanceof WeakSet; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
}

function isElement(x) {
    if (!x || typeof x !== 'object') { return false; }
    if (typeof HTMLElement !== 'undefined' && x instanceof HTMLElement) {
        return true;
    }
    return typeof x.nodeName === 'string' && typeof x.getAttribute === 'function';
}

function inspectString(str, opts) {
    if (str.length > opts.maxStringLength) {
        var remaining = str.length - opts.maxStringLength;
        var trailer = '... ' + remaining + ' more character' + (remaining > 1 ? 's' : '');
        return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;
    }
    // eslint-disable-next-line no-control-regex
    var s = $replace.call($replace.call(str, /(['\\])/g, '\\$1'), /[\x00-\x1f]/g, lowbyte);
    return wrapQuotes(s, 'single', opts);
}

function lowbyte(c) {
    var n = c.charCodeAt(0);
    var x = {
        8: 'b',
        9: 't',
        10: 'n',
        12: 'f',
        13: 'r'
    }[n];
    if (x) { return '\\' + x; }
    return '\\x' + (n < 0x10 ? '0' : '') + $toUpperCase.call(n.toString(16));
}

function markBoxed(str) {
    return 'Object(' + str + ')';
}

function weakCollectionOf(type) {
    return type + ' { ? }';
}

function collectionOf(type, size, entries, indent) {
    var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ', ');
    return type + ' (' + size + ') {' + joinedEntries + '}';
}

function singleLineValues(xs) {
    for (var i = 0; i < xs.length; i++) {
        if (indexOf(xs[i], '\n') >= 0) {
            return false;
        }
    }
    return true;
}

function getIndent(opts, depth) {
    var baseIndent;
    if (opts.indent === '\t') {
        baseIndent = '\t';
    } else if (typeof opts.indent === 'number' && opts.indent > 0) {
        baseIndent = $join.call(Array(opts.indent + 1), ' ');
    } else {
        return null;
    }
    return {
        base: baseIndent,
        prev: $join.call(Array(depth + 1), baseIndent)
    };
}

function indentedJoin(xs, indent) {
    if (xs.length === 0) { return ''; }
    var lineJoiner = '\n' + indent.prev + indent.base;
    return lineJoiner + $join.call(xs, ',' + lineJoiner) + '\n' + indent.prev;
}

function arrObjKeys(obj, inspect) {
    var isArr = isArray(obj);
    var xs = [];
    if (isArr) {
        xs.length = obj.length;
        for (var i = 0; i < obj.length; i++) {
            xs[i] = has(obj, i) ? inspect(obj[i], obj) : '';
        }
    }
    var syms = typeof gOPS === 'function' ? gOPS(obj) : [];
    var symMap;
    if (hasShammedSymbols) {
        symMap = {};
        for (var k = 0; k < syms.length; k++) {
            symMap['$' + syms[k]] = syms[k];
        }
    }

    for (var key in obj) { // eslint-disable-line no-restricted-syntax
        if (!has(obj, key)) { continue; } // eslint-disable-line no-restricted-syntax, no-continue
        if (isArr && String(Number(key)) === key && key < obj.length) { continue; } // eslint-disable-line no-restricted-syntax, no-continue
        if (hasShammedSymbols && symMap['$' + key] instanceof Symbol) {
            // this is to prevent shammed Symbols, which are stored as strings, from being included in the string key section
            continue; // eslint-disable-line no-restricted-syntax, no-continue
        } else if ($test.call(/[^\w$]/, key)) {
            xs.push(inspect(key, obj) + ': ' + inspect(obj[key], obj));
        } else {
            xs.push(key + ': ' + inspect(obj[key], obj));
        }
    }
    if (typeof gOPS === 'function') {
        for (var j = 0; j < syms.length; j++) {
            if (isEnumerable.call(obj, syms[j])) {
                xs.push('[' + inspect(syms[j]) + ']: ' + inspect(obj[syms[j]], obj));
            }
        }
    }
    return xs;
}
 //*/
})
//# sourceURL=file:///home/xyz/Development/endo/node_modules/object-inspect/index.js
,
// === functors[83] ===
(function (require, exports, module, __filename, __dirname) { 'use strict';

var GetIntrinsic = require('get-intrinsic');
var callBound = require('call-bind/callBound');
var inspect = require('object-inspect');

var $TypeError = GetIntrinsic('%TypeError%');
var $WeakMap = GetIntrinsic('%WeakMap%', true);
var $Map = GetIntrinsic('%Map%', true);

var $weakMapGet = callBound('WeakMap.prototype.get', true);
var $weakMapSet = callBound('WeakMap.prototype.set', true);
var $weakMapHas = callBound('WeakMap.prototype.has', true);
var $mapGet = callBound('Map.prototype.get', true);
var $mapSet = callBound('Map.prototype.set', true);
var $mapHas = callBound('Map.prototype.has', true);

/*
 * This function traverses the list returning the node corresponding to the
 * given key.
 *
 * That node is also moved to the head of the list, so that if it's accessed
 * again we don't need to traverse the whole list. By doing so, all the recently
 * used nodes can be accessed relatively quickly.
 */
var listGetNode = function (list, key) { // eslint-disable-line consistent-return
	for (var prev = list, curr; (curr = prev.next) !== null; prev = curr) {
		if (curr.key === key) {
			prev.next = curr.next;
			curr.next = list.next;
			list.next = curr; // eslint-disable-line no-param-reassign
			return curr;
		}
	}
};

var listGet = function (objects, key) {
	var node = listGetNode(objects, key);
	return node && node.value;
};
var listSet = function (objects, key, value) {
	var node = listGetNode(objects, key);
	if (node) {
		node.value = value;
	} else {
		// Prepend the new node to the beginning of the list
		objects.next = { // eslint-disable-line no-param-reassign
			key: key,
			next: objects.next,
			value: value
		};
	}
};
var listHas = function (objects, key) {
	return !!listGetNode(objects, key);
};

module.exports = function getSideChannel() {
	var $wm;
	var $m;
	var $o;
	var channel = {
		assert: function (key) {
			if (!channel.has(key)) {
				throw new $TypeError('Side channel does not contain ' + inspect(key));
			}
		},
		get: function (key) { // eslint-disable-line consistent-return
			if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
				if ($wm) {
					return $weakMapGet($wm, key);
				}
			} else if ($Map) {
				if ($m) {
					return $mapGet($m, key);
				}
			} else {
				if ($o) { // eslint-disable-line no-lonely-if
					return listGet($o, key);
				}
			}
		},
		has: function (key) {
			if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
				if ($wm) {
					return $weakMapHas($wm, key);
				}
			} else if ($Map) {
				if ($m) {
					return $mapHas($m, key);
				}
			} else {
				if ($o) { // eslint-disable-line no-lonely-if
					return listHas($o, key);
				}
			}
			return false;
		},
		set: function (key, value) {
			if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
				if (!$wm) {
					$wm = new $WeakMap();
				}
				$weakMapSet($wm, key, value);
			} else if ($Map) {
				if (!$m) {
					$m = new $Map();
				}
				$mapSet($m, key, value);
			} else {
				if (!$o) {
					/*
					 * Initialize the linked list as an empty node, so that we don't have
					 * to special-case handling of the first node: we can always refer to
					 * it as (previous node).next, instead of something like (list).head
					 */
					$o = { key: {}, next: null };
				}
				listSet($o, key, value);
			}
		}
	};
	return channel;
};
 //*/
})
//# sourceURL=file:///home/xyz/Development/endo/node_modules/side-channel/index.js
,
// === functors[84] ===
(function (require, exports, module, __filename, __dirname) { 'use strict';

var replace = String.prototype.replace;
var percentTwenties = /%20/g;

var Format = {
    RFC1738: 'RFC1738',
    RFC3986: 'RFC3986'
};

module.exports = {
    'default': Format.RFC3986,
    formatters: {
        RFC1738: function (value) {
            return replace.call(value, percentTwenties, '+');
        },
        RFC3986: function (value) {
            return String(value);
        }
    },
    RFC1738: Format.RFC1738,
    RFC3986: Format.RFC3986
};
 //*/
})
//# sourceURL=file:///home/xyz/Development/endo/node_modules/qs/lib/formats.js
,
// === functors[85] ===
(function (require, exports, module, __filename, __dirname) { 'use strict';

var formats = require('./formats');

var has = Object.prototype.hasOwnProperty;
var isArray = Array.isArray;

var hexTable = (function () {
    var array = [];
    for (var i = 0; i < 256; ++i) {
        array.push('%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase());
    }

    return array;
}());

var compactQueue = function compactQueue(queue) {
    while (queue.length > 1) {
        var item = queue.pop();
        var obj = item.obj[item.prop];

        if (isArray(obj)) {
            var compacted = [];

            for (var j = 0; j < obj.length; ++j) {
                if (typeof obj[j] !== 'undefined') {
                    compacted.push(obj[j]);
                }
            }

            item.obj[item.prop] = compacted;
        }
    }
};

var arrayToObject = function arrayToObject(source, options) {
    var obj = options && options.plainObjects ? Object.create(null) : {};
    for (var i = 0; i < source.length; ++i) {
        if (typeof source[i] !== 'undefined') {
            obj[i] = source[i];
        }
    }

    return obj;
};

var merge = function merge(target, source, options) {
    /* eslint no-param-reassign: 0 */
    if (!source) {
        return target;
    }

    if (typeof source !== 'object') {
        if (isArray(target)) {
            target.push(source);
        } else if (target && typeof target === 'object') {
            if ((options && (options.plainObjects || options.allowPrototypes)) || !has.call(Object.prototype, source)) {
                target[source] = true;
            }
        } else {
            return [target, source];
        }

        return target;
    }

    if (!target || typeof target !== 'object') {
        return [target].concat(source);
    }

    var mergeTarget = target;
    if (isArray(target) && !isArray(source)) {
        mergeTarget = arrayToObject(target, options);
    }

    if (isArray(target) && isArray(source)) {
        source.forEach(function (item, i) {
            if (has.call(target, i)) {
                var targetItem = target[i];
                if (targetItem && typeof targetItem === 'object' && item && typeof item === 'object') {
                    target[i] = merge(targetItem, item, options);
                } else {
                    target.push(item);
                }
            } else {
                target[i] = item;
            }
        });
        return target;
    }

    return Object.keys(source).reduce(function (acc, key) {
        var value = source[key];

        if (has.call(acc, key)) {
            acc[key] = merge(acc[key], value, options);
        } else {
            acc[key] = value;
        }
        return acc;
    }, mergeTarget);
};

var assign = function assignSingleSource(target, source) {
    return Object.keys(source).reduce(function (acc, key) {
        acc[key] = source[key];
        return acc;
    }, target);
};

var decode = function (str, decoder, charset) {
    var strWithoutPlus = str.replace(/\+/g, ' ');
    if (charset === 'iso-8859-1') {
        // unescape never throws, no try...catch needed:
        return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
    }
    // utf-8
    try {
        return decodeURIComponent(strWithoutPlus);
    } catch (e) {
        return strWithoutPlus;
    }
};

var encode = function encode(str, defaultEncoder, charset, kind, format) {
    // This code was originally written by Brian White (mscdex) for the io.js core querystring library.
    // It has been adapted here for stricter adherence to RFC 3986
    if (str.length === 0) {
        return str;
    }

    var string = str;
    if (typeof str === 'symbol') {
        string = Symbol.prototype.toString.call(str);
    } else if (typeof str !== 'string') {
        string = String(str);
    }

    if (charset === 'iso-8859-1') {
        return escape(string).replace(/%u[0-9a-f]{4}/gi, function ($0) {
            return '%26%23' + parseInt($0.slice(2), 16) + '%3B';
        });
    }

    var out = '';
    for (var i = 0; i < string.length; ++i) {
        var c = string.charCodeAt(i);

        if (
            c === 0x2D // -
            || c === 0x2E // .
            || c === 0x5F // _
            || c === 0x7E // ~
            || (c >= 0x30 && c <= 0x39) // 0-9
            || (c >= 0x41 && c <= 0x5A) // a-z
            || (c >= 0x61 && c <= 0x7A) // A-Z
            || (format === formats.RFC1738 && (c === 0x28 || c === 0x29)) // ( )
        ) {
            out += string.charAt(i);
            continue;
        }

        if (c < 0x80) {
            out = out + hexTable[c];
            continue;
        }

        if (c < 0x800) {
            out = out + (hexTable[0xC0 | (c >> 6)] + hexTable[0x80 | (c & 0x3F)]);
            continue;
        }

        if (c < 0xD800 || c >= 0xE000) {
            out = out + (hexTable[0xE0 | (c >> 12)] + hexTable[0x80 | ((c >> 6) & 0x3F)] + hexTable[0x80 | (c & 0x3F)]);
            continue;
        }

        i += 1;
        c = 0x10000 + (((c & 0x3FF) << 10) | (string.charCodeAt(i) & 0x3FF));
        /* eslint operator-linebreak: [2, "before"] */
        out += hexTable[0xF0 | (c >> 18)]
            + hexTable[0x80 | ((c >> 12) & 0x3F)]
            + hexTable[0x80 | ((c >> 6) & 0x3F)]
            + hexTable[0x80 | (c & 0x3F)];
    }

    return out;
};

var compact = function compact(value) {
    var queue = [{ obj: { o: value }, prop: 'o' }];
    var refs = [];

    for (var i = 0; i < queue.length; ++i) {
        var item = queue[i];
        var obj = item.obj[item.prop];

        var keys = Object.keys(obj);
        for (var j = 0; j < keys.length; ++j) {
            var key = keys[j];
            var val = obj[key];
            if (typeof val === 'object' && val !== null && refs.indexOf(val) === -1) {
                queue.push({ obj: obj, prop: key });
                refs.push(val);
            }
        }
    }

    compactQueue(queue);

    return value;
};

var isRegExp = function isRegExp(obj) {
    return Object.prototype.toString.call(obj) === '[object RegExp]';
};

var isBuffer = function isBuffer(obj) {
    if (!obj || typeof obj !== 'object') {
        return false;
    }

    return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
};

var combine = function combine(a, b) {
    return [].concat(a, b);
};

var maybeMap = function maybeMap(val, fn) {
    if (isArray(val)) {
        var mapped = [];
        for (var i = 0; i < val.length; i += 1) {
            mapped.push(fn(val[i]));
        }
        return mapped;
    }
    return fn(val);
};

module.exports = {
    arrayToObject: arrayToObject,
    assign: assign,
    combine: combine,
    compact: compact,
    decode: decode,
    encode: encode,
    isBuffer: isBuffer,
    isRegExp: isRegExp,
    maybeMap: maybeMap,
    merge: merge
};
 //*/
})
//# sourceURL=file:///home/xyz/Development/endo/node_modules/qs/lib/utils.js
,
// === functors[86] ===
(function (require, exports, module, __filename, __dirname) { 'use strict';

var getSideChannel = require('side-channel');
var utils = require('./utils');
var formats = require('./formats');
var has = Object.prototype.hasOwnProperty;

var arrayPrefixGenerators = {
    brackets: function brackets(prefix) {
        return prefix + '[]';
    },
    comma: 'comma',
    indices: function indices(prefix, key) {
        return prefix + '[' + key + ']';
    },
    repeat: function repeat(prefix) {
        return prefix;
    }
};

var isArray = Array.isArray;
var push = Array.prototype.push;
var pushToArray = function (arr, valueOrArray) {
    push.apply(arr, isArray(valueOrArray) ? valueOrArray : [valueOrArray]);
};

var toISO = Date.prototype.toISOString;

var defaultFormat = formats['default'];
var defaults = {
    addQueryPrefix: false,
    allowDots: false,
    charset: 'utf-8',
    charsetSentinel: false,
    delimiter: '&',
    encode: true,
    encoder: utils.encode,
    encodeValuesOnly: false,
    format: defaultFormat,
    formatter: formats.formatters[defaultFormat],
    // deprecated
    indices: false,
    serializeDate: function serializeDate(date) {
        return toISO.call(date);
    },
    skipNulls: false,
    strictNullHandling: false
};

var isNonNullishPrimitive = function isNonNullishPrimitive(v) {
    return typeof v === 'string'
        || typeof v === 'number'
        || typeof v === 'boolean'
        || typeof v === 'symbol'
        || typeof v === 'bigint';
};

var sentinel = {};

var stringify = function stringify(
    object,
    prefix,
    generateArrayPrefix,
    commaRoundTrip,
    strictNullHandling,
    skipNulls,
    encoder,
    filter,
    sort,
    allowDots,
    serializeDate,
    format,
    formatter,
    encodeValuesOnly,
    charset,
    sideChannel
) {
    var obj = object;

    var tmpSc = sideChannel;
    var step = 0;
    var findFlag = false;
    while ((tmpSc = tmpSc.get(sentinel)) !== void undefined && !findFlag) {
        // Where object last appeared in the ref tree
        var pos = tmpSc.get(object);
        step += 1;
        if (typeof pos !== 'undefined') {
            if (pos === step) {
                throw new RangeError('Cyclic object value');
            } else {
                findFlag = true; // Break while
            }
        }
        if (typeof tmpSc.get(sentinel) === 'undefined') {
            step = 0;
        }
    }

    if (typeof filter === 'function') {
        obj = filter(prefix, obj);
    } else if (obj instanceof Date) {
        obj = serializeDate(obj);
    } else if (generateArrayPrefix === 'comma' && isArray(obj)) {
        obj = utils.maybeMap(obj, function (value) {
            if (value instanceof Date) {
                return serializeDate(value);
            }
            return value;
        });
    }

    if (obj === null) {
        if (strictNullHandling) {
            return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder, charset, 'key', format) : prefix;
        }

        obj = '';
    }

    if (isNonNullishPrimitive(obj) || utils.isBuffer(obj)) {
        if (encoder) {
            var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder, charset, 'key', format);
            return [formatter(keyValue) + '=' + formatter(encoder(obj, defaults.encoder, charset, 'value', format))];
        }
        return [formatter(prefix) + '=' + formatter(String(obj))];
    }

    var values = [];

    if (typeof obj === 'undefined') {
        return values;
    }

    var objKeys;
    if (generateArrayPrefix === 'comma' && isArray(obj)) {
        // we need to join elements in
        if (encodeValuesOnly && encoder) {
            obj = utils.maybeMap(obj, encoder);
        }
        objKeys = [{ value: obj.length > 0 ? obj.join(',') || null : void undefined }];
    } else if (isArray(filter)) {
        objKeys = filter;
    } else {
        var keys = Object.keys(obj);
        objKeys = sort ? keys.sort(sort) : keys;
    }

    var adjustedPrefix = commaRoundTrip && isArray(obj) && obj.length === 1 ? prefix + '[]' : prefix;

    for (var j = 0; j < objKeys.length; ++j) {
        var key = objKeys[j];
        var value = typeof key === 'object' && typeof key.value !== 'undefined' ? key.value : obj[key];

        if (skipNulls && value === null) {
            continue;
        }

        var keyPrefix = isArray(obj)
            ? typeof generateArrayPrefix === 'function' ? generateArrayPrefix(adjustedPrefix, key) : adjustedPrefix
            : adjustedPrefix + (allowDots ? '.' + key : '[' + key + ']');

        sideChannel.set(object, step);
        var valueSideChannel = getSideChannel();
        valueSideChannel.set(sentinel, sideChannel);
        pushToArray(values, stringify(
            value,
            keyPrefix,
            generateArrayPrefix,
            commaRoundTrip,
            strictNullHandling,
            skipNulls,
            generateArrayPrefix === 'comma' && encodeValuesOnly && isArray(obj) ? null : encoder,
            filter,
            sort,
            allowDots,
            serializeDate,
            format,
            formatter,
            encodeValuesOnly,
            charset,
            valueSideChannel
        ));
    }

    return values;
};

var normalizeStringifyOptions = function normalizeStringifyOptions(opts) {
    if (!opts) {
        return defaults;
    }

    if (opts.encoder !== null && typeof opts.encoder !== 'undefined' && typeof opts.encoder !== 'function') {
        throw new TypeError('Encoder has to be a function.');
    }

    var charset = opts.charset || defaults.charset;
    if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {
        throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');
    }

    var format = formats['default'];
    if (typeof opts.format !== 'undefined') {
        if (!has.call(formats.formatters, opts.format)) {
            throw new TypeError('Unknown format option provided.');
        }
        format = opts.format;
    }
    var formatter = formats.formatters[format];

    var filter = defaults.filter;
    if (typeof opts.filter === 'function' || isArray(opts.filter)) {
        filter = opts.filter;
    }

    return {
        addQueryPrefix: typeof opts.addQueryPrefix === 'boolean' ? opts.addQueryPrefix : defaults.addQueryPrefix,
        allowDots: typeof opts.allowDots === 'undefined' ? defaults.allowDots : !!opts.allowDots,
        charset: charset,
        charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,
        delimiter: typeof opts.delimiter === 'undefined' ? defaults.delimiter : opts.delimiter,
        encode: typeof opts.encode === 'boolean' ? opts.encode : defaults.encode,
        encoder: typeof opts.encoder === 'function' ? opts.encoder : defaults.encoder,
        encodeValuesOnly: typeof opts.encodeValuesOnly === 'boolean' ? opts.encodeValuesOnly : defaults.encodeValuesOnly,
        filter: filter,
        format: format,
        formatter: formatter,
        serializeDate: typeof opts.serializeDate === 'function' ? opts.serializeDate : defaults.serializeDate,
        skipNulls: typeof opts.skipNulls === 'boolean' ? opts.skipNulls : defaults.skipNulls,
        sort: typeof opts.sort === 'function' ? opts.sort : null,
        strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults.strictNullHandling
    };
};

module.exports = function (object, opts) {
    var obj = object;
    var options = normalizeStringifyOptions(opts);

    var objKeys;
    var filter;

    if (typeof options.filter === 'function') {
        filter = options.filter;
        obj = filter('', obj);
    } else if (isArray(options.filter)) {
        filter = options.filter;
        objKeys = filter;
    }

    var keys = [];

    if (typeof obj !== 'object' || obj === null) {
        return '';
    }

    var arrayFormat;
    if (opts && opts.arrayFormat in arrayPrefixGenerators) {
        arrayFormat = opts.arrayFormat;
    } else if (opts && 'indices' in opts) {
        arrayFormat = opts.indices ? 'indices' : 'repeat';
    } else {
        arrayFormat = 'indices';
    }

    var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];
    if (opts && 'commaRoundTrip' in opts && typeof opts.commaRoundTrip !== 'boolean') {
        throw new TypeError('`commaRoundTrip` must be a boolean, or absent');
    }
    var commaRoundTrip = generateArrayPrefix === 'comma' && opts && opts.commaRoundTrip;

    if (!objKeys) {
        objKeys = Object.keys(obj);
    }

    if (options.sort) {
        objKeys.sort(options.sort);
    }

    var sideChannel = getSideChannel();
    for (var i = 0; i < objKeys.length; ++i) {
        var key = objKeys[i];

        if (options.skipNulls && obj[key] === null) {
            continue;
        }
        pushToArray(keys, stringify(
            obj[key],
            key,
            generateArrayPrefix,
            commaRoundTrip,
            options.strictNullHandling,
            options.skipNulls,
            options.encode ? options.encoder : null,
            options.filter,
            options.sort,
            options.allowDots,
            options.serializeDate,
            options.format,
            options.formatter,
            options.encodeValuesOnly,
            options.charset,
            sideChannel
        ));
    }

    var joined = keys.join(options.delimiter);
    var prefix = options.addQueryPrefix === true ? '?' : '';

    if (options.charsetSentinel) {
        if (options.charset === 'iso-8859-1') {
            // encodeURIComponent('&#10003;'), the "numeric entity" representation of a checkmark
            prefix += 'utf8=%26%2310003%3B&';
        } else {
            // encodeURIComponent('✓')
            prefix += 'utf8=%E2%9C%93&';
        }
    }

    return joined.length > 0 ? prefix + joined : '';
};
 //*/
})
//# sourceURL=file:///home/xyz/Development/endo/node_modules/qs/lib/stringify.js
,
// === functors[87] ===
(function (require, exports, module, __filename, __dirname) { 'use strict';

var utils = require('./utils');

var has = Object.prototype.hasOwnProperty;
var isArray = Array.isArray;

var defaults = {
    allowDots: false,
    allowPrototypes: false,
    allowSparse: false,
    arrayLimit: 20,
    charset: 'utf-8',
    charsetSentinel: false,
    comma: false,
    decoder: utils.decode,
    delimiter: '&',
    depth: 5,
    ignoreQueryPrefix: false,
    interpretNumericEntities: false,
    parameterLimit: 1000,
    parseArrays: true,
    plainObjects: false,
    strictNullHandling: false
};

var interpretNumericEntities = function (str) {
    return str.replace(/&#(\d+);/g, function ($0, numberStr) {
        return String.fromCharCode(parseInt(numberStr, 10));
    });
};

var parseArrayValue = function (val, options) {
    if (val && typeof val === 'string' && options.comma && val.indexOf(',') > -1) {
        return val.split(',');
    }

    return val;
};

// This is what browsers will submit when the ✓ character occurs in an
// application/x-www-form-urlencoded body and the encoding of the page containing
// the form is iso-8859-1, or when the submitted form has an accept-charset
// attribute of iso-8859-1. Presumably also with other charsets that do not contain
// the ✓ character, such as us-ascii.
var isoSentinel = 'utf8=%26%2310003%3B'; // encodeURIComponent('&#10003;')

// These are the percent-encoded utf-8 octets representing a checkmark, indicating that the request actually is utf-8 encoded.
var charsetSentinel = 'utf8=%E2%9C%93'; // encodeURIComponent('✓')

var parseValues = function parseQueryStringValues(str, options) {
    var obj = { __proto__: null };

    var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, '') : str;
    var limit = options.parameterLimit === Infinity ? undefined : options.parameterLimit;
    var parts = cleanStr.split(options.delimiter, limit);
    var skipIndex = -1; // Keep track of where the utf8 sentinel was found
    var i;

    var charset = options.charset;
    if (options.charsetSentinel) {
        for (i = 0; i < parts.length; ++i) {
            if (parts[i].indexOf('utf8=') === 0) {
                if (parts[i] === charsetSentinel) {
                    charset = 'utf-8';
                } else if (parts[i] === isoSentinel) {
                    charset = 'iso-8859-1';
                }
                skipIndex = i;
                i = parts.length; // The eslint settings do not allow break;
            }
        }
    }

    for (i = 0; i < parts.length; ++i) {
        if (i === skipIndex) {
            continue;
        }
        var part = parts[i];

        var bracketEqualsPos = part.indexOf(']=');
        var pos = bracketEqualsPos === -1 ? part.indexOf('=') : bracketEqualsPos + 1;

        var key, val;
        if (pos === -1) {
            key = options.decoder(part, defaults.decoder, charset, 'key');
            val = options.strictNullHandling ? null : '';
        } else {
            key = options.decoder(part.slice(0, pos), defaults.decoder, charset, 'key');
            val = utils.maybeMap(
                parseArrayValue(part.slice(pos + 1), options),
                function (encodedVal) {
                    return options.decoder(encodedVal, defaults.decoder, charset, 'value');
                }
            );
        }

        if (val && options.interpretNumericEntities && charset === 'iso-8859-1') {
            val = interpretNumericEntities(val);
        }

        if (part.indexOf('[]=') > -1) {
            val = isArray(val) ? [val] : val;
        }

        if (has.call(obj, key)) {
            obj[key] = utils.combine(obj[key], val);
        } else {
            obj[key] = val;
        }
    }

    return obj;
};

var parseObject = function (chain, val, options, valuesParsed) {
    var leaf = valuesParsed ? val : parseArrayValue(val, options);

    for (var i = chain.length - 1; i >= 0; --i) {
        var obj;
        var root = chain[i];

        if (root === '[]' && options.parseArrays) {
            obj = [].concat(leaf);
        } else {
            obj = options.plainObjects ? Object.create(null) : {};
            var cleanRoot = root.charAt(0) === '[' && root.charAt(root.length - 1) === ']' ? root.slice(1, -1) : root;
            var index = parseInt(cleanRoot, 10);
            if (!options.parseArrays && cleanRoot === '') {
                obj = { 0: leaf };
            } else if (
                !isNaN(index)
                && root !== cleanRoot
                && String(index) === cleanRoot
                && index >= 0
                && (options.parseArrays && index <= options.arrayLimit)
            ) {
                obj = [];
                obj[index] = leaf;
            } else if (cleanRoot !== '__proto__') {
                obj[cleanRoot] = leaf;
            }
        }

        leaf = obj;
    }

    return leaf;
};

var parseKeys = function parseQueryStringKeys(givenKey, val, options, valuesParsed) {
    if (!givenKey) {
        return;
    }

    // Transform dot notation to bracket notation
    var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, '[$1]') : givenKey;

    // The regex chunks

    var brackets = /(\[[^[\]]*])/;
    var child = /(\[[^[\]]*])/g;

    // Get the parent

    var segment = options.depth > 0 && brackets.exec(key);
    var parent = segment ? key.slice(0, segment.index) : key;

    // Stash the parent if it exists

    var keys = [];
    if (parent) {
        // If we aren't using plain objects, optionally prefix keys that would overwrite object prototype properties
        if (!options.plainObjects && has.call(Object.prototype, parent)) {
            if (!options.allowPrototypes) {
                return;
            }
        }

        keys.push(parent);
    }

    // Loop through children appending to the array until we hit depth

    var i = 0;
    while (options.depth > 0 && (segment = child.exec(key)) !== null && i < options.depth) {
        i += 1;
        if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
            if (!options.allowPrototypes) {
                return;
            }
        }
        keys.push(segment[1]);
    }

    // If there's a remainder, just add whatever is left

    if (segment) {
        keys.push('[' + key.slice(segment.index) + ']');
    }

    return parseObject(keys, val, options, valuesParsed);
};

var normalizeParseOptions = function normalizeParseOptions(opts) {
    if (!opts) {
        return defaults;
    }

    if (opts.decoder !== null && opts.decoder !== undefined && typeof opts.decoder !== 'function') {
        throw new TypeError('Decoder has to be a function.');
    }

    if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {
        throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');
    }
    var charset = typeof opts.charset === 'undefined' ? defaults.charset : opts.charset;

    return {
        allowDots: typeof opts.allowDots === 'undefined' ? defaults.allowDots : !!opts.allowDots,
        allowPrototypes: typeof opts.allowPrototypes === 'boolean' ? opts.allowPrototypes : defaults.allowPrototypes,
        allowSparse: typeof opts.allowSparse === 'boolean' ? opts.allowSparse : defaults.allowSparse,
        arrayLimit: typeof opts.arrayLimit === 'number' ? opts.arrayLimit : defaults.arrayLimit,
        charset: charset,
        charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,
        comma: typeof opts.comma === 'boolean' ? opts.comma : defaults.comma,
        decoder: typeof opts.decoder === 'function' ? opts.decoder : defaults.decoder,
        delimiter: typeof opts.delimiter === 'string' || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults.delimiter,
        // eslint-disable-next-line no-implicit-coercion, no-extra-parens
        depth: (typeof opts.depth === 'number' || opts.depth === false) ? +opts.depth : defaults.depth,
        ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
        interpretNumericEntities: typeof opts.interpretNumericEntities === 'boolean' ? opts.interpretNumericEntities : defaults.interpretNumericEntities,
        parameterLimit: typeof opts.parameterLimit === 'number' ? opts.parameterLimit : defaults.parameterLimit,
        parseArrays: opts.parseArrays !== false,
        plainObjects: typeof opts.plainObjects === 'boolean' ? opts.plainObjects : defaults.plainObjects,
        strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults.strictNullHandling
    };
};

module.exports = function (str, opts) {
    var options = normalizeParseOptions(opts);

    if (str === '' || str === null || typeof str === 'undefined') {
        return options.plainObjects ? Object.create(null) : {};
    }

    var tempObj = typeof str === 'string' ? parseValues(str, options) : str;
    var obj = options.plainObjects ? Object.create(null) : {};

    // Iterate over the keys and setup the new object

    var keys = Object.keys(tempObj);
    for (var i = 0; i < keys.length; ++i) {
        var key = keys[i];
        var newObj = parseKeys(key, tempObj[key], options, typeof str === 'string');
        obj = utils.merge(obj, newObj, options);
    }

    if (options.allowSparse === true) {
        return obj;
    }

    return utils.compact(obj);
};
 //*/
})
//# sourceURL=file:///home/xyz/Development/endo/node_modules/qs/lib/parse.js
,
// === functors[88] ===
(function (require, exports, module, __filename, __dirname) { 'use strict';

var stringify = require('./stringify');
var parse = require('./parse');
var formats = require('./formats');

module.exports = {
    formats: formats,
    parse: parse,
    stringify: stringify
};
 //*/
})
//# sourceURL=file:///home/xyz/Development/endo/node_modules/qs/lib/index.js
,
// === functors[89] ===
(function (require, exports, module, __filename, __dirname) { /*
 * Copyright Joyent, Inc. and other Node contributors.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to permit
 * persons to whom the Software is furnished to do so, subject to the
 * following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
 * NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
 * USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

'use strict';

var punycode = require('punycode');

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

/*
 * define these here so at least they only have to be
 * compiled once on the first module load.
 */
var protocolPattern = /^([a-z0-9.+-]+:)/i,
  portPattern = /:[0-9]*$/,

  // Special case for a simple path URL
  simplePathPattern = /^(\/\/?(?!\/)[^?\s]*)(\?[^\s]*)?$/,

  /*
   * RFC 2396: characters reserved for delimiting URLs.
   * We actually just auto-escape these.
   */
  delims = [
    '<', '>', '"', '`', ' ', '\r', '\n', '\t'
  ],

  // RFC 2396: characters not allowed for various reasons.
  unwise = [
    '{', '}', '|', '\\', '^', '`'
  ].concat(delims),

  // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
  autoEscape = ['\''].concat(unwise),
  /*
   * Characters that are never ever allowed in a hostname.
   * Note that any invalid chars are also handled, but these
   * are the ones that are *expected* to be seen, so we fast-path
   * them.
   */
  nonHostChars = [
    '%', '/', '?', ';', '#'
  ].concat(autoEscape),
  hostEndingChars = [
    '/', '?', '#'
  ],
  hostnameMaxLen = 255,
  hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
  hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
  // protocols that can allow "unsafe" and "unwise" chars.
  unsafeProtocol = {
    javascript: true,
    'javascript:': true
  },
  // protocols that never have a hostname.
  hostlessProtocol = {
    javascript: true,
    'javascript:': true
  },
  // protocols that always contain a // bit.
  slashedProtocol = {
    http: true,
    https: true,
    ftp: true,
    gopher: true,
    file: true,
    'http:': true,
    'https:': true,
    'ftp:': true,
    'gopher:': true,
    'file:': true
  },
  querystring = require('qs');

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && typeof url === 'object' && url instanceof Url) { return url; }

  var u = new Url();
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function (url, parseQueryString, slashesDenoteHost) {
  if (typeof url !== 'string') {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  /*
   * Copy chrome, IE, opera backslash-handling behavior.
   * Back slashes before the query string get converted to forward slashes
   * See: https://code.google.com/p/chromium/issues/detail?id=25916
   */
  var queryIndex = url.indexOf('?'),
    splitter = queryIndex !== -1 && queryIndex < url.indexOf('#') ? '?' : '#',
    uSplit = url.split(splitter),
    slashRegex = /\\/g;
  uSplit[0] = uSplit[0].replace(slashRegex, '/');
  url = uSplit.join(splitter);

  var rest = url;

  /*
   * trim before proceeding.
   * This is to support parse stuff like "  http://foo.com  \n"
   */
  rest = rest.trim();

  if (!slashesDenoteHost && url.split('#').length === 1) {
    // Try fast path regexp
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.path = rest;
      this.href = rest;
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
        if (parseQueryString) {
          this.query = querystring.parse(this.search.substr(1));
        } else {
          this.query = this.search.substr(1);
        }
      } else if (parseQueryString) {
        this.search = '';
        this.query = {};
      }
      return this;
    }
  }

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  /*
   * figure out if it's got a host
   * user@server is *always* interpreted as a hostname, and url
   * resolution will treat //foo/bar as host=foo,path=bar because that's
   * how the browser resolves relative URLs.
   */
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@/]+@[^@/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] && (slashes || (proto && !slashedProtocol[proto]))) {

    /*
     * there's a hostname.
     * the first instance of /, ?, ;, or # ends the host.
     *
     * If there is an @ in the hostname, then non-host chars *are* allowed
     * to the left of the last @ sign, unless some host-ending character
     * comes *before* the @-sign.
     * URLs are obnoxious.
     *
     * ex:
     * http://a@b@c/ => user:a@b host:c
     * http://a@b?@c => user:a host:c path:/?@c
     */

    /*
     * v0.12 TODO(isaacs): This is not quite how Chrome does things.
     * Review our test case against browsers more comprehensively.
     */

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) { hostEnd = hec; }
    }

    /*
     * at this point, either we have an explicit point where the
     * auth portion cannot go past, or the last @ char is the decider.
     */
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      /*
       * atSign must be in auth portion.
       * http://a@b/c@d => host:b auth:a path:/c@d
       */
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    /*
     * Now we have a portion which is definitely the auth.
     * Pull that off.
     */
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) { hostEnd = hec; }
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1) { hostEnd = rest.length; }

    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost();

    /*
     * we've indicated that there is a hostname,
     * so even if it's empty, it has to be present.
     */
    this.hostname = this.hostname || '';

    /*
     * if hostname begins with [ and ends with ]
     * assume that it's an IPv6 address.
     */
    var ipv6Hostname = this.hostname[0] === '[' && this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) { continue; }
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              /*
               * we replace non-ASCII char with a temporary placeholder
               * we need this to make sure size of hostname is not
               * broken by replacing non-ASCII by nothing
               */
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      /*
       * IDNA Support: Returns a punycoded representation of "domain".
       * It only converts parts of the domain name that
       * have non-ASCII characters, i.e. it doesn't matter if
       * you call it with a domain that already is ASCII-only.
       */
      this.hostname = punycode.toASCII(this.hostname);
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host;

    /*
     * strip [ and ] from the hostname
     * the host field still retains them, though
     */
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  /*
   * now rest is set to the post-host stuff.
   * chop off any delim chars.
   */
  if (!unsafeProtocol[lowerProto]) {

    /*
     * First, make 100% sure that any "autoEscape" chars get
     * escaped, even if encodeURIComponent doesn't think they
     * need to be.
     */
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      if (rest.indexOf(ae) === -1) { continue; }
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }

  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }
  if (rest) { this.pathname = rest; }
  if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
    this.pathname = '/';
  }

  // to support http.request
  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  }

  // finally, reconstruct the href based on what has been validated.
  this.href = this.format();
  return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
  /*
   * ensure it's an object, and not a string url.
   * If it's an obj, this is a no-op.
   * this way, you can call url_format() on strings
   * to clean up potentially wonky urls.
   */
  if (typeof obj === 'string') { obj = urlParse(obj); }
  if (!(obj instanceof Url)) { return Url.prototype.format.call(obj); }
  return obj.format();
}

Url.prototype.format = function () {
  var auth = this.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
    pathname = this.pathname || '',
    hash = this.hash || '',
    host = false,
    query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ? this.hostname : '[' + this.hostname + ']');
    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query && typeof this.query === 'object' && Object.keys(this.query).length) {
    query = querystring.stringify(this.query, {
      arrayFormat: 'repeat',
      addQueryPrefix: false
    });
  }

  var search = this.search || (query && ('?' + query)) || '';

  if (protocol && protocol.substr(-1) !== ':') { protocol += ':'; }

  /*
   * only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
   * unless they had them to begin with.
   */
  if (this.slashes || (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') { pathname = '/' + pathname; }
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') { hash = '#' + hash; }
  if (search && search.charAt(0) !== '?') { search = '?' + search; }

  pathname = pathname.replace(/[?#]/g, function (match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function (relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) { return relative; }
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function (relative) {
  if (typeof relative === 'string') {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  var tkeys = Object.keys(this);
  for (var tk = 0; tk < tkeys.length; tk++) {
    var tkey = tkeys[tk];
    result[tkey] = this[tkey];
  }

  /*
   * hash is always overridden, no matter what.
   * even href="" will remove it.
   */
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    var rkeys = Object.keys(relative);
    for (var rk = 0; rk < rkeys.length; rk++) {
      var rkey = rkeys[rk];
      if (rkey !== 'protocol') { result[rkey] = relative[rkey]; }
    }

    // urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] && result.hostname && !result.pathname) {
      result.pathname = '/';
      result.path = result.pathname;
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    /*
     * if it's a known url protocol, then changing
     * the protocol does weird things
     * first, if it's not file:, then we MUST have a host,
     * and if there was a path
     * to begin with, then we MUST have a path.
     * if it is file:, then the host is dropped,
     * because that's known to be hostless.
     * anything else is assumed to be absolute.
     */
    if (!slashedProtocol[relative.protocol]) {
      var keys = Object.keys(relative);
      for (var v = 0; v < keys.length; v++) {
        var k = keys[v];
        result[k] = relative[k];
      }
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift())) { }
      if (!relative.host) { relative.host = ''; }
      if (!relative.hostname) { relative.hostname = ''; }
      if (relPath[0] !== '') { relPath.unshift(''); }
      if (relPath.length < 2) { relPath.unshift(''); }
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = result.pathname && result.pathname.charAt(0) === '/',
    isRelAbs = relative.host || relative.pathname && relative.pathname.charAt(0) === '/',
    mustEndAbs = isRelAbs || isSourceAbs || (result.host && relative.pathname),
    removeAllDots = mustEndAbs,
    srcPath = result.pathname && result.pathname.split('/') || [],
    relPath = relative.pathname && relative.pathname.split('/') || [],
    psychotic = result.protocol && !slashedProtocol[result.protocol];

  /*
   * if the url is a non-slashed url, then relative
   * links like ../.. should be able
   * to crawl up to the hostname, as well.  This is strange.
   * result.protocol has already been set by now.
   * Later on, put the first path part into the host field.
   */
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') { srcPath[0] = result.host; } else { srcPath.unshift(result.host); }
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') { relPath[0] = relative.host; } else { relPath.unshift(relative.host); }
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = relative.host || relative.host === '' ? relative.host : result.host;
    result.hostname = relative.hostname || relative.hostname === '' ? relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    /*
     * it's relative
     * throw away the existing file, and take the new path instead.
     */
    if (!srcPath) { srcPath = []; }
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (relative.search != null) {
    /*
     * just pull out the search.
     * like href='?foo'.
     * Put this after the other two cases because it simplifies the booleans
     */
    if (psychotic) {
      result.host = srcPath.shift();
      result.hostname = result.host;
      /*
       * occationaly the auth can get stuck only in host
       * this especially happens in cases like
       * url.resolveObject('mailto:local1@domain1', 'local2@domain2')
       */
      var authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.hostname = authInHost.shift();
        result.host = result.hostname;
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    // to support http.request
    if (result.pathname !== null || result.search !== null) {
      result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    /*
     * no path at all.  easy.
     * we've already handled the other stuff above.
     */
    result.pathname = null;
    // to support http.request
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  /*
   * if a url ENDs in . or .., then it must get a trailing slash.
   * however, if it ends in anything else non-slashy,
   * then it must NOT get a trailing slash.
   */
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (result.host || relative.host || srcPath.length > 1) && (last === '.' || last === '..') || last === '';

  /*
   * strip single dots, resolve double dots to parent dir
   * if the path tries to go above the root, `up` ends up > 0
   */
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last === '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' && (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' || (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    result.hostname = isAbsolute ? '' : srcPath.length ? srcPath.shift() : '';
    result.host = result.hostname;
    /*
     * occationaly the auth can get stuck only in host
     * this especially happens in cases like
     * url.resolveObject('mailto:local1@domain1', 'local2@domain2')
     */
    var authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.hostname = authInHost.shift();
      result.host = result.hostname;
    }
  }

  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (srcPath.length > 0) {
    result.pathname = srcPath.join('/');
  } else {
    result.pathname = null;
    result.path = null;
  }

  // to support request.http
  if (result.pathname !== null || result.search !== null) {
    result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '');
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function () {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) { this.hostname = host; }
};

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

exports.Url = Url;
 //*/
})
//# sourceURL=file:///home/xyz/Development/endo/packages/daemon/node_modules/url/url.js
,
// === functors[90] ===
(function (require, exports, module, __filename, __dirname) { 'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}
 //*/
})
//# sourceURL=file:///home/xyz/Development/endo/node_modules/base64-js/index.js
,
// === functors[91] ===
(function (require, exports, module, __filename, __dirname) { /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}
 //*/
})
//# sourceURL=file:///home/xyz/Development/endo/node_modules/ieee754/index.js
,
// === functors[92] ===
(function (require, exports, module, __filename, __dirname) { /*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

const base64 = require('base64-js')
const ieee754 = require('ieee754')
const customInspectSymbol =
  (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation
    ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation
    : null

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

const K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    const arr = new Uint8Array(1)
    const proto = { foo: function () { return 42 } }
    Object.setPrototypeOf(proto, Uint8Array.prototype)
    Object.setPrototypeOf(arr, proto)
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.buffer
  }
})

Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.byteOffset
  }
})

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"')
  }
  // Return an augmented `Uint8Array` instance
  const buf = new Uint8Array(length)
  Object.setPrototypeOf(buf, Buffer.prototype)
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError(
        'The "string" argument must be of type string. Received type number'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  if (ArrayBuffer.isView(value)) {
    return fromArrayView(value)
  }

  if (value == null) {
    throw new TypeError(
      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
      'or Array-like Object. Received type ' + (typeof value)
    )
  }

  if (isInstance(value, ArrayBuffer) ||
      (value && isInstance(value.buffer, ArrayBuffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof SharedArrayBuffer !== 'undefined' &&
      (isInstance(value, SharedArrayBuffer) ||
      (value && isInstance(value.buffer, SharedArrayBuffer)))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'number') {
    throw new TypeError(
      'The "value" argument must not be of type number. Received type number'
    )
  }

  const valueOf = value.valueOf && value.valueOf()
  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length)
  }

  const b = fromObject(value)
  if (b) return b

  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
      typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length)
  }

  throw new TypeError(
    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
    'or Array-like Object. Received type ' + (typeof value)
  )
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)
Object.setPrototypeOf(Buffer, Uint8Array)

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number')
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpreted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  const length = byteLength(string, encoding) | 0
  let buf = createBuffer(length)

  const actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  const length = array.length < 0 ? 0 : checked(array.length) | 0
  const buf = createBuffer(length)
  for (let i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayView (arrayView) {
  if (isInstance(arrayView, Uint8Array)) {
    const copy = new Uint8Array(arrayView)
    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)
  }
  return fromArrayLike(arrayView)
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds')
  }

  let buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  Object.setPrototypeOf(buf, Buffer.prototype)

  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    const len = checked(obj.length) | 0
    const buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0)
    }
    return fromArrayLike(obj)
  }

  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data)
  }
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true &&
    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
}

Buffer.compare = function compare (a, b) {
  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)
  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError(
      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
    )
  }

  if (a === b) return 0

  let x = a.length
  let y = b.length

  for (let i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  let i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  const buffer = Buffer.allocUnsafe(length)
  let pos = 0
  for (i = 0; i < list.length; ++i) {
    let buf = list[i]
    if (isInstance(buf, Uint8Array)) {
      if (pos + buf.length > buffer.length) {
        if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf)
        buf.copy(buffer, pos)
      } else {
        Uint8Array.prototype.set.call(
          buffer,
          buf,
          pos
        )
      }
    } else if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    } else {
      buf.copy(buffer, pos)
    }
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    throw new TypeError(
      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
      'Received type ' + typeof string
    )
  }

  const len = string.length
  const mustMatch = (arguments.length > 2 && arguments[2] === true)
  if (!mustMatch && len === 0) return 0

  // Use a for loop to avoid recursion
  let loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
        }
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  let loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coercion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  const i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  const len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (let i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  const len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (let i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  const len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (let i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  const length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.toLocaleString = Buffer.prototype.toString

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  let str = ''
  const max = exports.INSPECT_MAX_BYTES
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
  if (this.length > max) str += ' ... '
  return '<Buffer ' + str + '>'
}
if (customInspectSymbol) {
  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer.from(target, target.offset, target.byteLength)
  }
  if (!Buffer.isBuffer(target)) {
    throw new TypeError(
      'The "target" argument must be one of type Buffer or Uint8Array. ' +
      'Received type ' + (typeof target)
    )
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  let x = thisEnd - thisStart
  let y = end - start
  const len = Math.min(x, y)

  const thisCopy = this.slice(thisStart, thisEnd)
  const targetCopy = target.slice(start, end)

  for (let i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  let indexSize = 1
  let arrLength = arr.length
  let valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  let i
  if (dir) {
    let foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      let found = true
      for (let j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  const remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  const strLen = string.length

  if (length > strLen / 2) {
    length = strLen / 2
  }
  let i
  for (i = 0; i < length; ++i) {
    const parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  const remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  let loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
      case 'latin1':
      case 'binary':
        return asciiWrite(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  const res = []

  let i = start
  while (i < end) {
    const firstByte = buf[i]
    let codePoint = null
    let bytesPerSequence = (firstByte > 0xEF)
      ? 4
      : (firstByte > 0xDF)
          ? 3
          : (firstByte > 0xBF)
              ? 2
              : 1

    if (i + bytesPerSequence <= end) {
      let secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
const MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  const len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  let res = ''
  let i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  let ret = ''
  end = Math.min(buf.length, end)

  for (let i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  let ret = ''
  end = Math.min(buf.length, end)

  for (let i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  const len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  let out = ''
  for (let i = start; i < end; ++i) {
    out += hexSliceLookupTable[buf[i]]
  }
  return out
}

function utf16leSlice (buf, start, end) {
  const bytes = buf.slice(start, end)
  let res = ''
  // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)
  for (let i = 0; i < bytes.length - 1; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  const len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  const newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  Object.setPrototypeOf(newBuf, Buffer.prototype)

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUintLE =
Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  let val = this[offset]
  let mul = 1
  let i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUintBE =
Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  let val = this[offset + --byteLength]
  let mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUint8 =
Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUint16LE =
Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUint16BE =
Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUint32LE =
Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUint32BE =
Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE (offset) {
  offset = offset >>> 0
  validateNumber(offset, 'offset')
  const first = this[offset]
  const last = this[offset + 7]
  if (first === undefined || last === undefined) {
    boundsError(offset, this.length - 8)
  }

  const lo = first +
    this[++offset] * 2 ** 8 +
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 24

  const hi = this[++offset] +
    this[++offset] * 2 ** 8 +
    this[++offset] * 2 ** 16 +
    last * 2 ** 24

  return BigInt(lo) + (BigInt(hi) << BigInt(32))
})

Buffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE (offset) {
  offset = offset >>> 0
  validateNumber(offset, 'offset')
  const first = this[offset]
  const last = this[offset + 7]
  if (first === undefined || last === undefined) {
    boundsError(offset, this.length - 8)
  }

  const hi = first * 2 ** 24 +
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 8 +
    this[++offset]

  const lo = this[++offset] * 2 ** 24 +
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 8 +
    last

  return (BigInt(hi) << BigInt(32)) + BigInt(lo)
})

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  let val = this[offset]
  let mul = 1
  let i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  let i = byteLength
  let mul = 1
  let val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  const val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  const val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE (offset) {
  offset = offset >>> 0
  validateNumber(offset, 'offset')
  const first = this[offset]
  const last = this[offset + 7]
  if (first === undefined || last === undefined) {
    boundsError(offset, this.length - 8)
  }

  const val = this[offset + 4] +
    this[offset + 5] * 2 ** 8 +
    this[offset + 6] * 2 ** 16 +
    (last << 24) // Overflow

  return (BigInt(val) << BigInt(32)) +
    BigInt(first +
    this[++offset] * 2 ** 8 +
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 24)
})

Buffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE (offset) {
  offset = offset >>> 0
  validateNumber(offset, 'offset')
  const first = this[offset]
  const last = this[offset + 7]
  if (first === undefined || last === undefined) {
    boundsError(offset, this.length - 8)
  }

  const val = (first << 24) + // Overflow
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 8 +
    this[++offset]

  return (BigInt(val) << BigInt(32)) +
    BigInt(this[++offset] * 2 ** 24 +
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 8 +
    last)
})

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUintLE =
Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    const maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  let mul = 1
  let i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUintBE =
Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    const maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  let i = byteLength - 1
  let mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUint8 =
Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUint16LE =
Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUint16BE =
Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUint32LE =
Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUint32BE =
Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function wrtBigUInt64LE (buf, value, offset, min, max) {
  checkIntBI(value, min, max, buf, offset, 7)

  let lo = Number(value & BigInt(0xffffffff))
  buf[offset++] = lo
  lo = lo >> 8
  buf[offset++] = lo
  lo = lo >> 8
  buf[offset++] = lo
  lo = lo >> 8
  buf[offset++] = lo
  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))
  buf[offset++] = hi
  hi = hi >> 8
  buf[offset++] = hi
  hi = hi >> 8
  buf[offset++] = hi
  hi = hi >> 8
  buf[offset++] = hi
  return offset
}

function wrtBigUInt64BE (buf, value, offset, min, max) {
  checkIntBI(value, min, max, buf, offset, 7)

  let lo = Number(value & BigInt(0xffffffff))
  buf[offset + 7] = lo
  lo = lo >> 8
  buf[offset + 6] = lo
  lo = lo >> 8
  buf[offset + 5] = lo
  lo = lo >> 8
  buf[offset + 4] = lo
  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))
  buf[offset + 3] = hi
  hi = hi >> 8
  buf[offset + 2] = hi
  hi = hi >> 8
  buf[offset + 1] = hi
  hi = hi >> 8
  buf[offset] = hi
  return offset + 8
}

Buffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE (value, offset = 0) {
  return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))
})

Buffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE (value, offset = 0) {
  return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))
})

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    const limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  let i = 0
  let mul = 1
  let sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    const limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  let i = byteLength - 1
  let mul = 1
  let sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE (value, offset = 0) {
  return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))
})

Buffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE (value, offset = 0) {
  return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))
})

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  const len = end - start

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end)
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    if (val.length === 1) {
      const code = val.charCodeAt(0)
      if ((encoding === 'utf8' && code < 128) ||
          encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255
  } else if (typeof val === 'boolean') {
    val = Number(val)
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  let i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    const bytes = Buffer.isBuffer(val)
      ? val
      : Buffer.from(val, encoding)
    const len = bytes.length
    if (len === 0) {
      throw new TypeError('The value "' + val +
        '" is invalid for argument "value"')
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// CUSTOM ERRORS
// =============

// Simplified versions from Node, changed for Buffer-only usage
const errors = {}
function E (sym, getMessage, Base) {
  errors[sym] = class NodeError extends Base {
    constructor () {
      super()

      Object.defineProperty(this, 'message', {
        value: getMessage.apply(this, arguments),
        writable: true,
        configurable: true
      })

      // Add the error code to the name to include it in the stack trace.
      this.name = `${this.name} [${sym}]`
      // Access the stack to generate the error message including the error code
      // from the name.
      this.stack // eslint-disable-line no-unused-expressions
      // Reset the name to the actual name.
      delete this.name
    }

    get code () {
      return sym
    }

    set code (value) {
      Object.defineProperty(this, 'code', {
        configurable: true,
        enumerable: true,
        value,
        writable: true
      })
    }

    toString () {
      return `${this.name} [${sym}]: ${this.message}`
    }
  }
}

E('ERR_BUFFER_OUT_OF_BOUNDS',
  function (name) {
    if (name) {
      return `${name} is outside of buffer bounds`
    }

    return 'Attempt to access memory outside buffer bounds'
  }, RangeError)
E('ERR_INVALID_ARG_TYPE',
  function (name, actual) {
    return `The "${name}" argument must be of type number. Received type ${typeof actual}`
  }, TypeError)
E('ERR_OUT_OF_RANGE',
  function (str, range, input) {
    let msg = `The value of "${str}" is out of range.`
    let received = input
    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
      received = addNumericalSeparator(String(input))
    } else if (typeof input === 'bigint') {
      received = String(input)
      if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
        received = addNumericalSeparator(received)
      }
      received += 'n'
    }
    msg += ` It must be ${range}. Received ${received}`
    return msg
  }, RangeError)

function addNumericalSeparator (val) {
  let res = ''
  let i = val.length
  const start = val[0] === '-' ? 1 : 0
  for (; i >= start + 4; i -= 3) {
    res = `_${val.slice(i - 3, i)}${res}`
  }
  return `${val.slice(0, i)}${res}`
}

// CHECK FUNCTIONS
// ===============

function checkBounds (buf, offset, byteLength) {
  validateNumber(offset, 'offset')
  if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {
    boundsError(offset, buf.length - (byteLength + 1))
  }
}

function checkIntBI (value, min, max, buf, offset, byteLength) {
  if (value > max || value < min) {
    const n = typeof min === 'bigint' ? 'n' : ''
    let range
    if (byteLength > 3) {
      if (min === 0 || min === BigInt(0)) {
        range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`
      } else {
        range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` +
                `${(byteLength + 1) * 8 - 1}${n}`
      }
    } else {
      range = `>= ${min}${n} and <= ${max}${n}`
    }
    throw new errors.ERR_OUT_OF_RANGE('value', range, value)
  }
  checkBounds(buf, offset, byteLength)
}

function validateNumber (value, name) {
  if (typeof value !== 'number') {
    throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value)
  }
}

function boundsError (value, length, type) {
  if (Math.floor(value) !== value) {
    validateNumber(value, type)
    throw new errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value)
  }

  if (length < 0) {
    throw new errors.ERR_BUFFER_OUT_OF_BOUNDS()
  }

  throw new errors.ERR_OUT_OF_RANGE(type || 'offset',
                                    `>= ${type ? 1 : 0} and <= ${length}`,
                                    value)
}

// HELPER FUNCTIONS
// ================

const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  let codePoint
  const length = string.length
  let leadSurrogate = null
  const bytes = []

  for (let i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  const byteArray = []
  for (let i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  let c, hi, lo
  const byteArray = []
  for (let i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  let i
  for (i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance (obj, type) {
  return obj instanceof type ||
    (obj != null && obj.constructor != null && obj.constructor.name != null &&
      obj.constructor.name === type.name)
}
function numberIsNaN (obj) {
  // For IE11 support
  return obj !== obj // eslint-disable-line no-self-compare
}

// Create lookup table for `toString('hex')`
// See: https://github.com/feross/buffer/issues/219
const hexSliceLookupTable = (function () {
  const alphabet = '0123456789abcdef'
  const table = new Array(256)
  for (let i = 0; i < 16; ++i) {
    const i16 = i * 16
    for (let j = 0; j < 16; ++j) {
      table[i16 + j] = alphabet[i] + alphabet[j]
    }
  }
  return table
})()

// Return not function with Error if BigInt not supported
function defineBigIntMethod (fn) {
  return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn
}

function BufferBigIntNotDefined () {
  throw new Error('BigInt not supported')
}
 //*/
})
//# sourceURL=file:///home/xyz/Development/endo/node_modules/buffer/index.js
,
// === functors[93] ===
(function (require, exports, module, __filename, __dirname) { (function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["BrowserFS"] = factory();
	else
		root["BrowserFS"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 19);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.



/*<replacement>*/

var processNextTick = __webpack_require__(7);
/*</replacement>*/

/*<replacement>*/
var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    keys.push(key);
  }return keys;
};
/*</replacement>*/

module.exports = Duplex;

/*<replacement>*/
var util = __webpack_require__(3);
util.inherits = __webpack_require__(1);
/*</replacement>*/

var Readable = __webpack_require__(14);
var Writable = __webpack_require__(12);

util.inherits(Duplex, Readable);

var keys = objectKeys(Writable.prototype);
for (var v = 0; v < keys.length; v++) {
  var method = keys[v];
  if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false) this.readable = false;

  if (options && options.writable === false) this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;

  this.once('end', onend);
}

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended) return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  processNextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

Object.defineProperty(Duplex.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }
    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});

Duplex.prototype._destroy = function (err, cb) {
  this.push(null);
  this.end();

  processNextTick(cb, err);
};

function forEach(xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}

/***/ }),
/* 1 */
/***/ (function(module, exports) {

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}


/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Process = __webpack_require__(22);
var process = new Process(), processProxy = {};
function defineKey(key) {
    if (processProxy[key]) {
        // Probably a builtin Object property we don't care about.
        return;
    }
    if (typeof process[key] === 'function') {
        processProxy[key] = function () {
            return process[key].apply(process, arguments);
        };
    }
    else {
        processProxy[key] = process[key];
    }
}
for (var key in process) {
    // Don't check if process.hasOwnProperty; we want to also expose objects
    // up the prototype hierarchy.
    defineKey(key);
}
// Special key: Ensure we update public-facing values of stdin/stdout/stderr.
processProxy.initializeTTYs = function () {
    if (process.stdin === null) {
        process.initializeTTYs();
        processProxy.stdin = process.stdin;
        processProxy.stdout = process.stdout;
        processProxy.stderr = process.stderr;
    }
};
process.nextTick(function () {
    processProxy.initializeTTYs();
});
module.exports = processProxy;


/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.

function isArray(arg) {
  if (Array.isArray) {
    return Array.isArray(arg);
  }
  return objectToString(arg) === '[object Array]';
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = Buffer.isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(9)))

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



var base64 = __webpack_require__(20)
var ieee754 = __webpack_require__(21)

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

var K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('Invalid typed array length')
  }
  // Return an augmented `Uint8Array` instance
  var buf = new Uint8Array(length)
  buf.__proto__ = Buffer.prototype
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
if (typeof Symbol !== 'undefined' && Symbol.species &&
    Buffer[Symbol.species] === Buffer) {
  Object.defineProperty(Buffer, Symbol.species, {
    value: null,
    configurable: true,
    enumerable: false,
    writable: false
  })
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (isArrayBuffer(value)) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  return fromObject(value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Buffer.prototype.__proto__ = Uint8Array.prototype
Buffer.__proto__ = Uint8Array

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  var buf = createBuffer(length)

  var actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  var buf = createBuffer(length)
  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  var buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  buf.__proto__ = Buffer.prototype
  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    var buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj) {
    if (isArrayBufferView(obj) || 'length' in obj) {
      if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
        return createBuffer(0)
      }
      return fromArrayLike(obj)
    }

    if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
      return fromArrayLike(obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (isArrayBufferView(string) || isArrayBuffer(string)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  newBuf.__proto__ = Buffer.prototype
  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : new Buffer(val, encoding)
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffers from another context (i.e. an iframe) do not pass the `instanceof` check
// but they should be treated as valid. See: https://github.com/feross/buffer/issues/166
function isArrayBuffer (obj) {
  return obj instanceof ArrayBuffer ||
    (obj != null && obj.constructor != null && obj.constructor.name === 'ArrayBuffer' &&
      typeof obj.byteLength === 'number')
}

// Node 0.10 supports `ArrayBuffer` but lacks `ArrayBuffer.isView`
function isArrayBufferView (obj) {
  return (typeof ArrayBuffer.isView === 'function') && ArrayBuffer.isView(obj)
}

function numberIsNaN (obj) {
  return obj !== obj // eslint-disable-line no-self-compare
}


/***/ }),
/* 5 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 6 */
/***/ (function(module, exports) {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      } else {
        // At least give some kind of context to the user
        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
        err.context = er;
        throw err;
      }
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    args = Array.prototype.slice.call(arguments, 1);
    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else if (listeners) {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.prototype.listenerCount = function(type) {
  if (this._events) {
    var evlistener = this._events[type];

    if (isFunction(evlistener))
      return 1;
    else if (evlistener)
      return evlistener.length;
  }
  return 0;
};

EventEmitter.listenerCount = function(emitter, type) {
  return emitter.listenerCount(type);
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}


/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

if (!process.version ||
    process.version.indexOf('v0.') === 0 ||
    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
  module.exports = nextTick;
} else {
  module.exports = process.nextTick;
}

function nextTick(fn, arg1, arg2, arg3) {
  if (typeof fn !== 'function') {
    throw new TypeError('"callback" argument must be a function');
  }
  var len = arguments.length;
  var args, i;
  switch (len) {
  case 0:
  case 1:
    return process.nextTick(fn);
  case 2:
    return process.nextTick(function afterTickOne() {
      fn.call(null, arg1);
    });
  case 3:
    return process.nextTick(function afterTickTwo() {
      fn.call(null, arg1, arg2);
    });
  case 4:
    return process.nextTick(function afterTickThree() {
      fn.call(null, arg1, arg2, arg3);
    });
  default:
    args = new Array(len - 1);
    i = 0;
    while (i < args.length) {
      args[i++] = arguments[i];
    }
    return process.nextTick(function afterTick() {
      fn.apply(null, args);
    });
  }
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";



var TYPED_OK =  (typeof Uint8Array !== 'undefined') &&
                (typeof Uint16Array !== 'undefined') &&
                (typeof Int32Array !== 'undefined');


exports.assign = function (obj /*from1, from2, from3, ...*/) {
  var sources = Array.prototype.slice.call(arguments, 1);
  while (sources.length) {
    var source = sources.shift();
    if (!source) { continue; }

    if (typeof source !== 'object') {
      throw new TypeError(source + 'must be non-object');
    }

    for (var p in source) {
      if (source.hasOwnProperty(p)) {
        obj[p] = source[p];
      }
    }
  }

  return obj;
};


// reduce buffer size, avoiding mem copy
exports.shrinkBuf = function (buf, size) {
  if (buf.length === size) { return buf; }
  if (buf.subarray) { return buf.subarray(0, size); }
  buf.length = size;
  return buf;
};


var fnTyped = {
  arraySet: function (dest, src, src_offs, len, dest_offs) {
    if (src.subarray && dest.subarray) {
      dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
      return;
    }
    // Fallback to ordinary array
    for (var i = 0; i < len; i++) {
      dest[dest_offs + i] = src[src_offs + i];
    }
  },
  // Join array of chunks to single array.
  flattenChunks: function (chunks) {
    var i, l, len, pos, chunk, result;

    // calculate data length
    len = 0;
    for (i = 0, l = chunks.length; i < l; i++) {
      len += chunks[i].length;
    }

    // join chunks
    result = new Uint8Array(len);
    pos = 0;
    for (i = 0, l = chunks.length; i < l; i++) {
      chunk = chunks[i];
      result.set(chunk, pos);
      pos += chunk.length;
    }

    return result;
  }
};

var fnUntyped = {
  arraySet: function (dest, src, src_offs, len, dest_offs) {
    for (var i = 0; i < len; i++) {
      dest[dest_offs + i] = src[src_offs + i];
    }
  },
  // Join array of chunks to single array.
  flattenChunks: function (chunks) {
    return [].concat.apply([], chunks);
  }
};


// Enable/Disable typed arrays use, for testing
//
exports.setTyped = function (on) {
  if (on) {
    exports.Buf8  = Uint8Array;
    exports.Buf16 = Uint16Array;
    exports.Buf32 = Int32Array;
    exports.assign(exports, fnTyped);
  } else {
    exports.Buf8  = Array;
    exports.Buf16 = Array;
    exports.Buf32 = Array;
    exports.assign(exports, fnUntyped);
  }
};

exports.setTyped(TYPED_OK);


/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(4).Buffer;


/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(14);
exports.Stream = exports;
exports.Readable = exports;
exports.Writable = __webpack_require__(12);
exports.Duplex = __webpack_require__(0);
exports.Transform = __webpack_require__(18);
exports.PassThrough = __webpack_require__(29);


/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

/* eslint-disable node/no-deprecated-api */
var buffer = __webpack_require__(4)
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}


/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process, global) {// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.



/*<replacement>*/

var processNextTick = __webpack_require__(7);
/*</replacement>*/

module.exports = Writable;

/* <replacement> */
function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
}

// It seems a linked list but it is not
// there will be only 2 of these for each stream
function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;
  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/
var asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : processNextTick;
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;

/*<replacement>*/
var util = __webpack_require__(3);
util.inherits = __webpack_require__(1);
/*</replacement>*/

/*<replacement>*/
var internalUtil = {
  deprecate: __webpack_require__(28)
};
/*</replacement>*/

/*<replacement>*/
var Stream = __webpack_require__(15);
/*</replacement>*/

/*<replacement>*/
var Buffer = __webpack_require__(11).Buffer;
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
/*</replacement>*/

var destroyImpl = __webpack_require__(16);

util.inherits(Writable, Stream);

function nop() {}

function WritableState(options, stream) {
  Duplex = Duplex || __webpack_require__(0);

  options = options || {};

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;

  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // if _final has been called
  this.finalCalled = false;

  // drain event flag.
  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // has it been destroyed
  this.destroyed = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // when true all writes will be buffered until .uncork() call
  this.corked = 0;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function (er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;

  this.bufferedRequest = null;
  this.lastBufferedRequest = null;

  // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted
  this.pendingcb = 0;

  // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams
  this.prefinished = false;

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;

  // count buffered requests
  this.bufferedRequestCount = 0;

  // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two
  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];
  while (current) {
    out.push(current);
    current = current.next;
  }
  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function () {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})();

// Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.
var realHasInstance;
if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function (object) {
      if (realHasInstance.call(this, object)) return true;

      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function (object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || __webpack_require__(0);

  // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.

  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
    return new Writable(options);
  }

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;

    if (typeof options.writev === 'function') this._writev = options.writev;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;

    if (typeof options.final === 'function') this._final = options.final;
  }

  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function () {
  this.emit('error', new Error('Cannot pipe, not readable'));
};

function writeAfterEnd(stream, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  processNextTick(cb, er);
}

// Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  var er = false;

  if (chunk === null) {
    er = new TypeError('May not write null values to stream');
  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  if (er) {
    stream.emit('error', er);
    processNextTick(cb, er);
    valid = false;
  }
  return valid;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;
  var isBuf = _isUint8Array(chunk) && !state.objectMode;

  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;

  if (typeof cb !== 'function') cb = nop;

  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }

  return ret;
};

Writable.prototype.cork = function () {
  var state = this._writableState;

  state.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;

    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }
  return chunk;
}

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);
    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }
  var len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };
    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }
    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;

  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    processNextTick(cb, er);
    // this can emit finish, and it will always happen
    // after error
    processNextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
    // this can emit finish, but finish must
    // always follow error
    finishMaybe(stream, state);
  }
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;

  onwriteStateUpdate(state);

  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state);

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      /*<replacement>*/
      asyncWrite(afterWrite, stream, state, finished, cb);
      /*</replacement>*/
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}

// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;

    var count = 0;
    var allBuffers = true;
    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }
    buffer.allBuffers = allBuffers;

    doWrite(stream, state, true, state.length, buffer, '', holder.finish);

    // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite
    state.pendingcb++;
    state.lastBufferedRequest = null;
    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;

      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.
      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequestCount = 0;
  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new Error('_write() is not implemented'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

  // .end() fully uncorks
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }

  // ignore unnecessary end() calls.
  if (!state.ending && !state.finished) endWritable(this, state, cb);
};

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}
function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;
    if (err) {
      stream.emit('error', err);
    }
    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}
function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function') {
      state.pendingcb++;
      state.finalCalled = true;
      processNextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);
  if (need) {
    prefinish(stream, state);
    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');
    }
  }
  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished) processNextTick(cb);else stream.once('finish', cb);
  }
  state.ended = true;
  stream.writable = false;
}

function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;
  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  }
  if (state.corkedRequestsFree) {
    state.corkedRequestsFree.next = corkReq;
  } else {
    state.corkedRequestsFree = corkReq;
  }
}

Object.defineProperty(Writable.prototype, 'destroyed', {
  get: function () {
    if (this._writableState === undefined) {
      return false;
    }
    return this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._writableState.destroyed = value;
  }
});

Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;
Writable.prototype._destroy = function (err, cb) {
  this.end();
  cb(err);
};
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2), __webpack_require__(5)))

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {
// Split a filename into [root, dir, basename, ext], unix version
// 'root' is just a slash, or nothing.
var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
function posixSplitPath(filename) {
    var out = splitPathRe.exec(filename);
    out.shift();
    return out;
}
/**
 * Emulates Node's `path` module. This module contains utilities for handling and
 * transforming file paths. **All** of these methods perform only string
 * transformations. The file system is not consulted to check whether paths are
 * valid.
 * @see http://nodejs.org/api/path.html
 * @class
 */
var path = (function () {
    function path() {
    }
    /**
     * Normalize a string path, taking care of '..' and '.' parts.
     *
     * When multiple slashes are found, they're replaced by a single one; when the path contains a trailing slash, it is preserved. On Windows backslashes are used.
     * @example Usage example
     *   path.normalize('/foo/bar//baz/asdf/quux/..')
     *   // returns
     *   '/foo/bar/baz/asdf'
     * @param [String] p The path to normalize.
     * @return [String]
     */
    path.normalize = function (p) {
        // Special case: '' -> '.'
        if (p === '') {
            p = '.';
        }
        // It's very important to know if the path is relative or not, since it
        // changes how we process .. and reconstruct the split string.
        var absolute = p.charAt(0) === path.sep;
        // Remove repeated //s
        p = path._removeDuplicateSeps(p);
        // Try to remove as many '../' as possible, and remove '.' completely.
        var components = p.split(path.sep);
        var goodComponents = [];
        for (var idx = 0; idx < components.length; idx++) {
            var c = components[idx];
            if (c === '.') {
                continue;
            }
            else if (c === '..' && (absolute || (!absolute && goodComponents.length > 0 && goodComponents[0] !== '..'))) {
                // In the absolute case: Path is relative to root, so we may pop even if
                // goodComponents is empty (e.g. /../ => /)
                // In the relative case: We're getting rid of a directory that preceded
                // it (e.g. /foo/../bar -> /bar)
                goodComponents.pop();
            }
            else {
                goodComponents.push(c);
            }
        }
        // Add in '.' when it's a relative path with no other nonempty components.
        // Possible results: '.' and './' (input: [''] or [])
        // @todo Can probably simplify this logic.
        if (!absolute && goodComponents.length < 2) {
            switch (goodComponents.length) {
                case 1:
                    if (goodComponents[0] === '') {
                        goodComponents.unshift('.');
                    }
                    break;
                default:
                    goodComponents.push('.');
            }
        }
        p = goodComponents.join(path.sep);
        if (absolute && p.charAt(0) !== path.sep) {
            p = path.sep + p;
        }
        return p;
    };
    /**
     * Join all arguments together and normalize the resulting path.
     *
     * Arguments must be strings.
     * @example Usage
     *   path.join('/foo', 'bar', 'baz/asdf', 'quux', '..')
     *   // returns
     *   '/foo/bar/baz/asdf'
     *
     *   path.join('foo', {}, 'bar')
     *   // throws exception
     *   TypeError: Arguments to path.join must be strings
     * @param [String,...] paths Each component of the path
     * @return [String]
     */
    path.join = function () {
        var paths = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            paths[_i - 0] = arguments[_i];
        }
        // Required: Prune any non-strings from the path. I also prune empty segments
        // so we can do a simple join of the array.
        var processed = [];
        for (var i = 0; i < paths.length; i++) {
            var segment = paths[i];
            if (typeof segment !== 'string') {
                throw new TypeError("Invalid argument type to path.join: " + (typeof segment));
            }
            else if (segment !== '') {
                processed.push(segment);
            }
        }
        return path.normalize(processed.join(path.sep));
    };
    /**
     * Resolves to to an absolute path.
     *
     * If to isn't already absolute from arguments are prepended in right to left
     * order, until an absolute path is found. If after using all from paths still
     * no absolute path is found, the current working directory is used as well.
     * The resulting path is normalized, and trailing slashes are removed unless
     * the path gets resolved to the root directory. Non-string arguments are
     * ignored.
     *
     * Another way to think of it is as a sequence of cd commands in a shell.
     *
     *     path.resolve('foo/bar', '/tmp/file/', '..', 'a/../subfile')
     *
     * Is similar to:
     *
     *     cd foo/bar
     *     cd /tmp/file/
     *     cd ..
     *     cd a/../subfile
     *     pwd
     *
     * The difference is that the different paths don't need to exist and may also
     * be files.
     * @example Usage example
     *   path.resolve('/foo/bar', './baz')
     *   // returns
     *   '/foo/bar/baz'
     *
     *   path.resolve('/foo/bar', '/tmp/file/')
     *   // returns
     *   '/tmp/file'
     *
     *   path.resolve('wwwroot', 'static_files/png/', '../gif/image.gif')
     *   // if currently in /home/myself/node, it returns
     *   '/home/myself/node/wwwroot/static_files/gif/image.gif'
     * @param [String,...] paths
     * @return [String]
     */
    path.resolve = function () {
        var paths = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            paths[_i - 0] = arguments[_i];
        }
        // Monitor for invalid paths, throw out empty paths, and look for the *last*
        // absolute path that we see.
        var processed = [];
        for (var i = 0; i < paths.length; i++) {
            var p = paths[i];
            if (typeof p !== 'string') {
                throw new TypeError("Invalid argument type to path.join: " + (typeof p));
            }
            else if (p !== '') {
                // Remove anything that has occurred before this absolute path, as it
                // doesn't matter.
                if (p.charAt(0) === path.sep) {
                    processed = [];
                }
                processed.push(p);
            }
        }
        // Special: Remove trailing slash unless it's the root
        var resolved = path.normalize(processed.join(path.sep));
        if (resolved.length > 1 && resolved.charAt(resolved.length - 1) === path.sep) {
            return resolved.substr(0, resolved.length - 1);
        }
        // Special: If it doesn't start with '/', it's relative and we need to append
        // the current directory.
        if (resolved.charAt(0) !== path.sep) {
            // Remove ./, since we're going to append the current directory.
            if (resolved.charAt(0) === '.' && (resolved.length === 1 || resolved.charAt(1) === path.sep)) {
                resolved = resolved.length === 1 ? '' : resolved.substr(2);
            }
            // Append the current directory, which *must* be an absolute path.
            var cwd = process.cwd();
            if (resolved !== '') {
                // cwd will never end in a /... unless it's the root.
                resolved = this.normalize(cwd + (cwd !== '/' ? path.sep : '') + resolved);
            }
            else {
                resolved = cwd;
            }
        }
        return resolved;
    };
    /**
     * Solve the relative path from from to to.
     *
     * At times we have two absolute paths, and we need to derive the relative path
     * from one to the other. This is actually the reverse transform of
     * path.resolve, which means we see that:
     *
     *    path.resolve(from, path.relative(from, to)) == path.resolve(to)
     *
     * @example Usage example
     *   path.relative('C:\\orandea\\test\\aaa', 'C:\\orandea\\impl\\bbb')
     *   // returns
     *   '..\\..\\impl\\bbb'
     *
     *   path.relative('/data/orandea/test/aaa', '/data/orandea/impl/bbb')
     *   // returns
     *   '../../impl/bbb'
     * @param [String] from
     * @param [String] to
     * @return [String]
     */
    path.relative = function (from, to) {
        var i;
        // Alright. Let's resolve these two to absolute paths and remove any
        // weirdness.
        from = path.resolve(from);
        to = path.resolve(to);
        var fromSegs = from.split(path.sep);
        var toSegs = to.split(path.sep);
        // Remove the first segment on both, as it's '' (both are absolute paths)
        toSegs.shift();
        fromSegs.shift();
        // There are two segments to this path:
        // * Going *up* the directory hierarchy with '..'
        // * Going *down* the directory hierarchy with foo/baz/bat.
        var upCount = 0;
        var downSegs = [];
        // Figure out how many things in 'from' are shared with 'to'.
        for (i = 0; i < fromSegs.length; i++) {
            var seg = fromSegs[i];
            if (seg === toSegs[i]) {
                continue;
            }
            // The rest of 'from', including the current element, indicates how many
            // directories we need to go up.
            upCount = fromSegs.length - i;
            break;
        }
        // The rest of 'to' indicates where we need to change to. We place this
        // outside of the loop, as toSegs.length may be greater than fromSegs.length.
        downSegs = toSegs.slice(i);
        // Special case: If 'from' is '/'
        if (fromSegs.length === 1 && fromSegs[0] === '') {
            upCount = 0;
        }
        // upCount can't be greater than the number of fromSegs
        // (cd .. from / is still /)
        if (upCount > fromSegs.length) {
            upCount = fromSegs.length;
        }
        // Create the final string!
        var rv = '';
        for (i = 0; i < upCount; i++) {
            rv += '../';
        }
        rv += downSegs.join(path.sep);
        // Special case: Remove trailing '/'. Happens if it's all up and no down.
        if (rv.length > 1 && rv.charAt(rv.length - 1) === path.sep) {
            rv = rv.substr(0, rv.length - 1);
        }
        return rv;
    };
    /**
     * Return the directory name of a path. Similar to the Unix `dirname` command.
     *
     * Note that BrowserFS does not validate if the path is actually a valid
     * directory.
     * @example Usage example
     *   path.dirname('/foo/bar/baz/asdf/quux')
     *   // returns
     *   '/foo/bar/baz/asdf'
     * @param [String] p The path to get the directory name of.
     * @return [String]
     */
    path.dirname = function (p) {
        // We get rid of //, but we don't modify anything else (e.g. any extraneous .
        // and ../ are kept intact)
        p = path._removeDuplicateSeps(p);
        var absolute = p.charAt(0) === path.sep;
        var sections = p.split(path.sep);
        // Do 1 if it's /foo/bar, 2 if it's /foo/bar/
        if (sections.pop() === '' && sections.length > 0) {
            sections.pop();
        }
        // # of sections needs to be > 1 if absolute, since the first section is '' for '/'.
        // If not absolute, the first section is the first part of the path, and is OK
        // to return.
        if (sections.length > 1 || (sections.length === 1 && !absolute)) {
            return sections.join(path.sep);
        }
        else if (absolute) {
            return path.sep;
        }
        else {
            return '.';
        }
    };
    /**
     * Return the last portion of a path. Similar to the Unix basename command.
     * @example Usage example
     *   path.basename('/foo/bar/baz/asdf/quux.html')
     *   // returns
     *   'quux.html'
     *
     *   path.basename('/foo/bar/baz/asdf/quux.html', '.html')
     *   // returns
     *   'quux'
     * @param [String] p
     * @param [String?] ext
     * @return [String]
     */
    path.basename = function (p, ext) {
        if (ext === void 0) { ext = ""; }
        // Special case: Normalize will modify this to '.'
        if (p === '') {
            return p;
        }
        // Normalize the string first to remove any weirdness.
        p = path.normalize(p);
        // Get the last part of the string.
        var sections = p.split(path.sep);
        var lastPart = sections[sections.length - 1];
        // Special case: If it's empty, then we have a string like so: foo/
        // Meaning, 'foo' is guaranteed to be a directory.
        if (lastPart === '' && sections.length > 1) {
            return sections[sections.length - 2];
        }
        // Remove the extension, if need be.
        if (ext.length > 0) {
            var lastPartExt = lastPart.substr(lastPart.length - ext.length);
            if (lastPartExt === ext) {
                return lastPart.substr(0, lastPart.length - ext.length);
            }
        }
        return lastPart;
    };
    /**
     * Return the extension of the path, from the last '.' to end of string in the
     * last portion of the path. If there is no '.' in the last portion of the path
     * or the first character of it is '.', then it returns an empty string.
     * @example Usage example
     *   path.extname('index.html')
     *   // returns
     *   '.html'
     *
     *   path.extname('index.')
     *   // returns
     *   '.'
     *
     *   path.extname('index')
     *   // returns
     *   ''
     * @param [String] p
     * @return [String]
     */
    path.extname = function (p) {
        p = path.normalize(p);
        var sections = p.split(path.sep);
        p = sections.pop();
        // Special case: foo/file.ext/ should return '.ext'
        if (p === '' && sections.length > 0) {
            p = sections.pop();
        }
        if (p === '..') {
            return '';
        }
        var i = p.lastIndexOf('.');
        if (i === -1 || i === 0) {
            return '';
        }
        return p.substr(i);
    };
    /**
     * Checks if the given path is an absolute path.
     *
     * Despite not being documented, this is a tested part of Node's path API.
     * @param [String] p
     * @return [Boolean] True if the path appears to be an absolute path.
     */
    path.isAbsolute = function (p) {
        return p.length > 0 && p.charAt(0) === path.sep;
    };
    /**
     * Unknown. Undocumented.
     */
    path._makeLong = function (p) {
        return p;
    };
    /**
     * Returns an object from a path string.
     */
    path.parse = function (p) {
        var allParts = posixSplitPath(p);
        return {
            root: allParts[0],
            dir: allParts[0] + allParts[1].slice(0, -1),
            base: allParts[2],
            ext: allParts[3],
            name: allParts[2].slice(0, allParts[2].length - allParts[3].length)
        };
    };
    path.format = function (pathObject) {
        if (pathObject === null || typeof pathObject !== 'object') {
            throw new TypeError("Parameter 'pathObject' must be an object, not " + typeof pathObject);
        }
        var root = pathObject.root || '';
        if (typeof root !== 'string') {
            throw new TypeError("'pathObject.root' must be a string or undefined, not " +
                typeof pathObject.root);
        }
        var dir = pathObject.dir ? pathObject.dir + path.sep : '';
        var base = pathObject.base || '';
        return dir + base;
    };
    path._removeDuplicateSeps = function (p) {
        p = p.replace(this._replaceRegex, this.sep);
        return p;
    };
    // The platform-specific file separator. BrowserFS uses `/`.
    path.sep = '/';
    path._replaceRegex = new RegExp("//+", 'g');
    // The platform-specific path delimiter. BrowserFS uses `:`.
    path.delimiter = ':';
    path.posix = path;
    // XXX: Typing hack. We don't actually support win32.
    path.win32 = path;
    return path;
}());
var _ = path;
module.exports = path;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global, process) {// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



/*<replacement>*/

var processNextTick = __webpack_require__(7);
/*</replacement>*/

module.exports = Readable;

/*<replacement>*/
var isArray = __webpack_require__(25);
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;

/*<replacement>*/
var EE = __webpack_require__(6).EventEmitter;

var EElistenerCount = function (emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/
var Stream = __webpack_require__(15);
/*</replacement>*/

// TODO(bmeurer): Change this back to const once hole checks are
// properly optimized away early in Ignition+TurboFan.
/*<replacement>*/
var Buffer = __webpack_require__(11).Buffer;
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
/*</replacement>*/

/*<replacement>*/
var util = __webpack_require__(3);
util.inherits = __webpack_require__(1);
/*</replacement>*/

/*<replacement>*/
var debugUtil = __webpack_require__(26);
var debug = void 0;
if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function () {};
}
/*</replacement>*/

var BufferList = __webpack_require__(27);
var destroyImpl = __webpack_require__(16);
var StringDecoder;

util.inherits(Readable, Stream);

var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') {
    return emitter.prependListener(event, fn);
  } else {
    // This is a hack to make sure that our error handler is attached before any
    // userland ones.  NEVER DO THIS. This is here only because this code needs
    // to continue to work with older versions of Node.js that do not include
    // the prependListener() method. The goal is to eventually remove this hack.
    if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
  }
}

function ReadableState(options, stream) {
  Duplex = Duplex || __webpack_require__(0);

  options = options || {};

  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()
  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;

  // has it been destroyed
  this.destroyed = false;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder) StringDecoder = __webpack_require__(17).StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || __webpack_require__(0);

  if (!(this instanceof Readable)) return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') this._read = options.read;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }

  Stream.call(this);
}

Object.defineProperty(Readable.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined) {
      return false;
    }
    return this._readableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
  }
});

Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;
Readable.prototype._destroy = function (err, cb) {
  this.push(null);
  cb(err);
};

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;

  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;
      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }
      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }

  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};

function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  var state = stream._readableState;
  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);
    if (er) {
      stream.emit('error', er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      if (addToFront) {
        if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        stream.emit('error', new Error('stream.push() after EOF'));
      } else {
        state.reading = false;
        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
    }
  }

  return needMoreData(state);
}

function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    stream.emit('data', chunk);
    stream.read(0);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);

    if (state.needReadable) emitReadable(stream);
  }
  maybeReadMore(stream, state);
}

function chunkInvalid(state, chunk) {
  var er;
  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}

// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
}

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
};

// backwards compatibility.
Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = __webpack_require__(17).StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
};

// Don't raise the hwm > 8MB
var MAX_HWM = 0x800000;
function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }
  return n;
}

// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;
  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  }
  // If we're asking for more than the current hwm, then raise the hwm.
  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n;
  // Don't have enough
  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }
  return state.length;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;

  if (n !== 0) state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0) state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
    // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.
    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  } else {
    state.length -= n;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true;

    // If we tried to read() past the EOF, then emit end on the next tick.
    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);

  return ret;
};

function onEofChunk(stream, state) {
  if (state.ended) return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // emit 'readable' now to make sure it gets picked up.
  emitReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    if (state.sync) processNextTick(emitReadable_, stream);else emitReadable_(stream);
  }
}

function emitReadable_(stream) {
  debug('emit readable');
  stream.emit('readable');
  flow(stream);
}

// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    processNextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;else len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function (n) {
  this.emit('error', new Error('_read() is not implemented'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;

  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) processNextTick(endFn);else src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');
    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  var cleanedUp = false;
  function cleanup() {
    debug('cleanup');
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);

    cleanedUp = true;

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  // If the user pushes more data while we're writing to dest then we'll end up
  // in ondata again. However, we only want to increase awaitDrain once because
  // dest will only emit one 'drain' event for the multiple writes.
  // => Introduce a guard on increasing awaitDrain.
  var increasedAwaitDrain = false;
  src.on('data', ondata);
  function ondata(chunk) {
    debug('ondata');
    increasedAwaitDrain = false;
    var ret = dest.write(chunk);
    if (false === ret && !increasedAwaitDrain) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', src._readableState.awaitDrain);
        src._readableState.awaitDrain++;
        increasedAwaitDrain = true;
      }
      src.pause();
    }
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
  }

  // Make sure our error handler is attached before userland ones.
  prependListener(dest, 'error', onerror);

  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function () {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;
    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = { hasUnpiped: false };

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0) return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;

    if (!dest) dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, unpipeInfo);
    }return this;
  }

  // try to find the right one.
  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;

  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];

  dest.emit('unpipe', this, unpipeInfo);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  if (ev === 'data') {
    // Start flowing on next tick if stream isn't explicitly paused
    if (this._readableState.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    var state = this._readableState;
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.emittedReadable = false;
      if (!state.reading) {
        processNextTick(nReadingNextTick, this);
      } else if (state.length) {
        emitReadable(this);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
}

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function () {
  var state = this._readableState;
  if (!state.flowing) {
    debug('resume');
    state.flowing = true;
    resume(this, state);
  }
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    processNextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  if (!state.reading) {
    debug('resume read 0');
    stream.read(0);
  }

  state.resumeScheduled = false;
  state.awaitDrain = 0;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);
  if (false !== this._readableState.flowing) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);
  while (state.flowing && stream.read() !== null) {}
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function (stream) {
  var state = this._readableState;
  var paused = false;

  var self = this;
  stream.on('end', function () {
    debug('wrapped end');
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) self.push(chunk);
    }

    self.push(null);
  });

  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk);

    // don't skip over falsy values in objectMode
    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = self.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function (method) {
        return function () {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  }

  // proxy certain important events.
  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], self.emit.bind(self, kProxyEvents[n]));
  }

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  self._read = function (n) {
    debug('wrapped _read', n);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return self;
};

// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;

  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = fromListPartial(n, state.buffer, state.decoder);
  }

  return ret;
}

// Extracts only enough buffered data to satisfy the amount requested.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromListPartial(n, list, hasStrings) {
  var ret;
  if (n < list.head.data.length) {
    // slice is the same for buffers and strings
    ret = list.head.data.slice(0, n);
    list.head.data = list.head.data.slice(n);
  } else if (n === list.head.data.length) {
    // first chunk is a perfect match
    ret = list.shift();
  } else {
    // result spans more than one buffer
    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
  }
  return ret;
}

// Copies a specified amount of characters from the list of buffered data
// chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBufferString(n, list) {
  var p = list.head;
  var c = 1;
  var ret = p.data;
  n -= ret.length;
  while (p = p.next) {
    var str = p.data;
    var nb = n > str.length ? str.length : n;
    if (nb === str.length) ret += str;else ret += str.slice(0, n);
    n -= nb;
    if (n === 0) {
      if (nb === str.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = str.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

// Copies a specified amount of bytes from the list of buffered data chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBuffer(n, list) {
  var ret = Buffer.allocUnsafe(n);
  var p = list.head;
  var c = 1;
  p.data.copy(ret);
  n -= p.data.length;
  while (p = p.next) {
    var buf = p.data;
    var nb = n > buf.length ? buf.length : n;
    buf.copy(ret, ret.length - n, 0, nb);
    n -= nb;
    if (n === 0) {
      if (nb === buf.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = buf.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');

  if (!state.endEmitted) {
    state.ended = true;
    processNextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  // Check that we didn't get one last unshift.
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
  }
}

function forEach(xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5), __webpack_require__(2)))

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(6).EventEmitter;


/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*<replacement>*/

var processNextTick = __webpack_require__(7);
/*</replacement>*/

// undocumented cb() API, needed for core, not for public API
function destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {
      processNextTick(emitErrorNT, this, err);
    }
    return;
  }

  // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks

  if (this._readableState) {
    this._readableState.destroyed = true;
  }

  // if this is a duplex stream mark the writable part as destroyed as well
  if (this._writableState) {
    this._writableState.destroyed = true;
  }

  this._destroy(err || null, function (err) {
    if (!cb && err) {
      processNextTick(emitErrorNT, _this, err);
      if (_this._writableState) {
        _this._writableState.errorEmitted = true;
      }
    } else if (cb) {
      cb(err);
    }
  });
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }

  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}

function emitErrorNT(self, err) {
  self.emit('error', err);
}

module.exports = {
  destroy: destroy,
  undestroy: undestroy
};

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var Buffer = __webpack_require__(4).Buffer;

var isBufferEncoding = Buffer.isEncoding
  || function(encoding) {
       switch (encoding && encoding.toLowerCase()) {
         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;
         default: return false;
       }
     }


function assertEncoding(encoding) {
  if (encoding && !isBufferEncoding(encoding)) {
    throw new Error('Unknown encoding: ' + encoding);
  }
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters. CESU-8 is handled as part of the UTF-8 encoding.
//
// @TODO Handling all encodings inside a single object makes it very difficult
// to reason about this code, so it should be split up in the future.
// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code
// points as used by CESU-8.
var StringDecoder = exports.StringDecoder = function(encoding) {
  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
  assertEncoding(encoding);
  switch (this.encoding) {
    case 'utf8':
      // CESU-8 represents each of Surrogate Pair by 3-bytes
      this.surrogateSize = 3;
      break;
    case 'ucs2':
    case 'utf16le':
      // UTF-16 represents each of Surrogate Pair by 2-bytes
      this.surrogateSize = 2;
      this.detectIncompleteChar = utf16DetectIncompleteChar;
      break;
    case 'base64':
      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
      this.surrogateSize = 3;
      this.detectIncompleteChar = base64DetectIncompleteChar;
      break;
    default:
      this.write = passThroughWrite;
      return;
  }

  // Enough space to store all bytes of a single character. UTF-8 needs 4
  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).
  this.charBuffer = new Buffer(6);
  // Number of bytes received for the current incomplete multi-byte character.
  this.charReceived = 0;
  // Number of bytes expected for the current incomplete multi-byte character.
  this.charLength = 0;
};


// write decodes the given buffer and returns it as JS string that is
// guaranteed to not contain any partial multi-byte characters. Any partial
// character found at the end of the buffer is buffered up, and will be
// returned when calling write again with the remaining bytes.
//
// Note: Converting a Buffer containing an orphan surrogate to a String
// currently works, but converting a String to a Buffer (via `new Buffer`, or
// Buffer#write) will replace incomplete surrogates with the unicode
// replacement character. See https://codereview.chromium.org/121173009/ .
StringDecoder.prototype.write = function(buffer) {
  var charStr = '';
  // if our last write ended with an incomplete multibyte character
  while (this.charLength) {
    // determine how many remaining bytes this buffer has to offer for this char
    var available = (buffer.length >= this.charLength - this.charReceived) ?
        this.charLength - this.charReceived :
        buffer.length;

    // add the new bytes to the char buffer
    buffer.copy(this.charBuffer, this.charReceived, 0, available);
    this.charReceived += available;

    if (this.charReceived < this.charLength) {
      // still not enough chars in this buffer? wait for more ...
      return '';
    }

    // remove bytes belonging to the current character from the buffer
    buffer = buffer.slice(available, buffer.length);

    // get the character that was split
    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);

    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
    var charCode = charStr.charCodeAt(charStr.length - 1);
    if (charCode >= 0xD800 && charCode <= 0xDBFF) {
      this.charLength += this.surrogateSize;
      charStr = '';
      continue;
    }
    this.charReceived = this.charLength = 0;

    // if there are no more bytes in this buffer, just emit our char
    if (buffer.length === 0) {
      return charStr;
    }
    break;
  }

  // determine and set charLength / charReceived
  this.detectIncompleteChar(buffer);

  var end = buffer.length;
  if (this.charLength) {
    // buffer the incomplete character bytes we got
    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
    end -= this.charReceived;
  }

  charStr += buffer.toString(this.encoding, 0, end);

  var end = charStr.length - 1;
  var charCode = charStr.charCodeAt(end);
  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
  if (charCode >= 0xD800 && charCode <= 0xDBFF) {
    var size = this.surrogateSize;
    this.charLength += size;
    this.charReceived += size;
    this.charBuffer.copy(this.charBuffer, size, 0, size);
    buffer.copy(this.charBuffer, 0, 0, size);
    return charStr.substring(0, end);
  }

  // or just emit the charStr
  return charStr;
};

// detectIncompleteChar determines if there is an incomplete UTF-8 character at
// the end of the given buffer. If so, it sets this.charLength to the byte
// length that character, and sets this.charReceived to the number of bytes
// that are available for this character.
StringDecoder.prototype.detectIncompleteChar = function(buffer) {
  // determine how many bytes we have to check at the end of this buffer
  var i = (buffer.length >= 3) ? 3 : buffer.length;

  // Figure out if one of the last i bytes of our buffer announces an
  // incomplete char.
  for (; i > 0; i--) {
    var c = buffer[buffer.length - i];

    // See http://en.wikipedia.org/wiki/UTF-8#Description

    // 110XXXXX
    if (i == 1 && c >> 5 == 0x06) {
      this.charLength = 2;
      break;
    }

    // 1110XXXX
    if (i <= 2 && c >> 4 == 0x0E) {
      this.charLength = 3;
      break;
    }

    // 11110XXX
    if (i <= 3 && c >> 3 == 0x1E) {
      this.charLength = 4;
      break;
    }
  }
  this.charReceived = i;
};

StringDecoder.prototype.end = function(buffer) {
  var res = '';
  if (buffer && buffer.length)
    res = this.write(buffer);

  if (this.charReceived) {
    var cr = this.charReceived;
    var buf = this.charBuffer;
    var enc = this.encoding;
    res += buf.slice(0, cr).toString(enc);
  }

  return res;
};

function passThroughWrite(buffer) {
  return buffer.toString(this.encoding);
}

function utf16DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 2;
  this.charLength = this.charReceived ? 2 : 0;
}

function base64DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 3;
  this.charLength = this.charReceived ? 3 : 0;
}


/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.



module.exports = Transform;

var Duplex = __webpack_require__(0);

/*<replacement>*/
var util = __webpack_require__(3);
util.inherits = __webpack_require__(1);
/*</replacement>*/

util.inherits(Transform, Duplex);

function TransformState(stream) {
  this.afterTransform = function (er, data) {
    return afterTransform(stream, er, data);
  };

  this.needTransform = false;
  this.transforming = false;
  this.writecb = null;
  this.writechunk = null;
  this.writeencoding = null;
}

function afterTransform(stream, er, data) {
  var ts = stream._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb) {
    return stream.emit('error', new Error('write callback called multiple times'));
  }

  ts.writechunk = null;
  ts.writecb = null;

  if (data !== null && data !== undefined) stream.push(data);

  cb(er);

  var rs = stream._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    stream._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);

  Duplex.call(this, options);

  this._transformState = new TransformState(this);

  var stream = this;

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;

    if (typeof options.flush === 'function') this._flush = options.flush;
  }

  // When the writable side finishes, then flush out anything remaining.
  this.once('prefinish', function () {
    if (typeof this._flush === 'function') this._flush(function (er, data) {
      done(stream, er, data);
    });else done(stream);
  });
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function (chunk, encoding, cb) {
  throw new Error('_transform() is not implemented');
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

Transform.prototype._destroy = function (err, cb) {
  var _this = this;

  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
    _this.emit('close');
  });
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);

  if (data !== null && data !== undefined) stream.push(data);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  var ws = stream._writableState;
  var ts = stream._transformState;

  if (ws.length) throw new Error('Calling transform done when ws.length != 0');

  if (ts.transforming) throw new Error('Calling transform done when still transforming');

  return stream.push(null);
}

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer, global, process, module) {

Object.defineProperty(exports, '__esModule', { value: true });

var buffer = __webpack_require__(4);
var path = __webpack_require__(13);

/**
 * Standard libc error codes. Add more to this enum and ErrorStrings as they are
 * needed.
 * @url http://www.gnu.org/software/libc/manual/html_node/Error-Codes.html
 */
var ErrorCode;
(function (ErrorCode) {
    ErrorCode[ErrorCode["EPERM"] = 1] = "EPERM";
    ErrorCode[ErrorCode["ENOENT"] = 2] = "ENOENT";
    ErrorCode[ErrorCode["EIO"] = 5] = "EIO";
    ErrorCode[ErrorCode["EBADF"] = 9] = "EBADF";
    ErrorCode[ErrorCode["EACCES"] = 13] = "EACCES";
    ErrorCode[ErrorCode["EBUSY"] = 16] = "EBUSY";
    ErrorCode[ErrorCode["EEXIST"] = 17] = "EEXIST";
    ErrorCode[ErrorCode["ENOTDIR"] = 20] = "ENOTDIR";
    ErrorCode[ErrorCode["EISDIR"] = 21] = "EISDIR";
    ErrorCode[ErrorCode["EINVAL"] = 22] = "EINVAL";
    ErrorCode[ErrorCode["EFBIG"] = 27] = "EFBIG";
    ErrorCode[ErrorCode["ENOSPC"] = 28] = "ENOSPC";
    ErrorCode[ErrorCode["EROFS"] = 30] = "EROFS";
    ErrorCode[ErrorCode["ENOTEMPTY"] = 39] = "ENOTEMPTY";
    ErrorCode[ErrorCode["ENOTSUP"] = 95] = "ENOTSUP";
})(ErrorCode || (ErrorCode = {}));
/* tslint:disable:variable-name */
/**
 * Strings associated with each error code.
 * @hidden
 */
var ErrorStrings = {};
ErrorStrings[ErrorCode.EPERM] = 'Operation not permitted.';
ErrorStrings[ErrorCode.ENOENT] = 'No such file or directory.';
ErrorStrings[ErrorCode.EIO] = 'Input/output error.';
ErrorStrings[ErrorCode.EBADF] = 'Bad file descriptor.';
ErrorStrings[ErrorCode.EACCES] = 'Permission denied.';
ErrorStrings[ErrorCode.EBUSY] = 'Resource busy or locked.';
ErrorStrings[ErrorCode.EEXIST] = 'File exists.';
ErrorStrings[ErrorCode.ENOTDIR] = 'File is not a directory.';
ErrorStrings[ErrorCode.EISDIR] = 'File is a directory.';
ErrorStrings[ErrorCode.EINVAL] = 'Invalid argument.';
ErrorStrings[ErrorCode.EFBIG] = 'File is too big.';
ErrorStrings[ErrorCode.ENOSPC] = 'No space left on disk.';
ErrorStrings[ErrorCode.EROFS] = 'Cannot modify a read-only file system.';
ErrorStrings[ErrorCode.ENOTEMPTY] = 'Directory is not empty.';
ErrorStrings[ErrorCode.ENOTSUP] = 'Operation is not supported.';
/* tslint:enable:variable-name */
/**
 * Represents a BrowserFS error. Passed back to applications after a failed
 * call to the BrowserFS API.
 */
var ApiError = (function (Error) {
    function ApiError(type, message, path$$1) {
        if ( message === void 0 ) message = ErrorStrings[type];

        Error.call(this, message);
        // Unsupported.
        this.syscall = "";
        this.errno = type;
        this.code = ErrorCode[type];
        this.path = path$$1;
        this.stack = new Error().stack;
        this.message = "Error: " + (this.code) + ": " + message + (this.path ? (", '" + (this.path) + "'") : '');
    }

    if ( Error ) ApiError.__proto__ = Error;
    ApiError.prototype = Object.create( Error && Error.prototype );
    ApiError.prototype.constructor = ApiError;
    ApiError.fromJSON = function fromJSON (json) {
        var err = new ApiError(0);
        err.errno = json.errno;
        err.code = json.code;
        err.path = json.path;
        err.stack = json.stack;
        err.message = json.message;
        return err;
    };
    /**
     * Creates an ApiError object from a buffer.
     */
    ApiError.fromBuffer = function fromBuffer (buffer$$1, i) {
        if ( i === void 0 ) i = 0;

        return ApiError.fromJSON(JSON.parse(buffer$$1.toString('utf8', i + 4, i + 4 + buffer$$1.readUInt32LE(i))));
    };
    ApiError.FileError = function FileError (code, p) {
        return new ApiError(code, ErrorStrings[code], p);
    };
    ApiError.ENOENT = function ENOENT (path$$1) {
        return this.FileError(ErrorCode.ENOENT, path$$1);
    };
    ApiError.EEXIST = function EEXIST (path$$1) {
        return this.FileError(ErrorCode.EEXIST, path$$1);
    };
    ApiError.EISDIR = function EISDIR (path$$1) {
        return this.FileError(ErrorCode.EISDIR, path$$1);
    };
    ApiError.ENOTDIR = function ENOTDIR (path$$1) {
        return this.FileError(ErrorCode.ENOTDIR, path$$1);
    };
    ApiError.EPERM = function EPERM (path$$1) {
        return this.FileError(ErrorCode.EPERM, path$$1);
    };
    ApiError.ENOTEMPTY = function ENOTEMPTY (path$$1) {
        return this.FileError(ErrorCode.ENOTEMPTY, path$$1);
    };
    /**
     * @return A friendly error message.
     */
    ApiError.prototype.toString = function toString () {
        return this.message;
    };
    ApiError.prototype.toJSON = function toJSON () {
        return {
            errno: this.errno,
            code: this.code,
            path: this.path,
            stack: this.stack,
            message: this.message
        };
    };
    /**
     * Writes the API error into a buffer.
     */
    ApiError.prototype.writeToBuffer = function writeToBuffer (buffer$$1, i) {
        if ( buffer$$1 === void 0 ) buffer$$1 = Buffer.alloc(this.bufferSize());
        if ( i === void 0 ) i = 0;

        var bytesWritten = buffer$$1.write(JSON.stringify(this.toJSON()), i + 4);
        buffer$$1.writeUInt32LE(bytesWritten, i);
        return buffer$$1;
    };
    /**
     * The size of the API error in buffer-form in bytes.
     */
    ApiError.prototype.bufferSize = function bufferSize () {
        // 4 bytes for string length.
        return 4 + Buffer.byteLength(JSON.stringify(this.toJSON()));
    };

    return ApiError;
}(Error));


var api_error = Object.freeze({
	get ErrorCode () { return ErrorCode; },
	ErrorStrings: ErrorStrings,
	ApiError: ApiError
});

var ActionType;
(function (ActionType) {
    // Indicates that the code should not do anything.
    ActionType[ActionType["NOP"] = 0] = "NOP";
    // Indicates that the code should throw an exception.
    ActionType[ActionType["THROW_EXCEPTION"] = 1] = "THROW_EXCEPTION";
    // Indicates that the code should truncate the file, but only if it is a file.
    ActionType[ActionType["TRUNCATE_FILE"] = 2] = "TRUNCATE_FILE";
    // Indicates that the code should create the file.
    ActionType[ActionType["CREATE_FILE"] = 3] = "CREATE_FILE";
})(ActionType || (ActionType = {}));
/**
 * Represents one of the following file flags. A convenience object.
 *
 * * `'r'` - Open file for reading. An exception occurs if the file does not exist.
 * * `'r+'` - Open file for reading and writing. An exception occurs if the file does not exist.
 * * `'rs'` - Open file for reading in synchronous mode. Instructs the filesystem to not cache writes.
 * * `'rs+'` - Open file for reading and writing, and opens the file in synchronous mode.
 * * `'w'` - Open file for writing. The file is created (if it does not exist) or truncated (if it exists).
 * * `'wx'` - Like 'w' but opens the file in exclusive mode.
 * * `'w+'` - Open file for reading and writing. The file is created (if it does not exist) or truncated (if it exists).
 * * `'wx+'` - Like 'w+' but opens the file in exclusive mode.
 * * `'a'` - Open file for appending. The file is created if it does not exist.
 * * `'ax'` - Like 'a' but opens the file in exclusive mode.
 * * `'a+'` - Open file for reading and appending. The file is created if it does not exist.
 * * `'ax+'` - Like 'a+' but opens the file in exclusive mode.
 *
 * Exclusive mode ensures that the file path is newly created.
 */
var FileFlag = function FileFlag(flagStr) {
    this.flagStr = flagStr;
    if (FileFlag.validFlagStrs.indexOf(flagStr) < 0) {
        throw new ApiError(ErrorCode.EINVAL, "Invalid flag: " + flagStr);
    }
};
/**
 * Get an object representing the given file flag.
 * @param modeStr The string representing the flag
 * @return The FileFlag object representing the flag
 * @throw when the flag string is invalid
 */
FileFlag.getFileFlag = function getFileFlag (flagStr) {
    // Check cache first.
    if (FileFlag.flagCache.hasOwnProperty(flagStr)) {
        return FileFlag.flagCache[flagStr];
    }
    return FileFlag.flagCache[flagStr] = new FileFlag(flagStr);
};
/**
 * Get the underlying flag string for this flag.
 */
FileFlag.prototype.getFlagString = function getFlagString () {
    return this.flagStr;
};
/**
 * Returns true if the file is readable.
 */
FileFlag.prototype.isReadable = function isReadable () {
    return this.flagStr.indexOf('r') !== -1 || this.flagStr.indexOf('+') !== -1;
};
/**
 * Returns true if the file is writeable.
 */
FileFlag.prototype.isWriteable = function isWriteable () {
    return this.flagStr.indexOf('w') !== -1 || this.flagStr.indexOf('a') !== -1 || this.flagStr.indexOf('+') !== -1;
};
/**
 * Returns true if the file mode should truncate.
 */
FileFlag.prototype.isTruncating = function isTruncating () {
    return this.flagStr.indexOf('w') !== -1;
};
/**
 * Returns true if the file is appendable.
 */
FileFlag.prototype.isAppendable = function isAppendable () {
    return this.flagStr.indexOf('a') !== -1;
};
/**
 * Returns true if the file is open in synchronous mode.
 */
FileFlag.prototype.isSynchronous = function isSynchronous () {
    return this.flagStr.indexOf('s') !== -1;
};
/**
 * Returns true if the file is open in exclusive mode.
 */
FileFlag.prototype.isExclusive = function isExclusive () {
    return this.flagStr.indexOf('x') !== -1;
};
/**
 * Returns one of the static fields on this object that indicates the
 * appropriate response to the path existing.
 */
FileFlag.prototype.pathExistsAction = function pathExistsAction () {
    if (this.isExclusive()) {
        return ActionType.THROW_EXCEPTION;
    }
    else if (this.isTruncating()) {
        return ActionType.TRUNCATE_FILE;
    }
    else {
        return ActionType.NOP;
    }
};
/**
 * Returns one of the static fields on this object that indicates the
 * appropriate response to the path not existing.
 */
FileFlag.prototype.pathNotExistsAction = function pathNotExistsAction () {
    if ((this.isWriteable() || this.isAppendable()) && this.flagStr !== 'r+') {
        return ActionType.CREATE_FILE;
    }
    else {
        return ActionType.THROW_EXCEPTION;
    }
};
// Contains cached FileMode instances.
FileFlag.flagCache = {};
// Array of valid mode strings.
FileFlag.validFlagStrs = ['r', 'r+', 'rs', 'rs+', 'w', 'wx', 'w+', 'wx+', 'a', 'ax', 'a+', 'ax+'];

/**
 * Indicates the type of the given file. Applied to 'mode'.
 */
var FileType;
(function (FileType) {
    FileType[FileType["FILE"] = 32768] = "FILE";
    FileType[FileType["DIRECTORY"] = 16384] = "DIRECTORY";
    FileType[FileType["SYMLINK"] = 40960] = "SYMLINK";
})(FileType || (FileType = {}));
/**
 * Emulation of Node's `fs.Stats` object.
 *
 * Attribute descriptions are from `man 2 stat'
 * @see http://nodejs.org/api/fs.html#fs_class_fs_stats
 * @see http://man7.org/linux/man-pages/man2/stat.2.html
 */
var Stats = function Stats(itemType, size, mode, atime, mtime, ctime) {
    if ( atime === void 0 ) atime = new Date();
    if ( mtime === void 0 ) mtime = new Date();
    if ( ctime === void 0 ) ctime = new Date();

    this.size = size;
    this.atime = atime;
    this.mtime = mtime;
    this.ctime = ctime;
    /**
     * UNSUPPORTED ATTRIBUTES
     * I assume no one is going to need these details, although we could fake
     * appropriate values if need be.
     */
    // ID of device containing file
    this.dev = 0;
    // inode number
    this.ino = 0;
    // device ID (if special file)
    this.rdev = 0;
    // number of hard links
    this.nlink = 1;
    // blocksize for file system I/O
    this.blksize = 4096;
    // @todo Maybe support these? atm, it's a one-user filesystem.
    // user ID of owner
    this.uid = 0;
    // group ID of owner
    this.gid = 0;
    // time file was created (currently unsupported)
    this.birthtime = new Date(0);
    // XXX: Some file systems stash data on stats objects.
    this.fileData = null;
    if (!mode) {
        switch (itemType) {
            case FileType.FILE:
                this.mode = 0x1a4;
                break;
            case FileType.DIRECTORY:
            default:
                this.mode = 0x1ff;
        }
    }
    else {
        this.mode = mode;
    }
    // number of 512B blocks allocated
    this.blocks = Math.ceil(size / 512);
    // Check if mode also includes top-most bits, which indicate the file's
    // type.
    if (this.mode < 0x1000) {
        this.mode |= itemType;
    }
};
Stats.fromBuffer = function fromBuffer (buffer$$1) {
    var size = buffer$$1.readUInt32LE(0), mode = buffer$$1.readUInt32LE(4), atime = buffer$$1.readDoubleLE(8), mtime = buffer$$1.readDoubleLE(16), ctime = buffer$$1.readDoubleLE(24);
    return new Stats(mode & 0xF000, size, mode & 0xFFF, new Date(atime), new Date(mtime), new Date(ctime));
};
/**
 * Clones the stats object.
 */
Stats.clone = function clone (s) {
    return new Stats(s.mode & 0xF000, s.size, s.mode & 0xFFF, s.atime, s.mtime, s.ctime);
};
Stats.prototype.toBuffer = function toBuffer () {
    var buffer$$1 = Buffer.alloc(32);
    buffer$$1.writeUInt32LE(this.size, 0);
    buffer$$1.writeUInt32LE(this.mode, 4);
    buffer$$1.writeDoubleLE(this.atime.getTime(), 8);
    buffer$$1.writeDoubleLE(this.mtime.getTime(), 16);
    buffer$$1.writeDoubleLE(this.ctime.getTime(), 24);
    return buffer$$1;
};
/**
 * @return [Boolean] True if this item is a file.
 */
Stats.prototype.isFile = function isFile () {
    return (this.mode & 0xF000) === FileType.FILE;
};
/**
 * @return [Boolean] True if this item is a directory.
 */
Stats.prototype.isDirectory = function isDirectory () {
    return (this.mode & 0xF000) === FileType.DIRECTORY;
};
/**
 * @return [Boolean] True if this item is a symbolic link (only valid through lstat)
 */
Stats.prototype.isSymbolicLink = function isSymbolicLink () {
    return (this.mode & 0xF000) === FileType.SYMLINK;
};
/**
 * Change the mode of the file. We use this helper function to prevent messing
 * up the type of the file, which is encoded in mode.
 */
Stats.prototype.chmod = function chmod (mode) {
    this.mode = (this.mode & 0xF000) | mode;
};
// We don't support the following types of files.
Stats.prototype.isSocket = function isSocket () {
    return false;
};
Stats.prototype.isBlockDevice = function isBlockDevice () {
    return false;
};
Stats.prototype.isCharacterDevice = function isCharacterDevice () {
    return false;
};
Stats.prototype.isFIFO = function isFIFO () {
    return false;
};

/**
 * Wraps a callback function. Used for unit testing. Defaults to a NOP.
 * @hidden
 */
var wrapCb = function (cb, numArgs) {
    return cb;
};
/**
 * @hidden
 */
function assertRoot(fs) {
    if (fs) {
        return fs;
    }
    throw new ApiError(ErrorCode.EIO, "Initialize BrowserFS with a file system using BrowserFS.initialize(filesystem)");
}
/**
 * @hidden
 */
function normalizeMode(mode, def) {
    switch (typeof mode) {
        case 'number':
            // (path, flag, mode, cb?)
            return mode;
        case 'string':
            // (path, flag, modeString, cb?)
            var trueMode = parseInt(mode, 8);
            if (!isNaN(trueMode)) {
                return trueMode;
            }
            // Invalid string.
            return def;
        default:
            return def;
    }
}
/**
 * @hidden
 */
function normalizeTime(time) {
    if (time instanceof Date) {
        return time;
    }
    else if (typeof time === 'number') {
        return new Date(time * 1000);
    }
    else {
        throw new ApiError(ErrorCode.EINVAL, "Invalid time.");
    }
}
/**
 * @hidden
 */
function normalizePath(p) {
    // Node doesn't allow null characters in paths.
    if (p.indexOf('\u0000') >= 0) {
        throw new ApiError(ErrorCode.EINVAL, 'Path must be a string without null bytes.');
    }
    else if (p === '') {
        throw new ApiError(ErrorCode.EINVAL, 'Path must not be empty.');
    }
    return path.resolve(p);
}
/**
 * @hidden
 */
function normalizeOptions(options, defEnc, defFlag, defMode) {
    switch (typeof options) {
        case 'object':
            return {
                encoding: typeof options['encoding'] !== 'undefined' ? options['encoding'] : defEnc,
                flag: typeof options['flag'] !== 'undefined' ? options['flag'] : defFlag,
                mode: normalizeMode(options['mode'], defMode)
            };
        case 'string':
            return {
                encoding: options,
                flag: defFlag,
                mode: defMode
            };
        default:
            return {
                encoding: defEnc,
                flag: defFlag,
                mode: defMode
            };
    }
}
/**
 * The default callback is a NOP.
 * @hidden
 * @private
 */
function nopCb() {
    // NOP.
}
/**
 * The node frontend to all filesystems.
 * This layer handles:
 *
 * * Sanity checking inputs.
 * * Normalizing paths.
 * * Resetting stack depth for asynchronous operations which may not go through
 *   the browser by wrapping all input callbacks using `setImmediate`.
 * * Performing the requested operation through the filesystem or the file
 *   descriptor, as appropriate.
 * * Handling optional arguments and setting default arguments.
 * @see http://nodejs.org/api/fs.html
 */
var FS = function FS() {
    /* tslint:enable:variable-name */
    this.F_OK = 0;
    this.R_OK = 4;
    this.W_OK = 2;
    this.X_OK = 1;
    this.root = null;
    this.fdMap = {};
    this.nextFd = 100;
};
FS.prototype.initialize = function initialize (rootFS) {
    if (!rootFS.constructor.isAvailable()) {
        throw new ApiError(ErrorCode.EINVAL, 'Tried to instantiate BrowserFS with an unavailable file system.');
    }
    return this.root = rootFS;
};
/**
 * converts Date or number to a fractional UNIX timestamp
 * Grabbed from NodeJS sources (lib/fs.js)
 */
FS.prototype._toUnixTimestamp = function _toUnixTimestamp (time) {
    if (typeof time === 'number') {
        return time;
    }
    else if (time instanceof Date) {
        return time.getTime() / 1000;
    }
    throw new Error("Cannot parse time: " + time);
};
/**
 * **NONSTANDARD**: Grab the FileSystem instance that backs this API.
 * @return [BrowserFS.FileSystem | null] Returns null if the file system has
 *   not been initialized.
 */
FS.prototype.getRootFS = function getRootFS () {
    if (this.root) {
        return this.root;
    }
    else {
        return null;
    }
};
// FILE OR DIRECTORY METHODS
/**
 * Asynchronous rename. No arguments other than a possible exception are given
 * to the completion callback.
 * @param oldPath
 * @param newPath
 * @param callback
 */
FS.prototype.rename = function rename (oldPath, newPath, cb) {
        if ( cb === void 0 ) cb = nopCb;

    var newCb = wrapCb(cb, 1);
    try {
        assertRoot(this.root).rename(normalizePath(oldPath), normalizePath(newPath), newCb);
    }
    catch (e) {
        newCb(e);
    }
};
/**
 * Synchronous rename.
 * @param oldPath
 * @param newPath
 */
FS.prototype.renameSync = function renameSync (oldPath, newPath) {
    assertRoot(this.root).renameSync(normalizePath(oldPath), normalizePath(newPath));
};
/**
 * Test whether or not the given path exists by checking with the file system.
 * Then call the callback argument with either true or false.
 * @example Sample invocation
 *   fs.exists('/etc/passwd', function (exists) {
 * util.debug(exists ? "it's there" : "no passwd!");
 *   });
 * @param path
 * @param callback
 */
FS.prototype.exists = function exists (path$$1, cb) {
        if ( cb === void 0 ) cb = nopCb;

    var newCb = wrapCb(cb, 1);
    try {
        return assertRoot(this.root).exists(normalizePath(path$$1), newCb);
    }
    catch (e) {
        // Doesn't return an error. If something bad happens, we assume it just
        // doesn't exist.
        return newCb(false);
    }
};
/**
 * Test whether or not the given path exists by checking with the file system.
 * @param path
 * @return [boolean]
 */
FS.prototype.existsSync = function existsSync (path$$1) {
    try {
        return assertRoot(this.root).existsSync(normalizePath(path$$1));
    }
    catch (e) {
        // Doesn't return an error. If something bad happens, we assume it just
        // doesn't exist.
        return false;
    }
};
/**
 * Asynchronous `stat`.
 * @param path
 * @param callback
 */
FS.prototype.stat = function stat (path$$1, cb) {
        if ( cb === void 0 ) cb = nopCb;

    var newCb = wrapCb(cb, 2);
    try {
        return assertRoot(this.root).stat(normalizePath(path$$1), false, newCb);
    }
    catch (e) {
        return newCb(e);
    }
};
/**
 * Synchronous `stat`.
 * @param path
 * @return [BrowserFS.node.fs.Stats]
 */
FS.prototype.statSync = function statSync (path$$1) {
    return assertRoot(this.root).statSync(normalizePath(path$$1), false);
};
/**
 * Asynchronous `lstat`.
 * `lstat()` is identical to `stat()`, except that if path is a symbolic link,
 * then the link itself is stat-ed, not the file that it refers to.
 * @param path
 * @param callback
 */
FS.prototype.lstat = function lstat (path$$1, cb) {
        if ( cb === void 0 ) cb = nopCb;

    var newCb = wrapCb(cb, 2);
    try {
        return assertRoot(this.root).stat(normalizePath(path$$1), true, newCb);
    }
    catch (e) {
        return newCb(e);
    }
};
/**
 * Synchronous `lstat`.
 * `lstat()` is identical to `stat()`, except that if path is a symbolic link,
 * then the link itself is stat-ed, not the file that it refers to.
 * @param path
 * @return [BrowserFS.node.fs.Stats]
 */
FS.prototype.lstatSync = function lstatSync (path$$1) {
    return assertRoot(this.root).statSync(normalizePath(path$$1), true);
};
FS.prototype.truncate = function truncate (path$$1, arg2, cb) {
        if ( arg2 === void 0 ) arg2 = 0;
        if ( cb === void 0 ) cb = nopCb;

    var len = 0;
    if (typeof arg2 === 'function') {
        cb = arg2;
    }
    else if (typeof arg2 === 'number') {
        len = arg2;
    }
    var newCb = wrapCb(cb, 1);
    try {
        if (len < 0) {
            throw new ApiError(ErrorCode.EINVAL);
        }
        return assertRoot(this.root).truncate(normalizePath(path$$1), len, newCb);
    }
    catch (e) {
        return newCb(e);
    }
};
/**
 * Synchronous `truncate`.
 * @param path
 * @param len
 */
FS.prototype.truncateSync = function truncateSync (path$$1, len) {
        if ( len === void 0 ) len = 0;

    if (len < 0) {
        throw new ApiError(ErrorCode.EINVAL);
    }
    return assertRoot(this.root).truncateSync(normalizePath(path$$1), len);
};
/**
 * Asynchronous `unlink`.
 * @param path
 * @param callback
 */
FS.prototype.unlink = function unlink (path$$1, cb) {
        if ( cb === void 0 ) cb = nopCb;

    var newCb = wrapCb(cb, 1);
    try {
        return assertRoot(this.root).unlink(normalizePath(path$$1), newCb);
    }
    catch (e) {
        return newCb(e);
    }
};
/**
 * Synchronous `unlink`.
 * @param path
 */
FS.prototype.unlinkSync = function unlinkSync (path$$1) {
    return assertRoot(this.root).unlinkSync(normalizePath(path$$1));
};
FS.prototype.open = function open (path$$1, flag, arg2, cb) {
        var this$1 = this;
        if ( cb === void 0 ) cb = nopCb;

    var mode = normalizeMode(arg2, 0x1a4);
    cb = typeof arg2 === 'function' ? arg2 : cb;
    var newCb = wrapCb(cb, 2);
    try {
        assertRoot(this.root).open(normalizePath(path$$1), FileFlag.getFileFlag(flag), mode, function (e, file) {
            if (file) {
                newCb(e, this$1.getFdForFile(file));
            }
            else {
                newCb(e);
            }
        });
    }
    catch (e) {
        newCb(e);
    }
};
/**
 * Synchronous file open.
 * @see http://www.manpagez.com/man/2/open/
 * @param path
 * @param flags
 * @param mode defaults to `0644`
 * @return [BrowserFS.File]
 */
FS.prototype.openSync = function openSync (path$$1, flag, mode) {
        if ( mode === void 0 ) mode = 0x1a4;

    return this.getFdForFile(assertRoot(this.root).openSync(normalizePath(path$$1), FileFlag.getFileFlag(flag), normalizeMode(mode, 0x1a4)));
};
FS.prototype.readFile = function readFile (filename, arg2, cb) {
        if ( arg2 === void 0 ) arg2 = {};
        if ( cb === void 0 ) cb = nopCb;

    var options = normalizeOptions(arg2, null, 'r', null);
    cb = typeof arg2 === 'function' ? arg2 : cb;
    var newCb = wrapCb(cb, 2);
    try {
        var flag = FileFlag.getFileFlag(options['flag']);
        if (!flag.isReadable()) {
            return newCb(new ApiError(ErrorCode.EINVAL, 'Flag passed to readFile must allow for reading.'));
        }
        return assertRoot(this.root).readFile(normalizePath(filename), options.encoding, flag, newCb);
    }
    catch (e) {
        return newCb(e);
    }
};
FS.prototype.readFileSync = function readFileSync (filename, arg2) {
        if ( arg2 === void 0 ) arg2 = {};

    var options = normalizeOptions(arg2, null, 'r', null);
    var flag = FileFlag.getFileFlag(options.flag);
    if (!flag.isReadable()) {
        throw new ApiError(ErrorCode.EINVAL, 'Flag passed to readFile must allow for reading.');
    }
    return assertRoot(this.root).readFileSync(normalizePath(filename), options.encoding, flag);
};
FS.prototype.writeFile = function writeFile (filename, data, arg3, cb) {
        if ( arg3 === void 0 ) arg3 = {};
        if ( cb === void 0 ) cb = nopCb;

    var options = normalizeOptions(arg3, 'utf8', 'w', 0x1a4);
    cb = typeof arg3 === 'function' ? arg3 : cb;
    var newCb = wrapCb(cb, 1);
    try {
        var flag = FileFlag.getFileFlag(options.flag);
        if (!flag.isWriteable()) {
            return newCb(new ApiError(ErrorCode.EINVAL, 'Flag passed to writeFile must allow for writing.'));
        }
        return assertRoot(this.root).writeFile(normalizePath(filename), data, options.encoding, flag, options.mode, newCb);
    }
    catch (e) {
        return newCb(e);
    }
};
FS.prototype.writeFileSync = function writeFileSync (filename, data, arg3) {
    var options = normalizeOptions(arg3, 'utf8', 'w', 0x1a4);
    var flag = FileFlag.getFileFlag(options.flag);
    if (!flag.isWriteable()) {
        throw new ApiError(ErrorCode.EINVAL, 'Flag passed to writeFile must allow for writing.');
    }
    return assertRoot(this.root).writeFileSync(normalizePath(filename), data, options.encoding, flag, options.mode);
};
FS.prototype.appendFile = function appendFile (filename, data, arg3, cb) {
        if ( cb === void 0 ) cb = nopCb;

    var options = normalizeOptions(arg3, 'utf8', 'a', 0x1a4);
    cb = typeof arg3 === 'function' ? arg3 : cb;
    var newCb = wrapCb(cb, 1);
    try {
        var flag = FileFlag.getFileFlag(options.flag);
        if (!flag.isAppendable()) {
            return newCb(new ApiError(ErrorCode.EINVAL, 'Flag passed to appendFile must allow for appending.'));
        }
        assertRoot(this.root).appendFile(normalizePath(filename), data, options.encoding, flag, options.mode, newCb);
    }
    catch (e) {
        newCb(e);
    }
};
FS.prototype.appendFileSync = function appendFileSync (filename, data, arg3) {
    var options = normalizeOptions(arg3, 'utf8', 'a', 0x1a4);
    var flag = FileFlag.getFileFlag(options.flag);
    if (!flag.isAppendable()) {
        throw new ApiError(ErrorCode.EINVAL, 'Flag passed to appendFile must allow for appending.');
    }
    return assertRoot(this.root).appendFileSync(normalizePath(filename), data, options.encoding, flag, options.mode);
};
// FILE DESCRIPTOR METHODS
/**
 * Asynchronous `fstat`.
 * `fstat()` is identical to `stat()`, except that the file to be stat-ed is
 * specified by the file descriptor `fd`.
 * @param fd
 * @param callback
 */
FS.prototype.fstat = function fstat (fd, cb) {
        if ( cb === void 0 ) cb = nopCb;

    var newCb = wrapCb(cb, 2);
    try {
        var file = this.fd2file(fd);
        file.stat(newCb);
    }
    catch (e) {
        newCb(e);
    }
};
/**
 * Synchronous `fstat`.
 * `fstat()` is identical to `stat()`, except that the file to be stat-ed is
 * specified by the file descriptor `fd`.
 * @param fd
 * @return [BrowserFS.node.fs.Stats]
 */
FS.prototype.fstatSync = function fstatSync (fd) {
    return this.fd2file(fd).statSync();
};
/**
 * Asynchronous close.
 * @param fd
 * @param callback
 */
FS.prototype.close = function close (fd, cb) {
        var this$1 = this;
        if ( cb === void 0 ) cb = nopCb;

    var newCb = wrapCb(cb, 1);
    try {
        this.fd2file(fd).close(function (e) {
            if (!e) {
                this$1.closeFd(fd);
            }
            newCb(e);
        });
    }
    catch (e) {
        newCb(e);
    }
};
/**
 * Synchronous close.
 * @param fd
 */
FS.prototype.closeSync = function closeSync (fd) {
    this.fd2file(fd).closeSync();
    this.closeFd(fd);
};
FS.prototype.ftruncate = function ftruncate (fd, arg2, cb) {
        if ( cb === void 0 ) cb = nopCb;

    var length = typeof arg2 === 'number' ? arg2 : 0;
    cb = typeof arg2 === 'function' ? arg2 : cb;
    var newCb = wrapCb(cb, 1);
    try {
        var file = this.fd2file(fd);
        if (length < 0) {
            throw new ApiError(ErrorCode.EINVAL);
        }
        file.truncate(length, newCb);
    }
    catch (e) {
        newCb(e);
    }
};
/**
 * Synchronous ftruncate.
 * @param fd
 * @param len
 */
FS.prototype.ftruncateSync = function ftruncateSync (fd, len) {
        if ( len === void 0 ) len = 0;

    var file = this.fd2file(fd);
    if (len < 0) {
        throw new ApiError(ErrorCode.EINVAL);
    }
    file.truncateSync(len);
};
/**
 * Asynchronous fsync.
 * @param fd
 * @param callback
 */
FS.prototype.fsync = function fsync (fd, cb) {
        if ( cb === void 0 ) cb = nopCb;

    var newCb = wrapCb(cb, 1);
    try {
        this.fd2file(fd).sync(newCb);
    }
    catch (e) {
        newCb(e);
    }
};
/**
 * Synchronous fsync.
 * @param fd
 */
FS.prototype.fsyncSync = function fsyncSync (fd) {
    this.fd2file(fd).syncSync();
};
/**
 * Asynchronous fdatasync.
 * @param fd
 * @param callback
 */
FS.prototype.fdatasync = function fdatasync (fd, cb) {
        if ( cb === void 0 ) cb = nopCb;

    var newCb = wrapCb(cb, 1);
    try {
        this.fd2file(fd).datasync(newCb);
    }
    catch (e) {
        newCb(e);
    }
};
/**
 * Synchronous fdatasync.
 * @param fd
 */
FS.prototype.fdatasyncSync = function fdatasyncSync (fd) {
    this.fd2file(fd).datasyncSync();
};
FS.prototype.write = function write (fd, arg2, arg3, arg4, arg5, cb) {
        if ( cb === void 0 ) cb = nopCb;

    var buffer$$1, offset, length, position = null;
    if (typeof arg2 === 'string') {
        // Signature 1: (fd, string, [position?, [encoding?]], cb?)
        var encoding = 'utf8';
        switch (typeof arg3) {
            case 'function':
                // (fd, string, cb)
                cb = arg3;
                break;
            case 'number':
                // (fd, string, position, encoding?, cb?)
                position = arg3;
                encoding = typeof arg4 === 'string' ? arg4 : 'utf8';
                cb = typeof arg5 === 'function' ? arg5 : cb;
                break;
            default:
                // ...try to find the callback and get out of here!
                cb = typeof arg4 === 'function' ? arg4 : typeof arg5 === 'function' ? arg5 : cb;
                return cb(new ApiError(ErrorCode.EINVAL, 'Invalid arguments.'));
        }
        buffer$$1 = Buffer.from(arg2, encoding);
        offset = 0;
        length = buffer$$1.length;
    }
    else {
        // Signature 2: (fd, buffer, offset, length, position?, cb?)
        buffer$$1 = arg2;
        offset = arg3;
        length = arg4;
        position = typeof arg5 === 'number' ? arg5 : null;
        cb = typeof arg5 === 'function' ? arg5 : cb;
    }
    var newCb = wrapCb(cb, 3);
    try {
        var file = this.fd2file(fd);
        if (position === undefined || position === null) {
            position = file.getPos();
        }
        file.write(buffer$$1, offset, length, position, newCb);
    }
    catch (e) {
        newCb(e);
    }
};
FS.prototype.writeSync = function writeSync (fd, arg2, arg3, arg4, arg5) {
    var buffer$$1, offset = 0, length, position;
    if (typeof arg2 === 'string') {
        // Signature 1: (fd, string, [position?, [encoding?]])
        position = typeof arg3 === 'number' ? arg3 : null;
        var encoding = typeof arg4 === 'string' ? arg4 : 'utf8';
        offset = 0;
        buffer$$1 = Buffer.from(arg2, encoding);
        length = buffer$$1.length;
    }
    else {
        // Signature 2: (fd, buffer, offset, length, position?)
        buffer$$1 = arg2;
        offset = arg3;
        length = arg4;
        position = typeof arg5 === 'number' ? arg5 : null;
    }
    var file = this.fd2file(fd);
    if (position === undefined || position === null) {
        position = file.getPos();
    }
    return file.writeSync(buffer$$1, offset, length, position);
};
FS.prototype.read = function read (fd, arg2, arg3, arg4, arg5, cb) {
        if ( cb === void 0 ) cb = nopCb;

    var position, offset, length, buffer$$1, newCb;
    if (typeof arg2 === 'number') {
        // legacy interface
        // (fd, length, position, encoding, callback)
        length = arg2;
        position = arg3;
        var encoding = arg4;
        cb = typeof arg5 === 'function' ? arg5 : cb;
        offset = 0;
        buffer$$1 = Buffer.alloc(length);
        // XXX: Inefficient.
        // Wrap the cb so we shelter upper layers of the API from these
        // shenanigans.
        newCb = wrapCb(function (err, bytesRead, buf) {
            if (err) {
                return cb(err);
            }
            cb(err, buf.toString(encoding), bytesRead);
        }, 3);
    }
    else {
        buffer$$1 = arg2;
        offset = arg3;
        length = arg4;
        position = arg5;
        newCb = wrapCb(cb, 3);
    }
    try {
        var file = this.fd2file(fd);
        if (position === undefined || position === null) {
            position = file.getPos();
        }
        file.read(buffer$$1, offset, length, position, newCb);
    }
    catch (e) {
        newCb(e);
    }
};
FS.prototype.readSync = function readSync (fd, arg2, arg3, arg4, arg5) {
    var shenanigans = false;
    var buffer$$1, offset, length, position, encoding = 'utf8';
    if (typeof arg2 === 'number') {
        length = arg2;
        position = arg3;
        encoding = arg4;
        offset = 0;
        buffer$$1 = Buffer.alloc(length);
        shenanigans = true;
    }
    else {
        buffer$$1 = arg2;
        offset = arg3;
        length = arg4;
        position = arg5;
    }
    var file = this.fd2file(fd);
    if (position === undefined || position === null) {
        position = file.getPos();
    }
    var rv = file.readSync(buffer$$1, offset, length, position);
    if (!shenanigans) {
        return rv;
    }
    else {
        return [buffer$$1.toString(encoding), rv];
    }
};
/**
 * Asynchronous `fchown`.
 * @param fd
 * @param uid
 * @param gid
 * @param callback
 */
FS.prototype.fchown = function fchown (fd, uid, gid, callback) {
        if ( callback === void 0 ) callback = nopCb;

    var newCb = wrapCb(callback, 1);
    try {
        this.fd2file(fd).chown(uid, gid, newCb);
    }
    catch (e) {
        newCb(e);
    }
};
/**
 * Synchronous `fchown`.
 * @param fd
 * @param uid
 * @param gid
 */
FS.prototype.fchownSync = function fchownSync (fd, uid, gid) {
    this.fd2file(fd).chownSync(uid, gid);
};
/**
 * Asynchronous `fchmod`.
 * @param fd
 * @param mode
 * @param callback
 */
FS.prototype.fchmod = function fchmod (fd, mode, cb) {
    var newCb = wrapCb(cb, 1);
    try {
        var numMode = typeof mode === 'string' ? parseInt(mode, 8) : mode;
        this.fd2file(fd).chmod(numMode, newCb);
    }
    catch (e) {
        newCb(e);
    }
};
/**
 * Synchronous `fchmod`.
 * @param fd
 * @param mode
 */
FS.prototype.fchmodSync = function fchmodSync (fd, mode) {
    var numMode = typeof mode === 'string' ? parseInt(mode, 8) : mode;
    this.fd2file(fd).chmodSync(numMode);
};
/**
 * Change the file timestamps of a file referenced by the supplied file
 * descriptor.
 * @param fd
 * @param atime
 * @param mtime
 * @param callback
 */
FS.prototype.futimes = function futimes (fd, atime, mtime, cb) {
        if ( cb === void 0 ) cb = nopCb;

    var newCb = wrapCb(cb, 1);
    try {
        var file = this.fd2file(fd);
        if (typeof atime === 'number') {
            atime = new Date(atime * 1000);
        }
        if (typeof mtime === 'number') {
            mtime = new Date(mtime * 1000);
        }
        file.utimes(atime, mtime, newCb);
    }
    catch (e) {
        newCb(e);
    }
};
/**
 * Change the file timestamps of a file referenced by the supplied file
 * descriptor.
 * @param fd
 * @param atime
 * @param mtime
 */
FS.prototype.futimesSync = function futimesSync (fd, atime, mtime) {
    this.fd2file(fd).utimesSync(normalizeTime(atime), normalizeTime(mtime));
};
// DIRECTORY-ONLY METHODS
/**
 * Asynchronous `rmdir`.
 * @param path
 * @param callback
 */
FS.prototype.rmdir = function rmdir (path$$1, cb) {
        if ( cb === void 0 ) cb = nopCb;

    var newCb = wrapCb(cb, 1);
    try {
        path$$1 = normalizePath(path$$1);
        assertRoot(this.root).rmdir(path$$1, newCb);
    }
    catch (e) {
        newCb(e);
    }
};
/**
 * Synchronous `rmdir`.
 * @param path
 */
FS.prototype.rmdirSync = function rmdirSync (path$$1) {
    path$$1 = normalizePath(path$$1);
    return assertRoot(this.root).rmdirSync(path$$1);
};
/**
 * Asynchronous `mkdir`.
 * @param path
 * @param mode defaults to `0777`
 * @param callback
 */
FS.prototype.mkdir = function mkdir (path$$1, mode, cb) {
        if ( cb === void 0 ) cb = nopCb;

    if (typeof mode === 'function') {
        cb = mode;
        mode = 0x1ff;
    }
    var newCb = wrapCb(cb, 1);
    try {
        path$$1 = normalizePath(path$$1);
        assertRoot(this.root).mkdir(path$$1, mode, newCb);
    }
    catch (e) {
        newCb(e);
    }
};
/**
 * Synchronous `mkdir`.
 * @param path
 * @param mode defaults to `0777`
 */
FS.prototype.mkdirSync = function mkdirSync (path$$1, mode) {
    assertRoot(this.root).mkdirSync(normalizePath(path$$1), normalizeMode(mode, 0x1ff));
};
/**
 * Asynchronous `readdir`. Reads the contents of a directory.
 * The callback gets two arguments `(err, files)` where `files` is an array of
 * the names of the files in the directory excluding `'.'` and `'..'`.
 * @param path
 * @param callback
 */
FS.prototype.readdir = function readdir (path$$1, cb) {
        if ( cb === void 0 ) cb = nopCb;

    var newCb = wrapCb(cb, 2);
    try {
        path$$1 = normalizePath(path$$1);
        assertRoot(this.root).readdir(path$$1, newCb);
    }
    catch (e) {
        newCb(e);
    }
};
/**
 * Synchronous `readdir`. Reads the contents of a directory.
 * @param path
 * @return [String[]]
 */
FS.prototype.readdirSync = function readdirSync (path$$1) {
    path$$1 = normalizePath(path$$1);
    return assertRoot(this.root).readdirSync(path$$1);
};
// SYMLINK METHODS
/**
 * Asynchronous `link`.
 * @param srcpath
 * @param dstpath
 * @param callback
 */
FS.prototype.link = function link (srcpath, dstpath, cb) {
        if ( cb === void 0 ) cb = nopCb;

    var newCb = wrapCb(cb, 1);
    try {
        srcpath = normalizePath(srcpath);
        dstpath = normalizePath(dstpath);
        assertRoot(this.root).link(srcpath, dstpath, newCb);
    }
    catch (e) {
        newCb(e);
    }
};
/**
 * Synchronous `link`.
 * @param srcpath
 * @param dstpath
 */
FS.prototype.linkSync = function linkSync (srcpath, dstpath) {
    srcpath = normalizePath(srcpath);
    dstpath = normalizePath(dstpath);
    return assertRoot(this.root).linkSync(srcpath, dstpath);
};
FS.prototype.symlink = function symlink (srcpath, dstpath, arg3, cb) {
        if ( cb === void 0 ) cb = nopCb;

    var type = typeof arg3 === 'string' ? arg3 : 'file';
    cb = typeof arg3 === 'function' ? arg3 : cb;
    var newCb = wrapCb(cb, 1);
    try {
        if (type !== 'file' && type !== 'dir') {
            return newCb(new ApiError(ErrorCode.EINVAL, "Invalid type: " + type));
        }
        srcpath = normalizePath(srcpath);
        dstpath = normalizePath(dstpath);
        assertRoot(this.root).symlink(srcpath, dstpath, type, newCb);
    }
    catch (e) {
        newCb(e);
    }
};
/**
 * Synchronous `symlink`.
 * @param srcpath
 * @param dstpath
 * @param type can be either `'dir'` or `'file'` (default is `'file'`)
 */
FS.prototype.symlinkSync = function symlinkSync (srcpath, dstpath, type) {
    if (!type) {
        type = 'file';
    }
    else if (type !== 'file' && type !== 'dir') {
        throw new ApiError(ErrorCode.EINVAL, "Invalid type: " + type);
    }
    srcpath = normalizePath(srcpath);
    dstpath = normalizePath(dstpath);
    return assertRoot(this.root).symlinkSync(srcpath, dstpath, type);
};
/**
 * Asynchronous readlink.
 * @param path
 * @param callback
 */
FS.prototype.readlink = function readlink (path$$1, cb) {
        if ( cb === void 0 ) cb = nopCb;

    var newCb = wrapCb(cb, 2);
    try {
        path$$1 = normalizePath(path$$1);
        assertRoot(this.root).readlink(path$$1, newCb);
    }
    catch (e) {
        newCb(e);
    }
};
/**
 * Synchronous readlink.
 * @param path
 * @return [String]
 */
FS.prototype.readlinkSync = function readlinkSync (path$$1) {
    path$$1 = normalizePath(path$$1);
    return assertRoot(this.root).readlinkSync(path$$1);
};
// PROPERTY OPERATIONS
/**
 * Asynchronous `chown`.
 * @param path
 * @param uid
 * @param gid
 * @param callback
 */
FS.prototype.chown = function chown (path$$1, uid, gid, cb) {
        if ( cb === void 0 ) cb = nopCb;

    var newCb = wrapCb(cb, 1);
    try {
        path$$1 = normalizePath(path$$1);
        assertRoot(this.root).chown(path$$1, false, uid, gid, newCb);
    }
    catch (e) {
        newCb(e);
    }
};
/**
 * Synchronous `chown`.
 * @param path
 * @param uid
 * @param gid
 */
FS.prototype.chownSync = function chownSync (path$$1, uid, gid) {
    path$$1 = normalizePath(path$$1);
    assertRoot(this.root).chownSync(path$$1, false, uid, gid);
};
/**
 * Asynchronous `lchown`.
 * @param path
 * @param uid
 * @param gid
 * @param callback
 */
FS.prototype.lchown = function lchown (path$$1, uid, gid, cb) {
        if ( cb === void 0 ) cb = nopCb;

    var newCb = wrapCb(cb, 1);
    try {
        path$$1 = normalizePath(path$$1);
        assertRoot(this.root).chown(path$$1, true, uid, gid, newCb);
    }
    catch (e) {
        newCb(e);
    }
};
/**
 * Synchronous `lchown`.
 * @param path
 * @param uid
 * @param gid
 */
FS.prototype.lchownSync = function lchownSync (path$$1, uid, gid) {
    path$$1 = normalizePath(path$$1);
    assertRoot(this.root).chownSync(path$$1, true, uid, gid);
};
/**
 * Asynchronous `chmod`.
 * @param path
 * @param mode
 * @param callback
 */
FS.prototype.chmod = function chmod (path$$1, mode, cb) {
        if ( cb === void 0 ) cb = nopCb;

    var newCb = wrapCb(cb, 1);
    try {
        var numMode = normalizeMode(mode, -1);
        if (numMode < 0) {
            throw new ApiError(ErrorCode.EINVAL, "Invalid mode.");
        }
        assertRoot(this.root).chmod(normalizePath(path$$1), false, numMode, newCb);
    }
    catch (e) {
        newCb(e);
    }
};
/**
 * Synchronous `chmod`.
 * @param path
 * @param mode
 */
FS.prototype.chmodSync = function chmodSync (path$$1, mode) {
    var numMode = normalizeMode(mode, -1);
    if (numMode < 0) {
        throw new ApiError(ErrorCode.EINVAL, "Invalid mode.");
    }
    path$$1 = normalizePath(path$$1);
    assertRoot(this.root).chmodSync(path$$1, false, numMode);
};
/**
 * Asynchronous `lchmod`.
 * @param path
 * @param mode
 * @param callback
 */
FS.prototype.lchmod = function lchmod (path$$1, mode, cb) {
        if ( cb === void 0 ) cb = nopCb;

    var newCb = wrapCb(cb, 1);
    try {
        var numMode = normalizeMode(mode, -1);
        if (numMode < 0) {
            throw new ApiError(ErrorCode.EINVAL, "Invalid mode.");
        }
        assertRoot(this.root).chmod(normalizePath(path$$1), true, numMode, newCb);
    }
    catch (e) {
        newCb(e);
    }
};
/**
 * Synchronous `lchmod`.
 * @param path
 * @param mode
 */
FS.prototype.lchmodSync = function lchmodSync (path$$1, mode) {
    var numMode = normalizeMode(mode, -1);
    if (numMode < 1) {
        throw new ApiError(ErrorCode.EINVAL, "Invalid mode.");
    }
    assertRoot(this.root).chmodSync(normalizePath(path$$1), true, numMode);
};
/**
 * Change file timestamps of the file referenced by the supplied path.
 * @param path
 * @param atime
 * @param mtime
 * @param callback
 */
FS.prototype.utimes = function utimes (path$$1, atime, mtime, cb) {
        if ( cb === void 0 ) cb = nopCb;

    var newCb = wrapCb(cb, 1);
    try {
        assertRoot(this.root).utimes(normalizePath(path$$1), normalizeTime(atime), normalizeTime(mtime), newCb);
    }
    catch (e) {
        newCb(e);
    }
};
/**
 * Change file timestamps of the file referenced by the supplied path.
 * @param path
 * @param atime
 * @param mtime
 */
FS.prototype.utimesSync = function utimesSync (path$$1, atime, mtime) {
    assertRoot(this.root).utimesSync(normalizePath(path$$1), normalizeTime(atime), normalizeTime(mtime));
};
FS.prototype.realpath = function realpath (path$$1, arg2, cb) {
        if ( cb === void 0 ) cb = nopCb;

    var cache = typeof (arg2) === 'object' ? arg2 : {};
    cb = typeof (arg2) === 'function' ? arg2 : nopCb;
    var newCb = wrapCb(cb, 2);
    try {
        path$$1 = normalizePath(path$$1);
        assertRoot(this.root).realpath(path$$1, cache, newCb);
    }
    catch (e) {
        newCb(e);
    }
};
/**
 * Synchronous `realpath`.
 * @param path
 * @param cache An object literal of mapped paths that can be used to
 *   force a specific path resolution or avoid additional `fs.stat` calls for
 *   known real paths.
 * @return [String]
 */
FS.prototype.realpathSync = function realpathSync (path$$1, cache) {
        if ( cache === void 0 ) cache = {};

    path$$1 = normalizePath(path$$1);
    return assertRoot(this.root).realpathSync(path$$1, cache);
};
FS.prototype.watchFile = function watchFile (filename, arg2, listener) {
        if ( listener === void 0 ) listener = nopCb;

    throw new ApiError(ErrorCode.ENOTSUP);
};
FS.prototype.unwatchFile = function unwatchFile (filename, listener) {
        if ( listener === void 0 ) listener = nopCb;

    throw new ApiError(ErrorCode.ENOTSUP);
};
FS.prototype.watch = function watch (filename, arg2, listener) {
        if ( listener === void 0 ) listener = nopCb;

    throw new ApiError(ErrorCode.ENOTSUP);
};
FS.prototype.access = function access (path$$1, arg2, cb) {
        if ( cb === void 0 ) cb = nopCb;

    throw new ApiError(ErrorCode.ENOTSUP);
};
FS.prototype.accessSync = function accessSync (path$$1, mode) {
    throw new ApiError(ErrorCode.ENOTSUP);
};
FS.prototype.createReadStream = function createReadStream (path$$1, options) {
    throw new ApiError(ErrorCode.ENOTSUP);
};
FS.prototype.createWriteStream = function createWriteStream (path$$1, options) {
    throw new ApiError(ErrorCode.ENOTSUP);
};
/**
 * For unit testing. Passes all incoming callbacks to cbWrapper for wrapping.
 */
FS.prototype.wrapCallbacks = function wrapCallbacks (cbWrapper) {
    wrapCb = cbWrapper;
};
FS.prototype.getFdForFile = function getFdForFile (file) {
    var fd = this.nextFd++;
    this.fdMap[fd] = file;
    return fd;
};
FS.prototype.fd2file = function fd2file (fd) {
    var rv = this.fdMap[fd];
    if (rv) {
        return rv;
    }
    else {
        throw new ApiError(ErrorCode.EBADF, 'Invalid file descriptor.');
    }
};
FS.prototype.closeFd = function closeFd (fd) {
    delete this.fdMap[fd];
};

/* tslint:disable:variable-name */
// Exported fs.Stats.
FS.Stats = Stats;

// Manually export the individual public functions of fs.
// Required because some code will invoke functions off of the module.
// e.g.:
// let writeFile = fs.writeFile;
// writeFile(...)
/**
 * @hidden
 */
var fs = new FS();
/**
 * @hidden
 */
var _fsMock = {};
/**
 * @hidden
 */
var fsProto = FS.prototype;
Object.keys(fsProto).forEach(function (key) {
    if (typeof fs[key] === 'function') {
        _fsMock[key] = function () {
            return fs[key].apply(fs, arguments);
        };
    }
    else {
        _fsMock[key] = fs[key];
    }
});
_fsMock['changeFSModule'] = function (newFs) {
    fs = newFs;
};
_fsMock['getFSModule'] = function () {
    return fs;
};
_fsMock['FS'] = FS;

/*
 * Levenshtein distance, from the `js-levenshtein` NPM module.
 * Copied here to avoid complexity of adding another CommonJS module dependency.
 */
function _min(d0, d1, d2, bx, ay) {
    return d0 < d1 || d2 < d1
        ? d0 > d2
            ? d2 + 1
            : d0 + 1
        : bx === ay
            ? d1
            : d1 + 1;
}
/**
 * Calculates levenshtein distance.
 * @param a
 * @param b
 */
function levenshtein(a, b) {
    if (a === b) {
        return 0;
    }
    if (a.length > b.length) {
        var tmp = a;
        a = b;
        b = tmp;
    }
    var la = a.length;
    var lb = b.length;
    while (la > 0 && (a.charCodeAt(la - 1) === b.charCodeAt(lb - 1))) {
        la--;
        lb--;
    }
    var offset = 0;
    while (offset < la && (a.charCodeAt(offset) === b.charCodeAt(offset))) {
        offset++;
    }
    la -= offset;
    lb -= offset;
    if (la === 0 || lb === 1) {
        return lb;
    }
    var vector = new Array(la << 1);
    for (var y = 0; y < la;) {
        vector[la + y] = a.charCodeAt(offset + y);
        vector[y] = ++y;
    }
    var x;
    var d0;
    var d1;
    var d2;
    var d3;
    for (x = 0; (x + 3) < lb;) {
        var bx0 = b.charCodeAt(offset + (d0 = x));
        var bx1 = b.charCodeAt(offset + (d1 = x + 1));
        var bx2 = b.charCodeAt(offset + (d2 = x + 2));
        var bx3 = b.charCodeAt(offset + (d3 = x + 3));
        var dd$1 = (x += 4);
        for (var y$1 = 0; y$1 < la;) {
            var ay = vector[la + y$1];
            var dy = vector[y$1];
            d0 = _min(dy, d0, d1, bx0, ay);
            d1 = _min(d0, d1, d2, bx1, ay);
            d2 = _min(d1, d2, d3, bx2, ay);
            dd$1 = _min(d2, d3, dd$1, bx3, ay);
            vector[y$1++] = dd$1;
            d3 = d2;
            d2 = d1;
            d1 = d0;
            d0 = dy;
        }
    }
    var dd = 0;
    for (; x < lb;) {
        var bx0$1 = b.charCodeAt(offset + (d0 = x));
        dd = ++x;
        for (var y$2 = 0; y$2 < la; y$2++) {
            var dy$1 = vector[y$2];
            vector[y$2] = dd = dy$1 < d0 || dd < d0
                ? dy$1 > dd ? dd + 1 : dy$1 + 1
                : bx0$1 === vector[la + y$2]
                    ? d0
                    : d0 + 1;
            d0 = dy$1;
        }
    }
    return dd;
}

function deprecationMessage(print, fsName, opts) {
    if (print) {
        // tslint:disable-next-line:no-console
        console.warn(("[" + fsName + "] Direct file system constructor usage is deprecated for this file system, and will be removed in the next major version. Please use the '" + fsName + ".Create(" + (JSON.stringify(opts)) + ", callback)' method instead. See https://github.com/jvilk/BrowserFS/issues/176 for more details."));
        // tslint:enable-next-line:no-console
    }
}
/**
 * Checks for any IE version, including IE11 which removed MSIE from the
 * userAgent string.
 * @hidden
 */
var isIE = typeof navigator !== "undefined" && !!(/(msie) ([\w.]+)/.exec(navigator.userAgent.toLowerCase()) || navigator.userAgent.indexOf('Trident') !== -1);
/**
 * Check if we're in a web worker.
 * @hidden
 */
var isWebWorker = typeof window === "undefined";
/**
 * Throws an exception. Called on code paths that should be impossible.
 * @hidden
 */
function fail() {
    throw new Error("BFS has reached an impossible code path; please file a bug.");
}
/**
 * Synchronous recursive makedir.
 * @hidden
 */
function mkdirpSync(p, mode, fs) {
    if (!fs.existsSync(p)) {
        mkdirpSync(path.dirname(p), mode, fs);
        fs.mkdirSync(p, mode);
    }
}
/**
 * Converts a buffer into an array buffer. Attempts to do so in a
 * zero-copy manner, e.g. the array references the same memory.
 * @hidden
 */
function buffer2ArrayBuffer(buff) {
    var u8 = buffer2Uint8array(buff), u8offset = u8.byteOffset, u8Len = u8.byteLength;
    if (u8offset === 0 && u8Len === u8.buffer.byteLength) {
        return u8.buffer;
    }
    else {
        return u8.buffer.slice(u8offset, u8offset + u8Len);
    }
}
/**
 * Converts a buffer into a Uint8Array. Attempts to do so in a
 * zero-copy manner, e.g. the array references the same memory.
 * @hidden
 */
function buffer2Uint8array(buff) {
    if (buff instanceof Uint8Array) {
        // BFS & Node v4.0 buffers *are* Uint8Arrays.
        return buff;
    }
    else {
        // Uint8Arrays can be constructed from arrayish numbers.
        // At this point, we assume this isn't a BFS array.
        return new Uint8Array(buff);
    }
}
/**
 * Converts the given arrayish object into a Buffer. Attempts to
 * be zero-copy.
 * @hidden
 */
function arrayish2Buffer(arr) {
    if (arr instanceof Buffer) {
        return arr;
    }
    else if (arr instanceof Uint8Array) {
        return uint8Array2Buffer(arr);
    }
    else {
        return Buffer.from(arr);
    }
}
/**
 * Converts the given Uint8Array into a Buffer. Attempts to be zero-copy.
 * @hidden
 */
function uint8Array2Buffer(u8) {
    if (u8 instanceof Buffer) {
        return u8;
    }
    else if (u8.byteOffset === 0 && u8.byteLength === u8.buffer.byteLength) {
        return arrayBuffer2Buffer(u8.buffer);
    }
    else {
        return Buffer.from(u8.buffer, u8.byteOffset, u8.byteLength);
    }
}
/**
 * Converts the given array buffer into a Buffer. Attempts to be
 * zero-copy.
 * @hidden
 */
function arrayBuffer2Buffer(ab) {
    return Buffer.from(ab);
}
/**
 * Copies a slice of the given buffer
 * @hidden
 */
function copyingSlice(buff, start, end) {
    if ( start === void 0 ) start = 0;
    if ( end === void 0 ) end = buff.length;

    if (start < 0 || end < 0 || end > buff.length || start > end) {
        throw new TypeError(("Invalid slice bounds on buffer of length " + (buff.length) + ": [" + start + ", " + end + "]"));
    }
    if (buff.length === 0) {
        // Avoid s0 corner case in ArrayBuffer case.
        return emptyBuffer();
    }
    else {
        var u8 = buffer2Uint8array(buff), s0 = buff[0], newS0 = (s0 + 1) % 0xFF;
        buff[0] = newS0;
        if (u8[0] === newS0) {
            // Same memory. Revert & copy.
            u8[0] = s0;
            return uint8Array2Buffer(u8.slice(start, end));
        }
        else {
            // Revert.
            buff[0] = s0;
            return uint8Array2Buffer(u8.subarray(start, end));
        }
    }
}
/**
 * @hidden
 */
var emptyBuff = null;
/**
 * Returns an empty buffer.
 * @hidden
 */
function emptyBuffer() {
    if (emptyBuff) {
        return emptyBuff;
    }
    return emptyBuff = Buffer.alloc(0);
}
/**
 * Option validator for a Buffer file system option.
 * @hidden
 */
function bufferValidator(v, cb) {
    if (Buffer.isBuffer(v)) {
        cb();
    }
    else {
        cb(new ApiError(ErrorCode.EINVAL, "option must be a Buffer."));
    }
}
/**
 * Checks that the given options object is valid for the file system options.
 * @hidden
 */
function checkOptions(fsType, opts, cb) {
    var optsInfo = fsType.Options;
    var fsName = fsType.Name;
    var pendingValidators = 0;
    var callbackCalled = false;
    var loopEnded = false;
    function validatorCallback(e) {
        if (!callbackCalled) {
            if (e) {
                callbackCalled = true;
                cb(e);
            }
            pendingValidators--;
            if (pendingValidators === 0 && loopEnded) {
                cb();
            }
        }
    }
    // Check for required options.
    var loop = function ( optName ) {
        if (optsInfo.hasOwnProperty(optName)) {
            var opt = optsInfo[optName];
            var providedValue = opts[optName];
            if (providedValue === undefined || providedValue === null) {
                if (!opt.optional) {
                    // Required option, not provided.
                    // Any incorrect options provided? Which ones are close to the provided one?
                    // (edit distance 5 === close)
                    var incorrectOptions = Object.keys(opts).filter(function (o) { return !(o in optsInfo); }).map(function (a) {
                        return { str: a, distance: levenshtein(optName, a) };
                    }).filter(function (o) { return o.distance < 5; }).sort(function (a, b) { return a.distance - b.distance; });
                    // Validators may be synchronous.
                    if (callbackCalled) {
                        return {};
                    }
                    callbackCalled = true;
                    return { v: cb(new ApiError(ErrorCode.EINVAL, ("[" + fsName + "] Required option '" + optName + "' not provided." + (incorrectOptions.length > 0 ? (" You provided unrecognized option '" + (incorrectOptions[0].str) + "'; perhaps you meant to type '" + optName + "'.") : '') + "\nOption description: " + (opt.description)))) };
                }
                // Else: Optional option, not provided. That is OK.
            }
            else {
                // Option provided! Check type.
                var typeMatches = false;
                if (Array.isArray(opt.type)) {
                    typeMatches = opt.type.indexOf(typeof (providedValue)) !== -1;
                }
                else {
                    typeMatches = typeof (providedValue) === opt.type;
                }
                if (!typeMatches) {
                    // Validators may be synchronous.
                    if (callbackCalled) {
                        return {};
                    }
                    callbackCalled = true;
                    return { v: cb(new ApiError(ErrorCode.EINVAL, ("[" + fsName + "] Value provided for option " + optName + " is not the proper type. Expected " + (Array.isArray(opt.type) ? ("one of {" + (opt.type.join(", ")) + "}") : opt.type) + ", but received " + (typeof (providedValue)) + "\nOption description: " + (opt.description)))) };
                }
                else if (opt.validator) {
                    pendingValidators++;
                    opt.validator(providedValue, validatorCallback);
                }
                // Otherwise: All good!
            }
        }
    };

    for (var optName in optsInfo) {
        var returned = loop( optName );

        if ( returned ) return returned.v;
    }
    loopEnded = true;
    if (pendingValidators === 0 && !callbackCalled) {
        cb();
    }
}


var BFSUtils = Object.freeze({
	deprecationMessage: deprecationMessage,
	isIE: isIE,
	isWebWorker: isWebWorker,
	fail: fail,
	mkdirpSync: mkdirpSync,
	buffer2ArrayBuffer: buffer2ArrayBuffer,
	buffer2Uint8array: buffer2Uint8array,
	arrayish2Buffer: arrayish2Buffer,
	uint8Array2Buffer: uint8Array2Buffer,
	arrayBuffer2Buffer: arrayBuffer2Buffer,
	copyingSlice: copyingSlice,
	emptyBuffer: emptyBuffer,
	bufferValidator: bufferValidator,
	checkOptions: checkOptions
});

var BFSEmscriptenStreamOps = function BFSEmscriptenStreamOps(fs) {
    this.fs = fs;
    this.nodefs = fs.getNodeFS();
    this.FS = fs.getFS();
    this.PATH = fs.getPATH();
    this.ERRNO_CODES = fs.getERRNO_CODES();
};
BFSEmscriptenStreamOps.prototype.open = function open (stream) {
    var path$$1 = this.fs.realPath(stream.node);
    var FS = this.FS;
    try {
        if (FS.isFile(stream.node.mode)) {
            stream.nfd = this.nodefs.openSync(path$$1, this.fs.flagsToPermissionString(stream.flags));
        }
    }
    catch (e) {
        if (!e.code) {
            throw e;
        }
        throw new FS.ErrnoError(this.ERRNO_CODES[e.code]);
    }
};
BFSEmscriptenStreamOps.prototype.close = function close (stream) {
    var FS = this.FS;
    try {
        if (FS.isFile(stream.node.mode) && stream.nfd) {
            this.nodefs.closeSync(stream.nfd);
        }
    }
    catch (e) {
        if (!e.code) {
            throw e;
        }
        throw new FS.ErrnoError(this.ERRNO_CODES[e.code]);
    }
};
BFSEmscriptenStreamOps.prototype.read = function read (stream, buffer$$1, offset, length, position) {
    // Avoid copying overhead by reading directly into buffer.
    try {
        return this.nodefs.readSync(stream.nfd, uint8Array2Buffer(buffer$$1), offset, length, position);
    }
    catch (e) {
        throw new this.FS.ErrnoError(this.ERRNO_CODES[e.code]);
    }
};
BFSEmscriptenStreamOps.prototype.write = function write (stream, buffer$$1, offset, length, position) {
    // Avoid copying overhead.
    try {
        return this.nodefs.writeSync(stream.nfd, uint8Array2Buffer(buffer$$1), offset, length, position);
    }
    catch (e) {
        throw new this.FS.ErrnoError(this.ERRNO_CODES[e.code]);
    }
};
BFSEmscriptenStreamOps.prototype.llseek = function llseek (stream, offset, whence) {
    var position = offset;
    if (whence === 1) {
        position += stream.position;
    }
    else if (whence === 2) {
        if (this.FS.isFile(stream.node.mode)) {
            try {
                var stat = this.nodefs.fstatSync(stream.nfd);
                position += stat.size;
            }
            catch (e) {
                throw new this.FS.ErrnoError(this.ERRNO_CODES[e.code]);
            }
        }
    }
    if (position < 0) {
        throw new this.FS.ErrnoError(this.ERRNO_CODES.EINVAL);
    }
    stream.position = position;
    return position;
};
var BFSEmscriptenNodeOps = function BFSEmscriptenNodeOps(fs) {
    this.fs = fs;
    this.nodefs = fs.getNodeFS();
    this.FS = fs.getFS();
    this.PATH = fs.getPATH();
    this.ERRNO_CODES = fs.getERRNO_CODES();
};
BFSEmscriptenNodeOps.prototype.getattr = function getattr (node) {
    var path$$1 = this.fs.realPath(node);
    var stat;
    try {
        stat = this.nodefs.lstatSync(path$$1);
    }
    catch (e) {
        if (!e.code) {
            throw e;
        }
        throw new this.FS.ErrnoError(this.ERRNO_CODES[e.code]);
    }
    return {
        dev: stat.dev,
        ino: stat.ino,
        mode: stat.mode,
        nlink: stat.nlink,
        uid: stat.uid,
        gid: stat.gid,
        rdev: stat.rdev,
        size: stat.size,
        atime: stat.atime,
        mtime: stat.mtime,
        ctime: stat.ctime,
        blksize: stat.blksize,
        blocks: stat.blocks
    };
};
BFSEmscriptenNodeOps.prototype.setattr = function setattr (node, attr) {
    var path$$1 = this.fs.realPath(node);
    try {
        if (attr.mode !== undefined) {
            this.nodefs.chmodSync(path$$1, attr.mode);
            // update the common node structure mode as well
            node.mode = attr.mode;
        }
        if (attr.timestamp !== undefined) {
            var date = new Date(attr.timestamp);
            this.nodefs.utimesSync(path$$1, date, date);
        }
    }
    catch (e) {
        if (!e.code) {
            throw e;
        }
        // Ignore not supported errors. Emscripten does utimesSync when it
        // writes files, but never really requires the value to be set.
        if (e.code !== "ENOTSUP") {
            throw new this.FS.ErrnoError(this.ERRNO_CODES[e.code]);
        }
    }
    if (attr.size !== undefined) {
        try {
            this.nodefs.truncateSync(path$$1, attr.size);
        }
        catch (e) {
            if (!e.code) {
                throw e;
            }
            throw new this.FS.ErrnoError(this.ERRNO_CODES[e.code]);
        }
    }
};
BFSEmscriptenNodeOps.prototype.lookup = function lookup (parent, name) {
    var path$$1 = this.PATH.join2(this.fs.realPath(parent), name);
    var mode = this.fs.getMode(path$$1);
    return this.fs.createNode(parent, name, mode);
};
BFSEmscriptenNodeOps.prototype.mknod = function mknod (parent, name, mode, dev) {
    var node = this.fs.createNode(parent, name, mode, dev);
    // create the backing node for this in the fs root as well
    var path$$1 = this.fs.realPath(node);
    try {
        if (this.FS.isDir(node.mode)) {
            this.nodefs.mkdirSync(path$$1, node.mode);
        }
        else {
            this.nodefs.writeFileSync(path$$1, '', { mode: node.mode });
        }
    }
    catch (e) {
        if (!e.code) {
            throw e;
        }
        throw new this.FS.ErrnoError(this.ERRNO_CODES[e.code]);
    }
    return node;
};
BFSEmscriptenNodeOps.prototype.rename = function rename (oldNode, newDir, newName) {
    var oldPath = this.fs.realPath(oldNode);
    var newPath = this.PATH.join2(this.fs.realPath(newDir), newName);
    try {
        this.nodefs.renameSync(oldPath, newPath);
        // This logic is missing from the original NodeFS,
        // causing Emscripten's filesystem to think that the old file still exists.
        oldNode.name = newName;
        oldNode.parent = newDir;
    }
    catch (e) {
        if (!e.code) {
            throw e;
        }
        throw new this.FS.ErrnoError(this.ERRNO_CODES[e.code]);
    }
};
BFSEmscriptenNodeOps.prototype.unlink = function unlink (parent, name) {
    var path$$1 = this.PATH.join2(this.fs.realPath(parent), name);
    try {
        this.nodefs.unlinkSync(path$$1);
    }
    catch (e) {
        if (!e.code) {
            throw e;
        }
        throw new this.FS.ErrnoError(this.ERRNO_CODES[e.code]);
    }
};
BFSEmscriptenNodeOps.prototype.rmdir = function rmdir (parent, name) {
    var path$$1 = this.PATH.join2(this.fs.realPath(parent), name);
    try {
        this.nodefs.rmdirSync(path$$1);
    }
    catch (e) {
        if (!e.code) {
            throw e;
        }
        throw new this.FS.ErrnoError(this.ERRNO_CODES[e.code]);
    }
};
BFSEmscriptenNodeOps.prototype.readdir = function readdir (node) {
    var path$$1 = this.fs.realPath(node);
    try {
        // Node does not list . and .. in directory listings,
        // but Emscripten expects it.
        var contents = this.nodefs.readdirSync(path$$1);
        contents.push('.', '..');
        return contents;
    }
    catch (e) {
        if (!e.code) {
            throw e;
        }
        throw new this.FS.ErrnoError(this.ERRNO_CODES[e.code]);
    }
};
BFSEmscriptenNodeOps.prototype.symlink = function symlink (parent, newName, oldPath) {
    var newPath = this.PATH.join2(this.fs.realPath(parent), newName);
    try {
        this.nodefs.symlinkSync(oldPath, newPath);
    }
    catch (e) {
        if (!e.code) {
            throw e;
        }
        throw new this.FS.ErrnoError(this.ERRNO_CODES[e.code]);
    }
};
BFSEmscriptenNodeOps.prototype.readlink = function readlink (node) {
    var path$$1 = this.fs.realPath(node);
    try {
        return this.nodefs.readlinkSync(path$$1);
    }
    catch (e) {
        if (!e.code) {
            throw e;
        }
        throw new this.FS.ErrnoError(this.ERRNO_CODES[e.code]);
    }
};
var BFSEmscriptenFS = function BFSEmscriptenFS(_FS, _PATH, _ERRNO_CODES, nodefs) {
    if ( _FS === void 0 ) _FS = self['FS'];
    if ( _PATH === void 0 ) _PATH = self['PATH'];
    if ( _ERRNO_CODES === void 0 ) _ERRNO_CODES = self['ERRNO_CODES'];
    if ( nodefs === void 0 ) nodefs = _fsMock;

    // This maps the integer permission modes from http://linux.die.net/man/3/open
    // to node.js-specific file open permission strings at http://nodejs.org/api/fs.html#fs_fs_open_path_flags_mode_callback
    this.flagsToPermissionStringMap = {
        0 /*O_RDONLY*/: 'r',
        1 /*O_WRONLY*/: 'r+',
        2 /*O_RDWR*/: 'r+',
        64 /*O_CREAT*/: 'r',
        65 /*O_WRONLY|O_CREAT*/: 'r+',
        66 /*O_RDWR|O_CREAT*/: 'r+',
        129 /*O_WRONLY|O_EXCL*/: 'rx+',
        193 /*O_WRONLY|O_CREAT|O_EXCL*/: 'rx+',
        514 /*O_RDWR|O_TRUNC*/: 'w+',
        577 /*O_WRONLY|O_CREAT|O_TRUNC*/: 'w',
        578 /*O_CREAT|O_RDWR|O_TRUNC*/: 'w+',
        705 /*O_WRONLY|O_CREAT|O_EXCL|O_TRUNC*/: 'wx',
        706 /*O_RDWR|O_CREAT|O_EXCL|O_TRUNC*/: 'wx+',
        1024 /*O_APPEND*/: 'a',
        1025 /*O_WRONLY|O_APPEND*/: 'a',
        1026 /*O_RDWR|O_APPEND*/: 'a+',
        1089 /*O_WRONLY|O_CREAT|O_APPEND*/: 'a',
        1090 /*O_RDWR|O_CREAT|O_APPEND*/: 'a+',
        1153 /*O_WRONLY|O_EXCL|O_APPEND*/: 'ax',
        1154 /*O_RDWR|O_EXCL|O_APPEND*/: 'ax+',
        1217 /*O_WRONLY|O_CREAT|O_EXCL|O_APPEND*/: 'ax',
        1218 /*O_RDWR|O_CREAT|O_EXCL|O_APPEND*/: 'ax+',
        4096 /*O_RDONLY|O_DSYNC*/: 'rs',
        4098 /*O_RDWR|O_DSYNC*/: 'rs+'
    };
    this.nodefs = nodefs;
    this.FS = _FS;
    this.PATH = _PATH;
    this.ERRNO_CODES = _ERRNO_CODES;
    this.node_ops = new BFSEmscriptenNodeOps(this);
    this.stream_ops = new BFSEmscriptenStreamOps(this);
};
BFSEmscriptenFS.prototype.mount = function mount (m) {
    return this.createNode(null, '/', this.getMode(m.opts.root), 0);
};
BFSEmscriptenFS.prototype.createNode = function createNode (parent, name, mode, dev) {
    var FS = this.FS;
    if (!FS.isDir(mode) && !FS.isFile(mode) && !FS.isLink(mode)) {
        throw new FS.ErrnoError(this.ERRNO_CODES.EINVAL);
    }
    var node = FS.createNode(parent, name, mode);
    node.node_ops = this.node_ops;
    node.stream_ops = this.stream_ops;
    return node;
};
BFSEmscriptenFS.prototype.getMode = function getMode (path$$1) {
    var stat;
    try {
        stat = this.nodefs.lstatSync(path$$1);
    }
    catch (e) {
        if (!e.code) {
            throw e;
        }
        throw new this.FS.ErrnoError(this.ERRNO_CODES[e.code]);
    }
    return stat.mode;
};
BFSEmscriptenFS.prototype.realPath = function realPath (node) {
    var parts = [];
    while (node.parent !== node) {
        parts.push(node.name);
        node = node.parent;
    }
    parts.push(node.mount.opts.root);
    parts.reverse();
    return this.PATH.join.apply(null, parts);
};
BFSEmscriptenFS.prototype.flagsToPermissionString = function flagsToPermissionString (flags) {
    var parsedFlags = (typeof flags === "string") ? parseInt(flags, 10) : flags;
    parsedFlags &= 0x1FFF;
    if (parsedFlags in this.flagsToPermissionStringMap) {
        return this.flagsToPermissionStringMap[parsedFlags];
    }
    else {
        return flags;
    }
};
BFSEmscriptenFS.prototype.getNodeFS = function getNodeFS () {
    return this.nodefs;
};
BFSEmscriptenFS.prototype.getFS = function getFS () {
    return this.FS;
};
BFSEmscriptenFS.prototype.getPATH = function getPATH () {
    return this.PATH;
};
BFSEmscriptenFS.prototype.getERRNO_CODES = function getERRNO_CODES () {
    return this.ERRNO_CODES;
};

/**
 * Basic filesystem class. Most filesystems should extend this class, as it
 * provides default implementations for a handful of methods.
 */
var BaseFileSystem = function BaseFileSystem () {};

BaseFileSystem.prototype.supportsLinks = function supportsLinks () {
    return false;
};
BaseFileSystem.prototype.diskSpace = function diskSpace (p, cb) {
    cb(0, 0);
};
/**
 * Opens the file at path p with the given flag. The file must exist.
 * @param p The path to open.
 * @param flag The flag to use when opening the file.
 */
BaseFileSystem.prototype.openFile = function openFile (p, flag, cb) {
    throw new ApiError(ErrorCode.ENOTSUP);
};
/**
 * Create the file at path p with the given mode. Then, open it with the given
 * flag.
 */
BaseFileSystem.prototype.createFile = function createFile (p, flag, mode, cb) {
    throw new ApiError(ErrorCode.ENOTSUP);
};
BaseFileSystem.prototype.open = function open (p, flag, mode, cb) {
        var this$1 = this;

    var mustBeFile = function (e, stats) {
        if (e) {
            // File does not exist.
            switch (flag.pathNotExistsAction()) {
                case ActionType.CREATE_FILE:
                    // Ensure parent exists.
                    return this$1.stat(path.dirname(p), false, function (e, parentStats) {
                        if (e) {
                            cb(e);
                        }
                        else if (parentStats && !parentStats.isDirectory()) {
                            cb(ApiError.ENOTDIR(path.dirname(p)));
                        }
                        else {
                            this$1.createFile(p, flag, mode, cb);
                        }
                    });
                case ActionType.THROW_EXCEPTION:
                    return cb(ApiError.ENOENT(p));
                default:
                    return cb(new ApiError(ErrorCode.EINVAL, 'Invalid FileFlag object.'));
            }
        }
        else {
            // File exists.
            if (stats && stats.isDirectory()) {
                return cb(ApiError.EISDIR(p));
            }
            switch (flag.pathExistsAction()) {
                case ActionType.THROW_EXCEPTION:
                    return cb(ApiError.EEXIST(p));
                case ActionType.TRUNCATE_FILE:
                    // NOTE: In a previous implementation, we deleted the file and
                    // re-created it. However, this created a race condition if another
                    // asynchronous request was trying to read the file, as the file
                    // would not exist for a small period of time.
                    return this$1.openFile(p, flag, function (e, fd) {
                        if (e) {
                            cb(e);
                        }
                        else if (fd) {
                            fd.truncate(0, function () {
                                fd.sync(function () {
                                    cb(null, fd);
                                });
                            });
                        }
                        else {
                            fail();
                        }
                    });
                case ActionType.NOP:
                    return this$1.openFile(p, flag, cb);
                default:
                    return cb(new ApiError(ErrorCode.EINVAL, 'Invalid FileFlag object.'));
            }
        }
    };
    this.stat(p, false, mustBeFile);
};
BaseFileSystem.prototype.rename = function rename (oldPath, newPath, cb) {
    cb(new ApiError(ErrorCode.ENOTSUP));
};
BaseFileSystem.prototype.renameSync = function renameSync (oldPath, newPath) {
    throw new ApiError(ErrorCode.ENOTSUP);
};
BaseFileSystem.prototype.stat = function stat (p, isLstat, cb) {
    cb(new ApiError(ErrorCode.ENOTSUP));
};
BaseFileSystem.prototype.statSync = function statSync (p, isLstat) {
    throw new ApiError(ErrorCode.ENOTSUP);
};
/**
 * Opens the file at path p with the given flag. The file must exist.
 * @param p The path to open.
 * @param flag The flag to use when opening the file.
 * @return A File object corresponding to the opened file.
 */
BaseFileSystem.prototype.openFileSync = function openFileSync (p, flag, mode) {
    throw new ApiError(ErrorCode.ENOTSUP);
};
/**
 * Create the file at path p with the given mode. Then, open it with the given
 * flag.
 */
BaseFileSystem.prototype.createFileSync = function createFileSync (p, flag, mode) {
    throw new ApiError(ErrorCode.ENOTSUP);
};
BaseFileSystem.prototype.openSync = function openSync (p, flag, mode) {
    // Check if the path exists, and is a file.
    var stats;
    try {
        stats = this.statSync(p, false);
    }
    catch (e) {
        // File does not exist.
        switch (flag.pathNotExistsAction()) {
            case ActionType.CREATE_FILE:
                // Ensure parent exists.
                var parentStats = this.statSync(path.dirname(p), false);
                if (!parentStats.isDirectory()) {
                    throw ApiError.ENOTDIR(path.dirname(p));
                }
                return this.createFileSync(p, flag, mode);
            case ActionType.THROW_EXCEPTION:
                throw ApiError.ENOENT(p);
            default:
                throw new ApiError(ErrorCode.EINVAL, 'Invalid FileFlag object.');
        }
    }
    // File exists.
    if (stats.isDirectory()) {
        throw ApiError.EISDIR(p);
    }
    switch (flag.pathExistsAction()) {
        case ActionType.THROW_EXCEPTION:
            throw ApiError.EEXIST(p);
        case ActionType.TRUNCATE_FILE:
            // Delete file.
            this.unlinkSync(p);
            // Create file. Use the same mode as the old file.
            // Node itself modifies the ctime when this occurs, so this action
            // will preserve that behavior if the underlying file system
            // supports those properties.
            return this.createFileSync(p, flag, stats.mode);
        case ActionType.NOP:
            return this.openFileSync(p, flag, mode);
        default:
            throw new ApiError(ErrorCode.EINVAL, 'Invalid FileFlag object.');
    }
};
BaseFileSystem.prototype.unlink = function unlink (p, cb) {
    cb(new ApiError(ErrorCode.ENOTSUP));
};
BaseFileSystem.prototype.unlinkSync = function unlinkSync (p) {
    throw new ApiError(ErrorCode.ENOTSUP);
};
BaseFileSystem.prototype.rmdir = function rmdir (p, cb) {
    cb(new ApiError(ErrorCode.ENOTSUP));
};
BaseFileSystem.prototype.rmdirSync = function rmdirSync (p) {
    throw new ApiError(ErrorCode.ENOTSUP);
};
BaseFileSystem.prototype.mkdir = function mkdir (p, mode, cb) {
    cb(new ApiError(ErrorCode.ENOTSUP));
};
BaseFileSystem.prototype.mkdirSync = function mkdirSync (p, mode) {
    throw new ApiError(ErrorCode.ENOTSUP);
};
BaseFileSystem.prototype.readdir = function readdir (p, cb) {
    cb(new ApiError(ErrorCode.ENOTSUP));
};
BaseFileSystem.prototype.readdirSync = function readdirSync (p) {
    throw new ApiError(ErrorCode.ENOTSUP);
};
BaseFileSystem.prototype.exists = function exists (p, cb) {
    this.stat(p, null, function (err) {
        cb(!err);
    });
};
BaseFileSystem.prototype.existsSync = function existsSync (p) {
    try {
        this.statSync(p, true);
        return true;
    }
    catch (e) {
        return false;
    }
};
BaseFileSystem.prototype.realpath = function realpath (p, cache, cb) {
    if (this.supportsLinks()) {
        // The path could contain symlinks. Split up the path,
        // resolve any symlinks, return the resolved string.
        var splitPath = p.split(path.sep);
        // TODO: Simpler to just pass through file, find sep and such.
        for (var i = 0; i < splitPath.length; i++) {
            var addPaths = splitPath.slice(0, i + 1);
            splitPath[i] = path.join.apply(null, addPaths);
        }
    }
    else {
        // No symlinks. We just need to verify that it exists.
        this.exists(p, function (doesExist) {
            if (doesExist) {
                cb(null, p);
            }
            else {
                cb(ApiError.ENOENT(p));
            }
        });
    }
};
BaseFileSystem.prototype.realpathSync = function realpathSync (p, cache) {
    if (this.supportsLinks()) {
        // The path could contain symlinks. Split up the path,
        // resolve any symlinks, return the resolved string.
        var splitPath = p.split(path.sep);
        // TODO: Simpler to just pass through file, find sep and such.
        for (var i = 0; i < splitPath.length; i++) {
            var addPaths = splitPath.slice(0, i + 1);
            splitPath[i] = path.join.apply(path, addPaths);
        }
        return splitPath.join(path.sep);
    }
    else {
        // No symlinks. We just need to verify that it exists.
        if (this.existsSync(p)) {
            return p;
        }
        else {
            throw ApiError.ENOENT(p);
        }
    }
};
BaseFileSystem.prototype.truncate = function truncate (p, len, cb) {
    this.open(p, FileFlag.getFileFlag('r+'), 0x1a4, (function (er, fd) {
        if (er) {
            return cb(er);
        }
        fd.truncate(len, (function (er) {
            fd.close((function (er2) {
                cb(er || er2);
            }));
        }));
    }));
};
BaseFileSystem.prototype.truncateSync = function truncateSync (p, len) {
    var fd = this.openSync(p, FileFlag.getFileFlag('r+'), 0x1a4);
    // Need to safely close FD, regardless of whether or not truncate succeeds.
    try {
        fd.truncateSync(len);
    }
    catch (e) {
        throw e;
    }
    finally {
        fd.closeSync();
    }
};
BaseFileSystem.prototype.readFile = function readFile (fname, encoding, flag, cb) {
    // Wrap cb in file closing code.
    var oldCb = cb;
    // Get file.
    this.open(fname, flag, 0x1a4, function (err, fd) {
        if (err) {
            return cb(err);
        }
        cb = function (err, arg) {
            fd.close(function (err2) {
                if (!err) {
                    err = err2;
                }
                return oldCb(err, arg);
            });
        };
        fd.stat(function (err, stat) {
            if (err) {
                return cb(err);
            }
            // Allocate buffer.
            var buf = Buffer.alloc(stat.size);
            fd.read(buf, 0, stat.size, 0, function (err) {
                if (err) {
                    return cb(err);
                }
                else if (encoding === null) {
                    return cb(err, buf);
                }
                try {
                    cb(null, buf.toString(encoding));
                }
                catch (e) {
                    cb(e);
                }
            });
        });
    });
};
BaseFileSystem.prototype.readFileSync = function readFileSync (fname, encoding, flag) {
    // Get file.
    var fd = this.openSync(fname, flag, 0x1a4);
    try {
        var stat = fd.statSync();
        // Allocate buffer.
        var buf = Buffer.alloc(stat.size);
        fd.readSync(buf, 0, stat.size, 0);
        fd.closeSync();
        if (encoding === null) {
            return buf;
        }
        return buf.toString(encoding);
    }
    finally {
        fd.closeSync();
    }
};
BaseFileSystem.prototype.writeFile = function writeFile (fname, data, encoding, flag, mode, cb) {
    // Wrap cb in file closing code.
    var oldCb = cb;
    // Get file.
    this.open(fname, flag, 0x1a4, function (err, fd) {
        if (err) {
            return cb(err);
        }
        cb = function (err) {
            fd.close(function (err2) {
                oldCb(err ? err : err2);
            });
        };
        try {
            if (typeof data === 'string') {
                data = Buffer.from(data, encoding);
            }
        }
        catch (e) {
            return cb(e);
        }
        // Write into file.
        fd.write(data, 0, data.length, 0, cb);
    });
};
BaseFileSystem.prototype.writeFileSync = function writeFileSync (fname, data, encoding, flag, mode) {
    // Get file.
    var fd = this.openSync(fname, flag, mode);
    try {
        if (typeof data === 'string') {
            data = Buffer.from(data, encoding);
        }
        // Write into file.
        fd.writeSync(data, 0, data.length, 0);
    }
    finally {
        fd.closeSync();
    }
};
BaseFileSystem.prototype.appendFile = function appendFile (fname, data, encoding, flag, mode, cb) {
    // Wrap cb in file closing code.
    var oldCb = cb;
    this.open(fname, flag, mode, function (err, fd) {
        if (err) {
            return cb(err);
        }
        cb = function (err) {
            fd.close(function (err2) {
                oldCb(err ? err : err2);
            });
        };
        if (typeof data === 'string') {
            data = Buffer.from(data, encoding);
        }
        fd.write(data, 0, data.length, null, cb);
    });
};
BaseFileSystem.prototype.appendFileSync = function appendFileSync (fname, data, encoding, flag, mode) {
    var fd = this.openSync(fname, flag, mode);
    try {
        if (typeof data === 'string') {
            data = Buffer.from(data, encoding);
        }
        fd.writeSync(data, 0, data.length, null);
    }
    finally {
        fd.closeSync();
    }
};
BaseFileSystem.prototype.chmod = function chmod (p, isLchmod, mode, cb) {
    cb(new ApiError(ErrorCode.ENOTSUP));
};
BaseFileSystem.prototype.chmodSync = function chmodSync (p, isLchmod, mode) {
    throw new ApiError(ErrorCode.ENOTSUP);
};
BaseFileSystem.prototype.chown = function chown (p, isLchown, uid, gid, cb) {
    cb(new ApiError(ErrorCode.ENOTSUP));
};
BaseFileSystem.prototype.chownSync = function chownSync (p, isLchown, uid, gid) {
    throw new ApiError(ErrorCode.ENOTSUP);
};
BaseFileSystem.prototype.utimes = function utimes (p, atime, mtime, cb) {
    cb(new ApiError(ErrorCode.ENOTSUP));
};
BaseFileSystem.prototype.utimesSync = function utimesSync (p, atime, mtime) {
    throw new ApiError(ErrorCode.ENOTSUP);
};
BaseFileSystem.prototype.link = function link (srcpath, dstpath, cb) {
    cb(new ApiError(ErrorCode.ENOTSUP));
};
BaseFileSystem.prototype.linkSync = function linkSync (srcpath, dstpath) {
    throw new ApiError(ErrorCode.ENOTSUP);
};
BaseFileSystem.prototype.symlink = function symlink (srcpath, dstpath, type, cb) {
    cb(new ApiError(ErrorCode.ENOTSUP));
};
BaseFileSystem.prototype.symlinkSync = function symlinkSync (srcpath, dstpath, type) {
    throw new ApiError(ErrorCode.ENOTSUP);
};
BaseFileSystem.prototype.readlink = function readlink (p, cb) {
    cb(new ApiError(ErrorCode.ENOTSUP));
};
BaseFileSystem.prototype.readlinkSync = function readlinkSync (p) {
    throw new ApiError(ErrorCode.ENOTSUP);
};
/**
 * Implements the asynchronous API in terms of the synchronous API.
 * @class SynchronousFileSystem
 */
var SynchronousFileSystem = (function (BaseFileSystem) {
    function SynchronousFileSystem () {
        BaseFileSystem.apply(this, arguments);
    }

    if ( BaseFileSystem ) SynchronousFileSystem.__proto__ = BaseFileSystem;
    SynchronousFileSystem.prototype = Object.create( BaseFileSystem && BaseFileSystem.prototype );
    SynchronousFileSystem.prototype.constructor = SynchronousFileSystem;

    SynchronousFileSystem.prototype.supportsSynch = function supportsSynch () {
        return true;
    };
    SynchronousFileSystem.prototype.rename = function rename (oldPath, newPath, cb) {
        try {
            this.renameSync(oldPath, newPath);
            cb();
        }
        catch (e) {
            cb(e);
        }
    };
    SynchronousFileSystem.prototype.stat = function stat (p, isLstat, cb) {
        try {
            cb(null, this.statSync(p, isLstat));
        }
        catch (e) {
            cb(e);
        }
    };
    SynchronousFileSystem.prototype.open = function open (p, flags, mode, cb) {
        try {
            cb(null, this.openSync(p, flags, mode));
        }
        catch (e) {
            cb(e);
        }
    };
    SynchronousFileSystem.prototype.unlink = function unlink (p, cb) {
        try {
            this.unlinkSync(p);
            cb();
        }
        catch (e) {
            cb(e);
        }
    };
    SynchronousFileSystem.prototype.rmdir = function rmdir (p, cb) {
        try {
            this.rmdirSync(p);
            cb();
        }
        catch (e) {
            cb(e);
        }
    };
    SynchronousFileSystem.prototype.mkdir = function mkdir (p, mode, cb) {
        try {
            this.mkdirSync(p, mode);
            cb();
        }
        catch (e) {
            cb(e);
        }
    };
    SynchronousFileSystem.prototype.readdir = function readdir (p, cb) {
        try {
            cb(null, this.readdirSync(p));
        }
        catch (e) {
            cb(e);
        }
    };
    SynchronousFileSystem.prototype.chmod = function chmod (p, isLchmod, mode, cb) {
        try {
            this.chmodSync(p, isLchmod, mode);
            cb();
        }
        catch (e) {
            cb(e);
        }
    };
    SynchronousFileSystem.prototype.chown = function chown (p, isLchown, uid, gid, cb) {
        try {
            this.chownSync(p, isLchown, uid, gid);
            cb();
        }
        catch (e) {
            cb(e);
        }
    };
    SynchronousFileSystem.prototype.utimes = function utimes (p, atime, mtime, cb) {
        try {
            this.utimesSync(p, atime, mtime);
            cb();
        }
        catch (e) {
            cb(e);
        }
    };
    SynchronousFileSystem.prototype.link = function link (srcpath, dstpath, cb) {
        try {
            this.linkSync(srcpath, dstpath);
            cb();
        }
        catch (e) {
            cb(e);
        }
    };
    SynchronousFileSystem.prototype.symlink = function symlink (srcpath, dstpath, type, cb) {
        try {
            this.symlinkSync(srcpath, dstpath, type);
            cb();
        }
        catch (e) {
            cb(e);
        }
    };
    SynchronousFileSystem.prototype.readlink = function readlink (p, cb) {
        try {
            cb(null, this.readlinkSync(p));
        }
        catch (e) {
            cb(e);
        }
    };

    return SynchronousFileSystem;
}(BaseFileSystem));

/**
 * Base class that contains shared implementations of functions for the file
 * object.
 */
var BaseFile = function BaseFile () {};

BaseFile.prototype.sync = function sync (cb) {
    cb(new ApiError(ErrorCode.ENOTSUP));
};
BaseFile.prototype.syncSync = function syncSync () {
    throw new ApiError(ErrorCode.ENOTSUP);
};
BaseFile.prototype.datasync = function datasync (cb) {
    this.sync(cb);
};
BaseFile.prototype.datasyncSync = function datasyncSync () {
    return this.syncSync();
};
BaseFile.prototype.chown = function chown (uid, gid, cb) {
    cb(new ApiError(ErrorCode.ENOTSUP));
};
BaseFile.prototype.chownSync = function chownSync (uid, gid) {
    throw new ApiError(ErrorCode.ENOTSUP);
};
BaseFile.prototype.chmod = function chmod (mode, cb) {
    cb(new ApiError(ErrorCode.ENOTSUP));
};
BaseFile.prototype.chmodSync = function chmodSync (mode) {
    throw new ApiError(ErrorCode.ENOTSUP);
};
BaseFile.prototype.utimes = function utimes (atime, mtime, cb) {
    cb(new ApiError(ErrorCode.ENOTSUP));
};
BaseFile.prototype.utimesSync = function utimesSync (atime, mtime) {
    throw new ApiError(ErrorCode.ENOTSUP);
};

/**
 * An implementation of the File interface that operates on a file that is
 * completely in-memory. PreloadFiles are backed by a Buffer.
 *
 * This is also an abstract class, as it lacks an implementation of 'sync' and
 * 'close'. Each filesystem that wishes to use this file representation must
 * extend this class and implement those two methods.
 * @todo 'close' lever that disables functionality once closed.
 */
var PreloadFile = (function (BaseFile$$1) {
    function PreloadFile(_fs, _path, _flag, _stat, contents) {
        BaseFile$$1.call(this);
        this._pos = 0;
        this._dirty = false;
        this._fs = _fs;
        this._path = _path;
        this._flag = _flag;
        this._stat = _stat;
        this._buffer = contents ? contents : emptyBuffer();
        // Note: This invariant is *not* maintained once the file starts getting
        // modified.
        // Note: Only actually matters if file is readable, as writeable modes may
        // truncate/append to file.
        if (this._stat.size !== this._buffer.length && this._flag.isReadable()) {
            throw new Error(("Invalid buffer: Buffer is " + (this._buffer.length) + " long, yet Stats object specifies that file is " + (this._stat.size) + " long."));
        }
    }

    if ( BaseFile$$1 ) PreloadFile.__proto__ = BaseFile$$1;
    PreloadFile.prototype = Object.create( BaseFile$$1 && BaseFile$$1.prototype );
    PreloadFile.prototype.constructor = PreloadFile;
    /**
     * NONSTANDARD: Get the underlying buffer for this file. !!DO NOT MUTATE!! Will mess up dirty tracking.
     */
    PreloadFile.prototype.getBuffer = function getBuffer () {
        return this._buffer;
    };
    /**
     * NONSTANDARD: Get underlying stats for this file. !!DO NOT MUTATE!!
     */
    PreloadFile.prototype.getStats = function getStats () {
        return this._stat;
    };
    PreloadFile.prototype.getFlag = function getFlag () {
        return this._flag;
    };
    /**
     * Get the path to this file.
     * @return [String] The path to the file.
     */
    PreloadFile.prototype.getPath = function getPath () {
        return this._path;
    };
    /**
     * Get the current file position.
     *
     * We emulate the following bug mentioned in the Node documentation:
     * > On Linux, positional writes don't work when the file is opened in append
     *   mode. The kernel ignores the position argument and always appends the data
     *   to the end of the file.
     * @return [Number] The current file position.
     */
    PreloadFile.prototype.getPos = function getPos () {
        if (this._flag.isAppendable()) {
            return this._stat.size;
        }
        return this._pos;
    };
    /**
     * Advance the current file position by the indicated number of positions.
     * @param [Number] delta
     */
    PreloadFile.prototype.advancePos = function advancePos (delta) {
        return this._pos += delta;
    };
    /**
     * Set the file position.
     * @param [Number] newPos
     */
    PreloadFile.prototype.setPos = function setPos (newPos) {
        return this._pos = newPos;
    };
    /**
     * **Core**: Asynchronous sync. Must be implemented by subclasses of this
     * class.
     * @param [Function(BrowserFS.ApiError)] cb
     */
    PreloadFile.prototype.sync = function sync (cb) {
        try {
            this.syncSync();
            cb();
        }
        catch (e) {
            cb(e);
        }
    };
    /**
     * **Core**: Synchronous sync.
     */
    PreloadFile.prototype.syncSync = function syncSync () {
        throw new ApiError(ErrorCode.ENOTSUP);
    };
    /**
     * **Core**: Asynchronous close. Must be implemented by subclasses of this
     * class.
     * @param [Function(BrowserFS.ApiError)] cb
     */
    PreloadFile.prototype.close = function close (cb) {
        try {
            this.closeSync();
            cb();
        }
        catch (e) {
            cb(e);
        }
    };
    /**
     * **Core**: Synchronous close.
     */
    PreloadFile.prototype.closeSync = function closeSync () {
        throw new ApiError(ErrorCode.ENOTSUP);
    };
    /**
     * Asynchronous `stat`.
     * @param [Function(BrowserFS.ApiError, BrowserFS.node.fs.Stats)] cb
     */
    PreloadFile.prototype.stat = function stat (cb) {
        try {
            cb(null, Stats.clone(this._stat));
        }
        catch (e) {
            cb(e);
        }
    };
    /**
     * Synchronous `stat`.
     */
    PreloadFile.prototype.statSync = function statSync () {
        return Stats.clone(this._stat);
    };
    /**
     * Asynchronous truncate.
     * @param [Number] len
     * @param [Function(BrowserFS.ApiError)] cb
     */
    PreloadFile.prototype.truncate = function truncate (len, cb) {
        try {
            this.truncateSync(len);
            if (this._flag.isSynchronous() && !_fsMock.getRootFS().supportsSynch()) {
                this.sync(cb);
            }
            cb();
        }
        catch (e) {
            return cb(e);
        }
    };
    /**
     * Synchronous truncate.
     * @param [Number] len
     */
    PreloadFile.prototype.truncateSync = function truncateSync (len) {
        this._dirty = true;
        if (!this._flag.isWriteable()) {
            throw new ApiError(ErrorCode.EPERM, 'File not opened with a writeable mode.');
        }
        this._stat.mtime = new Date();
        if (len > this._buffer.length) {
            var buf = Buffer.alloc(len - this._buffer.length, 0);
            // Write will set @_stat.size for us.
            this.writeSync(buf, 0, buf.length, this._buffer.length);
            if (this._flag.isSynchronous() && _fsMock.getRootFS().supportsSynch()) {
                this.syncSync();
            }
            return;
        }
        this._stat.size = len;
        // Truncate buffer to 'len'.
        var newBuff = Buffer.alloc(len);
        this._buffer.copy(newBuff, 0, 0, len);
        this._buffer = newBuff;
        if (this._flag.isSynchronous() && _fsMock.getRootFS().supportsSynch()) {
            this.syncSync();
        }
    };
    /**
     * Write buffer to the file.
     * Note that it is unsafe to use fs.write multiple times on the same file
     * without waiting for the callback.
     * @param [BrowserFS.node.Buffer] buffer Buffer containing the data to write to
     *  the file.
     * @param [Number] offset Offset in the buffer to start reading data from.
     * @param [Number] length The amount of bytes to write to the file.
     * @param [Number] position Offset from the beginning of the file where this
     *   data should be written. If position is null, the data will be written at
     *   the current position.
     * @param [Function(BrowserFS.ApiError, Number, BrowserFS.node.Buffer)]
     *   cb The number specifies the number of bytes written into the file.
     */
    PreloadFile.prototype.write = function write (buffer$$1, offset, length, position, cb) {
        try {
            cb(null, this.writeSync(buffer$$1, offset, length, position), buffer$$1);
        }
        catch (e) {
            cb(e);
        }
    };
    /**
     * Write buffer to the file.
     * Note that it is unsafe to use fs.writeSync multiple times on the same file
     * without waiting for the callback.
     * @param [BrowserFS.node.Buffer] buffer Buffer containing the data to write to
     *  the file.
     * @param [Number] offset Offset in the buffer to start reading data from.
     * @param [Number] length The amount of bytes to write to the file.
     * @param [Number] position Offset from the beginning of the file where this
     *   data should be written. If position is null, the data will be written at
     *   the current position.
     * @return [Number]
     */
    PreloadFile.prototype.writeSync = function writeSync (buffer$$1, offset, length, position) {
        this._dirty = true;
        if (position === undefined || position === null) {
            position = this.getPos();
        }
        if (!this._flag.isWriteable()) {
            throw new ApiError(ErrorCode.EPERM, 'File not opened with a writeable mode.');
        }
        var endFp = position + length;
        if (endFp > this._stat.size) {
            this._stat.size = endFp;
            if (endFp > this._buffer.length) {
                // Extend the buffer!
                var newBuff = Buffer.alloc(endFp);
                this._buffer.copy(newBuff);
                this._buffer = newBuff;
            }
        }
        var len = buffer$$1.copy(this._buffer, position, offset, offset + length);
        this._stat.mtime = new Date();
        if (this._flag.isSynchronous()) {
            this.syncSync();
            return len;
        }
        this.setPos(position + len);
        return len;
    };
    /**
     * Read data from the file.
     * @param [BrowserFS.node.Buffer] buffer The buffer that the data will be
     *   written to.
     * @param [Number] offset The offset within the buffer where writing will
     *   start.
     * @param [Number] length An integer specifying the number of bytes to read.
     * @param [Number] position An integer specifying where to begin reading from
     *   in the file. If position is null, data will be read from the current file
     *   position.
     * @param [Function(BrowserFS.ApiError, Number, BrowserFS.node.Buffer)] cb The
     *   number is the number of bytes read
     */
    PreloadFile.prototype.read = function read (buffer$$1, offset, length, position, cb) {
        try {
            cb(null, this.readSync(buffer$$1, offset, length, position), buffer$$1);
        }
        catch (e) {
            cb(e);
        }
    };
    /**
     * Read data from the file.
     * @param [BrowserFS.node.Buffer] buffer The buffer that the data will be
     *   written to.
     * @param [Number] offset The offset within the buffer where writing will
     *   start.
     * @param [Number] length An integer specifying the number of bytes to read.
     * @param [Number] position An integer specifying where to begin reading from
     *   in the file. If position is null, data will be read from the current file
     *   position.
     * @return [Number]
     */
    PreloadFile.prototype.readSync = function readSync (buffer$$1, offset, length, position) {
        if (!this._flag.isReadable()) {
            throw new ApiError(ErrorCode.EPERM, 'File not opened with a readable mode.');
        }
        if (position === undefined || position === null) {
            position = this.getPos();
        }
        var endRead = position + length;
        if (endRead > this._stat.size) {
            length = this._stat.size - position;
        }
        var rv = this._buffer.copy(buffer$$1, offset, position, position + length);
        this._stat.atime = new Date();
        this._pos = position + length;
        return rv;
    };
    /**
     * Asynchronous `fchmod`.
     * @param [Number|String] mode
     * @param [Function(BrowserFS.ApiError)] cb
     */
    PreloadFile.prototype.chmod = function chmod (mode, cb) {
        try {
            this.chmodSync(mode);
            cb();
        }
        catch (e) {
            cb(e);
        }
    };
    /**
     * Asynchronous `fchmod`.
     * @param [Number] mode
     */
    PreloadFile.prototype.chmodSync = function chmodSync (mode) {
        if (!this._fs.supportsProps()) {
            throw new ApiError(ErrorCode.ENOTSUP);
        }
        this._dirty = true;
        this._stat.chmod(mode);
        this.syncSync();
    };
    PreloadFile.prototype.isDirty = function isDirty () {
        return this._dirty;
    };
    /**
     * Resets the dirty bit. Should only be called after a sync has completed successfully.
     */
    PreloadFile.prototype.resetDirty = function resetDirty () {
        this._dirty = false;
    };

    return PreloadFile;
}(BaseFile));

/**
 * File class for the InMemory and XHR file systems.
 * Doesn't sync to anything, so it works nicely for memory-only files.
 */
var NoSyncFile = (function (PreloadFile) {
    function NoSyncFile(_fs, _path, _flag, _stat, contents) {
        PreloadFile.call(this, _fs, _path, _flag, _stat, contents);
    }

    if ( PreloadFile ) NoSyncFile.__proto__ = PreloadFile;
    NoSyncFile.prototype = Object.create( PreloadFile && PreloadFile.prototype );
    NoSyncFile.prototype.constructor = NoSyncFile;
    /**
     * Asynchronous sync. Doesn't do anything, simply calls the cb.
     * @param [Function(BrowserFS.ApiError)] cb
     */
    NoSyncFile.prototype.sync = function sync (cb) {
        cb();
    };
    /**
     * Synchronous sync. Doesn't do anything.
     */
    NoSyncFile.prototype.syncSync = function syncSync () {
        // NOP.
    };
    /**
     * Asynchronous close. Doesn't do anything, simply calls the cb.
     * @param [Function(BrowserFS.ApiError)] cb
     */
    NoSyncFile.prototype.close = function close (cb) {
        cb();
    };
    /**
     * Synchronous close. Doesn't do anything.
     */
    NoSyncFile.prototype.closeSync = function closeSync () {
        // NOP.
    };

    return NoSyncFile;
}(PreloadFile));

/**
 * We define our own file to interpose on syncSync() for mirroring purposes.
 */
var MirrorFile = (function (PreloadFile$$1) {
    function MirrorFile(fs, path$$1, flag, stat, data) {
        PreloadFile$$1.call(this, fs, path$$1, flag, stat, data);
    }

    if ( PreloadFile$$1 ) MirrorFile.__proto__ = PreloadFile$$1;
    MirrorFile.prototype = Object.create( PreloadFile$$1 && PreloadFile$$1.prototype );
    MirrorFile.prototype.constructor = MirrorFile;
    MirrorFile.prototype.syncSync = function syncSync () {
        if (this.isDirty()) {
            this._fs._syncSync(this);
            this.resetDirty();
        }
    };
    MirrorFile.prototype.closeSync = function closeSync () {
        this.syncSync();
    };

    return MirrorFile;
}(PreloadFile));
/**
 * AsyncMirrorFS mirrors a synchronous filesystem into an asynchronous filesystem
 * by:
 *
 * * Performing operations over the in-memory copy, while asynchronously pipelining them
 *   to the backing store.
 * * During application loading, the contents of the async file system can be reloaded into
 *   the synchronous store, if desired.
 *
 * The two stores will be kept in sync. The most common use-case is to pair a synchronous
 * in-memory filesystem with an asynchronous backing store.
 *
 * Example: Mirroring an IndexedDB file system to an in memory file system. Now, you can use
 * IndexedDB synchronously.
 *
 * ```javascript
 * BrowserFS.configure({
 *   fs: "AsyncMirror",
 *   options: {
 *     sync: { fs: "InMemory" },
 *     async: { fs: "IndexedDB" }
 *   }
 * }, function(e) {
 *   // BrowserFS is initialized and ready-to-use!
 * });
 * ```
 *
 * Or, alternatively:
 *
 * ```javascript
 * BrowserFS.FileSystem.IndexedDB.Create(function(e, idbfs) {
 *   BrowserFS.FileSystem.InMemory.Create(function(e, inMemory) {
 *     BrowserFS.FileSystem.AsyncMirror({
 *       sync: inMemory, async: idbfs
 *     }, function(e, mirrored) {
 *       BrowserFS.initialize(mirrored);
 *     });
 *   });
 * });
 * ```
 */
var AsyncMirror = (function (SynchronousFileSystem$$1) {
    function AsyncMirror(sync, async) {
        SynchronousFileSystem$$1.call(this);
        /**
         * Queue of pending asynchronous operations.
         */
        this._queue = [];
        this._queueRunning = false;
        this._isInitialized = false;
        this._initializeCallbacks = [];
        this._sync = sync;
        this._async = async;
    }

    if ( SynchronousFileSystem$$1 ) AsyncMirror.__proto__ = SynchronousFileSystem$$1;
    AsyncMirror.prototype = Object.create( SynchronousFileSystem$$1 && SynchronousFileSystem$$1.prototype );
    AsyncMirror.prototype.constructor = AsyncMirror;
    /**
     * Constructs and initializes an AsyncMirror file system with the given options.
     */
    AsyncMirror.Create = function Create (opts, cb) {
        try {
            var fs = new AsyncMirror(opts.sync, opts.async);
            fs._initialize(function (e) {
                if (e) {
                    cb(e);
                }
                else {
                    cb(null, fs);
                }
            });
        }
        catch (e) {
            cb(e);
        }
    };
    AsyncMirror.isAvailable = function isAvailable () {
        return true;
    };
    AsyncMirror.prototype.getName = function getName () {
        return AsyncMirror.Name;
    };
    AsyncMirror.prototype._syncSync = function _syncSync (fd) {
        this._sync.writeFileSync(fd.getPath(), fd.getBuffer(), null, FileFlag.getFileFlag('w'), fd.getStats().mode);
        this.enqueueOp({
            apiMethod: 'writeFile',
            arguments: [fd.getPath(), fd.getBuffer(), null, fd.getFlag(), fd.getStats().mode]
        });
    };
    AsyncMirror.prototype.isReadOnly = function isReadOnly () { return false; };
    AsyncMirror.prototype.supportsSynch = function supportsSynch () { return true; };
    AsyncMirror.prototype.supportsLinks = function supportsLinks () { return false; };
    AsyncMirror.prototype.supportsProps = function supportsProps () { return this._sync.supportsProps() && this._async.supportsProps(); };
    AsyncMirror.prototype.renameSync = function renameSync (oldPath, newPath) {
        this._sync.renameSync(oldPath, newPath);
        this.enqueueOp({
            apiMethod: 'rename',
            arguments: [oldPath, newPath]
        });
    };
    AsyncMirror.prototype.statSync = function statSync (p, isLstat) {
        return this._sync.statSync(p, isLstat);
    };
    AsyncMirror.prototype.openSync = function openSync (p, flag, mode) {
        // Sanity check: Is this open/close permitted?
        var fd = this._sync.openSync(p, flag, mode);
        fd.closeSync();
        return new MirrorFile(this, p, flag, this._sync.statSync(p, false), this._sync.readFileSync(p, null, FileFlag.getFileFlag('r')));
    };
    AsyncMirror.prototype.unlinkSync = function unlinkSync (p) {
        this._sync.unlinkSync(p);
        this.enqueueOp({
            apiMethod: 'unlink',
            arguments: [p]
        });
    };
    AsyncMirror.prototype.rmdirSync = function rmdirSync (p) {
        this._sync.rmdirSync(p);
        this.enqueueOp({
            apiMethod: 'rmdir',
            arguments: [p]
        });
    };
    AsyncMirror.prototype.mkdirSync = function mkdirSync (p, mode) {
        this._sync.mkdirSync(p, mode);
        this.enqueueOp({
            apiMethod: 'mkdir',
            arguments: [p, mode]
        });
    };
    AsyncMirror.prototype.readdirSync = function readdirSync (p) {
        return this._sync.readdirSync(p);
    };
    AsyncMirror.prototype.existsSync = function existsSync (p) {
        return this._sync.existsSync(p);
    };
    AsyncMirror.prototype.chmodSync = function chmodSync (p, isLchmod, mode) {
        this._sync.chmodSync(p, isLchmod, mode);
        this.enqueueOp({
            apiMethod: 'chmod',
            arguments: [p, isLchmod, mode]
        });
    };
    AsyncMirror.prototype.chownSync = function chownSync (p, isLchown, uid, gid) {
        this._sync.chownSync(p, isLchown, uid, gid);
        this.enqueueOp({
            apiMethod: 'chown',
            arguments: [p, isLchown, uid, gid]
        });
    };
    AsyncMirror.prototype.utimesSync = function utimesSync (p, atime, mtime) {
        this._sync.utimesSync(p, atime, mtime);
        this.enqueueOp({
            apiMethod: 'utimes',
            arguments: [p, atime, mtime]
        });
    };
    /**
     * Called once to load up files from async storage into sync storage.
     */
    AsyncMirror.prototype._initialize = function _initialize (userCb) {
        var this$1 = this;

        var callbacks = this._initializeCallbacks;
        var end = function (e) {
            this$1._isInitialized = !e;
            this$1._initializeCallbacks = [];
            callbacks.forEach(function (cb) { return cb(e); });
        };
        if (!this._isInitialized) {
            // First call triggers initialization, the rest wait.
            if (callbacks.push(userCb) === 1) {
                var copyDirectory = function (p, mode, cb) {
                    if (p !== '/') {
                        this$1._sync.mkdirSync(p, mode);
                    }
                    this$1._async.readdir(p, function (err, files) {
                        var i = 0;
                        // NOTE: This function must not be in a lexically nested statement,
                        // such as an if or while statement. Safari refuses to run the
                        // script since it is undefined behavior.
                        function copyNextFile(err) {
                            if (err) {
                                cb(err);
                            }
                            else if (i < files.length) {
                                copyItem(path.join(p, files[i]), copyNextFile);
                                i++;
                            }
                            else {
                                cb();
                            }
                        }
                        if (err) {
                            cb(err);
                        }
                        else {
                            copyNextFile();
                        }
                    });
                }, copyFile = function (p, mode, cb) {
                    this$1._async.readFile(p, null, FileFlag.getFileFlag('r'), function (err, data) {
                        if (err) {
                            cb(err);
                        }
                        else {
                            try {
                                this$1._sync.writeFileSync(p, data, null, FileFlag.getFileFlag('w'), mode);
                            }
                            catch (e) {
                                err = e;
                            }
                            finally {
                                cb(err);
                            }
                        }
                    });
                }, copyItem = function (p, cb) {
                    this$1._async.stat(p, false, function (err, stats) {
                        if (err) {
                            cb(err);
                        }
                        else if (stats.isDirectory()) {
                            copyDirectory(p, stats.mode, cb);
                        }
                        else {
                            copyFile(p, stats.mode, cb);
                        }
                    });
                };
                copyDirectory('/', 0, end);
            }
        }
        else {
            userCb();
        }
    };
    AsyncMirror.prototype.enqueueOp = function enqueueOp (op) {
        var this$1 = this;

        this._queue.push(op);
        if (!this._queueRunning) {
            this._queueRunning = true;
            var doNextOp = function (err) {
                if (err) {
                    throw new Error(("WARNING: File system has desynchronized. Received following error: " + err + "\n$"));
                }
                if (this$1._queue.length > 0) {
                    var op = this$1._queue.shift(), args = op.arguments;
                    args.push(doNextOp);
                    this$1._async[op.apiMethod].apply(this$1._async, args);
                }
                else {
                    this$1._queueRunning = false;
                }
            };
            doNextOp();
        }
    };

    return AsyncMirror;
}(SynchronousFileSystem));

AsyncMirror.Name = "AsyncMirror";
AsyncMirror.Options = {
    sync: {
        type: "object",
        description: "The synchronous file system to mirror the asynchronous file system to.",
        validator: function (v, cb) {
            if (v && typeof (v['supportsSynch']) === "function" && v.supportsSynch()) {
                cb();
            }
            else {
                cb(new ApiError(ErrorCode.EINVAL, "'sync' option must be a file system that supports synchronous operations"));
            }
        }
    },
    async: {
        type: "object",
        description: "The asynchronous file system to mirror."
    }
};

/**
 * @hidden
 */
var toExport = typeof (window) !== 'undefined' ? window : typeof (self) !== 'undefined' ? self : global;

/**
 * @hidden
 */
var bfsSetImmediate;
if (typeof (setImmediate) !== "undefined") {
    bfsSetImmediate = setImmediate;
}
else {
    var gScope = toExport;
    var timeouts = [];
    var messageName = "zero-timeout-message";
    var canUsePostMessage = function () {
        if (typeof gScope.importScripts !== 'undefined' || !gScope.postMessage) {
            return false;
        }
        var postMessageIsAsync = true;
        var oldOnMessage = gScope.onmessage;
        gScope.onmessage = function () {
            postMessageIsAsync = false;
        };
        gScope.postMessage('', '*');
        gScope.onmessage = oldOnMessage;
        return postMessageIsAsync;
    };
    if (canUsePostMessage()) {
        bfsSetImmediate = function (fn) {
            timeouts.push(fn);
            gScope.postMessage(messageName, "*");
        };
        var handleMessage = function (event) {
            if (event.source === self && event.data === messageName) {
                if (event.stopPropagation) {
                    event.stopPropagation();
                }
                else {
                    event.cancelBubble = true;
                }
                if (timeouts.length > 0) {
                    var fn = timeouts.shift();
                    return fn();
                }
            }
        };
        if (gScope.addEventListener) {
            gScope.addEventListener('message', handleMessage, true);
        }
        else {
            gScope.attachEvent('onmessage', handleMessage);
        }
    }
    else if (gScope.MessageChannel) {
        // WebWorker MessageChannel
        var channel = new gScope.MessageChannel();
        channel.port1.onmessage = function (event) {
            if (timeouts.length > 0) {
                return timeouts.shift()();
            }
        };
        bfsSetImmediate = function (fn) {
            timeouts.push(fn);
            channel.port2.postMessage('');
        };
    }
    else {
        bfsSetImmediate = function (fn) {
            return setTimeout(fn, 0);
        };
    }
}
var setImmediate$1 = bfsSetImmediate;

/**
 * Dropbox paths do not begin with a /, they just begin with a folder at the root node.
 * Here, we strip the `/`.
 * @param p An absolute path
 */
function FixPath(p) {
    if (p === '/') {
        return '';
    }
    else {
        return p;
    }
}
/**
 * HACK: Dropbox errors are FUBAR'd sometimes.
 * @url https://github.com/dropbox/dropbox-sdk-js/issues/146
 * @param e
 */
function ExtractTheFuckingError(e) {
    var obj = e.error;
    if (obj['.tag']) {
        // Everything is OK.
        return obj;
    }
    else if (obj['error']) {
        // Terrible nested object bug.
        var obj2 = obj.error;
        if (obj2['.tag']) {
            return obj2;
        }
        else if (obj2['reason'] && obj2['reason']['.tag']) {
            return obj2.reason;
        }
        else {
            return obj2;
        }
    }
    else if (typeof (obj) === 'string') {
        // Might be a fucking JSON object error.
        try {
            var obj2$1 = JSON.parse(obj);
            if (obj2$1['error'] && obj2$1['error']['reason'] && obj2$1['error']['reason']['.tag']) {
                return obj2$1.error.reason;
            }
        }
        catch (e) {
            // Nope. Give up.
        }
    }
    return obj;
}
/**
 * Returns a user-facing error message given an error.
 *
 * HACK: Dropbox error messages sometimes lack a `user_message` field.
 * Sometimes, they are even strings. Ugh.
 * @url https://github.com/dropbox/dropbox-sdk-js/issues/146
 * @url https://github.com/dropbox/dropbox-sdk-js/issues/145
 * @url https://github.com/dropbox/dropbox-sdk-js/issues/144
 * @param err An error.
 */
function GetErrorMessage(err) {
    if (err['user_message']) {
        return err.user_message.text;
    }
    else if (err['error_summary']) {
        return err.error_summary;
    }
    else if (typeof (err.error) === "string") {
        return err.error;
    }
    else if (typeof (err.error) === "object") {
        // DROPBOX BUG: Sometimes, error is a nested error.
        return GetErrorMessage(err.error);
    }
    else {
        throw new Error(("Dropbox's servers gave us a garbage error message: " + (JSON.stringify(err))));
    }
}
function LookupErrorToError(err, p, msg) {
    switch (err['.tag']) {
        case 'malformed_path':
            return new ApiError(ErrorCode.EBADF, msg, p);
        case 'not_found':
            return ApiError.ENOENT(p);
        case 'not_file':
            return ApiError.EISDIR(p);
        case 'not_folder':
            return ApiError.ENOTDIR(p);
        case 'restricted_content':
            return ApiError.EPERM(p);
        case 'other':
        default:
            return new ApiError(ErrorCode.EIO, msg, p);
    }
}
function WriteErrorToError(err, p, msg) {
    switch (err['.tag']) {
        case 'malformed_path':
        case 'disallowed_name':
            return new ApiError(ErrorCode.EBADF, msg, p);
        case 'conflict':
        case 'no_write_permission':
        case 'team_folder':
            return ApiError.EPERM(p);
        case 'insufficient_space':
            return new ApiError(ErrorCode.ENOSPC, msg);
        case 'other':
        default:
            return new ApiError(ErrorCode.EIO, msg, p);
    }
}
function FilesDeleteWrapped(client, p, cb) {
    var arg = {
        path: FixPath(p)
    };
    client.filesDeleteV2(arg)
        .then(function () {
        cb();
    }).catch(function (e) {
        var err = ExtractTheFuckingError(e);
        switch (err['.tag']) {
            case 'path_lookup':
                cb(LookupErrorToError(err.path_lookup, p, GetErrorMessage(e)));
                break;
            case 'path_write':
                cb(WriteErrorToError(err.path_write, p, GetErrorMessage(e)));
                break;
            case 'too_many_write_operations':
                setTimeout(function () { return FilesDeleteWrapped(client, p, cb); }, 500 + (300 * (Math.random())));
                break;
            case 'other':
            default:
                cb(new ApiError(ErrorCode.EIO, GetErrorMessage(e), p));
                break;
        }
    });
}
var DropboxFile = (function (PreloadFile$$1) {
    function DropboxFile(_fs, _path, _flag, _stat, contents) {
        PreloadFile$$1.call(this, _fs, _path, _flag, _stat, contents);
    }

    if ( PreloadFile$$1 ) DropboxFile.__proto__ = PreloadFile$$1;
    DropboxFile.prototype = Object.create( PreloadFile$$1 && PreloadFile$$1.prototype );
    DropboxFile.prototype.constructor = DropboxFile;
    DropboxFile.prototype.sync = function sync (cb) {
        this._fs._syncFile(this.getPath(), this.getBuffer(), cb);
    };
    DropboxFile.prototype.close = function close (cb) {
        this.sync(cb);
    };

    return DropboxFile;
}(PreloadFile));
/**
 * A read/write file system backed by Dropbox cloud storage.
 *
 * Uses the Dropbox V2 API, and the 2.x JS SDK.
 */
var DropboxFileSystem = (function (BaseFileSystem$$1) {
    function DropboxFileSystem(client) {
        BaseFileSystem$$1.call(this);
        this._client = client;
    }

    if ( BaseFileSystem$$1 ) DropboxFileSystem.__proto__ = BaseFileSystem$$1;
    DropboxFileSystem.prototype = Object.create( BaseFileSystem$$1 && BaseFileSystem$$1.prototype );
    DropboxFileSystem.prototype.constructor = DropboxFileSystem;
    /**
     * Creates a new DropboxFileSystem instance with the given options.
     * Must be given an *authenticated* Dropbox client from 2.x JS SDK.
     */
    DropboxFileSystem.Create = function Create (opts, cb) {
        cb(null, new DropboxFileSystem(opts.client));
    };
    DropboxFileSystem.isAvailable = function isAvailable () {
        // Checks if the Dropbox library is loaded.
        return typeof Dropbox !== 'undefined';
    };
    DropboxFileSystem.prototype.getName = function getName () {
        return DropboxFileSystem.Name;
    };
    DropboxFileSystem.prototype.isReadOnly = function isReadOnly () {
        return false;
    };
    // Dropbox doesn't support symlinks, properties, or synchronous calls
    // TODO: does it???
    DropboxFileSystem.prototype.supportsSymlinks = function supportsSymlinks () {
        return false;
    };
    DropboxFileSystem.prototype.supportsProps = function supportsProps () {
        return false;
    };
    DropboxFileSystem.prototype.supportsSynch = function supportsSynch () {
        return false;
    };
    /**
     * Deletes *everything* in the file system. Mainly intended for unit testing!
     * @param mainCb Called when operation completes.
     */
    DropboxFileSystem.prototype.empty = function empty (mainCb) {
        var this$1 = this;

        this.readdir('/', function (e, paths) {
            if (paths) {
                var next = function (e) {
                    if (paths.length === 0) {
                        mainCb();
                    }
                    else {
                        FilesDeleteWrapped(this$1._client, paths.shift(), next);
                    }
                };
                next();
            }
            else {
                mainCb(e);
            }
        });
    };
    DropboxFileSystem.prototype.rename = function rename (oldPath, newPath, cb) {
        var this$1 = this;

        // Dropbox doesn't let you rename things over existing things, but POSIX does.
        // So, we need to see if newPath exists...
        this.stat(newPath, false, function (e, stats) {
            var rename = function () {
                var relocationArg = {
                    from_path: FixPath(oldPath),
                    to_path: FixPath(newPath)
                };
                this$1._client.filesMoveV2(relocationArg)
                    .then(function () { return cb(); })
                    .catch(function (e) {
                    var err = ExtractTheFuckingError(e);
                    switch (err['.tag']) {
                        case 'from_lookup':
                            cb(LookupErrorToError(err.from_lookup, oldPath, GetErrorMessage(e)));
                            break;
                        case 'from_write':
                            cb(WriteErrorToError(err.from_write, oldPath, GetErrorMessage(e)));
                            break;
                        case 'to':
                            cb(WriteErrorToError(err.to, newPath, GetErrorMessage(e)));
                            break;
                        case 'cant_copy_shared_folder':
                        case 'cant_nest_shared_folder':
                            cb(new ApiError(ErrorCode.EPERM, GetErrorMessage(e), oldPath));
                            break;
                        case 'cant_move_folder_into_itself':
                        case 'duplicated_or_nested_paths':
                            cb(new ApiError(ErrorCode.EBADF, GetErrorMessage(e), oldPath));
                            break;
                        case 'too_many_files':
                            cb(new ApiError(ErrorCode.ENOSPC, GetErrorMessage(e), oldPath));
                            break;
                        case 'other':
                        default:
                            cb(new ApiError(ErrorCode.EIO, GetErrorMessage(e), oldPath));
                            break;
                    }
                });
            };
            if (e) {
                // Doesn't exist. Proceed!
                rename();
            }
            else if (oldPath === newPath) {
                // NOP if the path exists. Error if it doesn't exist.
                if (e) {
                    cb(ApiError.ENOENT(newPath));
                }
                else {
                    cb();
                }
            }
            else if (stats && stats.isDirectory()) {
                // Exists, is a directory. Cannot rename over an existing directory.
                cb(ApiError.EISDIR(newPath));
            }
            else {
                // Exists, is a file, and differs from oldPath. Delete and rename.
                this$1.unlink(newPath, function (e) {
                    if (e) {
                        cb(e);
                    }
                    else {
                        rename();
                    }
                });
            }
        });
    };
    DropboxFileSystem.prototype.stat = function stat (path$$1, isLstat, cb) {
        if (path$$1 === '/') {
            // Dropbox doesn't support querying the root directory.
            setImmediate$1(function () {
                cb(null, new Stats(FileType.DIRECTORY, 4096));
            });
            return;
        }
        var arg = {
            path: FixPath(path$$1)
        };
        this._client.filesGetMetadata(arg).then(function (ref) {
            switch (ref['.tag']) {
                case 'file':
                    var fileMetadata = ref;
                    // TODO: Parse time fields.
                    cb(null, new Stats(FileType.FILE, fileMetadata.size));
                    break;
                case 'folder':
                    cb(null, new Stats(FileType.DIRECTORY, 4096));
                    break;
                case 'deleted':
                    cb(ApiError.ENOENT(path$$1));
                    break;
                default:
                    // Unknown.
                    break;
            }
        }).catch(function (e) {
            var err = ExtractTheFuckingError(e);
            switch (err['.tag']) {
                case 'path':
                    cb(LookupErrorToError(err.path, path$$1, GetErrorMessage(e)));
                    break;
                default:
                    cb(new ApiError(ErrorCode.EIO, GetErrorMessage(e), path$$1));
                    break;
            }
        });
    };
    DropboxFileSystem.prototype.openFile = function openFile (path$$1, flags, cb) {
        var this$1 = this;

        var downloadArg = {
            path: FixPath(path$$1)
        };
        this._client.filesDownload(downloadArg).then(function (res) {
            var b = res.fileBlob;
            var fr = new FileReader();
            fr.onload = function () {
                var ab = fr.result;
                cb(null, new DropboxFile(this$1, path$$1, flags, new Stats(FileType.FILE, ab.byteLength), arrayBuffer2Buffer(ab)));
            };
            fr.readAsArrayBuffer(b);
        }).catch(function (e) {
            var err = ExtractTheFuckingError(e);
            switch (err['.tag']) {
                case 'path':
                    var dpError = err;
                    cb(LookupErrorToError(dpError.path, path$$1, GetErrorMessage(e)));
                    break;
                case 'other':
                default:
                    cb(new ApiError(ErrorCode.EIO, GetErrorMessage(e), path$$1));
                    break;
            }
        });
    };
    DropboxFileSystem.prototype.createFile = function createFile (p, flags, mode, cb) {
        var this$1 = this;

        var fileData = Buffer.alloc(0);
        var blob = new Blob([buffer2ArrayBuffer(fileData)], { type: "octet/stream" });
        var commitInfo = {
            contents: blob,
            path: FixPath(p)
        };
        this._client.filesUpload(commitInfo).then(function (metadata) {
            cb(null, new DropboxFile(this$1, p, flags, new Stats(FileType.FILE, 0), fileData));
        }).catch(function (e) {
            var err = ExtractTheFuckingError(e);
            // HACK: Casting to 'any' since tag can be 'too_many_write_operations'.
            switch (err['.tag']) {
                case 'path':
                    var upError = err;
                    cb(WriteErrorToError(upError.path.reason, p, GetErrorMessage(e)));
                    break;
                case 'too_many_write_operations':
                    // Retry in (500, 800) ms.
                    setTimeout(function () { return this$1.createFile(p, flags, mode, cb); }, 500 + (300 * (Math.random())));
                    break;
                case 'other':
                default:
                    cb(new ApiError(ErrorCode.EIO, GetErrorMessage(e), p));
                    break;
            }
        });
    };
    /**
     * Delete a file
     */
    DropboxFileSystem.prototype.unlink = function unlink (path$$1, cb) {
        var this$1 = this;

        // Must be a file. Check first.
        this.stat(path$$1, false, function (e, stat) {
            if (stat) {
                if (stat.isDirectory()) {
                    cb(ApiError.EISDIR(path$$1));
                }
                else {
                    FilesDeleteWrapped(this$1._client, path$$1, cb);
                }
            }
            else {
                cb(e);
            }
        });
    };
    /**
     * Delete a directory
     */
    DropboxFileSystem.prototype.rmdir = function rmdir (path$$1, cb) {
        var this$1 = this;

        this.readdir(path$$1, function (e, paths) {
            if (paths) {
                if (paths.length > 0) {
                    cb(ApiError.ENOTEMPTY(path$$1));
                }
                else {
                    FilesDeleteWrapped(this$1._client, path$$1, cb);
                }
            }
            else {
                cb(e);
            }
        });
    };
    /**
     * Create a directory
     */
    DropboxFileSystem.prototype.mkdir = function mkdir (p, mode, cb) {
        var this$1 = this;

        // Dropbox's create_folder is recursive. Check if parent exists.
        var parent = path.dirname(p);
        this.stat(parent, false, function (e, stats) {
            if (e) {
                cb(e);
            }
            else if (stats && !stats.isDirectory()) {
                cb(ApiError.ENOTDIR(parent));
            }
            else {
                var arg = {
                    path: FixPath(p)
                };
                this$1._client.filesCreateFolderV2(arg).then(function () { return cb(); }).catch(function (e) {
                    var err = ExtractTheFuckingError(e);
                    if (err['.tag'] === "too_many_write_operations") {
                        // Retry in a bit.
                        setTimeout(function () { return this$1.mkdir(p, mode, cb); }, 500 + (300 * (Math.random())));
                    }
                    else {
                        cb(WriteErrorToError(ExtractTheFuckingError(e).path, p, GetErrorMessage(e)));
                    }
                });
            }
        });
    };
    /**
     * Get the names of the files in a directory
     */
    DropboxFileSystem.prototype.readdir = function readdir (path$$1, cb) {
        var this$1 = this;

        var arg = {
            path: FixPath(path$$1)
        };
        this._client.filesListFolder(arg).then(function (res) {
            ContinueReadingDir(this$1._client, path$$1, res, [], cb);
        }).catch(function (e) {
            ProcessListFolderError(e, path$$1, cb);
        });
    };
    /**
     * (Internal) Syncs file to Dropbox.
     */
    DropboxFileSystem.prototype._syncFile = function _syncFile (p, d, cb) {
        var this$1 = this;

        var blob = new Blob([buffer2ArrayBuffer(d)], { type: "octet/stream" });
        var arg = {
            contents: blob,
            path: FixPath(p),
            mode: {
                '.tag': 'overwrite'
            }
        };
        this._client.filesUpload(arg).then(function () {
            cb();
        }).catch(function (e) {
            var err = ExtractTheFuckingError(e);
            switch (err['.tag']) {
                case 'path':
                    var upError = err;
                    cb(WriteErrorToError(upError.path.reason, p, GetErrorMessage(e)));
                    break;
                case 'too_many_write_operations':
                    setTimeout(function () { return this$1._syncFile(p, d, cb); }, 500 + (300 * (Math.random())));
                    break;
                case 'other':
                default:
                    cb(new ApiError(ErrorCode.EIO, GetErrorMessage(e), p));
                    break;
            }
        });
    };

    return DropboxFileSystem;
}(BaseFileSystem));

DropboxFileSystem.Name = "DropboxV2";
DropboxFileSystem.Options = {
    client: {
        type: "object",
        description: "An *authenticated* Dropbox client. Must be from the 2.5.x JS SDK."
    }
};
function ProcessListFolderError(e, path$$1, cb) {
    var err = ExtractTheFuckingError(e);
    switch (err['.tag']) {
        case 'path':
            var pathError = err;
            cb(LookupErrorToError(pathError.path, path$$1, GetErrorMessage(e)));
            break;
        case 'other':
        default:
            cb(new ApiError(ErrorCode.EIO, GetErrorMessage(e), path$$1));
            break;
    }
}
function ContinueReadingDir(client, path$$1, res, previousEntries, cb) {
    var newEntries = res.entries.map(function (e) { return e.path_display; }).filter(function (p) { return !!p; });
    var entries = previousEntries.concat(newEntries);
    if (!res.has_more) {
        cb(null, entries);
    }
    else {
        var arg = {
            cursor: res.cursor
        };
        client.filesListFolderContinue(arg).then(function (res) {
            ContinueReadingDir(client, path$$1, res, entries, cb);
        }).catch(function (e) {
            ProcessListFolderError(e, path$$1, cb);
        });
    }
}

/**
 * @hidden
 */
function convertError(e, path$$1) {
    if ( path$$1 === void 0 ) path$$1 = '';

    var errno = e.errno;
    var parent = e.node;
    var paths = [];
    while (parent) {
        paths.unshift(parent.name);
        if (parent === parent.parent) {
            break;
        }
        parent = parent.parent;
    }
    return new ApiError(errno, ErrorStrings[errno], paths.length > 0 ? '/' + paths.join('/') : path$$1);
}
var EmscriptenFile = (function (BaseFile$$1) {
    function EmscriptenFile(_fs, _FS, _path, _stream) {
        BaseFile$$1.call(this);
        this._fs = _fs;
        this._FS = _FS;
        this._path = _path;
        this._stream = _stream;
    }

    if ( BaseFile$$1 ) EmscriptenFile.__proto__ = BaseFile$$1;
    EmscriptenFile.prototype = Object.create( BaseFile$$1 && BaseFile$$1.prototype );
    EmscriptenFile.prototype.constructor = EmscriptenFile;
    EmscriptenFile.prototype.getPos = function getPos () {
        return undefined;
    };
    EmscriptenFile.prototype.close = function close (cb) {
        var err = null;
        try {
            this.closeSync();
        }
        catch (e) {
            err = e;
        }
        finally {
            cb(err);
        }
    };
    EmscriptenFile.prototype.closeSync = function closeSync () {
        try {
            this._FS.close(this._stream);
        }
        catch (e) {
            throw convertError(e, this._path);
        }
    };
    EmscriptenFile.prototype.stat = function stat (cb) {
        try {
            cb(null, this.statSync());
        }
        catch (e) {
            cb(e);
        }
    };
    EmscriptenFile.prototype.statSync = function statSync () {
        try {
            return this._fs.statSync(this._path, false);
        }
        catch (e) {
            throw convertError(e, this._path);
        }
    };
    EmscriptenFile.prototype.truncate = function truncate (len, cb) {
        var err = null;
        try {
            this.truncateSync(len);
        }
        catch (e) {
            err = e;
        }
        finally {
            cb(err);
        }
    };
    EmscriptenFile.prototype.truncateSync = function truncateSync (len) {
        try {
            this._FS.ftruncate(this._stream.fd, len);
        }
        catch (e) {
            throw convertError(e, this._path);
        }
    };
    EmscriptenFile.prototype.write = function write (buffer$$1, offset, length, position, cb) {
        try {
            cb(null, this.writeSync(buffer$$1, offset, length, position), buffer$$1);
        }
        catch (e) {
            cb(e);
        }
    };
    EmscriptenFile.prototype.writeSync = function writeSync (buffer$$1, offset, length, position) {
        try {
            var u8 = buffer2Uint8array(buffer$$1);
            // Emscripten is particular about what position is set to.
            var emPosition = position === null ? undefined : position;
            return this._FS.write(this._stream, u8, offset, length, emPosition);
        }
        catch (e) {
            throw convertError(e, this._path);
        }
    };
    EmscriptenFile.prototype.read = function read (buffer$$1, offset, length, position, cb) {
        try {
            cb(null, this.readSync(buffer$$1, offset, length, position), buffer$$1);
        }
        catch (e) {
            cb(e);
        }
    };
    EmscriptenFile.prototype.readSync = function readSync (buffer$$1, offset, length, position) {
        try {
            var u8 = buffer2Uint8array(buffer$$1);
            // Emscripten is particular about what position is set to.
            var emPosition = position === null ? undefined : position;
            return this._FS.read(this._stream, u8, offset, length, emPosition);
        }
        catch (e) {
            throw convertError(e, this._path);
        }
    };
    EmscriptenFile.prototype.sync = function sync (cb) {
        // NOP.
        cb();
    };
    EmscriptenFile.prototype.syncSync = function syncSync () {
        // NOP.
    };
    EmscriptenFile.prototype.chown = function chown (uid, gid, cb) {
        var err = null;
        try {
            this.chownSync(uid, gid);
        }
        catch (e) {
            err = e;
        }
        finally {
            cb(err);
        }
    };
    EmscriptenFile.prototype.chownSync = function chownSync (uid, gid) {
        try {
            this._FS.fchown(this._stream.fd, uid, gid);
        }
        catch (e) {
            throw convertError(e, this._path);
        }
    };
    EmscriptenFile.prototype.chmod = function chmod (mode, cb) {
        var err = null;
        try {
            this.chmodSync(mode);
        }
        catch (e) {
            err = e;
        }
        finally {
            cb(err);
        }
    };
    EmscriptenFile.prototype.chmodSync = function chmodSync (mode) {
        try {
            this._FS.fchmod(this._stream.fd, mode);
        }
        catch (e) {
            throw convertError(e, this._path);
        }
    };
    EmscriptenFile.prototype.utimes = function utimes (atime, mtime, cb) {
        var err = null;
        try {
            this.utimesSync(atime, mtime);
        }
        catch (e) {
            err = e;
        }
        finally {
            cb(err);
        }
    };
    EmscriptenFile.prototype.utimesSync = function utimesSync (atime, mtime) {
        this._fs.utimesSync(this._path, atime, mtime);
    };

    return EmscriptenFile;
}(BaseFile));
/**
 * Mounts an Emscripten file system into the BrowserFS file system.
 */
var EmscriptenFileSystem = (function (SynchronousFileSystem$$1) {
    function EmscriptenFileSystem(_FS) {
        SynchronousFileSystem$$1.call(this);
        this._FS = _FS;
    }

    if ( SynchronousFileSystem$$1 ) EmscriptenFileSystem.__proto__ = SynchronousFileSystem$$1;
    EmscriptenFileSystem.prototype = Object.create( SynchronousFileSystem$$1 && SynchronousFileSystem$$1.prototype );
    EmscriptenFileSystem.prototype.constructor = EmscriptenFileSystem;
    /**
     * Create an EmscriptenFileSystem instance with the given options.
     */
    EmscriptenFileSystem.Create = function Create (opts, cb) {
        cb(null, new EmscriptenFileSystem(opts.FS));
    };
    EmscriptenFileSystem.isAvailable = function isAvailable () { return true; };
    EmscriptenFileSystem.prototype.getName = function getName () { return this._FS.DB_NAME(); };
    EmscriptenFileSystem.prototype.isReadOnly = function isReadOnly () { return false; };
    EmscriptenFileSystem.prototype.supportsLinks = function supportsLinks () { return true; };
    EmscriptenFileSystem.prototype.supportsProps = function supportsProps () { return true; };
    EmscriptenFileSystem.prototype.supportsSynch = function supportsSynch () { return true; };
    EmscriptenFileSystem.prototype.renameSync = function renameSync (oldPath, newPath) {
        try {
            this._FS.rename(oldPath, newPath);
        }
        catch (e) {
            if (e.errno === ErrorCode.ENOENT) {
                throw convertError(e, this.existsSync(oldPath) ? newPath : oldPath);
            }
            else {
                throw convertError(e);
            }
        }
    };
    EmscriptenFileSystem.prototype.statSync = function statSync (p, isLstat) {
        try {
            var stats = isLstat ? this._FS.lstat(p) : this._FS.stat(p);
            var itemType = this.modeToFileType(stats.mode);
            return new Stats(itemType, stats.size, stats.mode, stats.atime, stats.mtime, stats.ctime);
        }
        catch (e) {
            throw convertError(e, p);
        }
    };
    EmscriptenFileSystem.prototype.openSync = function openSync (p, flag, mode) {
        try {
            var stream = this._FS.open(p, flag.getFlagString(), mode);
            if (this._FS.isDir(stream.node.mode)) {
                this._FS.close(stream);
                throw ApiError.EISDIR(p);
            }
            return new EmscriptenFile(this, this._FS, p, stream);
        }
        catch (e) {
            throw convertError(e, p);
        }
    };
    EmscriptenFileSystem.prototype.unlinkSync = function unlinkSync (p) {
        try {
            this._FS.unlink(p);
        }
        catch (e) {
            throw convertError(e, p);
        }
    };
    EmscriptenFileSystem.prototype.rmdirSync = function rmdirSync (p) {
        try {
            this._FS.rmdir(p);
        }
        catch (e) {
            throw convertError(e, p);
        }
    };
    EmscriptenFileSystem.prototype.mkdirSync = function mkdirSync (p, mode) {
        try {
            this._FS.mkdir(p, mode);
        }
        catch (e) {
            throw convertError(e, p);
        }
    };
    EmscriptenFileSystem.prototype.readdirSync = function readdirSync (p) {
        try {
            // Emscripten returns items for '.' and '..'. Node does not.
            return this._FS.readdir(p).filter(function (p) { return p !== '.' && p !== '..'; });
        }
        catch (e) {
            throw convertError(e, p);
        }
    };
    EmscriptenFileSystem.prototype.truncateSync = function truncateSync (p, len) {
        try {
            this._FS.truncate(p, len);
        }
        catch (e) {
            throw convertError(e, p);
        }
    };
    EmscriptenFileSystem.prototype.readFileSync = function readFileSync (p, encoding, flag) {
        try {
            var data = this._FS.readFile(p, { flags: flag.getFlagString() });
            var buff = uint8Array2Buffer(data);
            if (encoding) {
                return buff.toString(encoding);
            }
            else {
                return buff;
            }
        }
        catch (e) {
            throw convertError(e, p);
        }
    };
    EmscriptenFileSystem.prototype.writeFileSync = function writeFileSync (p, data, encoding, flag, mode) {
        try {
            if (encoding) {
                data = Buffer.from(data, encoding);
            }
            var u8 = buffer2Uint8array(data);
            this._FS.writeFile(p, u8, { flags: flag.getFlagString(), encoding: 'binary' });
            this._FS.chmod(p, mode);
        }
        catch (e) {
            throw convertError(e, p);
        }
    };
    EmscriptenFileSystem.prototype.chmodSync = function chmodSync (p, isLchmod, mode) {
        try {
            isLchmod ? this._FS.lchmod(p, mode) : this._FS.chmod(p, mode);
        }
        catch (e) {
            throw convertError(e, p);
        }
    };
    EmscriptenFileSystem.prototype.chownSync = function chownSync (p, isLchown, uid, gid) {
        try {
            isLchown ? this._FS.lchown(p, uid, gid) : this._FS.chown(p, uid, gid);
        }
        catch (e) {
            throw convertError(e, p);
        }
    };
    EmscriptenFileSystem.prototype.symlinkSync = function symlinkSync (srcpath, dstpath, type) {
        try {
            this._FS.symlink(srcpath, dstpath);
        }
        catch (e) {
            throw convertError(e);
        }
    };
    EmscriptenFileSystem.prototype.readlinkSync = function readlinkSync (p) {
        try {
            return this._FS.readlink(p);
        }
        catch (e) {
            throw convertError(e, p);
        }
    };
    EmscriptenFileSystem.prototype.utimesSync = function utimesSync (p, atime, mtime) {
        try {
            this._FS.utime(p, atime.getTime(), mtime.getTime());
        }
        catch (e) {
            throw convertError(e, p);
        }
    };
    EmscriptenFileSystem.prototype.modeToFileType = function modeToFileType (mode) {
        if (this._FS.isDir(mode)) {
            return FileType.DIRECTORY;
        }
        else if (this._FS.isFile(mode)) {
            return FileType.FILE;
        }
        else if (this._FS.isLink(mode)) {
            return FileType.SYMLINK;
        }
        else {
            throw ApiError.EPERM(("Invalid mode: " + mode));
        }
    };

    return EmscriptenFileSystem;
}(SynchronousFileSystem));

EmscriptenFileSystem.Name = "EmscriptenFileSystem";
EmscriptenFileSystem.Options = {
    FS: {
        type: "object",
        description: "The Emscripten file system to use (the `FS` variable)"
    }
};

/**
 * The FolderAdapter file system wraps a file system, and scopes all interactions to a subfolder of that file system.
 *
 * Example: Given a file system `foo` with folder `bar` and file `bar/baz`...
 *
 * ```javascript
 * BrowserFS.configure({
 *   fs: "FolderAdapter",
 *   options: {
 *     folder: "bar",
 *     wrapped: foo
 *   }
 * }, function(e) {
 *   var fs = BrowserFS.BFSRequire('fs');
 *   fs.readdirSync('/'); // ['baz']
 * });
 * ```
 */
var FolderAdapter = (function (BaseFileSystem$$1) {
    function FolderAdapter(folder, wrapped) {
        BaseFileSystem$$1.call(this);
        this._folder = folder;
        this._wrapped = wrapped;
    }

    if ( BaseFileSystem$$1 ) FolderAdapter.__proto__ = BaseFileSystem$$1;
    FolderAdapter.prototype = Object.create( BaseFileSystem$$1 && BaseFileSystem$$1.prototype );
    FolderAdapter.prototype.constructor = FolderAdapter;
    /**
     * Creates a FolderAdapter instance with the given options.
     */
    FolderAdapter.Create = function Create (opts, cb) {
        var fa = new FolderAdapter(opts.folder, opts.wrapped);
        fa._initialize(function (e) {
            if (e) {
                cb(e);
            }
            else {
                cb(null, fa);
            }
        });
    };
    FolderAdapter.isAvailable = function isAvailable () {
        return true;
    };
    FolderAdapter.prototype.getName = function getName () { return this._wrapped.getName(); };
    FolderAdapter.prototype.isReadOnly = function isReadOnly () { return this._wrapped.isReadOnly(); };
    FolderAdapter.prototype.supportsProps = function supportsProps () { return this._wrapped.supportsProps(); };
    FolderAdapter.prototype.supportsSynch = function supportsSynch () { return this._wrapped.supportsSynch(); };
    FolderAdapter.prototype.supportsLinks = function supportsLinks () { return false; };
    /**
     * Initialize the file system. Ensures that the wrapped file system
     * has the given folder.
     */
    FolderAdapter.prototype._initialize = function _initialize (cb) {
        var this$1 = this;

        this._wrapped.exists(this._folder, function (exists) {
            if (exists) {
                cb();
            }
            else if (this$1._wrapped.isReadOnly()) {
                cb(ApiError.ENOENT(this$1._folder));
            }
            else {
                this$1._wrapped.mkdir(this$1._folder, 0x1ff, cb);
            }
        });
    };

    return FolderAdapter;
}(BaseFileSystem));

FolderAdapter.Name = "FolderAdapter";
FolderAdapter.Options = {
    folder: {
        type: "string",
        description: "The folder to use as the root directory"
    },
    wrapped: {
        type: "object",
        description: "The file system to wrap"
    }
};
/**
 * @hidden
 */
function translateError(folder, e) {
    if (e !== null && typeof e === 'object') {
        var err = e;
        var p = err.path;
        if (p) {
            p = '/' + path.relative(folder, p);
            err.message = err.message.replace(err.path, p);
            err.path = p;
        }
    }
    return e;
}
/**
 * @hidden
 */
function wrapCallback(folder, cb) {
    if (typeof cb === 'function') {
        return function (err) {
            if (arguments.length > 0) {
                arguments[0] = translateError(folder, err);
            }
            cb.apply(null, arguments);
        };
    }
    else {
        return cb;
    }
}
/**
 * @hidden
 */
function wrapFunction(name, wrapFirst, wrapSecond) {
    if (name.slice(name.length - 4) !== 'Sync') {
        // Async function. Translate error in callback.
        return function () {
            if (arguments.length > 0) {
                if (wrapFirst) {
                    arguments[0] = path.join(this._folder, arguments[0]);
                }
                if (wrapSecond) {
                    arguments[1] = path.join(this._folder, arguments[1]);
                }
                arguments[arguments.length - 1] = wrapCallback(this._folder, arguments[arguments.length - 1]);
            }
            return this._wrapped[name].apply(this._wrapped, arguments);
        };
    }
    else {
        // Sync function. Translate error in catch.
        return function () {
            try {
                if (wrapFirst) {
                    arguments[0] = path.join(this._folder, arguments[0]);
                }
                if (wrapSecond) {
                    arguments[1] = path.join(this._folder, arguments[1]);
                }
                return this._wrapped[name].apply(this._wrapped, arguments);
            }
            catch (e) {
                throw translateError(this._folder, e);
            }
        };
    }
}
// First argument is a path.
['diskSpace', 'stat', 'statSync', 'open', 'openSync', 'unlink', 'unlinkSync',
    'rmdir', 'rmdirSync', 'mkdir', 'mkdirSync', 'readdir', 'readdirSync', 'exists',
    'existsSync', 'realpath', 'realpathSync', 'truncate', 'truncateSync', 'readFile',
    'readFileSync', 'writeFile', 'writeFileSync', 'appendFile', 'appendFileSync',
    'chmod', 'chmodSync', 'chown', 'chownSync', 'utimes', 'utimesSync', 'readlink',
    'readlinkSync'].forEach(function (name) {
    FolderAdapter.prototype[name] = wrapFunction(name, true, false);
});
// First and second arguments are paths.
['rename', 'renameSync', 'link', 'linkSync', 'symlink', 'symlinkSync'].forEach(function (name) {
    FolderAdapter.prototype[name] = wrapFunction(name, true, true);
});

function slice(arrayLike, start) {
    start = start|0;
    var newLen = Math.max(arrayLike.length - start, 0);
    var newArr = Array(newLen);
    for(var idx = 0; idx < newLen; idx++)  {
        newArr[idx] = arrayLike[start + idx];
    }
    return newArr;
}

var initialParams = function (fn) {
    return function (/*...args, callback*/) {
        var args = slice(arguments);
        var callback = args.pop();
        fn.call(this, args, callback);
    };
};

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

var hasSetImmediate = typeof setImmediate === 'function' && setImmediate;
var hasNextTick = typeof process === 'object' && typeof process.nextTick === 'function';

function fallback(fn) {
    setTimeout(fn, 0);
}

function wrap(defer) {
    return function (fn/*, ...args*/) {
        var args = slice(arguments, 1);
        defer(function () {
            fn.apply(null, args);
        });
    };
}

var _defer;

if (hasSetImmediate) {
    _defer = setImmediate;
} else if (hasNextTick) {
    _defer = process.nextTick;
} else {
    _defer = fallback;
}

var setImmediate$2 = wrap(_defer);

/**
 * Take a sync function and make it async, passing its return value to a
 * callback. This is useful for plugging sync functions into a waterfall,
 * series, or other async functions. Any arguments passed to the generated
 * function will be passed to the wrapped function (except for the final
 * callback argument). Errors thrown will be passed to the callback.
 *
 * If the function passed to `asyncify` returns a Promise, that promises's
 * resolved/rejected state will be used to call the callback, rather than simply
 * the synchronous return value.
 *
 * This also means you can asyncify ES2017 `async` functions.
 *
 * @name asyncify
 * @static
 * @memberOf module:Utils
 * @method
 * @alias wrapSync
 * @category Util
 * @param {Function} func - The synchronous function, or Promise-returning
 * function to convert to an {@link AsyncFunction}.
 * @returns {AsyncFunction} An asynchronous wrapper of the `func`. To be
 * invoked with `(args..., callback)`.
 * @example
 *
 * // passing a regular synchronous function
 * async.waterfall([
 *     async.apply(fs.readFile, filename, "utf8"),
 *     async.asyncify(JSON.parse),
 *     function (data, next) {
 *         // data is the result of parsing the text.
 *         // If there was a parsing error, it would have been caught.
 *     }
 * ], callback);
 *
 * // passing a function returning a promise
 * async.waterfall([
 *     async.apply(fs.readFile, filename, "utf8"),
 *     async.asyncify(function (contents) {
 *         return db.model.create(contents);
 *     }),
 *     function (model, next) {
 *         // `model` is the instantiated model object.
 *         // If there was an error, this function would be skipped.
 *     }
 * ], callback);
 *
 * // es2017 example, though `asyncify` is not needed if your JS environment
 * // supports async functions out of the box
 * var q = async.queue(async.asyncify(async function(file) {
 *     var intermediateStep = await processFile(file);
 *     return await somePromise(intermediateStep)
 * }));
 *
 * q.push(files);
 */
function asyncify(func) {
    return initialParams(function (args, callback) {
        var result;
        try {
            result = func.apply(this, args);
        } catch (e) {
            return callback(e);
        }
        // if result is Promise object
        if (isObject(result) && typeof result.then === 'function') {
            result.then(function(value) {
                invokeCallback(callback, null, value);
            }, function(err) {
                invokeCallback(callback, err.message ? err : new Error(err));
            });
        } else {
            callback(null, result);
        }
    });
}

function invokeCallback(callback, error, value) {
    try {
        callback(error, value);
    } catch (e) {
        setImmediate$2(rethrow, e);
    }
}

function rethrow(error) {
    throw error;
}

var supportsSymbol = typeof Symbol === 'function';

function isAsync(fn) {
    return supportsSymbol && fn[Symbol.toStringTag] === 'AsyncFunction';
}

function wrapAsync(asyncFn) {
    return isAsync(asyncFn) ? asyncify(asyncFn) : asyncFn;
}

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/** Built-in value references. */
var Symbol$1 = root.Symbol;

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Built-in value references. */
var symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag$1),
      tag = value[symToStringTag$1];

  try {
    value[symToStringTag$1] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag$1] = tag;
    } else {
      delete value[symToStringTag$1];
    }
  }
  return result;
}

/** Used for built-in method references. */
var objectProto$1 = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString$1 = objectProto$1.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString$1.call(value);
}

/** `Object#toString` result references. */
var nullTag = '[object Null]';
var undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = Symbol$1 ? Symbol$1.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? getRawTag(value)
    : objectToString(value);
}

/** `Object#toString` result references. */
var asyncTag = '[object AsyncFunction]';
var funcTag = '[object Function]';
var genTag = '[object GeneratorFunction]';
var proxyTag = '[object Proxy]';

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  if (!isObject(value)) {
    return false;
  }
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag = baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

// A temporary value used to identify if the loop should be broken.
// See #1064, #1293
var breakLoop = {};

/**
 * This method returns `undefined`.
 *
 * @static
 * @memberOf _
 * @since 2.3.0
 * @category Util
 * @example
 *
 * _.times(2, _.noop);
 * // => [undefined, undefined]
 */
function noop() {
  // No operation performed.
}

function once(fn) {
    return function () {
        if (fn === null) { return; }
        var callFn = fn;
        fn = null;
        callFn.apply(this, arguments);
    };
}

var iteratorSymbol = typeof Symbol === 'function' && Symbol.iterator;

var getIterator = function (coll) {
    return iteratorSymbol && coll[iteratorSymbol] && coll[iteratorSymbol]();
};

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

/** `Object#toString` result references. */
var argsTag = '[object Arguments]';

/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag;
}

/** Used for built-in method references. */
var objectProto$3 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$2 = objectProto$3.hasOwnProperty;

/** Built-in value references. */
var propertyIsEnumerable = objectProto$3.propertyIsEnumerable;

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
  return isObjectLike(value) && hasOwnProperty$2.call(value, 'callee') &&
    !propertyIsEnumerable.call(value, 'callee');
};

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer$1 = moduleExports ? root.Buffer : undefined;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeIsBuffer = Buffer$1 ? Buffer$1.isBuffer : undefined;

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || stubFalse;

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER$1 = 9007199254740991;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  length = length == null ? MAX_SAFE_INTEGER$1 : length;
  return !!length &&
    (typeof value == 'number' || reIsUint.test(value)) &&
    (value > -1 && value % 1 == 0 && value < length);
}

/** `Object#toString` result references. */
var argsTag$1 = '[object Arguments]';
var arrayTag = '[object Array]';
var boolTag = '[object Boolean]';
var dateTag = '[object Date]';
var errorTag = '[object Error]';
var funcTag$1 = '[object Function]';
var mapTag = '[object Map]';
var numberTag = '[object Number]';
var objectTag = '[object Object]';
var regexpTag = '[object RegExp]';
var setTag = '[object Set]';
var stringTag = '[object String]';
var weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]';
var dataViewTag = '[object DataView]';
var float32Tag = '[object Float32Array]';
var float64Tag = '[object Float64Array]';
var int8Tag = '[object Int8Array]';
var int16Tag = '[object Int16Array]';
var int32Tag = '[object Int32Array]';
var uint8Tag = '[object Uint8Array]';
var uint8ClampedTag = '[object Uint8ClampedArray]';
var uint16Tag = '[object Uint16Array]';
var uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag$1] = typedArrayTags[arrayTag] =
typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
typedArrayTags[errorTag] = typedArrayTags[funcTag$1] =
typedArrayTags[mapTag] = typedArrayTags[numberTag] =
typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
typedArrayTags[setTag] = typedArrayTags[stringTag] =
typedArrayTags[weakMapTag] = false;

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
  return isObjectLike(value) &&
    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

/** Detect free variable `exports`. */
var freeExports$1 = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule$1 = freeExports$1 && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports$1 && freeGlobal.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = (function() {
  try {
    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}());

/* Node.js helper references. */
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

/** Used for built-in method references. */
var objectProto$2 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$1 = objectProto$2.hasOwnProperty;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value),
      isArg = !isArr && isArguments(value),
      isBuff = !isArr && !isArg && isBuffer(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty$1.call(value, key)) &&
        !(skipIndexes && (
           // Safari 9 has enumerable `arguments.length` in strict mode.
           key == 'length' ||
           // Node.js 0.10 has enumerable non-index properties on buffers.
           (isBuff && (key == 'offset' || key == 'parent')) ||
           // PhantomJS 2 has enumerable non-index properties on typed arrays.
           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
           // Skip index properties.
           isIndex(key, length)
        ))) {
      result.push(key);
    }
  }
  return result;
}

/** Used for built-in method references. */
var objectProto$5 = Object.prototype;

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto$5;

  return value === proto;
}

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeKeys = overArg(Object.keys, Object);

/** Used for built-in method references. */
var objectProto$4 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$3 = objectProto$4.hasOwnProperty;

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty$3.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

function createArrayIterator(coll) {
    var i = -1;
    var len = coll.length;
    return function next() {
        return ++i < len ? {value: coll[i], key: i} : null;
    }
}

function createES2015Iterator(iterator) {
    var i = -1;
    return function next() {
        var item = iterator.next();
        if (item.done)
            { return null; }
        i++;
        return {value: item.value, key: i};
    }
}

function createObjectIterator(obj) {
    var okeys = keys(obj);
    var i = -1;
    var len = okeys.length;
    return function next() {
        var key = okeys[++i];
        return i < len ? {value: obj[key], key: key} : null;
    };
}

function iterator(coll) {
    if (isArrayLike(coll)) {
        return createArrayIterator(coll);
    }

    var iterator = getIterator(coll);
    return iterator ? createES2015Iterator(iterator) : createObjectIterator(coll);
}

function onlyOnce(fn) {
    return function() {
        if (fn === null) { throw new Error("Callback was already called."); }
        var callFn = fn;
        fn = null;
        callFn.apply(this, arguments);
    };
}

function _eachOfLimit(limit) {
    return function (obj, iteratee, callback) {
        callback = once(callback || noop);
        if (limit <= 0 || !obj) {
            return callback(null);
        }
        var nextElem = iterator(obj);
        var done = false;
        var running = 0;

        function iterateeCallback(err, value) {
            running -= 1;
            if (err) {
                done = true;
                callback(err);
            }
            else if (value === breakLoop || (done && running <= 0)) {
                done = true;
                return callback(null);
            }
            else {
                replenish();
            }
        }

        function replenish () {
            while (running < limit && !done) {
                var elem = nextElem();
                if (elem === null) {
                    done = true;
                    if (running <= 0) {
                        callback(null);
                    }
                    return;
                }
                running += 1;
                iteratee(elem.value, elem.key, onlyOnce(iterateeCallback));
            }
        }

        replenish();
    };
}

/**
 * The same as [`eachOf`]{@link module:Collections.eachOf} but runs a maximum of `limit` async operations at a
 * time.
 *
 * @name eachOfLimit
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.eachOf]{@link module:Collections.eachOf}
 * @alias forEachOfLimit
 * @category Collection
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {number} limit - The maximum number of async operations at a time.
 * @param {AsyncFunction} iteratee - An async function to apply to each
 * item in `coll`. The `key` is the item's key, or index in the case of an
 * array.
 * Invoked with (item, key, callback).
 * @param {Function} [callback] - A callback which is called when all
 * `iteratee` functions have finished, or an error occurs. Invoked with (err).
 */
function eachOfLimit$$1(coll, limit, iteratee, callback) {
    _eachOfLimit(limit)(coll, wrapAsync(iteratee), callback);
}

function doLimit(fn, limit) {
    return function (iterable, iteratee, callback) {
        return fn(iterable, limit, iteratee, callback);
    };
}

// eachOf implementation optimized for array-likes
function eachOfArrayLike(coll, iteratee, callback) {
    callback = once(callback || noop);
    var index = 0,
        completed = 0,
        length = coll.length;
    if (length === 0) {
        callback(null);
    }

    function iteratorCallback(err, value) {
        if (err) {
            callback(err);
        } else if ((++completed === length) || value === breakLoop) {
            callback(null);
        }
    }

    for (; index < length; index++) {
        iteratee(coll[index], index, onlyOnce(iteratorCallback));
    }
}

// a generic version of eachOf which can handle array, object, and iterator cases.
var eachOfGeneric = doLimit(eachOfLimit$$1, Infinity);

/**
 * Like [`each`]{@link module:Collections.each}, except that it passes the key (or index) as the second argument
 * to the iteratee.
 *
 * @name eachOf
 * @static
 * @memberOf module:Collections
 * @method
 * @alias forEachOf
 * @category Collection
 * @see [async.each]{@link module:Collections.each}
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {AsyncFunction} iteratee - A function to apply to each
 * item in `coll`.
 * The `key` is the item's key, or index in the case of an array.
 * Invoked with (item, key, callback).
 * @param {Function} [callback] - A callback which is called when all
 * `iteratee` functions have finished, or an error occurs. Invoked with (err).
 * @example
 *
 * var obj = {dev: "/dev.json", test: "/test.json", prod: "/prod.json"};
 * var configs = {};
 *
 * async.forEachOf(obj, function (value, key, callback) {
 *     fs.readFile(__dirname + value, "utf8", function (err, data) {
 *         if (err) return callback(err);
 *         try {
 *             configs[key] = JSON.parse(data);
 *         } catch (e) {
 *             return callback(e);
 *         }
 *         callback();
 *     });
 * }, function (err) {
 *     if (err) console.error(err.message);
 *     // configs is now a map of JSON data
 *     doSomethingWith(configs);
 * });
 */
var eachOf = function(coll, iteratee, callback) {
    var eachOfImplementation = isArrayLike(coll) ? eachOfArrayLike : eachOfGeneric;
    eachOfImplementation(coll, wrapAsync(iteratee), callback);
};

/**
 * Produces a new collection of values by mapping each value in `coll` through
 * the `iteratee` function. The `iteratee` is called with an item from `coll`
 * and a callback for when it has finished processing. Each of these callback
 * takes 2 arguments: an `error`, and the transformed item from `coll`. If
 * `iteratee` passes an error to its callback, the main `callback` (for the
 * `map` function) is immediately called with the error.
 *
 * Note, that since this function applies the `iteratee` to each item in
 * parallel, there is no guarantee that the `iteratee` functions will complete
 * in order. However, the results array will be in the same order as the
 * original `coll`.
 *
 * If `map` is passed an Object, the results will be an Array.  The results
 * will roughly be in the order of the original Objects' keys (but this can
 * vary across JavaScript engines).
 *
 * @name map
 * @static
 * @memberOf module:Collections
 * @method
 * @category Collection
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {AsyncFunction} iteratee - An async function to apply to each item in
 * `coll`.
 * The iteratee should complete with the transformed item.
 * Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called when all `iteratee`
 * functions have finished, or an error occurs. Results is an Array of the
 * transformed items from the `coll`. Invoked with (err, results).
 * @example
 *
 * async.map(['file1','file2','file3'], fs.stat, function(err, results) {
 *     // results is now an array of stats for each file
 * });
 */

/**
 * Applies the provided arguments to each function in the array, calling
 * `callback` after all functions have completed. If you only provide the first
 * argument, `fns`, then it will return a function which lets you pass in the
 * arguments as if it were a single function call. If more arguments are
 * provided, `callback` is required while `args` is still optional.
 *
 * @name applyEach
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @category Control Flow
 * @param {Array|Iterable|Object} fns - A collection of {@link AsyncFunction}s
 * to all call with the same arguments
 * @param {...*} [args] - any number of separate arguments to pass to the
 * function.
 * @param {Function} [callback] - the final argument should be the callback,
 * called when all functions have completed processing.
 * @returns {Function} - If only the first argument, `fns`, is provided, it will
 * return a function which lets you pass in the arguments as if it were a single
 * function call. The signature is `(..args, callback)`. If invoked with any
 * arguments, `callback` is required.
 * @example
 *
 * async.applyEach([enableSearch, updateSchema], 'bucket', callback);
 *
 * // partial application example:
 * async.each(
 *     buckets,
 *     async.applyEach([enableSearch, updateSchema]),
 *     callback
 * );
 */

/**
 * The same as [`map`]{@link module:Collections.map} but runs a maximum of `limit` async operations at a time.
 *
 * @name mapLimit
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.map]{@link module:Collections.map}
 * @category Collection
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {number} limit - The maximum number of async operations at a time.
 * @param {AsyncFunction} iteratee - An async function to apply to each item in
 * `coll`.
 * The iteratee should complete with the transformed item.
 * Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called when all `iteratee`
 * functions have finished, or an error occurs. Results is an array of the
 * transformed items from the `coll`. Invoked with (err, results).
 */

/**
 * The same as [`map`]{@link module:Collections.map} but runs only a single async operation at a time.
 *
 * @name mapSeries
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.map]{@link module:Collections.map}
 * @category Collection
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {AsyncFunction} iteratee - An async function to apply to each item in
 * `coll`.
 * The iteratee should complete with the transformed item.
 * Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called when all `iteratee`
 * functions have finished, or an error occurs. Results is an array of the
 * transformed items from the `coll`. Invoked with (err, results).
 */

/**
 * The same as [`applyEach`]{@link module:ControlFlow.applyEach} but runs only a single async operation at a time.
 *
 * @name applyEachSeries
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @see [async.applyEach]{@link module:ControlFlow.applyEach}
 * @category Control Flow
 * @param {Array|Iterable|Object} fns - A collection of {@link AsyncFunction}s to all
 * call with the same arguments
 * @param {...*} [args] - any number of separate arguments to pass to the
 * function.
 * @param {Function} [callback] - the final argument should be the callback,
 * called when all functions have completed processing.
 * @returns {Function} - If only the first argument is provided, it will return
 * a function which lets you pass in the arguments as if it were a single
 * function call.
 */

/**
 * A specialized version of `_.forEach` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */
function arrayEach(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }
  return array;
}

/**
 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseFor(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index = -1,
        iterable = Object(object),
        props = keysFunc(object),
        length = props.length;

    while (length--) {
      var key = props[fromRight ? length : ++index];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}

/**
 * The base implementation of `baseForOwn` which iterates over `object`
 * properties returned by `keysFunc` and invokes `iteratee` for each property.
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */
var baseFor = createBaseFor();

/**
 * The base implementation of `_.forOwn` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Object} Returns `object`.
 */
function baseForOwn(object, iteratee) {
  return object && baseFor(object, iteratee, keys);
}

/**
 * The base implementation of `_.findIndex` and `_.findLastIndex` without
 * support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} predicate The function invoked per iteration.
 * @param {number} fromIndex The index to search from.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseFindIndex(array, predicate, fromIndex, fromRight) {
  var length = array.length,
      index = fromIndex + (fromRight ? 1 : -1);

  while ((fromRight ? index-- : ++index < length)) {
    if (predicate(array[index], index, array)) {
      return index;
    }
  }
  return -1;
}

/**
 * The base implementation of `_.isNaN` without support for number objects.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
 */
function baseIsNaN(value) {
  return value !== value;
}

/**
 * A specialized version of `_.indexOf` which performs strict equality
 * comparisons of values, i.e. `===`.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function strictIndexOf(array, value, fromIndex) {
  var index = fromIndex - 1,
      length = array.length;

  while (++index < length) {
    if (array[index] === value) {
      return index;
    }
  }
  return -1;
}

/**
 * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseIndexOf(array, value, fromIndex) {
  return value === value
    ? strictIndexOf(array, value, fromIndex)
    : baseFindIndex(array, baseIsNaN, fromIndex);
}

/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */

/**
 * The base implementation of `_.slice` without an iteratee call guard.
 *
 * @private
 * @param {Array} array The array to slice.
 * @param {number} [start=0] The start position.
 * @param {number} [end=array.length] The end position.
 * @returns {Array} Returns the slice of `array`.
 */

/**
 * Converts an ASCII `string` to an array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the converted array.
 */

/** Used to compose unicode character classes. */

/** Used to compose unicode character classes. */
var rsAstralRange$1 = '\\ud800-\\udfff';
var rsComboMarksRange$1 = '\\u0300-\\u036f';
var reComboHalfMarksRange$1 = '\\ufe20-\\ufe2f';
var rsComboSymbolsRange$1 = '\\u20d0-\\u20ff';
var rsComboRange$1 = rsComboMarksRange$1 + reComboHalfMarksRange$1 + rsComboSymbolsRange$1;
var rsVarRange$1 = '\\ufe0e\\ufe0f';

/** Used to compose unicode capture groups. */
var rsAstral = '[' + rsAstralRange$1 + ']';
var rsCombo = '[' + rsComboRange$1 + ']';
var rsFitz = '\\ud83c[\\udffb-\\udfff]';
var rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')';
var rsNonAstral = '[^' + rsAstralRange$1 + ']';
var rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}';
var rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]';
var rsZWJ$1 = '\\u200d';

/** Used to compose unicode regexes. */
var reOptMod = rsModifier + '?';
var rsOptVar = '[' + rsVarRange$1 + ']?';
var rsOptJoin = '(?:' + rsZWJ$1 + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*';
var rsSeq = rsOptVar + reOptMod + rsOptJoin;
var rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';

// Simple doubly linked list (https://en.wikipedia.org/wiki/Doubly_linked_list) implementation
// used for queues. This implementation assumes that the node provided by the user can be modified
// to adjust the next and last properties. We implement only the minimal functionality
// for queue support.

/**
 * The same as [`eachOf`]{@link module:Collections.eachOf} but runs only a single async operation at a time.
 *
 * @name eachOfSeries
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.eachOf]{@link module:Collections.eachOf}
 * @alias forEachOfSeries
 * @category Collection
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {AsyncFunction} iteratee - An async function to apply to each item in
 * `coll`.
 * Invoked with (item, key, callback).
 * @param {Function} [callback] - A callback which is called when all `iteratee`
 * functions have finished, or an error occurs. Invoked with (err).
 */

/**
 * Applies `iteratee` to each item in `coll`, concatenating the results. Returns
 * the concatenated list. The `iteratee`s are called in parallel, and the
 * results are concatenated as they return. There is no guarantee that the
 * results array will be returned in the original order of `coll` passed to the
 * `iteratee` function.
 *
 * @name concat
 * @static
 * @memberOf module:Collections
 * @method
 * @category Collection
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {AsyncFunction} iteratee - A function to apply to each item in `coll`,
 * which should use an array as its result. Invoked with (item, callback).
 * @param {Function} [callback(err)] - A callback which is called after all the
 * `iteratee` functions have finished, or an error occurs. Results is an array
 * containing the concatenated results of the `iteratee` function. Invoked with
 * (err, results).
 * @example
 *
 * async.concat(['dir1','dir2','dir3'], fs.readdir, function(err, files) {
 *     // files is now a list of filenames that exist in the 3 directories
 * });
 */

/**
 * The same as [`concat`]{@link module:Collections.concat} but runs only a single async operation at a time.
 *
 * @name concatSeries
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.concat]{@link module:Collections.concat}
 * @category Collection
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {AsyncFunction} iteratee - A function to apply to each item in `coll`.
 * The iteratee should complete with an array an array of results.
 * Invoked with (item, callback).
 * @param {Function} [callback(err)] - A callback which is called after all the
 * `iteratee` functions have finished, or an error occurs. Results is an array
 * containing the concatenated results of the `iteratee` function. Invoked with
 * (err, results).
 */

/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */

/**
 * Returns the first value in `coll` that passes an async truth test. The
 * `iteratee` is applied in parallel, meaning the first iteratee to return
 * `true` will fire the detect `callback` with that result. That means the
 * result might not be the first item in the original `coll` (in terms of order)
 * that passes the test.

 * If order within the original `coll` is important, then look at
 * [`detectSeries`]{@link module:Collections.detectSeries}.
 *
 * @name detect
 * @static
 * @memberOf module:Collections
 * @method
 * @alias find
 * @category Collections
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {AsyncFunction} iteratee - A truth test to apply to each item in `coll`.
 * The iteratee must complete with a boolean value as its result.
 * Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called as soon as any
 * iteratee returns `true`, or after all the `iteratee` functions have finished.
 * Result will be the first item in the array that passes the truth test
 * (iteratee) or the value `undefined` if none passed. Invoked with
 * (err, result).
 * @example
 *
 * async.detect(['file1','file2','file3'], function(filePath, callback) {
 *     fs.access(filePath, function(err) {
 *         callback(null, !err)
 *     });
 * }, function(err, result) {
 *     // result now equals the first file in the list that exists
 * });
 */

/**
 * The same as [`detect`]{@link module:Collections.detect} but runs a maximum of `limit` async operations at a
 * time.
 *
 * @name detectLimit
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.detect]{@link module:Collections.detect}
 * @alias findLimit
 * @category Collections
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {number} limit - The maximum number of async operations at a time.
 * @param {AsyncFunction} iteratee - A truth test to apply to each item in `coll`.
 * The iteratee must complete with a boolean value as its result.
 * Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called as soon as any
 * iteratee returns `true`, or after all the `iteratee` functions have finished.
 * Result will be the first item in the array that passes the truth test
 * (iteratee) or the value `undefined` if none passed. Invoked with
 * (err, result).
 */

/**
 * The same as [`detect`]{@link module:Collections.detect} but runs only a single async operation at a time.
 *
 * @name detectSeries
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.detect]{@link module:Collections.detect}
 * @alias findSeries
 * @category Collections
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {AsyncFunction} iteratee - A truth test to apply to each item in `coll`.
 * The iteratee must complete with a boolean value as its result.
 * Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called as soon as any
 * iteratee returns `true`, or after all the `iteratee` functions have finished.
 * Result will be the first item in the array that passes the truth test
 * (iteratee) or the value `undefined` if none passed. Invoked with
 * (err, result).
 */

/**
 * Logs the result of an [`async` function]{@link AsyncFunction} to the
 * `console` using `console.dir` to display the properties of the resulting object.
 * Only works in Node.js or in browsers that support `console.dir` and
 * `console.error` (such as FF and Chrome).
 * If multiple arguments are returned from the async function,
 * `console.dir` is called on each argument in order.
 *
 * @name dir
 * @static
 * @memberOf module:Utils
 * @method
 * @category Util
 * @param {AsyncFunction} function - The function you want to eventually apply
 * all arguments to.
 * @param {...*} arguments... - Any number of arguments to apply to the function.
 * @example
 *
 * // in a module
 * var hello = function(name, callback) {
 *     setTimeout(function() {
 *         callback(null, {hello: name});
 *     }, 1000);
 * };
 *
 * // in the node repl
 * node> async.dir(hello, 'world');
 * {hello: 'world'}
 */

function _withoutIndex(iteratee) {
    return function (value, index, callback) {
        return iteratee(value, callback);
    };
}

/**
 * Applies the function `iteratee` to each item in `coll`, in parallel.
 * The `iteratee` is called with an item from the list, and a callback for when
 * it has finished. If the `iteratee` passes an error to its `callback`, the
 * main `callback` (for the `each` function) is immediately called with the
 * error.
 *
 * Note, that since this function applies `iteratee` to each item in parallel,
 * there is no guarantee that the iteratee functions will complete in order.
 *
 * @name each
 * @static
 * @memberOf module:Collections
 * @method
 * @alias forEach
 * @category Collection
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {AsyncFunction} iteratee - An async function to apply to
 * each item in `coll`. Invoked with (item, callback).
 * The array index is not passed to the iteratee.
 * If you need the index, use `eachOf`.
 * @param {Function} [callback] - A callback which is called when all
 * `iteratee` functions have finished, or an error occurs. Invoked with (err).
 * @example
 *
 * // assuming openFiles is an array of file names and saveFile is a function
 * // to save the modified contents of that file:
 *
 * async.each(openFiles, saveFile, function(err){
 *   // if any of the saves produced an error, err would equal that error
 * });
 *
 * // assuming openFiles is an array of file names
 * async.each(openFiles, function(file, callback) {
 *
 *     // Perform operation on file here.
 *     console.log('Processing file ' + file);
 *
 *     if( file.length > 32 ) {
 *       console.log('This file name is too long');
 *       callback('File name too long');
 *     } else {
 *       // Do work to process file here
 *       console.log('File processed');
 *       callback();
 *     }
 * }, function(err) {
 *     // if any of the file processing produced an error, err would equal that error
 *     if( err ) {
 *       // One of the iterations produced an error.
 *       // All processing will now stop.
 *       console.log('A file failed to process');
 *     } else {
 *       console.log('All files have been processed successfully');
 *     }
 * });
 */
function eachLimit(coll, iteratee, callback) {
    eachOf(coll, _withoutIndex(wrapAsync(iteratee)), callback);
}

/**
 * The same as [`each`]{@link module:Collections.each} but runs only a single async operation at a time.
 *
 * @name eachSeries
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.each]{@link module:Collections.each}
 * @alias forEachSeries
 * @category Collection
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {AsyncFunction} iteratee - An async function to apply to each
 * item in `coll`.
 * The array index is not passed to the iteratee.
 * If you need the index, use `eachOfSeries`.
 * Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called when all
 * `iteratee` functions have finished, or an error occurs. Invoked with (err).
 */

/**
 * Returns `true` if every element in `coll` satisfies an async test. If any
 * iteratee call returns `false`, the main `callback` is immediately called.
 *
 * @name every
 * @static
 * @memberOf module:Collections
 * @method
 * @alias all
 * @category Collection
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {AsyncFunction} iteratee - An async truth test to apply to each item
 * in the collection in parallel.
 * The iteratee must complete with a boolean result value.
 * Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called after all the
 * `iteratee` functions have finished. Result will be either `true` or `false`
 * depending on the values of the async tests. Invoked with (err, result).
 * @example
 *
 * async.every(['file1','file2','file3'], function(filePath, callback) {
 *     fs.access(filePath, function(err) {
 *         callback(null, !err)
 *     });
 * }, function(err, result) {
 *     // if result is true then every file exists
 * });
 */

/**
 * The same as [`every`]{@link module:Collections.every} but runs a maximum of `limit` async operations at a time.
 *
 * @name everyLimit
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.every]{@link module:Collections.every}
 * @alias allLimit
 * @category Collection
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {number} limit - The maximum number of async operations at a time.
 * @param {AsyncFunction} iteratee - An async truth test to apply to each item
 * in the collection in parallel.
 * The iteratee must complete with a boolean result value.
 * Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called after all the
 * `iteratee` functions have finished. Result will be either `true` or `false`
 * depending on the values of the async tests. Invoked with (err, result).
 */

/**
 * The same as [`every`]{@link module:Collections.every} but runs only a single async operation at a time.
 *
 * @name everySeries
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.every]{@link module:Collections.every}
 * @alias allSeries
 * @category Collection
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {AsyncFunction} iteratee - An async truth test to apply to each item
 * in the collection in series.
 * The iteratee must complete with a boolean result value.
 * Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called after all the
 * `iteratee` functions have finished. Result will be either `true` or `false`
 * depending on the values of the async tests. Invoked with (err, result).
 */

/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new accessor function.
 */

/**
 * Returns a new array of all the values in `coll` which pass an async truth
 * test. This operation is performed in parallel, but the results array will be
 * in the same order as the original.
 *
 * @name filter
 * @static
 * @memberOf module:Collections
 * @method
 * @alias select
 * @category Collection
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {Function} iteratee - A truth test to apply to each item in `coll`.
 * The `iteratee` is passed a `callback(err, truthValue)`, which must be called
 * with a boolean argument once it has completed. Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called after all the
 * `iteratee` functions have finished. Invoked with (err, results).
 * @example
 *
 * async.filter(['file1','file2','file3'], function(filePath, callback) {
 *     fs.access(filePath, function(err) {
 *         callback(null, !err)
 *     });
 * }, function(err, results) {
 *     // results now equals an array of the existing files
 * });
 */

/**
 * The same as [`filter`]{@link module:Collections.filter} but runs a maximum of `limit` async operations at a
 * time.
 *
 * @name filterLimit
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.filter]{@link module:Collections.filter}
 * @alias selectLimit
 * @category Collection
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {number} limit - The maximum number of async operations at a time.
 * @param {Function} iteratee - A truth test to apply to each item in `coll`.
 * The `iteratee` is passed a `callback(err, truthValue)`, which must be called
 * with a boolean argument once it has completed. Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called after all the
 * `iteratee` functions have finished. Invoked with (err, results).
 */

/**
 * The same as [`filter`]{@link module:Collections.filter} but runs only a single async operation at a time.
 *
 * @name filterSeries
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.filter]{@link module:Collections.filter}
 * @alias selectSeries
 * @category Collection
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {Function} iteratee - A truth test to apply to each item in `coll`.
 * The `iteratee` is passed a `callback(err, truthValue)`, which must be called
 * with a boolean argument once it has completed. Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called after all the
 * `iteratee` functions have finished. Invoked with (err, results)
 */

/**
 * Returns a new object, where each value corresponds to an array of items, from
 * `coll`, that returned the corresponding key. That is, the keys of the object
 * correspond to the values passed to the `iteratee` callback.
 *
 * Note: Since this function applies the `iteratee` to each item in parallel,
 * there is no guarantee that the `iteratee` functions will complete in order.
 * However, the values for each key in the `result` will be in the same order as
 * the original `coll`. For Objects, the values will roughly be in the order of
 * the original Objects' keys (but this can vary across JavaScript engines).
 *
 * @name groupBy
 * @static
 * @memberOf module:Collections
 * @method
 * @category Collection
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {AsyncFunction} iteratee - An async function to apply to each item in
 * `coll`.
 * The iteratee should complete with a `key` to group the value under.
 * Invoked with (value, callback).
 * @param {Function} [callback] - A callback which is called when all `iteratee`
 * functions have finished, or an error occurs. Result is an `Object` whoses
 * properties are arrays of values which returned the corresponding key.
 * @example
 *
 * async.groupBy(['userId1', 'userId2', 'userId3'], function(userId, callback) {
 *     db.findById(userId, function(err, user) {
 *         if (err) return callback(err);
 *         return callback(null, user.age);
 *     });
 * }, function(err, result) {
 *     // result is object containing the userIds grouped by age
 *     // e.g. { 30: ['userId1', 'userId3'], 42: ['userId2']};
 * });
 */

/**
 * The same as [`groupBy`]{@link module:Collections.groupBy} but runs only a single async operation at a time.
 *
 * @name groupBySeries
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.groupBy]{@link module:Collections.groupBy}
 * @category Collection
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {number} limit - The maximum number of async operations at a time.
 * @param {AsyncFunction} iteratee - An async function to apply to each item in
 * `coll`.
 * The iteratee should complete with a `key` to group the value under.
 * Invoked with (value, callback).
 * @param {Function} [callback] - A callback which is called when all `iteratee`
 * functions have finished, or an error occurs. Result is an `Object` whoses
 * properties are arrays of values which returned the corresponding key.
 */

/**
 * Logs the result of an `async` function to the `console`. Only works in
 * Node.js or in browsers that support `console.log` and `console.error` (such
 * as FF and Chrome). If multiple arguments are returned from the async
 * function, `console.log` is called on each argument in order.
 *
 * @name log
 * @static
 * @memberOf module:Utils
 * @method
 * @category Util
 * @param {AsyncFunction} function - The function you want to eventually apply
 * all arguments to.
 * @param {...*} arguments... - Any number of arguments to apply to the function.
 * @example
 *
 * // in a module
 * var hello = function(name, callback) {
 *     setTimeout(function() {
 *         callback(null, 'hello ' + name);
 *     }, 1000);
 * };
 *
 * // in the node repl
 * node> async.log(hello, 'world');
 * 'hello world'
 */

/**
 * A relative of [`map`]{@link module:Collections.map}, designed for use with objects.
 *
 * Produces a new Object by mapping each value of `obj` through the `iteratee`
 * function. The `iteratee` is called each `value` and `key` from `obj` and a
 * callback for when it has finished processing. Each of these callbacks takes
 * two arguments: an `error`, and the transformed item from `obj`. If `iteratee`
 * passes an error to its callback, the main `callback` (for the `mapValues`
 * function) is immediately called with the error.
 *
 * Note, the order of the keys in the result is not guaranteed.  The keys will
 * be roughly in the order they complete, (but this is very engine-specific)
 *
 * @name mapValues
 * @static
 * @memberOf module:Collections
 * @method
 * @category Collection
 * @param {Object} obj - A collection to iterate over.
 * @param {AsyncFunction} iteratee - A function to apply to each value and key
 * in `coll`.
 * The iteratee should complete with the transformed value as its result.
 * Invoked with (value, key, callback).
 * @param {Function} [callback] - A callback which is called when all `iteratee`
 * functions have finished, or an error occurs. `result` is a new object consisting
 * of each key from `obj`, with each transformed value on the right-hand side.
 * Invoked with (err, result).
 * @example
 *
 * async.mapValues({
 *     f1: 'file1',
 *     f2: 'file2',
 *     f3: 'file3'
 * }, function (file, key, callback) {
 *   fs.stat(file, callback);
 * }, function(err, result) {
 *     // result is now a map of stats for each file, e.g.
 *     // {
 *     //     f1: [stats for file1],
 *     //     f2: [stats for file2],
 *     //     f3: [stats for file3]
 *     // }
 * });
 */

/**
 * The same as [`mapValues`]{@link module:Collections.mapValues} but runs only a single async operation at a time.
 *
 * @name mapValuesSeries
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.mapValues]{@link module:Collections.mapValues}
 * @category Collection
 * @param {Object} obj - A collection to iterate over.
 * @param {AsyncFunction} iteratee - A function to apply to each value and key
 * in `coll`.
 * The iteratee should complete with the transformed value as its result.
 * Invoked with (value, key, callback).
 * @param {Function} [callback] - A callback which is called when all `iteratee`
 * functions have finished, or an error occurs. `result` is a new object consisting
 * of each key from `obj`, with each transformed value on the right-hand side.
 * Invoked with (err, result).
 */

/**
 * Calls `callback` on a later loop around the event loop. In Node.js this just
 * calls `setImmediate`.  In the browser it will use `setImmediate` if
 * available, otherwise `setTimeout(callback, 0)`, which means other higher
 * priority events may precede the execution of `callback`.
 *
 * This is used internally for browser-compatibility purposes.
 *
 * @name nextTick
 * @static
 * @memberOf module:Utils
 * @method
 * @alias setImmediate
 * @category Util
 * @param {Function} callback - The function to call on a later loop around
 * the event loop. Invoked with (args...).
 * @param {...*} args... - any number of additional arguments to pass to the
 * callback on the next tick.
 * @example
 *
 * var call_order = [];
 * async.nextTick(function() {
 *     call_order.push('two');
 *     // call_order now equals ['one','two']
 * });
 * call_order.push('one');
 *
 * async.setImmediate(function (a, b, c) {
 *     // a, b, and c equal 1, 2, and 3
 * }, 1, 2, 3);
 */
var _defer$1;

if (hasNextTick) {
    _defer$1 = process.nextTick;
} else if (hasSetImmediate) {
    _defer$1 = setImmediate;
} else {
    _defer$1 = fallback;
}

/**
 * Calls `callback` on a later loop around the event loop. In Node.js this just
 * calls `setImmediate`.  In the browser it will use `setImmediate` if
 * available, otherwise `setTimeout(callback, 0)`, which means other higher
 * priority events may precede the execution of `callback`.
 *
 * This is used internally for browser-compatibility purposes.
 *
 * @name setImmediate
 * @static
 * @memberOf module:Utils
 * @method
 * @alias nextTick
 * @category Util
 * @param {Function} callback - The function to call on a later loop around
 * the event loop. Invoked with (args...).
 * @param {...*} args... - any number of additional arguments to pass to the
 * callback on the next tick.
 * @example
 *
 * var call_order = [];
 * async.nextTick(function() {
 *     call_order.push('two');
 *     // call_order now equals ['one','two']
 * });
 * call_order.push('one');
 *
 * async.setImmediate(function (a, b, c) {
 *     // a, b, and c equal 1, 2, and 3
 * }, 1, 2, 3);
 */

/**
 * The opposite of [`filter`]{@link module:Collections.filter}. Removes values that pass an `async` truth test.
 *
 * @name reject
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.filter]{@link module:Collections.filter}
 * @category Collection
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {Function} iteratee - An async truth test to apply to each item in
 * `coll`.
 * The should complete with a boolean value as its `result`.
 * Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called after all the
 * `iteratee` functions have finished. Invoked with (err, results).
 * @example
 *
 * async.reject(['file1','file2','file3'], function(filePath, callback) {
 *     fs.access(filePath, function(err) {
 *         callback(null, !err)
 *     });
 * }, function(err, results) {
 *     // results now equals an array of missing files
 *     createFiles(results);
 * });
 */

/**
 * The same as [`reject`]{@link module:Collections.reject} but runs a maximum of `limit` async operations at a
 * time.
 *
 * @name rejectLimit
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.reject]{@link module:Collections.reject}
 * @category Collection
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {number} limit - The maximum number of async operations at a time.
 * @param {Function} iteratee - An async truth test to apply to each item in
 * `coll`.
 * The should complete with a boolean value as its `result`.
 * Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called after all the
 * `iteratee` functions have finished. Invoked with (err, results).
 */

/**
 * The same as [`reject`]{@link module:Collections.reject} but runs only a single async operation at a time.
 *
 * @name rejectSeries
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.reject]{@link module:Collections.reject}
 * @category Collection
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {Function} iteratee - An async truth test to apply to each item in
 * `coll`.
 * The should complete with a boolean value as its `result`.
 * Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called after all the
 * `iteratee` functions have finished. Invoked with (err, results).
 */

/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new constant function.
 * @example
 *
 * var objects = _.times(2, _.constant({ 'a': 1 }));
 *
 * console.log(objects);
 * // => [{ 'a': 1 }, { 'a': 1 }]
 *
 * console.log(objects[0] === objects[1]);
 * // => true
 */

/**
 * Returns `true` if at least one element in the `coll` satisfies an async test.
 * If any iteratee call returns `true`, the main `callback` is immediately
 * called.
 *
 * @name some
 * @static
 * @memberOf module:Collections
 * @method
 * @alias any
 * @category Collection
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {AsyncFunction} iteratee - An async truth test to apply to each item
 * in the collections in parallel.
 * The iteratee should complete with a boolean `result` value.
 * Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called as soon as any
 * iteratee returns `true`, or after all the iteratee functions have finished.
 * Result will be either `true` or `false` depending on the values of the async
 * tests. Invoked with (err, result).
 * @example
 *
 * async.some(['file1','file2','file3'], function(filePath, callback) {
 *     fs.access(filePath, function(err) {
 *         callback(null, !err)
 *     });
 * }, function(err, result) {
 *     // if result is true then at least one of the files exists
 * });
 */

/**
 * The same as [`some`]{@link module:Collections.some} but runs a maximum of `limit` async operations at a time.
 *
 * @name someLimit
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.some]{@link module:Collections.some}
 * @alias anyLimit
 * @category Collection
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {number} limit - The maximum number of async operations at a time.
 * @param {AsyncFunction} iteratee - An async truth test to apply to each item
 * in the collections in parallel.
 * The iteratee should complete with a boolean `result` value.
 * Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called as soon as any
 * iteratee returns `true`, or after all the iteratee functions have finished.
 * Result will be either `true` or `false` depending on the values of the async
 * tests. Invoked with (err, result).
 */

/**
 * The same as [`some`]{@link module:Collections.some} but runs only a single async operation at a time.
 *
 * @name someSeries
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.some]{@link module:Collections.some}
 * @alias anySeries
 * @category Collection
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {AsyncFunction} iteratee - An async truth test to apply to each item
 * in the collections in series.
 * The iteratee should complete with a boolean `result` value.
 * Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called as soon as any
 * iteratee returns `true`, or after all the iteratee functions have finished.
 * Result will be either `true` or `false` depending on the values of the async
 * tests. Invoked with (err, result).
 */

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeCeil = Math.ceil;
var nativeMax = Math.max;

/**
 * Calls the `iteratee` function `n` times, and accumulates results in the same
 * manner you would use with [map]{@link module:Collections.map}.
 *
 * @name times
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @see [async.map]{@link module:Collections.map}
 * @category Control Flow
 * @param {number} n - The number of times to run the function.
 * @param {AsyncFunction} iteratee - The async function to call `n` times.
 * Invoked with the iteration index and a callback: (n, next).
 * @param {Function} callback - see {@link module:Collections.map}.
 * @example
 *
 * // Pretend this is some complicated async factory
 * var createUser = function(id, callback) {
 *     callback(null, {
 *         id: 'user' + id
 *     });
 * };
 *
 * // generate 5 users
 * async.times(5, function(n, next) {
 *     createUser(n, function(err, user) {
 *         next(err, user);
 *     });
 * }, function(err, users) {
 *     // we should now have 5 users
 * });
 */

/**
 * The same as [times]{@link module:ControlFlow.times} but runs only a single async operation at a time.
 *
 * @name timesSeries
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @see [async.times]{@link module:ControlFlow.times}
 * @category Control Flow
 * @param {number} n - The number of times to run the function.
 * @param {AsyncFunction} iteratee - The async function to call `n` times.
 * Invoked with the iteration index and a callback: (n, next).
 * @param {Function} callback - see {@link module:Collections.map}.
 */

/**
 * Undoes a [memoize]{@link module:Utils.memoize}d function, reverting it to the original,
 * unmemoized form. Handy for testing.
 *
 * @name unmemoize
 * @static
 * @memberOf module:Utils
 * @method
 * @see [async.memoize]{@link module:Utils.memoize}
 * @category Util
 * @param {AsyncFunction} fn - the memoized function
 * @returns {AsyncFunction} a function that calls the original unmemoized function
 */

/**
 * An "async function" in the context of Async is an asynchronous function with
 * a variable number of parameters, with the final parameter being a callback.
 * (`function (arg1, arg2, ..., callback) {}`)
 * The final callback is of the form `callback(err, results...)`, which must be
 * called once the function is completed.  The callback should be called with a
 * Error as its first argument to signal that an error occurred.
 * Otherwise, if no error occurred, it should be called with `null` as the first
 * argument, and any additional `result` arguments that may apply, to signal
 * successful completion.
 * The callback must be called exactly once, ideally on a later tick of the
 * JavaScript event loop.
 *
 * This type of function is also referred to as a "Node-style async function",
 * or a "continuation passing-style function" (CPS). Most of the methods of this
 * library are themselves CPS/Node-style async functions, or functions that
 * return CPS/Node-style async functions.
 *
 * Wherever we accept a Node-style async function, we also directly accept an
 * [ES2017 `async` function]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function}.
 * In this case, the `async` function will not be passed a final callback
 * argument, and any thrown error will be used as the `err` argument of the
 * implicit callback, and the return value will be used as the `result` value.
 * (i.e. a `rejected` of the returned Promise becomes the `err` callback
 * argument, and a `resolved` value becomes the `result`.)
 *
 * Note, due to JavaScript limitations, we can only detect native `async`
 * functions and not transpilied implementations.
 * Your environment must have `async`/`await` support for this to work.
 * (e.g. Node > v7.6, or a recent version of a modern browser).
 * If you are using `async` functions through a transpiler (e.g. Babel), you
 * must still wrap the function with [asyncify]{@link module:Utils.asyncify},
 * because the `async function` will be compiled to an ordinary function that
 * returns a promise.
 *
 * @typedef {Function} AsyncFunction
 * @static
 */

/**
 * Async is a utility module which provides straight-forward, powerful functions
 * for working with asynchronous JavaScript. Although originally designed for
 * use with [Node.js](http://nodejs.org) and installable via
 * `npm install --save async`, it can also be used directly in the browser.
 * @module async
 * @see AsyncFunction
 */


/**
 * A collection of `async` functions for manipulating collections, such as
 * arrays and objects.
 * @module Collections
 */

/**
 * A collection of `async` functions for controlling the flow through a script.
 * @module ControlFlow
 */

/**
 * A collection of `async` utility functions.
 * @module Utils
 */

/**
 * @hidden
 */
function isDirectoryEntry(entry) {
    return entry.isDirectory;
}
/**
 * @hidden
 */
var _getFS = toExport.webkitRequestFileSystem || toExport.requestFileSystem || null;
/**
 * @hidden
 */
function _requestQuota(type, size, success, errorCallback) {
    // We cast navigator and window to '<any>' because everything here is
    // nonstandard functionality, despite the fact that Chrome has the only
    // implementation of the HTML5FS and is likely driving the standardization
    // process. Thus, these objects defined off of navigator and window are not
    // present in the DefinitelyTyped TypeScript typings for FileSystem.
    if (typeof navigator['webkitPersistentStorage'] !== 'undefined') {
        switch (type) {
            case toExport.PERSISTENT:
                navigator.webkitPersistentStorage.requestQuota(size, success, errorCallback);
                break;
            case toExport.TEMPORARY:
                navigator.webkitTemporaryStorage.requestQuota(size, success, errorCallback);
                break;
            default:
                errorCallback(new TypeError(("Invalid storage type: " + type)));
                break;
        }
    }
    else {
        toExport.webkitStorageInfo.requestQuota(type, size, success, errorCallback);
    }
}
/**
 * @hidden
 */
function _toArray(list) {
    return Array.prototype.slice.call(list || [], 0);
}
/**
 * Converts the given DOMError into an appropriate ApiError.
 * @url https://developer.mozilla.org/en-US/docs/Web/API/DOMError
 * @hidden
 */
function convertError$1(err, p, expectedDir) {
    switch (err.name) {
        /* The user agent failed to create a file or directory due to the existence of a file or
            directory with the same path.  */
        case "PathExistsError":
            return ApiError.EEXIST(p);
        /* The operation failed because it would cause the application to exceed its storage quota.  */
        case 'QuotaExceededError':
            return ApiError.FileError(ErrorCode.ENOSPC, p);
        /*  A required file or directory could not be found at the time an operation was processed.   */
        case 'NotFoundError':
            return ApiError.ENOENT(p);
        /* This is a security error code to be used in situations not covered by any other error codes.
            - A required file was unsafe for access within a Web application
            - Too many calls are being made on filesystem resources */
        case 'SecurityError':
            return ApiError.FileError(ErrorCode.EACCES, p);
        /* The modification requested was illegal. Examples of invalid modifications include moving a
            directory into its own child, moving a file into its parent directory without changing its name,
            or copying a directory to a path occupied by a file.  */
        case 'InvalidModificationError':
            return ApiError.FileError(ErrorCode.EPERM, p);
        /* The user has attempted to look up a file or directory, but the Entry found is of the wrong type
            [e.g. is a DirectoryEntry when the user requested a FileEntry].  */
        case 'TypeMismatchError':
            return ApiError.FileError(expectedDir ? ErrorCode.ENOTDIR : ErrorCode.EISDIR, p);
        /* A path or URL supplied to the API was malformed.  */
        case "EncodingError":
        /* An operation depended on state cached in an interface object, but that state that has changed
            since it was read from disk.  */
        case "InvalidStateError":
        /* The user attempted to write to a file or directory which could not be modified due to the state
            of the underlying filesystem.  */
        case "NoModificationAllowedError":
        default:
            return ApiError.FileError(ErrorCode.EINVAL, p);
    }
}
// A note about getFile and getDirectory options:
// These methods are called at numerous places in this file, and are passed
// some combination of these two options:
//   - create: If true, the entry will be created if it doesn't exist.
//             If false, an error will be thrown if it doesn't exist.
//   - exclusive: If true, only create the entry if it doesn't already exist,
//                and throw an error if it does.
var HTML5FSFile = (function (PreloadFile$$1) {
    function HTML5FSFile(fs, entry, path$$1, flag, stat, contents) {
        PreloadFile$$1.call(this, fs, path$$1, flag, stat, contents);
        this._entry = entry;
    }

    if ( PreloadFile$$1 ) HTML5FSFile.__proto__ = PreloadFile$$1;
    HTML5FSFile.prototype = Object.create( PreloadFile$$1 && PreloadFile$$1.prototype );
    HTML5FSFile.prototype.constructor = HTML5FSFile;
    HTML5FSFile.prototype.sync = function sync (cb) {
        var this$1 = this;

        if (!this.isDirty()) {
            return cb();
        }
        this._entry.createWriter(function (writer) {
            var buffer$$1 = this$1.getBuffer();
            var blob = new Blob([buffer2ArrayBuffer(buffer$$1)]);
            var length = blob.size;
            writer.onwriteend = function (err) {
                writer.onwriteend = null;
                writer.onerror = null;
                writer.truncate(length);
                this$1.resetDirty();
                cb();
            };
            writer.onerror = function (err) {
                cb(convertError$1(err, this$1.getPath(), false));
            };
            writer.write(blob);
        });
    };
    HTML5FSFile.prototype.close = function close (cb) {
        this.sync(cb);
    };

    return HTML5FSFile;
}(PreloadFile));
/**
 * A read-write filesystem backed by the HTML5 FileSystem API.
 *
 * As the HTML5 FileSystem is only implemented in Blink, this interface is
 * only available in Chrome.
 */
var HTML5FS = (function (BaseFileSystem$$1) {
    function HTML5FS(size, type) {
        if ( size === void 0 ) size = 5;
        if ( type === void 0 ) type = toExport.PERSISTENT;

        BaseFileSystem$$1.call(this);
        // Convert MB to bytes.
        this.size = 1024 * 1024 * size;
        this.type = type;
    }

    if ( BaseFileSystem$$1 ) HTML5FS.__proto__ = BaseFileSystem$$1;
    HTML5FS.prototype = Object.create( BaseFileSystem$$1 && BaseFileSystem$$1.prototype );
    HTML5FS.prototype.constructor = HTML5FS;
    /**
     * Creates an HTML5FS instance with the given options.
     */
    HTML5FS.Create = function Create (opts, cb) {
        var fs = new HTML5FS(opts.size, opts.type);
        fs._allocate(function (e) { return e ? cb(e) : cb(null, fs); });
    };
    HTML5FS.isAvailable = function isAvailable () {
        return !!_getFS;
    };
    HTML5FS.prototype.getName = function getName () {
        return HTML5FS.Name;
    };
    HTML5FS.prototype.isReadOnly = function isReadOnly () {
        return false;
    };
    HTML5FS.prototype.supportsSymlinks = function supportsSymlinks () {
        return false;
    };
    HTML5FS.prototype.supportsProps = function supportsProps () {
        return false;
    };
    HTML5FS.prototype.supportsSynch = function supportsSynch () {
        return false;
    };
    /**
     * Deletes everything in the FS. Used for testing.
     * Karma clears the storage after you quit it but not between runs of the test
     * suite, and the tests expect an empty FS every time.
     */
    HTML5FS.prototype.empty = function empty (mainCb) {
        // Get a list of all entries in the root directory to delete them
        this._readdir('/', function (err, entries) {
            if (err) {
                mainCb(err);
            }
            else {
                // Called when every entry has been operated on
                var finished = function (er) {
                    if (err) {
                        mainCb(err);
                    }
                    else {
                        mainCb();
                    }
                };
                // Removes files and recursively removes directories
                var deleteEntry = function (entry, cb) {
                    var succ = function () {
                        cb();
                    };
                    var error = function (err) {
                        cb(convertError$1(err, entry.fullPath, !entry.isDirectory));
                    };
                    if (isDirectoryEntry(entry)) {
                        entry.removeRecursively(succ, error);
                    }
                    else {
                        entry.remove(succ, error);
                    }
                };
                // Loop through the entries and remove them, then call the callback
                // when they're all finished.
                eachLimit(entries, deleteEntry, finished);
            }
        });
    };
    HTML5FS.prototype.rename = function rename (oldPath, newPath, cb) {
        var this$1 = this;

        var semaphore = 2;
        var successCount = 0;
        var root = this.fs.root;
        var currentPath = oldPath;
        var error = function (err) {
            if (--semaphore <= 0) {
                cb(convertError$1(err, currentPath, false));
            }
        };
        var success = function (file) {
            if (++successCount === 2) {
                return cb(new ApiError(ErrorCode.EINVAL, "Something was identified as both a file and a directory. This should never happen."));
            }
            // SPECIAL CASE: If newPath === oldPath, and the path exists, then
            // this operation trivially succeeds.
            if (oldPath === newPath) {
                return cb();
            }
            // Get the new parent directory.
            currentPath = path.dirname(newPath);
            root.getDirectory(currentPath, {}, function (parentDir) {
                currentPath = path.basename(newPath);
                file.moveTo(parentDir, currentPath, function (entry) { cb(); }, function (err) {
                    // SPECIAL CASE: If oldPath is a directory, and newPath is a
                    // file, rename should delete the file and perform the move.
                    if (file.isDirectory) {
                        currentPath = newPath;
                        // Unlink only works on files. Try to delete newPath.
                        this$1.unlink(newPath, function (e) {
                            if (e) {
                                // newPath is probably a directory.
                                error(err);
                            }
                            else {
                                // Recur, now that newPath doesn't exist.
                                this$1.rename(oldPath, newPath, cb);
                            }
                        });
                    }
                    else {
                        error(err);
                    }
                });
            }, error);
        };
        // We don't know if oldPath is a *file* or a *directory*, and there's no
        // way to stat items. So launch both requests, see which one succeeds.
        root.getFile(oldPath, {}, success, error);
        root.getDirectory(oldPath, {}, success, error);
    };
    HTML5FS.prototype.stat = function stat (path$$1, isLstat, cb) {
        var this$1 = this;

        // Throw an error if the entry doesn't exist, because then there's nothing
        // to stat.
        var opts = {
            create: false
        };
        // Called when the path has been successfully loaded as a file.
        var loadAsFile = function (entry) {
            var fileFromEntry = function (file) {
                var stat = new Stats(FileType.FILE, file.size);
                cb(null, stat);
            };
            entry.file(fileFromEntry, failedToLoad);
        };
        // Called when the path has been successfully loaded as a directory.
        var loadAsDir = function (dir$$1) {
            // Directory entry size can't be determined from the HTML5 FS API, and is
            // implementation-dependant anyway, so a dummy value is used.
            var size = 4096;
            var stat = new Stats(FileType.DIRECTORY, size);
            cb(null, stat);
        };
        // Called when the path couldn't be opened as a directory or a file.
        var failedToLoad = function (err) {
            cb(convertError$1(err, path$$1, false /* Unknown / irrelevant */));
        };
        // Called when the path couldn't be opened as a file, but might still be a
        // directory.
        var failedToLoadAsFile = function () {
            this$1.fs.root.getDirectory(path$$1, opts, loadAsDir, failedToLoad);
        };
        // No method currently exists to determine whether a path refers to a
        // directory or a file, so this implementation tries both and uses the first
        // one that succeeds.
        this.fs.root.getFile(path$$1, opts, loadAsFile, failedToLoadAsFile);
    };
    HTML5FS.prototype.open = function open (p, flags, mode, cb) {
        var this$1 = this;

        // XXX: err is a DOMError
        var error = function (err) {
            if (err.name === 'InvalidModificationError' && flags.isExclusive()) {
                cb(ApiError.EEXIST(p));
            }
            else {
                cb(convertError$1(err, p, false));
            }
        };
        this.fs.root.getFile(p, {
            create: flags.pathNotExistsAction() === ActionType.CREATE_FILE,
            exclusive: flags.isExclusive()
        }, function (entry) {
            // Try to fetch corresponding file.
            entry.file(function (file) {
                var reader = new FileReader();
                reader.onloadend = function (event) {
                    var bfsFile = this$1._makeFile(p, entry, flags, file, reader.result);
                    cb(null, bfsFile);
                };
                reader.onerror = function (ev) {
                    error(reader.error);
                };
                reader.readAsArrayBuffer(file);
            }, error);
        }, error);
    };
    HTML5FS.prototype.unlink = function unlink (path$$1, cb) {
        this._remove(path$$1, cb, true);
    };
    HTML5FS.prototype.rmdir = function rmdir (path$$1, cb) {
        var this$1 = this;

        // Check if directory is non-empty, first.
        this.readdir(path$$1, function (e, files) {
            if (e) {
                cb(e);
            }
            else if (files.length > 0) {
                cb(ApiError.ENOTEMPTY(path$$1));
            }
            else {
                this$1._remove(path$$1, cb, false);
            }
        });
    };
    HTML5FS.prototype.mkdir = function mkdir (path$$1, mode, cb) {
        // Create the directory, but throw an error if it already exists, as per
        // mkdir(1)
        var opts = {
            create: true,
            exclusive: true
        };
        var success = function (dir$$1) {
            cb();
        };
        var error = function (err) {
            cb(convertError$1(err, path$$1, true));
        };
        this.fs.root.getDirectory(path$$1, opts, success, error);
    };
    /**
     * Map _readdir's list of `FileEntry`s to their names and return that.
     */
    HTML5FS.prototype.readdir = function readdir (path$$1, cb) {
        this._readdir(path$$1, function (e, entries) {
            if (entries) {
                var rv = [];
                for (var i = 0, list = entries; i < list.length; i += 1) {
                    var entry = list[i];

                    rv.push(entry.name);
                }
                cb(null, rv);
            }
            else {
                return cb(e);
            }
        });
    };
    /**
     * Returns a BrowserFS object representing a File.
     */
    HTML5FS.prototype._makeFile = function _makeFile (path$$1, entry, flag, stat, data) {
        if ( data === void 0 ) data = new ArrayBuffer(0);

        var stats = new Stats(FileType.FILE, stat.size);
        var buffer$$1 = arrayBuffer2Buffer(data);
        return new HTML5FSFile(this, entry, path$$1, flag, stats, buffer$$1);
    };
    /**
     * Returns an array of `FileEntry`s. Used internally by empty and readdir.
     */
    HTML5FS.prototype._readdir = function _readdir (path$$1, cb) {
        var error = function (err) {
            cb(convertError$1(err, path$$1, true));
        };
        // Grab the requested directory.
        this.fs.root.getDirectory(path$$1, { create: false }, function (dirEntry) {
            var reader = dirEntry.createReader();
            var entries = [];
            // Call the reader.readEntries() until no more results are returned.
            var readEntries = function () {
                reader.readEntries((function (results) {
                    if (results.length) {
                        entries = entries.concat(_toArray(results));
                        readEntries();
                    }
                    else {
                        cb(null, entries);
                    }
                }), error);
            };
            readEntries();
        }, error);
    };
    /**
     * Requests a storage quota from the browser to back this FS.
     */
    HTML5FS.prototype._allocate = function _allocate (cb) {
        var this$1 = this;

        var success = function (fs) {
            this$1.fs = fs;
            cb();
        };
        var error = function (err) {
            cb(convertError$1(err, "/", true));
        };
        if (this.type === toExport.PERSISTENT) {
            _requestQuota(this.type, this.size, function (granted) {
                _getFS(this$1.type, granted, success, error);
            }, error);
        }
        else {
            _getFS(this.type, this.size, success, error);
        }
    };
    /**
     * Delete a file or directory from the file system
     * isFile should reflect which call was made to remove the it (`unlink` or
     * `rmdir`). If this doesn't match what's actually at `path`, an error will be
     * returned
     */
    HTML5FS.prototype._remove = function _remove (path$$1, cb, isFile) {
        var success = function (entry) {
            var succ = function () {
                cb();
            };
            var err = function (err) {
                cb(convertError$1(err, path$$1, !isFile));
            };
            entry.remove(succ, err);
        };
        var error = function (err) {
            cb(convertError$1(err, path$$1, !isFile));
        };
        // Deleting the entry, so don't create it
        var opts = {
            create: false
        };
        if (isFile) {
            this.fs.root.getFile(path$$1, opts, success, error);
        }
        else {
            this.fs.root.getDirectory(path$$1, opts, success, error);
        }
    };

    return HTML5FS;
}(BaseFileSystem));

HTML5FS.Name = "HTML5FS";
HTML5FS.Options = {
    size: {
        type: "number",
        optional: true,
        description: "Storage quota to request, in megabytes. Allocated value may be less. Defaults to 5."
    },
    type: {
        type: "number",
        optional: true,
        description: "window.PERSISTENT or window.TEMPORARY. Defaults to PERSISTENT."
    }
};

/**
 * Generic inode definition that can easily be serialized.
 */
var Inode = function Inode(id, size, mode, atime, mtime, ctime) {
    this.id = id;
    this.size = size;
    this.mode = mode;
    this.atime = atime;
    this.mtime = mtime;
    this.ctime = ctime;
};
/**
 * Converts the buffer into an Inode.
 */
Inode.fromBuffer = function fromBuffer (buffer$$1) {
    if (buffer$$1 === undefined) {
        throw new Error("NO");
    }
    return new Inode(buffer$$1.toString('ascii', 30), buffer$$1.readUInt32LE(0), buffer$$1.readUInt16LE(4), buffer$$1.readDoubleLE(6), buffer$$1.readDoubleLE(14), buffer$$1.readDoubleLE(22));
};
/**
 * Handy function that converts the Inode to a Node Stats object.
 */
Inode.prototype.toStats = function toStats () {
    return new Stats((this.mode & 0xF000) === FileType.DIRECTORY ? FileType.DIRECTORY : FileType.FILE, this.size, this.mode, new Date(this.atime), new Date(this.mtime), new Date(this.ctime));
};
/**
 * Get the size of this Inode, in bytes.
 */
Inode.prototype.getSize = function getSize () {
    // ASSUMPTION: ID is ASCII (1 byte per char).
    return 30 + this.id.length;
};
/**
 * Writes the inode into the start of the buffer.
 */
Inode.prototype.toBuffer = function toBuffer (buff) {
        if ( buff === void 0 ) buff = Buffer.alloc(this.getSize());

    buff.writeUInt32LE(this.size, 0);
    buff.writeUInt16LE(this.mode, 4);
    buff.writeDoubleLE(this.atime, 6);
    buff.writeDoubleLE(this.mtime, 14);
    buff.writeDoubleLE(this.ctime, 22);
    buff.write(this.id, 30, this.id.length, 'ascii');
    return buff;
};
/**
 * Updates the Inode using information from the stats object. Used by file
 * systems at sync time, e.g.:
 * - Program opens file and gets a File object.
 * - Program mutates file. File object is responsible for maintaining
 *   metadata changes locally -- typically in a Stats object.
 * - Program closes file. File object's metadata changes are synced with the
 *   file system.
 * @return True if any changes have occurred.
 */
Inode.prototype.update = function update (stats) {
    var hasChanged = false;
    if (this.size !== stats.size) {
        this.size = stats.size;
        hasChanged = true;
    }
    if (this.mode !== stats.mode) {
        this.mode = stats.mode;
        hasChanged = true;
    }
    var atimeMs = stats.atime.getTime();
    if (this.atime !== atimeMs) {
        this.atime = atimeMs;
        hasChanged = true;
    }
    var mtimeMs = stats.mtime.getTime();
    if (this.mtime !== mtimeMs) {
        this.mtime = mtimeMs;
        hasChanged = true;
    }
    var ctimeMs = stats.ctime.getTime();
    if (this.ctime !== ctimeMs) {
        this.ctime = ctimeMs;
        hasChanged = true;
    }
    return hasChanged;
};
// XXX: Copied from Stats. Should reconcile these two into something more
//  compact.
/**
 * @return [Boolean] True if this item is a file.
 */
Inode.prototype.isFile = function isFile () {
    return (this.mode & 0xF000) === FileType.FILE;
};
/**
 * @return [Boolean] True if this item is a directory.
 */
Inode.prototype.isDirectory = function isDirectory () {
    return (this.mode & 0xF000) === FileType.DIRECTORY;
};

/**
 * @hidden
 */
var ROOT_NODE_ID = "/";
/**
 * @hidden
 */
var emptyDirNode = null;
/**
 * Returns an empty directory node.
 * @hidden
 */
function getEmptyDirNode() {
    if (emptyDirNode) {
        return emptyDirNode;
    }
    return emptyDirNode = Buffer.from("{}");
}
/**
 * Generates a random ID.
 * @hidden
 */
function GenerateRandomID() {
    // From http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
        var r = Math.random() * 16 | 0;
        var v = c === 'x' ? r : (r & 0x3 | 0x8);
        return v.toString(16);
    });
}
/**
 * Helper function. Checks if 'e' is defined. If so, it triggers the callback
 * with 'e' and returns false. Otherwise, returns true.
 * @hidden
 */
function noError(e, cb) {
    if (e) {
        cb(e);
        return false;
    }
    return true;
}
/**
 * Helper function. Checks if 'e' is defined. If so, it aborts the transaction,
 * triggers the callback with 'e', and returns false. Otherwise, returns true.
 * @hidden
 */
function noErrorTx(e, tx, cb) {
    if (e) {
        tx.abort(function () {
            cb(e);
        });
        return false;
    }
    return true;
}
/**
 * A simple RW transaction for simple synchronous key-value stores.
 */
var SimpleSyncRWTransaction = function SimpleSyncRWTransaction(store) {
    this.store = store;
    /**
     * Stores data in the keys we modify prior to modifying them.
     * Allows us to roll back commits.
     */
    this.originalData = {};
    /**
     * List of keys modified in this transaction, if any.
     */
    this.modifiedKeys = [];
};
SimpleSyncRWTransaction.prototype.get = function get (key) {
    var val = this.store.get(key);
    this.stashOldValue(key, val);
    return val;
};
SimpleSyncRWTransaction.prototype.put = function put (key, data, overwrite) {
    this.markModified(key);
    return this.store.put(key, data, overwrite);
};
SimpleSyncRWTransaction.prototype.del = function del (key) {
    this.markModified(key);
    this.store.del(key);
};
SimpleSyncRWTransaction.prototype.commit = function commit () { };
SimpleSyncRWTransaction.prototype.abort = function abort () {
        var this$1 = this;

    // Rollback old values.
    for (var i = 0, list = this$1.modifiedKeys; i < list.length; i += 1) {
        var key = list[i];

            var value = this$1.originalData[key];
        if (!value) {
            // Key didn't exist.
            this$1.store.del(key);
        }
        else {
            // Key existed. Store old value.
            this$1.store.put(key, value, true);
        }
    }
};
/**
 * Stashes given key value pair into `originalData` if it doesn't already
 * exist. Allows us to stash values the program is requesting anyway to
 * prevent needless `get` requests if the program modifies the data later
 * on during the transaction.
 */
SimpleSyncRWTransaction.prototype.stashOldValue = function stashOldValue (key, value) {
    // Keep only the earliest value in the transaction.
    if (!this.originalData.hasOwnProperty(key)) {
        this.originalData[key] = value;
    }
};
/**
 * Marks the given key as modified, and stashes its value if it has not been
 * stashed already.
 */
SimpleSyncRWTransaction.prototype.markModified = function markModified (key) {
    if (this.modifiedKeys.indexOf(key) === -1) {
        this.modifiedKeys.push(key);
        if (!this.originalData.hasOwnProperty(key)) {
            this.originalData[key] = this.store.get(key);
        }
    }
};
var SyncKeyValueFile = (function (PreloadFile$$1) {
    function SyncKeyValueFile(_fs, _path, _flag, _stat, contents) {
        PreloadFile$$1.call(this, _fs, _path, _flag, _stat, contents);
    }

    if ( PreloadFile$$1 ) SyncKeyValueFile.__proto__ = PreloadFile$$1;
    SyncKeyValueFile.prototype = Object.create( PreloadFile$$1 && PreloadFile$$1.prototype );
    SyncKeyValueFile.prototype.constructor = SyncKeyValueFile;
    SyncKeyValueFile.prototype.syncSync = function syncSync () {
        if (this.isDirty()) {
            this._fs._syncSync(this.getPath(), this.getBuffer(), this.getStats());
            this.resetDirty();
        }
    };
    SyncKeyValueFile.prototype.closeSync = function closeSync () {
        this.syncSync();
    };

    return SyncKeyValueFile;
}(PreloadFile));
/**
 * A "Synchronous key-value file system". Stores data to/retrieves data from an
 * underlying key-value store.
 *
 * We use a unique ID for each node in the file system. The root node has a
 * fixed ID.
 * @todo Introduce Node ID caching.
 * @todo Check modes.
 */
var SyncKeyValueFileSystem = (function (SynchronousFileSystem$$1) {
    function SyncKeyValueFileSystem(options) {
        SynchronousFileSystem$$1.call(this);
        this.store = options.store;
        // INVARIANT: Ensure that the root exists.
        this.makeRootDirectory();
    }

    if ( SynchronousFileSystem$$1 ) SyncKeyValueFileSystem.__proto__ = SynchronousFileSystem$$1;
    SyncKeyValueFileSystem.prototype = Object.create( SynchronousFileSystem$$1 && SynchronousFileSystem$$1.prototype );
    SyncKeyValueFileSystem.prototype.constructor = SyncKeyValueFileSystem;
    SyncKeyValueFileSystem.isAvailable = function isAvailable () { return true; };

    SyncKeyValueFileSystem.prototype.getName = function getName () { return this.store.name(); };
    SyncKeyValueFileSystem.prototype.isReadOnly = function isReadOnly () { return false; };
    SyncKeyValueFileSystem.prototype.supportsSymlinks = function supportsSymlinks () { return false; };
    SyncKeyValueFileSystem.prototype.supportsProps = function supportsProps () { return false; };
    SyncKeyValueFileSystem.prototype.supportsSynch = function supportsSynch () { return true; };
    /**
     * Delete all contents stored in the file system.
     */
    SyncKeyValueFileSystem.prototype.empty = function empty () {
        this.store.clear();
        // INVARIANT: Root always exists.
        this.makeRootDirectory();
    };
    SyncKeyValueFileSystem.prototype.renameSync = function renameSync (oldPath, newPath) {
        var tx = this.store.beginTransaction('readwrite'), oldParent = path.dirname(oldPath), oldName = path.basename(oldPath), newParent = path.dirname(newPath), newName = path.basename(newPath), 
        // Remove oldPath from parent's directory listing.
        oldDirNode = this.findINode(tx, oldParent), oldDirList = this.getDirListing(tx, oldParent, oldDirNode);
        if (!oldDirList[oldName]) {
            throw ApiError.ENOENT(oldPath);
        }
        var nodeId = oldDirList[oldName];
        delete oldDirList[oldName];
        // Invariant: Can't move a folder inside itself.
        // This funny little hack ensures that the check passes only if oldPath
        // is a subpath of newParent. We append '/' to avoid matching folders that
        // are a substring of the bottom-most folder in the path.
        if ((newParent + '/').indexOf(oldPath + '/') === 0) {
            throw new ApiError(ErrorCode.EBUSY, oldParent);
        }
        // Add newPath to parent's directory listing.
        var newDirNode, newDirList;
        if (newParent === oldParent) {
            // Prevent us from re-grabbing the same directory listing, which still
            // contains oldName.
            newDirNode = oldDirNode;
            newDirList = oldDirList;
        }
        else {
            newDirNode = this.findINode(tx, newParent);
            newDirList = this.getDirListing(tx, newParent, newDirNode);
        }
        if (newDirList[newName]) {
            // If it's a file, delete it.
            var newNameNode = this.getINode(tx, newPath, newDirList[newName]);
            if (newNameNode.isFile()) {
                try {
                    tx.del(newNameNode.id);
                    tx.del(newDirList[newName]);
                }
                catch (e) {
                    tx.abort();
                    throw e;
                }
            }
            else {
                // If it's a directory, throw a permissions error.
                throw ApiError.EPERM(newPath);
            }
        }
        newDirList[newName] = nodeId;
        // Commit the two changed directory listings.
        try {
            tx.put(oldDirNode.id, Buffer.from(JSON.stringify(oldDirList)), true);
            tx.put(newDirNode.id, Buffer.from(JSON.stringify(newDirList)), true);
        }
        catch (e) {
            tx.abort();
            throw e;
        }
        tx.commit();
    };
    SyncKeyValueFileSystem.prototype.statSync = function statSync (p, isLstat) {
        // Get the inode to the item, convert it into a Stats object.
        return this.findINode(this.store.beginTransaction('readonly'), p).toStats();
    };
    SyncKeyValueFileSystem.prototype.createFileSync = function createFileSync (p, flag, mode) {
        var tx = this.store.beginTransaction('readwrite'), data = emptyBuffer(), newFile = this.commitNewFile(tx, p, FileType.FILE, mode, data);
        // Open the file.
        return new SyncKeyValueFile(this, p, flag, newFile.toStats(), data);
    };
    SyncKeyValueFileSystem.prototype.openFileSync = function openFileSync (p, flag) {
        var tx = this.store.beginTransaction('readonly'), node = this.findINode(tx, p), data = tx.get(node.id);
        if (data === undefined) {
            throw ApiError.ENOENT(p);
        }
        return new SyncKeyValueFile(this, p, flag, node.toStats(), data);
    };
    SyncKeyValueFileSystem.prototype.unlinkSync = function unlinkSync (p) {
        this.removeEntry(p, false);
    };
    SyncKeyValueFileSystem.prototype.rmdirSync = function rmdirSync (p) {
        // Check first if directory is empty.
        if (this.readdirSync(p).length > 0) {
            throw ApiError.ENOTEMPTY(p);
        }
        else {
            this.removeEntry(p, true);
        }
    };
    SyncKeyValueFileSystem.prototype.mkdirSync = function mkdirSync (p, mode) {
        var tx = this.store.beginTransaction('readwrite'), data = Buffer.from('{}');
        this.commitNewFile(tx, p, FileType.DIRECTORY, mode, data);
    };
    SyncKeyValueFileSystem.prototype.readdirSync = function readdirSync (p) {
        var tx = this.store.beginTransaction('readonly');
        return Object.keys(this.getDirListing(tx, p, this.findINode(tx, p)));
    };
    SyncKeyValueFileSystem.prototype._syncSync = function _syncSync (p, data, stats) {
        // @todo Ensure mtime updates properly, and use that to determine if a data
        //       update is required.
        var tx = this.store.beginTransaction('readwrite'), 
        // We use the _findInode helper because we actually need the INode id.
        fileInodeId = this._findINode(tx, path.dirname(p), path.basename(p)), fileInode = this.getINode(tx, p, fileInodeId), inodeChanged = fileInode.update(stats);
        try {
            // Sync data.
            tx.put(fileInode.id, data, true);
            // Sync metadata.
            if (inodeChanged) {
                tx.put(fileInodeId, fileInode.toBuffer(), true);
            }
        }
        catch (e) {
            tx.abort();
            throw e;
        }
        tx.commit();
    };
    /**
     * Checks if the root directory exists. Creates it if it doesn't.
     */
    SyncKeyValueFileSystem.prototype.makeRootDirectory = function makeRootDirectory () {
        var tx = this.store.beginTransaction('readwrite');
        if (tx.get(ROOT_NODE_ID) === undefined) {
            // Create new inode.
            var currTime = (new Date()).getTime(), 
            // Mode 0666
            dirInode = new Inode(GenerateRandomID(), 4096, 511 | FileType.DIRECTORY, currTime, currTime, currTime);
            // If the root doesn't exist, the first random ID shouldn't exist,
            // either.
            tx.put(dirInode.id, getEmptyDirNode(), false);
            tx.put(ROOT_NODE_ID, dirInode.toBuffer(), false);
            tx.commit();
        }
    };
    /**
     * Helper function for findINode.
     * @param parent The parent directory of the file we are attempting to find.
     * @param filename The filename of the inode we are attempting to find, minus
     *   the parent.
     * @return string The ID of the file's inode in the file system.
     */
    SyncKeyValueFileSystem.prototype._findINode = function _findINode (tx, parent, filename) {
        var this$1 = this;

        var readDirectory = function (inode) {
            // Get the root's directory listing.
            var dirList = this$1.getDirListing(tx, parent, inode);
            // Get the file's ID.
            if (dirList[filename]) {
                return dirList[filename];
            }
            else {
                throw ApiError.ENOENT(path.resolve(parent, filename));
            }
        };
        if (parent === '/') {
            if (filename === '') {
                // BASE CASE #1: Return the root's ID.
                return ROOT_NODE_ID;
            }
            else {
                // BASE CASE #2: Find the item in the root ndoe.
                return readDirectory(this.getINode(tx, parent, ROOT_NODE_ID));
            }
        }
        else {
            return readDirectory(this.getINode(tx, parent + path.sep + filename, this._findINode(tx, path.dirname(parent), path.basename(parent))));
        }
    };
    /**
     * Finds the Inode of the given path.
     * @param p The path to look up.
     * @return The Inode of the path p.
     * @todo memoize/cache
     */
    SyncKeyValueFileSystem.prototype.findINode = function findINode (tx, p) {
        return this.getINode(tx, p, this._findINode(tx, path.dirname(p), path.basename(p)));
    };
    /**
     * Given the ID of a node, retrieves the corresponding Inode.
     * @param tx The transaction to use.
     * @param p The corresponding path to the file (used for error messages).
     * @param id The ID to look up.
     */
    SyncKeyValueFileSystem.prototype.getINode = function getINode (tx, p, id) {
        var inode = tx.get(id);
        if (inode === undefined) {
            throw ApiError.ENOENT(p);
        }
        return Inode.fromBuffer(inode);
    };
    /**
     * Given the Inode of a directory, retrieves the corresponding directory
     * listing.
     */
    SyncKeyValueFileSystem.prototype.getDirListing = function getDirListing (tx, p, inode) {
        if (!inode.isDirectory()) {
            throw ApiError.ENOTDIR(p);
        }
        var data = tx.get(inode.id);
        if (data === undefined) {
            throw ApiError.ENOENT(p);
        }
        return JSON.parse(data.toString());
    };
    /**
     * Creates a new node under a random ID. Retries 5 times before giving up in
     * the exceedingly unlikely chance that we try to reuse a random GUID.
     * @return The GUID that the data was stored under.
     */
    SyncKeyValueFileSystem.prototype.addNewNode = function addNewNode (tx, data) {
        var retries = 0;
        var currId;
        while (retries < 5) {
            try {
                currId = GenerateRandomID();
                tx.put(currId, data, false);
                return currId;
            }
            catch (e) {
                // Ignore and reroll.
            }
        }
        throw new ApiError(ErrorCode.EIO, 'Unable to commit data to key-value store.');
    };
    /**
     * Commits a new file (well, a FILE or a DIRECTORY) to the file system with
     * the given mode.
     * Note: This will commit the transaction.
     * @param p The path to the new file.
     * @param type The type of the new file.
     * @param mode The mode to create the new file with.
     * @param data The data to store at the file's data node.
     * @return The Inode for the new file.
     */
    SyncKeyValueFileSystem.prototype.commitNewFile = function commitNewFile (tx, p, type, mode, data) {
        var parentDir = path.dirname(p), fname = path.basename(p), parentNode = this.findINode(tx, parentDir), dirListing = this.getDirListing(tx, parentDir, parentNode), currTime = (new Date()).getTime();
        // Invariant: The root always exists.
        // If we don't check this prior to taking steps below, we will create a
        // file with name '' in root should p == '/'.
        if (p === '/') {
            throw ApiError.EEXIST(p);
        }
        // Check if file already exists.
        if (dirListing[fname]) {
            throw ApiError.EEXIST(p);
        }
        var fileNode;
        try {
            // Commit data.
            var dataId = this.addNewNode(tx, data);
            fileNode = new Inode(dataId, data.length, mode | type, currTime, currTime, currTime);
            // Commit file node.
            var fileNodeId = this.addNewNode(tx, fileNode.toBuffer());
            // Update and commit parent directory listing.
            dirListing[fname] = fileNodeId;
            tx.put(parentNode.id, Buffer.from(JSON.stringify(dirListing)), true);
        }
        catch (e) {
            tx.abort();
            throw e;
        }
        tx.commit();
        return fileNode;
    };
    /**
     * Remove all traces of the given path from the file system.
     * @param p The path to remove from the file system.
     * @param isDir Does the path belong to a directory, or a file?
     * @todo Update mtime.
     */
    SyncKeyValueFileSystem.prototype.removeEntry = function removeEntry (p, isDir) {
        var tx = this.store.beginTransaction('readwrite'), parent = path.dirname(p), parentNode = this.findINode(tx, parent), parentListing = this.getDirListing(tx, parent, parentNode), fileName = path.basename(p);
        if (!parentListing[fileName]) {
            throw ApiError.ENOENT(p);
        }
        // Remove from directory listing of parent.
        var fileNodeId = parentListing[fileName];
        delete parentListing[fileName];
        // Get file inode.
        var fileNode = this.getINode(tx, p, fileNodeId);
        if (!isDir && fileNode.isDirectory()) {
            throw ApiError.EISDIR(p);
        }
        else if (isDir && !fileNode.isDirectory()) {
            throw ApiError.ENOTDIR(p);
        }
        try {
            // Delete data.
            tx.del(fileNode.id);
            // Delete node.
            tx.del(fileNodeId);
            // Update directory listing.
            tx.put(parentNode.id, Buffer.from(JSON.stringify(parentListing)), true);
        }
        catch (e) {
            tx.abort();
            throw e;
        }
        // Success.
        tx.commit();
    };

    return SyncKeyValueFileSystem;
}(SynchronousFileSystem));
var AsyncKeyValueFile = (function (PreloadFile$$1) {
    function AsyncKeyValueFile(_fs, _path, _flag, _stat, contents) {
        PreloadFile$$1.call(this, _fs, _path, _flag, _stat, contents);
    }

    if ( PreloadFile$$1 ) AsyncKeyValueFile.__proto__ = PreloadFile$$1;
    AsyncKeyValueFile.prototype = Object.create( PreloadFile$$1 && PreloadFile$$1.prototype );
    AsyncKeyValueFile.prototype.constructor = AsyncKeyValueFile;
    AsyncKeyValueFile.prototype.sync = function sync (cb) {
        var this$1 = this;

        if (this.isDirty()) {
            this._fs._sync(this.getPath(), this.getBuffer(), this.getStats(), function (e) {
                if (!e) {
                    this$1.resetDirty();
                }
                cb(e);
            });
        }
        else {
            cb();
        }
    };
    AsyncKeyValueFile.prototype.close = function close (cb) {
        this.sync(cb);
    };

    return AsyncKeyValueFile;
}(PreloadFile));
/**
 * An "Asynchronous key-value file system". Stores data to/retrieves data from
 * an underlying asynchronous key-value store.
 */
var AsyncKeyValueFileSystem = (function (BaseFileSystem$$1) {
    function AsyncKeyValueFileSystem () {
        BaseFileSystem$$1.apply(this, arguments);
    }

    if ( BaseFileSystem$$1 ) AsyncKeyValueFileSystem.__proto__ = BaseFileSystem$$1;
    AsyncKeyValueFileSystem.prototype = Object.create( BaseFileSystem$$1 && BaseFileSystem$$1.prototype );
    AsyncKeyValueFileSystem.prototype.constructor = AsyncKeyValueFileSystem;

    AsyncKeyValueFileSystem.isAvailable = function isAvailable () { return true; };
    /**
     * Initializes the file system. Typically called by subclasses' async
     * constructors.
     */
    AsyncKeyValueFileSystem.prototype.init = function init (store, cb) {
        this.store = store;
        // INVARIANT: Ensure that the root exists.
        this.makeRootDirectory(cb);
    };
    AsyncKeyValueFileSystem.prototype.getName = function getName () { return this.store.name(); };
    AsyncKeyValueFileSystem.prototype.isReadOnly = function isReadOnly () { return false; };
    AsyncKeyValueFileSystem.prototype.supportsSymlinks = function supportsSymlinks () { return false; };
    AsyncKeyValueFileSystem.prototype.supportsProps = function supportsProps () { return false; };
    AsyncKeyValueFileSystem.prototype.supportsSynch = function supportsSynch () { return false; };
    /**
     * Delete all contents stored in the file system.
     */
    AsyncKeyValueFileSystem.prototype.empty = function empty (cb) {
        var this$1 = this;

        this.store.clear(function (e) {
            if (noError(e, cb)) {
                // INVARIANT: Root always exists.
                this$1.makeRootDirectory(cb);
            }
        });
    };
    AsyncKeyValueFileSystem.prototype.rename = function rename (oldPath, newPath, cb) {
        var this$1 = this;

        var tx = this.store.beginTransaction('readwrite');
        var oldParent = path.dirname(oldPath), oldName = path.basename(oldPath);
        var newParent = path.dirname(newPath), newName = path.basename(newPath);
        var inodes = {};
        var lists = {};
        var errorOccurred = false;
        // Invariant: Can't move a folder inside itself.
        // This funny little hack ensures that the check passes only if oldPath
        // is a subpath of newParent. We append '/' to avoid matching folders that
        // are a substring of the bottom-most folder in the path.
        if ((newParent + '/').indexOf(oldPath + '/') === 0) {
            return cb(new ApiError(ErrorCode.EBUSY, oldParent));
        }
        /**
         * Responsible for Phase 2 of the rename operation: Modifying and
         * committing the directory listings. Called once we have successfully
         * retrieved both the old and new parent's inodes and listings.
         */
        var theOleSwitcharoo = function () {
            // Sanity check: Ensure both paths are present, and no error has occurred.
            if (errorOccurred || !lists.hasOwnProperty(oldParent) || !lists.hasOwnProperty(newParent)) {
                return;
            }
            var oldParentList = lists[oldParent], oldParentINode = inodes[oldParent], newParentList = lists[newParent], newParentINode = inodes[newParent];
            // Delete file from old parent.
            if (!oldParentList[oldName]) {
                cb(ApiError.ENOENT(oldPath));
            }
            else {
                var fileId = oldParentList[oldName];
                delete oldParentList[oldName];
                // Finishes off the renaming process by adding the file to the new
                // parent.
                var completeRename = function () {
                    newParentList[newName] = fileId;
                    // Commit old parent's list.
                    tx.put(oldParentINode.id, Buffer.from(JSON.stringify(oldParentList)), true, function (e) {
                        if (noErrorTx(e, tx, cb)) {
                            if (oldParent === newParent) {
                                // DONE!
                                tx.commit(cb);
                            }
                            else {
                                // Commit new parent's list.
                                tx.put(newParentINode.id, Buffer.from(JSON.stringify(newParentList)), true, function (e) {
                                    if (noErrorTx(e, tx, cb)) {
                                        tx.commit(cb);
                                    }
                                });
                            }
                        }
                    });
                };
                if (newParentList[newName]) {
                    // 'newPath' already exists. Check if it's a file or a directory, and
                    // act accordingly.
                    this$1.getINode(tx, newPath, newParentList[newName], function (e, inode) {
                        if (noErrorTx(e, tx, cb)) {
                            if (inode.isFile()) {
                                // Delete the file and continue.
                                tx.del(inode.id, function (e) {
                                    if (noErrorTx(e, tx, cb)) {
                                        tx.del(newParentList[newName], function (e) {
                                            if (noErrorTx(e, tx, cb)) {
                                                completeRename();
                                            }
                                        });
                                    }
                                });
                            }
                            else {
                                // Can't overwrite a directory using rename.
                                tx.abort(function (e) {
                                    cb(ApiError.EPERM(newPath));
                                });
                            }
                        }
                    });
                }
                else {
                    completeRename();
                }
            }
        };
        /**
         * Grabs a path's inode and directory listing, and shoves it into the
         * inodes and lists hashes.
         */
        var processInodeAndListings = function (p) {
            this$1.findINodeAndDirListing(tx, p, function (e, node, dirList) {
                if (e) {
                    if (!errorOccurred) {
                        errorOccurred = true;
                        tx.abort(function () {
                            cb(e);
                        });
                    }
                    // If error has occurred already, just stop here.
                }
                else {
                    inodes[p] = node;
                    lists[p] = dirList;
                    theOleSwitcharoo();
                }
            });
        };
        processInodeAndListings(oldParent);
        if (oldParent !== newParent) {
            processInodeAndListings(newParent);
        }
    };
    AsyncKeyValueFileSystem.prototype.stat = function stat (p, isLstat, cb) {
        var tx = this.store.beginTransaction('readonly');
        this.findINode(tx, p, function (e, inode) {
            if (noError(e, cb)) {
                cb(null, inode.toStats());
            }
        });
    };
    AsyncKeyValueFileSystem.prototype.createFile = function createFile (p, flag, mode, cb) {
        var this$1 = this;

        var tx = this.store.beginTransaction('readwrite'), data = emptyBuffer();
        this.commitNewFile(tx, p, FileType.FILE, mode, data, function (e, newFile) {
            if (noError(e, cb)) {
                cb(null, new AsyncKeyValueFile(this$1, p, flag, newFile.toStats(), data));
            }
        });
    };
    AsyncKeyValueFileSystem.prototype.openFile = function openFile (p, flag, cb) {
        var this$1 = this;

        var tx = this.store.beginTransaction('readonly');
        // Step 1: Grab the file's inode.
        this.findINode(tx, p, function (e, inode) {
            if (noError(e, cb)) {
                // Step 2: Grab the file's data.
                tx.get(inode.id, function (e, data) {
                    if (noError(e, cb)) {
                        if (data === undefined) {
                            cb(ApiError.ENOENT(p));
                        }
                        else {
                            cb(null, new AsyncKeyValueFile(this$1, p, flag, inode.toStats(), data));
                        }
                    }
                });
            }
        });
    };
    AsyncKeyValueFileSystem.prototype.unlink = function unlink (p, cb) {
        this.removeEntry(p, false, cb);
    };
    AsyncKeyValueFileSystem.prototype.rmdir = function rmdir (p, cb) {
        var this$1 = this;

        // Check first if directory is empty.
        this.readdir(p, function (err, files) {
            if (err) {
                cb(err);
            }
            else if (files.length > 0) {
                cb(ApiError.ENOTEMPTY(p));
            }
            else {
                this$1.removeEntry(p, true, cb);
            }
        });
    };
    AsyncKeyValueFileSystem.prototype.mkdir = function mkdir (p, mode, cb) {
        var tx = this.store.beginTransaction('readwrite'), data = Buffer.from('{}');
        this.commitNewFile(tx, p, FileType.DIRECTORY, mode, data, cb);
    };
    AsyncKeyValueFileSystem.prototype.readdir = function readdir (p, cb) {
        var this$1 = this;

        var tx = this.store.beginTransaction('readonly');
        this.findINode(tx, p, function (e, inode) {
            if (noError(e, cb)) {
                this$1.getDirListing(tx, p, inode, function (e, dirListing) {
                    if (noError(e, cb)) {
                        cb(null, Object.keys(dirListing));
                    }
                });
            }
        });
    };
    AsyncKeyValueFileSystem.prototype._sync = function _sync (p, data, stats, cb) {
        var this$1 = this;

        // @todo Ensure mtime updates properly, and use that to determine if a data
        //       update is required.
        var tx = this.store.beginTransaction('readwrite');
        // Step 1: Get the file node's ID.
        this._findINode(tx, path.dirname(p), path.basename(p), function (e, fileInodeId) {
            if (noErrorTx(e, tx, cb)) {
                // Step 2: Get the file inode.
                this$1.getINode(tx, p, fileInodeId, function (e, fileInode) {
                    if (noErrorTx(e, tx, cb)) {
                        var inodeChanged = fileInode.update(stats);
                        // Step 3: Sync the data.
                        tx.put(fileInode.id, data, true, function (e) {
                            if (noErrorTx(e, tx, cb)) {
                                // Step 4: Sync the metadata (if it changed)!
                                if (inodeChanged) {
                                    tx.put(fileInodeId, fileInode.toBuffer(), true, function (e) {
                                        if (noErrorTx(e, tx, cb)) {
                                            tx.commit(cb);
                                        }
                                    });
                                }
                                else {
                                    // No need to sync metadata; return.
                                    tx.commit(cb);
                                }
                            }
                        });
                    }
                });
            }
        });
    };
    /**
     * Checks if the root directory exists. Creates it if it doesn't.
     */
    AsyncKeyValueFileSystem.prototype.makeRootDirectory = function makeRootDirectory (cb) {
        var tx = this.store.beginTransaction('readwrite');
        tx.get(ROOT_NODE_ID, function (e, data) {
            if (e || data === undefined) {
                // Create new inode.
                var currTime = (new Date()).getTime(), 
                // Mode 0666
                dirInode = new Inode(GenerateRandomID(), 4096, 511 | FileType.DIRECTORY, currTime, currTime, currTime);
                // If the root doesn't exist, the first random ID shouldn't exist,
                // either.
                tx.put(dirInode.id, getEmptyDirNode(), false, function (e) {
                    if (noErrorTx(e, tx, cb)) {
                        tx.put(ROOT_NODE_ID, dirInode.toBuffer(), false, function (e) {
                            if (e) {
                                tx.abort(function () { cb(e); });
                            }
                            else {
                                tx.commit(cb);
                            }
                        });
                    }
                });
            }
            else {
                // We're good.
                tx.commit(cb);
            }
        });
    };
    /**
     * Helper function for findINode.
     * @param parent The parent directory of the file we are attempting to find.
     * @param filename The filename of the inode we are attempting to find, minus
     *   the parent.
     * @param cb Passed an error or the ID of the file's inode in the file system.
     */
    AsyncKeyValueFileSystem.prototype._findINode = function _findINode (tx, parent, filename, cb) {
        var this$1 = this;

        var handleDirectoryListings = function (e, inode, dirList) {
            if (e) {
                cb(e);
            }
            else if (dirList[filename]) {
                cb(null, dirList[filename]);
            }
            else {
                cb(ApiError.ENOENT(path.resolve(parent, filename)));
            }
        };
        if (parent === '/') {
            if (filename === '') {
                // BASE CASE #1: Return the root's ID.
                cb(null, ROOT_NODE_ID);
            }
            else {
                // BASE CASE #2: Find the item in the root node.
                this.getINode(tx, parent, ROOT_NODE_ID, function (e, inode) {
                    if (noError(e, cb)) {
                        this$1.getDirListing(tx, parent, inode, function (e, dirList) {
                            // handle_directory_listings will handle e for us.
                            handleDirectoryListings(e, inode, dirList);
                        });
                    }
                });
            }
        }
        else {
            // Get the parent directory's INode, and find the file in its directory
            // listing.
            this.findINodeAndDirListing(tx, parent, handleDirectoryListings);
        }
    };
    /**
     * Finds the Inode of the given path.
     * @param p The path to look up.
     * @param cb Passed an error or the Inode of the path p.
     * @todo memoize/cache
     */
    AsyncKeyValueFileSystem.prototype.findINode = function findINode (tx, p, cb) {
        var this$1 = this;

        this._findINode(tx, path.dirname(p), path.basename(p), function (e, id) {
            if (noError(e, cb)) {
                this$1.getINode(tx, p, id, cb);
            }
        });
    };
    /**
     * Given the ID of a node, retrieves the corresponding Inode.
     * @param tx The transaction to use.
     * @param p The corresponding path to the file (used for error messages).
     * @param id The ID to look up.
     * @param cb Passed an error or the inode under the given id.
     */
    AsyncKeyValueFileSystem.prototype.getINode = function getINode (tx, p, id, cb) {
        tx.get(id, function (e, data) {
            if (noError(e, cb)) {
                if (data === undefined) {
                    cb(ApiError.ENOENT(p));
                }
                else {
                    cb(null, Inode.fromBuffer(data));
                }
            }
        });
    };
    /**
     * Given the Inode of a directory, retrieves the corresponding directory
     * listing.
     */
    AsyncKeyValueFileSystem.prototype.getDirListing = function getDirListing (tx, p, inode, cb) {
        if (!inode.isDirectory()) {
            cb(ApiError.ENOTDIR(p));
        }
        else {
            tx.get(inode.id, function (e, data) {
                if (noError(e, cb)) {
                    try {
                        cb(null, JSON.parse(data.toString()));
                    }
                    catch (e) {
                        // Occurs when data is undefined, or corresponds to something other
                        // than a directory listing. The latter should never occur unless
                        // the file system is corrupted.
                        cb(ApiError.ENOENT(p));
                    }
                }
            });
        }
    };
    /**
     * Given a path to a directory, retrieves the corresponding INode and
     * directory listing.
     */
    AsyncKeyValueFileSystem.prototype.findINodeAndDirListing = function findINodeAndDirListing (tx, p, cb) {
        var this$1 = this;

        this.findINode(tx, p, function (e, inode) {
            if (noError(e, cb)) {
                this$1.getDirListing(tx, p, inode, function (e, listing) {
                    if (noError(e, cb)) {
                        cb(null, inode, listing);
                    }
                });
            }
        });
    };
    /**
     * Adds a new node under a random ID. Retries 5 times before giving up in
     * the exceedingly unlikely chance that we try to reuse a random GUID.
     * @param cb Passed an error or the GUID that the data was stored under.
     */
    AsyncKeyValueFileSystem.prototype.addNewNode = function addNewNode (tx, data, cb) {
        var retries = 0, currId;
        var reroll = function () {
            if (++retries === 5) {
                // Max retries hit. Return with an error.
                cb(new ApiError(ErrorCode.EIO, 'Unable to commit data to key-value store.'));
            }
            else {
                // Try again.
                currId = GenerateRandomID();
                tx.put(currId, data, false, function (e, committed) {
                    if (e || !committed) {
                        reroll();
                    }
                    else {
                        // Successfully stored under 'currId'.
                        cb(null, currId);
                    }
                });
            }
        };
        reroll();
    };
    /**
     * Commits a new file (well, a FILE or a DIRECTORY) to the file system with
     * the given mode.
     * Note: This will commit the transaction.
     * @param p The path to the new file.
     * @param type The type of the new file.
     * @param mode The mode to create the new file with.
     * @param data The data to store at the file's data node.
     * @param cb Passed an error or the Inode for the new file.
     */
    AsyncKeyValueFileSystem.prototype.commitNewFile = function commitNewFile (tx, p, type, mode, data, cb) {
        var this$1 = this;

        var parentDir = path.dirname(p), fname = path.basename(p), currTime = (new Date()).getTime();
        // Invariant: The root always exists.
        // If we don't check this prior to taking steps below, we will create a
        // file with name '' in root should p == '/'.
        if (p === '/') {
            return cb(ApiError.EEXIST(p));
        }
        // Let's build a pyramid of code!
        // Step 1: Get the parent directory's inode and directory listing
        this.findINodeAndDirListing(tx, parentDir, function (e, parentNode, dirListing) {
            if (noErrorTx(e, tx, cb)) {
                if (dirListing[fname]) {
                    // File already exists.
                    tx.abort(function () {
                        cb(ApiError.EEXIST(p));
                    });
                }
                else {
                    // Step 2: Commit data to store.
                    this$1.addNewNode(tx, data, function (e, dataId) {
                        if (noErrorTx(e, tx, cb)) {
                            // Step 3: Commit the file's inode to the store.
                            var fileInode = new Inode(dataId, data.length, mode | type, currTime, currTime, currTime);
                            this$1.addNewNode(tx, fileInode.toBuffer(), function (e, fileInodeId) {
                                if (noErrorTx(e, tx, cb)) {
                                    // Step 4: Update parent directory's listing.
                                    dirListing[fname] = fileInodeId;
                                    tx.put(parentNode.id, Buffer.from(JSON.stringify(dirListing)), true, function (e) {
                                        if (noErrorTx(e, tx, cb)) {
                                            // Step 5: Commit and return the new inode.
                                            tx.commit(function (e) {
                                                if (noErrorTx(e, tx, cb)) {
                                                    cb(null, fileInode);
                                                }
                                            });
                                        }
                                    });
                                }
                            });
                        }
                    });
                }
            }
        });
    };
    /**
     * Remove all traces of the given path from the file system.
     * @param p The path to remove from the file system.
     * @param isDir Does the path belong to a directory, or a file?
     * @todo Update mtime.
     */
    AsyncKeyValueFileSystem.prototype.removeEntry = function removeEntry (p, isDir, cb) {
        var this$1 = this;

        var tx = this.store.beginTransaction('readwrite'), parent = path.dirname(p), fileName = path.basename(p);
        // Step 1: Get parent directory's node and directory listing.
        this.findINodeAndDirListing(tx, parent, function (e, parentNode, parentListing) {
            if (noErrorTx(e, tx, cb)) {
                if (!parentListing[fileName]) {
                    tx.abort(function () {
                        cb(ApiError.ENOENT(p));
                    });
                }
                else {
                    // Remove from directory listing of parent.
                    var fileNodeId = parentListing[fileName];
                    delete parentListing[fileName];
                    // Step 2: Get file inode.
                    this$1.getINode(tx, p, fileNodeId, function (e, fileNode) {
                        if (noErrorTx(e, tx, cb)) {
                            if (!isDir && fileNode.isDirectory()) {
                                tx.abort(function () {
                                    cb(ApiError.EISDIR(p));
                                });
                            }
                            else if (isDir && !fileNode.isDirectory()) {
                                tx.abort(function () {
                                    cb(ApiError.ENOTDIR(p));
                                });
                            }
                            else {
                                // Step 3: Delete data.
                                tx.del(fileNode.id, function (e) {
                                    if (noErrorTx(e, tx, cb)) {
                                        // Step 4: Delete node.
                                        tx.del(fileNodeId, function (e) {
                                            if (noErrorTx(e, tx, cb)) {
                                                // Step 5: Update directory listing.
                                                tx.put(parentNode.id, Buffer.from(JSON.stringify(parentListing)), true, function (e) {
                                                    if (noErrorTx(e, tx, cb)) {
                                                        tx.commit(cb);
                                                    }
                                                });
                                            }
                                        });
                                    }
                                });
                            }
                        }
                    });
                }
            }
        });
    };

    return AsyncKeyValueFileSystem;
}(BaseFileSystem));

/**
 * A simple in-memory key-value store backed by a JavaScript object.
 */
var InMemoryStore = function InMemoryStore() {
    this.store = {};
};
InMemoryStore.prototype.name = function name () { return InMemoryFileSystem.Name; };
InMemoryStore.prototype.clear = function clear () { this.store = {}; };
InMemoryStore.prototype.beginTransaction = function beginTransaction (type) {
    return new SimpleSyncRWTransaction(this);
};
InMemoryStore.prototype.get = function get (key) {
    return this.store[key];
};
InMemoryStore.prototype.put = function put (key, data, overwrite) {
    if (!overwrite && this.store.hasOwnProperty(key)) {
        return false;
    }
    this.store[key] = data;
    return true;
};
InMemoryStore.prototype.del = function del (key) {
    delete this.store[key];
};
/**
 * A simple in-memory file system backed by an InMemoryStore.
 * Files are not persisted across page loads.
 */
var InMemoryFileSystem = (function (SyncKeyValueFileSystem$$1) {
    function InMemoryFileSystem() {
        SyncKeyValueFileSystem$$1.call(this, { store: new InMemoryStore() });
    }

    if ( SyncKeyValueFileSystem$$1 ) InMemoryFileSystem.__proto__ = SyncKeyValueFileSystem$$1;
    InMemoryFileSystem.prototype = Object.create( SyncKeyValueFileSystem$$1 && SyncKeyValueFileSystem$$1.prototype );
    InMemoryFileSystem.prototype.constructor = InMemoryFileSystem;
    /**
     * Creates an InMemoryFileSystem instance.
     */
    InMemoryFileSystem.Create = function Create (options, cb) {
        cb(null, new InMemoryFileSystem());
    };

    return InMemoryFileSystem;
}(SyncKeyValueFileSystem));

InMemoryFileSystem.Name = "InMemory";
InMemoryFileSystem.Options = {};

/**
 * Get the indexedDB constructor for the current browser.
 * @hidden
 */
var indexedDB = toExport.indexedDB ||
    toExport.mozIndexedDB ||
    toExport.webkitIndexedDB ||
    toExport.msIndexedDB;
/**
 * Converts a DOMException or a DOMError from an IndexedDB event into a
 * standardized BrowserFS API error.
 * @hidden
 */
function convertError$2(e, message) {
    if ( message === void 0 ) message = e.toString();

    switch (e.name) {
        case "NotFoundError":
            return new ApiError(ErrorCode.ENOENT, message);
        case "QuotaExceededError":
            return new ApiError(ErrorCode.ENOSPC, message);
        default:
            // The rest do not seem to map cleanly to standard error codes.
            return new ApiError(ErrorCode.EIO, message);
    }
}
/**
 * Produces a new onerror handler for IDB. Our errors are always fatal, so we
 * handle them generically: Call the user-supplied callback with a translated
 * version of the error, and let the error bubble up.
 * @hidden
 */
function onErrorHandler(cb, code, message) {
    if ( code === void 0 ) code = ErrorCode.EIO;
    if ( message === void 0 ) message = null;

    return function (e) {
        // Prevent the error from canceling the transaction.
        e.preventDefault();
        cb(new ApiError(code, message !== null ? message : undefined));
    };
}
/**
 * @hidden
 */
var IndexedDBROTransaction = function IndexedDBROTransaction(tx, store) {
    this.tx = tx;
    this.store = store;
};
IndexedDBROTransaction.prototype.get = function get (key, cb) {
    try {
        var r = this.store.get(key);
        r.onerror = onErrorHandler(cb);
        r.onsuccess = function (event) {
            // IDB returns the value 'undefined' when you try to get keys that
            // don't exist. The caller expects this behavior.
            var result = event.target.result;
            if (result === undefined) {
                cb(null, result);
            }
            else {
                // IDB data is stored as an ArrayBuffer
                cb(null, arrayBuffer2Buffer(result));
            }
        };
    }
    catch (e) {
        cb(convertError$2(e));
    }
};
/**
 * @hidden
 */
var IndexedDBRWTransaction = (function (IndexedDBROTransaction) {
    function IndexedDBRWTransaction(tx, store) {
        IndexedDBROTransaction.call(this, tx, store);
    }

    if ( IndexedDBROTransaction ) IndexedDBRWTransaction.__proto__ = IndexedDBROTransaction;
    IndexedDBRWTransaction.prototype = Object.create( IndexedDBROTransaction && IndexedDBROTransaction.prototype );
    IndexedDBRWTransaction.prototype.constructor = IndexedDBRWTransaction;
    IndexedDBRWTransaction.prototype.put = function put (key, data, overwrite, cb) {
        try {
            var arraybuffer = buffer2ArrayBuffer(data);
            var r;
            // Note: 'add' will never overwrite an existing key.
            r = overwrite ? this.store.put(arraybuffer, key) : this.store.add(arraybuffer, key);
            // XXX: NEED TO RETURN FALSE WHEN ADD HAS A KEY CONFLICT. NO ERROR.
            r.onerror = onErrorHandler(cb);
            r.onsuccess = function (event) {
                cb(null, true);
            };
        }
        catch (e) {
            cb(convertError$2(e));
        }
    };
    IndexedDBRWTransaction.prototype.del = function del (key, cb) {
        try {
            // NOTE: IE8 has a bug with identifiers named 'delete' unless used as a string
            // like this.
            // http://stackoverflow.com/a/26479152
            var r = this.store['delete'](key);
            r.onerror = onErrorHandler(cb);
            r.onsuccess = function (event) {
                cb();
            };
        }
        catch (e) {
            cb(convertError$2(e));
        }
    };
    IndexedDBRWTransaction.prototype.commit = function commit (cb) {
        // Return to the event loop to commit the transaction.
        setTimeout(cb, 0);
    };
    IndexedDBRWTransaction.prototype.abort = function abort (cb) {
        var _e = null;
        try {
            this.tx.abort();
        }
        catch (e) {
            _e = convertError$2(e);
        }
        finally {
            cb(_e);
        }
    };

    return IndexedDBRWTransaction;
}(IndexedDBROTransaction));
var IndexedDBStore = function IndexedDBStore(db, storeName) {
    this.db = db;
    this.storeName = storeName;
};
IndexedDBStore.Create = function Create (storeName, cb) {
    var openReq = indexedDB.open(storeName, 1);
    openReq.onupgradeneeded = function (event) {
        var db = event.target.result;
        // Huh. This should never happen; we're at version 1. Why does another
        // database exist?
        if (db.objectStoreNames.contains(storeName)) {
            db.deleteObjectStore(storeName);
        }
        db.createObjectStore(storeName);
    };
    openReq.onsuccess = function (event) {
        cb(null, new IndexedDBStore(event.target.result, storeName));
    };
    openReq.onerror = onErrorHandler(cb, ErrorCode.EACCES);
};
IndexedDBStore.prototype.name = function name () {
    return IndexedDBFileSystem.Name + " - " + this.storeName;
};
IndexedDBStore.prototype.clear = function clear (cb) {
    try {
        var tx = this.db.transaction(this.storeName, 'readwrite'), objectStore = tx.objectStore(this.storeName), r = objectStore.clear();
        r.onsuccess = function (event) {
            // Use setTimeout to commit transaction.
            setTimeout(cb, 0);
        };
        r.onerror = onErrorHandler(cb);
    }
    catch (e) {
        cb(convertError$2(e));
    }
};
IndexedDBStore.prototype.beginTransaction = function beginTransaction (type) {
        if ( type === void 0 ) type = 'readonly';

    var tx = this.db.transaction(this.storeName, type), objectStore = tx.objectStore(this.storeName);
    if (type === 'readwrite') {
        return new IndexedDBRWTransaction(tx, objectStore);
    }
    else if (type === 'readonly') {
        return new IndexedDBROTransaction(tx, objectStore);
    }
    else {
        throw new ApiError(ErrorCode.EINVAL, 'Invalid transaction type.');
    }
};
/**
 * A file system that uses the IndexedDB key value file system.
 */
var IndexedDBFileSystem = (function (AsyncKeyValueFileSystem$$1) {
    function IndexedDBFileSystem(store) {
        AsyncKeyValueFileSystem$$1.call(this);
        this.store = store;
    }

    if ( AsyncKeyValueFileSystem$$1 ) IndexedDBFileSystem.__proto__ = AsyncKeyValueFileSystem$$1;
    IndexedDBFileSystem.prototype = Object.create( AsyncKeyValueFileSystem$$1 && AsyncKeyValueFileSystem$$1.prototype );
    IndexedDBFileSystem.prototype.constructor = IndexedDBFileSystem;
    /**
     * Constructs an IndexedDB file system with the given options.
     */
    IndexedDBFileSystem.Create = function Create (opts, cb) {
        IndexedDBStore.Create(opts.storeName ? opts.storeName : 'browserfs', function (e, store) {
            if (store) {
                cb(null, new IndexedDBFileSystem(store));
            }
            else {
                cb(e);
            }
        });
    };
    IndexedDBFileSystem.isAvailable = function isAvailable () {
        // In Safari's private browsing mode, indexedDB.open returns NULL.
        // In Firefox, it throws an exception.
        // In Chrome, it "just works", and clears the database when you leave the page.
        // Untested: Opera, IE.
        try {
            return typeof indexedDB !== 'undefined' && null !== indexedDB.open("__browserfs_test__");
        }
        catch (e) {
            return false;
        }
    };

    return IndexedDBFileSystem;
}(AsyncKeyValueFileSystem));

IndexedDBFileSystem.Name = "IndexedDB";
IndexedDBFileSystem.Options = {
    storeName: {
        type: "string",
        optional: true,
        description: "The name of this file system. You can have multiple IndexedDB file systems operating at once, but each must have a different name."
    }
};

/**
 * Some versions of FF and all versions of IE do not support the full range of
 * 16-bit numbers encoded as characters, as they enforce UTF-16 restrictions.
 * @url http://stackoverflow.com/questions/11170716/are-there-any-characters-that-are-not-allowed-in-localstorage/11173673#11173673
 * @hidden
 */
var supportsBinaryString = false;
var binaryEncoding;
try {
    toExport.localStorage.setItem("__test__", String.fromCharCode(0xD800));
    supportsBinaryString = toExport.localStorage.getItem("__test__") === String.fromCharCode(0xD800);
}
catch (e) {
    // IE throws an exception.
    supportsBinaryString = false;
}
binaryEncoding = supportsBinaryString ? 'binary_string' : 'binary_string_ie';
if (!Buffer.isEncoding(binaryEncoding)) {
    // Fallback for non BrowserFS implementations of buffer that lack a
    // binary_string format.
    binaryEncoding = "base64";
}
/**
 * A synchronous key-value store backed by localStorage.
 */
var LocalStorageStore = function LocalStorageStore () {};

LocalStorageStore.prototype.name = function name () {
    return LocalStorageFileSystem.Name;
};
LocalStorageStore.prototype.clear = function clear () {
    toExport.localStorage.clear();
};
LocalStorageStore.prototype.beginTransaction = function beginTransaction (type) {
    // No need to differentiate.
    return new SimpleSyncRWTransaction(this);
};
LocalStorageStore.prototype.get = function get (key) {
    try {
        var data = toExport.localStorage.getItem(key);
        if (data !== null) {
            return Buffer.from(data, binaryEncoding);
        }
    }
    catch (e) {
        // Do nothing.
    }
    // Key doesn't exist, or a failure occurred.
    return undefined;
};
LocalStorageStore.prototype.put = function put (key, data, overwrite) {
    try {
        if (!overwrite && toExport.localStorage.getItem(key) !== null) {
            // Don't want to overwrite the key!
            return false;
        }
        toExport.localStorage.setItem(key, data.toString(binaryEncoding));
        return true;
    }
    catch (e) {
        throw new ApiError(ErrorCode.ENOSPC, "LocalStorage is full.");
    }
};
LocalStorageStore.prototype.del = function del (key) {
    try {
        toExport.localStorage.removeItem(key);
    }
    catch (e) {
        throw new ApiError(ErrorCode.EIO, "Unable to delete key " + key + ": " + e);
    }
};
/**
 * A synchronous file system backed by localStorage. Connects our
 * LocalStorageStore to our SyncKeyValueFileSystem.
 */
var LocalStorageFileSystem = (function (SyncKeyValueFileSystem$$1) {
    function LocalStorageFileSystem() { SyncKeyValueFileSystem$$1.call(this, { store: new LocalStorageStore() }); }

    if ( SyncKeyValueFileSystem$$1 ) LocalStorageFileSystem.__proto__ = SyncKeyValueFileSystem$$1;
    LocalStorageFileSystem.prototype = Object.create( SyncKeyValueFileSystem$$1 && SyncKeyValueFileSystem$$1.prototype );
    LocalStorageFileSystem.prototype.constructor = LocalStorageFileSystem;
    /**
     * Creates a LocalStorageFileSystem instance.
     */
    LocalStorageFileSystem.Create = function Create (options, cb) {
        cb(null, new LocalStorageFileSystem());
    };
    LocalStorageFileSystem.isAvailable = function isAvailable () {
        return typeof toExport.localStorage !== 'undefined';
    };

    return LocalStorageFileSystem;
}(SyncKeyValueFileSystem));

LocalStorageFileSystem.Name = "LocalStorage";
LocalStorageFileSystem.Options = {};

/**
 * The MountableFileSystem allows you to mount multiple backend types or
 * multiple instantiations of the same backend into a single file system tree.
 * The file systems do not need to know about each other; all interactions are
 * automatically facilitated through this interface.
 *
 * For example, if a file system is mounted at /mnt/blah, and a request came in
 * for /mnt/blah/foo.txt, the file system would see a request for /foo.txt.
 *
 * You can mount file systems when you configure the file system:
 * ```javascript
 * BrowserFS.configure({
 *   fs: "MountableFileSystem",
 *   options: {
 *     '/data': { fs: 'HTTPRequest', options: { index: "http://mysite.com/files/index.json" } },
 *     '/home': { fs: 'LocalStorage' }
 *   }
 * }, function(e) {
 *
 * });
 * ```
 *
 * For advanced users, you can also mount file systems *after* MFS is constructed:
 * ```javascript
 * BrowserFS.FileSystem.HTTPRequest.Create({
 *   index: "http://mysite.com/files/index.json"
 * }, function(e, xhrfs) {
 *   BrowserFS.FileSystem.MountableFileSystem.Create({
 *     '/data': xhrfs
 *   }, function(e, mfs) {
 *     BrowserFS.initialize(mfs);
 *
 *     // Added after-the-fact...
 *     BrowserFS.FileSystem.LocalStorage.Create(function(e, lsfs) {
 *       mfs.mount('/home', lsfs);
 *     });
 *   });
 * });
 * ```
 *
 * Since MountableFileSystem simply proxies requests to mounted file systems, it supports all of the operations that the mounted file systems support.
 *
 * With no mounted file systems, `MountableFileSystem` acts as a simple `InMemory` filesystem.
 */
var MountableFileSystem = (function (BaseFileSystem$$1) {
    function MountableFileSystem(rootFs) {
        BaseFileSystem$$1.call(this);
        // Contains the list of mount points in mntMap, sorted by string length in decreasing order.
        // Ensures that we scan the most specific mount points for a match first, which lets us
        // nest mount points.
        this.mountList = [];
        this.mntMap = {};
        this.rootFs = rootFs;
    }

    if ( BaseFileSystem$$1 ) MountableFileSystem.__proto__ = BaseFileSystem$$1;
    MountableFileSystem.prototype = Object.create( BaseFileSystem$$1 && BaseFileSystem$$1.prototype );
    MountableFileSystem.prototype.constructor = MountableFileSystem;
    /**
     * Creates a MountableFileSystem instance with the given options.
     */
    MountableFileSystem.Create = function Create (opts, cb) {
        InMemoryFileSystem.Create({}, function (e, imfs) {
            if (imfs) {
                var fs = new MountableFileSystem(imfs);
                try {
                    Object.keys(opts).forEach(function (mountPoint) {
                        fs.mount(mountPoint, opts[mountPoint]);
                    });
                }
                catch (e) {
                    return cb(e);
                }
                cb(null, fs);
            }
            else {
                cb(e);
            }
        });
    };
    MountableFileSystem.isAvailable = function isAvailable () {
        return true;
    };
    /**
     * Mounts the file system at the given mount point.
     */
    MountableFileSystem.prototype.mount = function mount (mountPoint, fs) {
        if (mountPoint[0] !== '/') {
            mountPoint = "/" + mountPoint;
        }
        mountPoint = path.resolve(mountPoint);
        if (this.mntMap[mountPoint]) {
            throw new ApiError(ErrorCode.EINVAL, "Mount point " + mountPoint + " is already taken.");
        }
        mkdirpSync(mountPoint, 0x1ff, this.rootFs);
        this.mntMap[mountPoint] = fs;
        this.mountList.push(mountPoint);
        this.mountList = this.mountList.sort(function (a, b) { return b.length - a.length; });
    };
    MountableFileSystem.prototype.umount = function umount (mountPoint) {
        var this$1 = this;

        if (mountPoint[0] !== '/') {
            mountPoint = "/" + mountPoint;
        }
        mountPoint = path.resolve(mountPoint);
        if (!this.mntMap[mountPoint]) {
            throw new ApiError(ErrorCode.EINVAL, "Mount point " + mountPoint + " is already unmounted.");
        }
        delete this.mntMap[mountPoint];
        this.mountList.splice(this.mountList.indexOf(mountPoint), 1);
        while (mountPoint !== '/') {
            if (this$1.rootFs.readdirSync(mountPoint).length === 0) {
                this$1.rootFs.rmdirSync(mountPoint);
                mountPoint = path.dirname(mountPoint);
            }
            else {
                break;
            }
        }
    };
    /**
     * Returns the file system that the path points to.
     */
    MountableFileSystem.prototype._getFs = function _getFs (path$$1) {
        var this$1 = this;

        var mountList = this.mountList, len = mountList.length;
        for (var i = 0; i < len; i++) {
            var mountPoint = mountList[i];
            // We know path is normalized, so it is a substring of the mount point.
            if (mountPoint.length <= path$$1.length && path$$1.indexOf(mountPoint) === 0) {
                path$$1 = path$$1.substr(mountPoint.length > 1 ? mountPoint.length : 0);
                if (path$$1 === '') {
                    path$$1 = '/';
                }
                return { fs: this$1.mntMap[mountPoint], path: path$$1 };
            }
        }
        // Query our root file system.
        return { fs: this.rootFs, path: path$$1 };
    };
    // Global information methods
    MountableFileSystem.prototype.getName = function getName () {
        return MountableFileSystem.Name;
    };
    MountableFileSystem.prototype.diskSpace = function diskSpace (path$$1, cb) {
        cb(0, 0);
    };
    MountableFileSystem.prototype.isReadOnly = function isReadOnly () {
        return false;
    };
    MountableFileSystem.prototype.supportsLinks = function supportsLinks () {
        // I'm not ready for cross-FS links yet.
        return false;
    };
    MountableFileSystem.prototype.supportsProps = function supportsProps () {
        return false;
    };
    MountableFileSystem.prototype.supportsSynch = function supportsSynch () {
        return true;
    };
    /**
     * Fixes up error messages so they mention the mounted file location relative
     * to the MFS root, not to the particular FS's root.
     * Mutates the input error, and returns it.
     */
    MountableFileSystem.prototype.standardizeError = function standardizeError (err, path$$1, realPath) {
        var index = err.message.indexOf(path$$1);
        if (index !== -1) {
            err.message = err.message.substr(0, index) + realPath + err.message.substr(index + path$$1.length);
            err.path = realPath;
        }
        return err;
    };
    // The following methods involve multiple file systems, and thus have custom
    // logic.
    // Note that we go through the Node API to use its robust default argument
    // processing.
    MountableFileSystem.prototype.rename = function rename (oldPath, newPath, cb) {
        var this$1 = this;

        // Scenario 1: old and new are on same FS.
        var fs1rv = this._getFs(oldPath);
        var fs2rv = this._getFs(newPath);
        if (fs1rv.fs === fs2rv.fs) {
            return fs1rv.fs.rename(fs1rv.path, fs2rv.path, function (e) {
                if (e) {
                    this$1.standardizeError(this$1.standardizeError(e, fs1rv.path, oldPath), fs2rv.path, newPath);
                }
                cb(e);
            });
        }
        // Scenario 2: Different file systems.
        // Read old file, write new file, delete old file.
        return _fsMock.readFile(oldPath, function (err, data) {
            if (err) {
                return cb(err);
            }
            _fsMock.writeFile(newPath, data, function (err) {
                if (err) {
                    return cb(err);
                }
                _fsMock.unlink(oldPath, cb);
            });
        });
    };
    MountableFileSystem.prototype.renameSync = function renameSync (oldPath, newPath) {
        // Scenario 1: old and new are on same FS.
        var fs1rv = this._getFs(oldPath);
        var fs2rv = this._getFs(newPath);
        if (fs1rv.fs === fs2rv.fs) {
            try {
                return fs1rv.fs.renameSync(fs1rv.path, fs2rv.path);
            }
            catch (e) {
                this.standardizeError(this.standardizeError(e, fs1rv.path, oldPath), fs2rv.path, newPath);
                throw e;
            }
        }
        // Scenario 2: Different file systems.
        var data = _fsMock.readFileSync(oldPath);
        _fsMock.writeFileSync(newPath, data);
        return _fsMock.unlinkSync(oldPath);
    };
    MountableFileSystem.prototype.readdirSync = function readdirSync (p) {
        var fsInfo = this._getFs(p);
        // If null, rootfs did not have the directory
        // (or the target FS is the root fs).
        var rv = null;
        // Mount points are all defined in the root FS.
        // Ensure that we list those, too.
        if (fsInfo.fs !== this.rootFs) {
            try {
                rv = this.rootFs.readdirSync(p);
            }
            catch (e) {
                // Ignore.
            }
        }
        try {
            var rv2 = fsInfo.fs.readdirSync(fsInfo.path);
            if (rv === null) {
                return rv2;
            }
            else {
                // Filter out duplicates.
                return rv2.concat(rv.filter(function (val) { return rv2.indexOf(val) === -1; }));
            }
        }
        catch (e) {
            if (rv === null) {
                throw this.standardizeError(e, fsInfo.path, p);
            }
            else {
                // The root FS had something.
                return rv;
            }
        }
    };
    MountableFileSystem.prototype.readdir = function readdir (p, cb) {
        var this$1 = this;

        var fsInfo = this._getFs(p);
        fsInfo.fs.readdir(fsInfo.path, function (err, files) {
            if (fsInfo.fs !== this$1.rootFs) {
                try {
                    var rv = this$1.rootFs.readdirSync(p);
                    if (files) {
                        // Filter out duplicates.
                        files = files.concat(rv.filter(function (val) { return files.indexOf(val) === -1; }));
                    }
                    else {
                        files = rv;
                    }
                }
                catch (e) {
                    // Root FS and target FS did not have directory.
                    if (err) {
                        return cb(this$1.standardizeError(err, fsInfo.path, p));
                    }
                }
            }
            else if (err) {
                // Root FS and target FS are the same, and did not have directory.
                return cb(this$1.standardizeError(err, fsInfo.path, p));
            }
            cb(null, files);
        });
    };
    MountableFileSystem.prototype.rmdirSync = function rmdirSync (p) {
        var fsInfo = this._getFs(p);
        if (this._containsMountPt(p)) {
            throw ApiError.ENOTEMPTY(p);
        }
        else {
            try {
                fsInfo.fs.rmdirSync(fsInfo.path);
            }
            catch (e) {
                throw this.standardizeError(e, fsInfo.path, p);
            }
        }
    };
    MountableFileSystem.prototype.rmdir = function rmdir (p, cb) {
        var this$1 = this;

        var fsInfo = this._getFs(p);
        if (this._containsMountPt(p)) {
            cb(ApiError.ENOTEMPTY(p));
        }
        else {
            fsInfo.fs.rmdir(fsInfo.path, function (err) {
                cb(err ? this$1.standardizeError(err, fsInfo.path, p) : null);
            });
        }
    };
    /**
     * Returns true if the given path contains a mount point.
     */
    MountableFileSystem.prototype._containsMountPt = function _containsMountPt (p) {
        var mountPoints = this.mountList, len = mountPoints.length;
        for (var i = 0; i < len; i++) {
            var pt = mountPoints[i];
            if (pt.length >= p.length && pt.slice(0, p.length) === p) {
                return true;
            }
        }
        return false;
    };

    return MountableFileSystem;
}(BaseFileSystem));

MountableFileSystem.Name = "MountableFileSystem";
MountableFileSystem.Options = {};
/**
 * Tricky: Define all of the functions that merely forward arguments to the
 * relevant file system, or return/throw an error.
 * Take advantage of the fact that the *first* argument is always the path, and
 * the *last* is the callback function (if async).
 * @todo Can use numArgs to make proxying more efficient.
 * @hidden
 */
function defineFcn(name, isSync, numArgs) {
    if (isSync) {
        return function () {
            var args = [], len = arguments.length;
            while ( len-- ) args[ len ] = arguments[ len ];

            var path$$1 = args[0];
            var rv = this._getFs(path$$1);
            args[0] = rv.path;
            try {
                return rv.fs[name].apply(rv.fs, args);
            }
            catch (e) {
                this.standardizeError(e, rv.path, path$$1);
                throw e;
            }
        };
    }
    else {
        return function () {
            var this$1 = this;
            var args = [], len = arguments.length;
            while ( len-- ) args[ len ] = arguments[ len ];

            var path$$1 = args[0];
            var rv = this._getFs(path$$1);
            args[0] = rv.path;
            if (typeof args[args.length - 1] === 'function') {
                var cb = args[args.length - 1];
                args[args.length - 1] = function () {
                    var args = [], len = arguments.length;
                    while ( len-- ) args[ len ] = arguments[ len ];

                    if (args.length > 0 && args[0] instanceof ApiError) {
                        this$1.standardizeError(args[0], rv.path, path$$1);
                    }
                    cb.apply(null, args);
                };
            }
            return rv.fs[name].apply(rv.fs, args);
        };
    }
}
/**
 * @hidden
 */
var fsCmdMap = [
    // 1 arg functions
    ['exists', 'unlink', 'readlink'],
    // 2 arg functions
    ['stat', 'mkdir', 'realpath', 'truncate'],
    // 3 arg functions
    ['open', 'readFile', 'chmod', 'utimes'],
    // 4 arg functions
    ['chown'],
    // 5 arg functions
    ['writeFile', 'appendFile']
];
for (var i = 0; i < fsCmdMap.length; i++) {
    var cmds = fsCmdMap[i];
    for (var i$1 = 0, list = cmds; i$1 < list.length; i$1 += 1) {
        var fnName = list[i$1];

        MountableFileSystem.prototype[fnName] = defineFcn(fnName, false, i + 1);
        MountableFileSystem.prototype[fnName + 'Sync'] = defineFcn(fnName + 'Sync', true, i + 1);
    }
}

/**
 * Non-recursive mutex
 * @hidden
 */
var Mutex = function Mutex() {
    this._locked = false;
    this._waiters = [];
};
Mutex.prototype.lock = function lock (cb) {
    if (this._locked) {
        this._waiters.push(cb);
        return;
    }
    this._locked = true;
    cb();
};
Mutex.prototype.unlock = function unlock () {
    if (!this._locked) {
        throw new Error('unlock of a non-locked mutex');
    }
    var next = this._waiters.shift();
    // don't unlock - we want to queue up next for the
    // _end_ of the current task execution, but we don't
    // want it to be called inline with whatever the
    // current stack is.  This way we still get the nice
    // behavior that an unlock immediately followed by a
    // lock won't cause starvation.
    if (next) {
        setImmediate$1(next);
        return;
    }
    this._locked = false;
};
Mutex.prototype.tryLock = function tryLock () {
    if (this._locked) {
        return false;
    }
    this._locked = true;
    return true;
};
Mutex.prototype.isLocked = function isLocked () {
    return this._locked;
};

/**
 * This class serializes access to an underlying async filesystem.
 * For example, on an OverlayFS instance with an async lower
 * directory operations like rename and rmdir may involve multiple
 * requests involving both the upper and lower filesystems -- they
 * are not executed in a single atomic step.  OverlayFS uses this
 * LockedFS to avoid having to reason about the correctness of
 * multiple requests interleaving.
 */
var LockedFS = function LockedFS(fs) {
    this._fs = fs;
    this._mu = new Mutex();
};
LockedFS.prototype.getName = function getName () {
    return 'LockedFS<' + this._fs.getName() + '>';
};
LockedFS.prototype.getFSUnlocked = function getFSUnlocked () {
    return this._fs;
};
LockedFS.prototype.diskSpace = function diskSpace (p, cb) {
    // FIXME: should this lock?
    this._fs.diskSpace(p, cb);
};
LockedFS.prototype.isReadOnly = function isReadOnly () {
    return this._fs.isReadOnly();
};
LockedFS.prototype.supportsLinks = function supportsLinks () {
    return this._fs.supportsLinks();
};
LockedFS.prototype.supportsProps = function supportsProps () {
    return this._fs.supportsProps();
};
LockedFS.prototype.supportsSynch = function supportsSynch () {
    return this._fs.supportsSynch();
};
LockedFS.prototype.rename = function rename (oldPath, newPath, cb) {
        var this$1 = this;

    this._mu.lock(function () {
        this$1._fs.rename(oldPath, newPath, function (err) {
            this$1._mu.unlock();
            cb(err);
        });
    });
};
LockedFS.prototype.renameSync = function renameSync (oldPath, newPath) {
    if (this._mu.isLocked()) {
        throw new Error('invalid sync call');
    }
    return this._fs.renameSync(oldPath, newPath);
};
LockedFS.prototype.stat = function stat (p, isLstat, cb) {
        var this$1 = this;

    this._mu.lock(function () {
        this$1._fs.stat(p, isLstat, function (err, stat) {
            this$1._mu.unlock();
            cb(err, stat);
        });
    });
};
LockedFS.prototype.statSync = function statSync (p, isLstat) {
    if (this._mu.isLocked()) {
        throw new Error('invalid sync call');
    }
    return this._fs.statSync(p, isLstat);
};
LockedFS.prototype.open = function open (p, flag, mode, cb) {
        var this$1 = this;

    this._mu.lock(function () {
        this$1._fs.open(p, flag, mode, function (err, fd) {
            this$1._mu.unlock();
            cb(err, fd);
        });
    });
};
LockedFS.prototype.openSync = function openSync (p, flag, mode) {
    if (this._mu.isLocked()) {
        throw new Error('invalid sync call');
    }
    return this._fs.openSync(p, flag, mode);
};
LockedFS.prototype.unlink = function unlink (p, cb) {
        var this$1 = this;

    this._mu.lock(function () {
        this$1._fs.unlink(p, function (err) {
            this$1._mu.unlock();
            cb(err);
        });
    });
};
LockedFS.prototype.unlinkSync = function unlinkSync (p) {
    if (this._mu.isLocked()) {
        throw new Error('invalid sync call');
    }
    return this._fs.unlinkSync(p);
};
LockedFS.prototype.rmdir = function rmdir (p, cb) {
        var this$1 = this;

    this._mu.lock(function () {
        this$1._fs.rmdir(p, function (err) {
            this$1._mu.unlock();
            cb(err);
        });
    });
};
LockedFS.prototype.rmdirSync = function rmdirSync (p) {
    if (this._mu.isLocked()) {
        throw new Error('invalid sync call');
    }
    return this._fs.rmdirSync(p);
};
LockedFS.prototype.mkdir = function mkdir (p, mode, cb) {
        var this$1 = this;

    this._mu.lock(function () {
        this$1._fs.mkdir(p, mode, function (err) {
            this$1._mu.unlock();
            cb(err);
        });
    });
};
LockedFS.prototype.mkdirSync = function mkdirSync (p, mode) {
    if (this._mu.isLocked()) {
        throw new Error('invalid sync call');
    }
    return this._fs.mkdirSync(p, mode);
};
LockedFS.prototype.readdir = function readdir (p, cb) {
        var this$1 = this;

    this._mu.lock(function () {
        this$1._fs.readdir(p, function (err, files) {
            this$1._mu.unlock();
            cb(err, files);
        });
    });
};
LockedFS.prototype.readdirSync = function readdirSync (p) {
    if (this._mu.isLocked()) {
        throw new Error('invalid sync call');
    }
    return this._fs.readdirSync(p);
};
LockedFS.prototype.exists = function exists (p, cb) {
        var this$1 = this;

    this._mu.lock(function () {
        this$1._fs.exists(p, function (exists) {
            this$1._mu.unlock();
            cb(exists);
        });
    });
};
LockedFS.prototype.existsSync = function existsSync (p) {
    if (this._mu.isLocked()) {
        throw new Error('invalid sync call');
    }
    return this._fs.existsSync(p);
};
LockedFS.prototype.realpath = function realpath (p, cache, cb) {
        var this$1 = this;

    this._mu.lock(function () {
        this$1._fs.realpath(p, cache, function (err, resolvedPath) {
            this$1._mu.unlock();
            cb(err, resolvedPath);
        });
    });
};
LockedFS.prototype.realpathSync = function realpathSync (p, cache) {
    if (this._mu.isLocked()) {
        throw new Error('invalid sync call');
    }
    return this._fs.realpathSync(p, cache);
};
LockedFS.prototype.truncate = function truncate (p, len, cb) {
        var this$1 = this;

    this._mu.lock(function () {
        this$1._fs.truncate(p, len, function (err) {
            this$1._mu.unlock();
            cb(err);
        });
    });
};
LockedFS.prototype.truncateSync = function truncateSync (p, len) {
    if (this._mu.isLocked()) {
        throw new Error('invalid sync call');
    }
    return this._fs.truncateSync(p, len);
};
LockedFS.prototype.readFile = function readFile (fname, encoding, flag, cb) {
        var this$1 = this;

    this._mu.lock(function () {
        this$1._fs.readFile(fname, encoding, flag, function (err, data) {
            this$1._mu.unlock();
            cb(err, data);
        });
    });
};
LockedFS.prototype.readFileSync = function readFileSync (fname, encoding, flag) {
    if (this._mu.isLocked()) {
        throw new Error('invalid sync call');
    }
    return this._fs.readFileSync(fname, encoding, flag);
};
LockedFS.prototype.writeFile = function writeFile (fname, data, encoding, flag, mode, cb) {
        var this$1 = this;

    this._mu.lock(function () {
        this$1._fs.writeFile(fname, data, encoding, flag, mode, function (err) {
            this$1._mu.unlock();
            cb(err);
        });
    });
};
LockedFS.prototype.writeFileSync = function writeFileSync (fname, data, encoding, flag, mode) {
    if (this._mu.isLocked()) {
        throw new Error('invalid sync call');
    }
    return this._fs.writeFileSync(fname, data, encoding, flag, mode);
};
LockedFS.prototype.appendFile = function appendFile (fname, data, encoding, flag, mode, cb) {
        var this$1 = this;

    this._mu.lock(function () {
        this$1._fs.appendFile(fname, data, encoding, flag, mode, function (err) {
            this$1._mu.unlock();
            cb(err);
        });
    });
};
LockedFS.prototype.appendFileSync = function appendFileSync (fname, data, encoding, flag, mode) {
    if (this._mu.isLocked()) {
        throw new Error('invalid sync call');
    }
    return this._fs.appendFileSync(fname, data, encoding, flag, mode);
};
LockedFS.prototype.chmod = function chmod (p, isLchmod, mode, cb) {
        var this$1 = this;

    this._mu.lock(function () {
        this$1._fs.chmod(p, isLchmod, mode, function (err) {
            this$1._mu.unlock();
            cb(err);
        });
    });
};
LockedFS.prototype.chmodSync = function chmodSync (p, isLchmod, mode) {
    if (this._mu.isLocked()) {
        throw new Error('invalid sync call');
    }
    return this._fs.chmodSync(p, isLchmod, mode);
};
LockedFS.prototype.chown = function chown (p, isLchown, uid, gid, cb) {
        var this$1 = this;

    this._mu.lock(function () {
        this$1._fs.chown(p, isLchown, uid, gid, function (err) {
            this$1._mu.unlock();
            cb(err);
        });
    });
};
LockedFS.prototype.chownSync = function chownSync (p, isLchown, uid, gid) {
    if (this._mu.isLocked()) {
        throw new Error('invalid sync call');
    }
    return this._fs.chownSync(p, isLchown, uid, gid);
};
LockedFS.prototype.utimes = function utimes (p, atime, mtime, cb) {
        var this$1 = this;

    this._mu.lock(function () {
        this$1._fs.utimes(p, atime, mtime, function (err) {
            this$1._mu.unlock();
            cb(err);
        });
    });
};
LockedFS.prototype.utimesSync = function utimesSync (p, atime, mtime) {
    if (this._mu.isLocked()) {
        throw new Error('invalid sync call');
    }
    return this._fs.utimesSync(p, atime, mtime);
};
LockedFS.prototype.link = function link (srcpath, dstpath, cb) {
        var this$1 = this;

    this._mu.lock(function () {
        this$1._fs.link(srcpath, dstpath, function (err) {
            this$1._mu.unlock();
            cb(err);
        });
    });
};
LockedFS.prototype.linkSync = function linkSync (srcpath, dstpath) {
    if (this._mu.isLocked()) {
        throw new Error('invalid sync call');
    }
    return this._fs.linkSync(srcpath, dstpath);
};
LockedFS.prototype.symlink = function symlink (srcpath, dstpath, type, cb) {
        var this$1 = this;

    this._mu.lock(function () {
        this$1._fs.symlink(srcpath, dstpath, type, function (err) {
            this$1._mu.unlock();
            cb(err);
        });
    });
};
LockedFS.prototype.symlinkSync = function symlinkSync (srcpath, dstpath, type) {
    if (this._mu.isLocked()) {
        throw new Error('invalid sync call');
    }
    return this._fs.symlinkSync(srcpath, dstpath, type);
};
LockedFS.prototype.readlink = function readlink (p, cb) {
        var this$1 = this;

    this._mu.lock(function () {
        this$1._fs.readlink(p, function (err, linkString) {
            this$1._mu.unlock();
            cb(err, linkString);
        });
    });
};
LockedFS.prototype.readlinkSync = function readlinkSync (p) {
    if (this._mu.isLocked()) {
        throw new Error('invalid sync call');
    }
    return this._fs.readlinkSync(p);
};

/**
 * @hidden
 */
var deletionLogPath = '/.deletedFiles.log';
/**
 * Given a read-only mode, makes it writable.
 * @hidden
 */
function makeModeWritable(mode) {
    return 146 | mode;
}
/**
 * @hidden
 */
function getFlag(f) {
    return FileFlag.getFileFlag(f);
}
/**
 * Overlays a RO file to make it writable.
 */
var OverlayFile = (function (PreloadFile$$1) {
    function OverlayFile(fs, path$$1, flag, stats, data) {
        PreloadFile$$1.call(this, fs, path$$1, flag, stats, data);
    }

    if ( PreloadFile$$1 ) OverlayFile.__proto__ = PreloadFile$$1;
    OverlayFile.prototype = Object.create( PreloadFile$$1 && PreloadFile$$1.prototype );
    OverlayFile.prototype.constructor = OverlayFile;
    OverlayFile.prototype.sync = function sync (cb) {
        var this$1 = this;

        if (!this.isDirty()) {
            cb(null);
            return;
        }
        this._fs._syncAsync(this, function (err) {
            this$1.resetDirty();
            cb(err);
        });
    };
    OverlayFile.prototype.syncSync = function syncSync () {
        if (this.isDirty()) {
            this._fs._syncSync(this);
            this.resetDirty();
        }
    };
    OverlayFile.prototype.close = function close (cb) {
        this.sync(cb);
    };
    OverlayFile.prototype.closeSync = function closeSync () {
        this.syncSync();
    };

    return OverlayFile;
}(PreloadFile));
/**
 * *INTERNAL, DO NOT USE DIRECTLY!*
 *
 * Core OverlayFS class that contains no locking whatsoever. We wrap these objects
 * in a LockedFS to prevent races.
 */
var UnlockedOverlayFS = (function (BaseFileSystem$$1) {
    function UnlockedOverlayFS(writable, readable) {
        BaseFileSystem$$1.call(this);
        this._isInitialized = false;
        this._initializeCallbacks = [];
        this._deletedFiles = {};
        this._deleteLog = '';
        // If 'true', we have scheduled a delete log update.
        this._deleteLogUpdatePending = false;
        // If 'true', a delete log update is needed after the scheduled delete log
        // update finishes.
        this._deleteLogUpdateNeeded = false;
        // If there was an error updating the delete log...
        this._deleteLogError = null;
        this._writable = writable;
        this._readable = readable;
        if (this._writable.isReadOnly()) {
            throw new ApiError(ErrorCode.EINVAL, "Writable file system must be writable.");
        }
    }

    if ( BaseFileSystem$$1 ) UnlockedOverlayFS.__proto__ = BaseFileSystem$$1;
    UnlockedOverlayFS.prototype = Object.create( BaseFileSystem$$1 && BaseFileSystem$$1.prototype );
    UnlockedOverlayFS.prototype.constructor = UnlockedOverlayFS;
    UnlockedOverlayFS.isAvailable = function isAvailable () {
        return true;
    };
    UnlockedOverlayFS.prototype.getOverlayedFileSystems = function getOverlayedFileSystems () {
        return {
            readable: this._readable,
            writable: this._writable
        };
    };
    UnlockedOverlayFS.prototype._syncAsync = function _syncAsync (file, cb) {
        var this$1 = this;

        this.createParentDirectoriesAsync(file.getPath(), function (err) {
            if (err) {
                return cb(err);
            }
            this$1._writable.writeFile(file.getPath(), file.getBuffer(), null, getFlag('w'), file.getStats().mode, cb);
        });
    };
    UnlockedOverlayFS.prototype._syncSync = function _syncSync (file) {
        this.createParentDirectories(file.getPath());
        this._writable.writeFileSync(file.getPath(), file.getBuffer(), null, getFlag('w'), file.getStats().mode);
    };
    UnlockedOverlayFS.prototype.getName = function getName () {
        return OverlayFS.Name;
    };
    /**
     * **INTERNAL METHOD**
     *
     * Called once to load up metadata stored on the writable file system.
     */
    UnlockedOverlayFS.prototype._initialize = function _initialize (cb) {
        var this$1 = this;

        var callbackArray = this._initializeCallbacks;
        var end = function (e) {
            this$1._isInitialized = !e;
            this$1._initializeCallbacks = [];
            callbackArray.forEach((function (cb) { return cb(e); }));
        };
        // if we're already initialized, immediately invoke the callback
        if (this._isInitialized) {
            return cb();
        }
        callbackArray.push(cb);
        // The first call to initialize initializes, the rest wait for it to complete.
        if (callbackArray.length !== 1) {
            return;
        }
        // Read deletion log, process into metadata.
        this._writable.readFile(deletionLogPath, 'utf8', getFlag('r'), function (err, data) {
            if (err) {
                // ENOENT === Newly-instantiated file system, and thus empty log.
                if (err.errno !== ErrorCode.ENOENT) {
                    return end(err);
                }
            }
            else {
                this$1._deleteLog = data;
            }
            this$1._reparseDeletionLog();
            end();
        });
    };
    UnlockedOverlayFS.prototype.isReadOnly = function isReadOnly () { return false; };
    UnlockedOverlayFS.prototype.supportsSynch = function supportsSynch () { return this._readable.supportsSynch() && this._writable.supportsSynch(); };
    UnlockedOverlayFS.prototype.supportsLinks = function supportsLinks () { return false; };
    UnlockedOverlayFS.prototype.supportsProps = function supportsProps () { return this._readable.supportsProps() && this._writable.supportsProps(); };
    UnlockedOverlayFS.prototype.getDeletionLog = function getDeletionLog () {
        return this._deleteLog;
    };
    UnlockedOverlayFS.prototype.restoreDeletionLog = function restoreDeletionLog (log) {
        this._deleteLog = log;
        this._reparseDeletionLog();
        this.updateLog('');
    };
    UnlockedOverlayFS.prototype.rename = function rename (oldPath, newPath, cb) {
        var this$1 = this;

        if (!this.checkInitAsync(cb) || this.checkPathAsync(oldPath, cb) || this.checkPathAsync(newPath, cb)) {
            return;
        }
        if (oldPath === deletionLogPath || newPath === deletionLogPath) {
            return cb(ApiError.EPERM('Cannot rename deletion log.'));
        }
        // nothing to do if paths match
        if (oldPath === newPath) {
            return cb();
        }
        this.stat(oldPath, false, function (oldErr, oldStats) {
            if (oldErr) {
                return cb(oldErr);
            }
            return this$1.stat(newPath, false, function (newErr, newStats) {
                var self = this$1;
                // precondition: both oldPath and newPath exist and are dirs.
                // decreases: |files|
                // Need to move *every file/folder* currently stored on
                // readable to its new location on writable.
                function copyDirContents(files) {
                    var file = files.shift();
                    if (!file) {
                        return cb();
                    }
                    var oldFile = path.resolve(oldPath, file);
                    var newFile = path.resolve(newPath, file);
                    // Recursion! Should work for any nested files / folders.
                    self.rename(oldFile, newFile, function (err) {
                        if (err) {
                            return cb(err);
                        }
                        copyDirContents(files);
                    });
                }
                var mode = 511;
                // from linux's rename(2) manpage: oldpath can specify a
                // directory.  In this case, newpath must either not exist, or
                // it must specify an empty directory.
                if (oldStats.isDirectory()) {
                    if (newErr) {
                        if (newErr.errno !== ErrorCode.ENOENT) {
                            return cb(newErr);
                        }
                        return this$1._writable.exists(oldPath, function (exists) {
                            // simple case - both old and new are on the writable layer
                            if (exists) {
                                return this$1._writable.rename(oldPath, newPath, cb);
                            }
                            this$1._writable.mkdir(newPath, mode, function (mkdirErr) {
                                if (mkdirErr) {
                                    return cb(mkdirErr);
                                }
                                this$1._readable.readdir(oldPath, function (err, files) {
                                    if (err) {
                                        return cb();
                                    }
                                    copyDirContents(files);
                                });
                            });
                        });
                    }
                    mode = newStats.mode;
                    if (!newStats.isDirectory()) {
                        return cb(ApiError.ENOTDIR(newPath));
                    }
                    this$1.readdir(newPath, function (readdirErr, files) {
                        if (files && files.length) {
                            return cb(ApiError.ENOTEMPTY(newPath));
                        }
                        this$1._readable.readdir(oldPath, function (err, files) {
                            if (err) {
                                return cb();
                            }
                            copyDirContents(files);
                        });
                    });
                }
                if (newStats && newStats.isDirectory()) {
                    return cb(ApiError.EISDIR(newPath));
                }
                this$1.readFile(oldPath, null, getFlag('r'), function (err, data) {
                    if (err) {
                        return cb(err);
                    }
                    return this$1.writeFile(newPath, data, null, getFlag('w'), oldStats.mode, function (err) {
                        if (err) {
                            return cb(err);
                        }
                        return this$1.unlink(oldPath, cb);
                    });
                });
            });
        });
    };
    UnlockedOverlayFS.prototype.renameSync = function renameSync (oldPath, newPath) {
        var this$1 = this;

        this.checkInitialized();
        this.checkPath(oldPath);
        this.checkPath(newPath);
        if (oldPath === deletionLogPath || newPath === deletionLogPath) {
            throw ApiError.EPERM('Cannot rename deletion log.');
        }
        // Write newPath using oldPath's contents, delete oldPath.
        var oldStats = this.statSync(oldPath, false);
        if (oldStats.isDirectory()) {
            // Optimization: Don't bother moving if old === new.
            if (oldPath === newPath) {
                return;
            }
            var mode = 511;
            if (this.existsSync(newPath)) {
                var stats = this.statSync(newPath, false);
                mode = stats.mode;
                if (stats.isDirectory()) {
                    if (this.readdirSync(newPath).length > 0) {
                        throw ApiError.ENOTEMPTY(newPath);
                    }
                }
                else {
                    throw ApiError.ENOTDIR(newPath);
                }
            }
            // Take care of writable first. Move any files there, or create an empty directory
            // if it doesn't exist.
            if (this._writable.existsSync(oldPath)) {
                this._writable.renameSync(oldPath, newPath);
            }
            else if (!this._writable.existsSync(newPath)) {
                this._writable.mkdirSync(newPath, mode);
            }
            // Need to move *every file/folder* currently stored on readable to its new location
            // on writable.
            if (this._readable.existsSync(oldPath)) {
                this._readable.readdirSync(oldPath).forEach(function (name) {
                    // Recursion! Should work for any nested files / folders.
                    this$1.renameSync(path.resolve(oldPath, name), path.resolve(newPath, name));
                });
            }
        }
        else {
            if (this.existsSync(newPath) && this.statSync(newPath, false).isDirectory()) {
                throw ApiError.EISDIR(newPath);
            }
            this.writeFileSync(newPath, this.readFileSync(oldPath, null, getFlag('r')), null, getFlag('w'), oldStats.mode);
        }
        if (oldPath !== newPath && this.existsSync(oldPath)) {
            this.unlinkSync(oldPath);
        }
    };
    UnlockedOverlayFS.prototype.stat = function stat (p, isLstat, cb) {
        var this$1 = this;

        if (!this.checkInitAsync(cb)) {
            return;
        }
        this._writable.stat(p, isLstat, function (err, stat) {
            if (err && err.errno === ErrorCode.ENOENT) {
                if (this$1._deletedFiles[p]) {
                    cb(ApiError.ENOENT(p));
                }
                this$1._readable.stat(p, isLstat, function (err, stat) {
                    if (stat) {
                        // Make the oldStat's mode writable. Preserve the topmost
                        // part of the mode, which specifies if it is a file or a
                        // directory.
                        stat = Stats.clone(stat);
                        stat.mode = makeModeWritable(stat.mode);
                    }
                    cb(err, stat);
                });
            }
            else {
                cb(err, stat);
            }
        });
    };
    UnlockedOverlayFS.prototype.statSync = function statSync (p, isLstat) {
        this.checkInitialized();
        try {
            return this._writable.statSync(p, isLstat);
        }
        catch (e) {
            if (this._deletedFiles[p]) {
                throw ApiError.ENOENT(p);
            }
            var oldStat = Stats.clone(this._readable.statSync(p, isLstat));
            // Make the oldStat's mode writable. Preserve the topmost part of the
            // mode, which specifies if it is a file or a directory.
            oldStat.mode = makeModeWritable(oldStat.mode);
            return oldStat;
        }
    };
    UnlockedOverlayFS.prototype.open = function open (p, flag, mode, cb) {
        var this$1 = this;

        if (!this.checkInitAsync(cb) || this.checkPathAsync(p, cb)) {
            return;
        }
        this.stat(p, false, function (err, stats) {
            if (stats) {
                switch (flag.pathExistsAction()) {
                    case ActionType.TRUNCATE_FILE:
                        return this$1.createParentDirectoriesAsync(p, function (err) {
                            if (err) {
                                return cb(err);
                            }
                            this$1._writable.open(p, flag, mode, cb);
                        });
                    case ActionType.NOP:
                        return this$1._writable.exists(p, function (exists) {
                            if (exists) {
                                this$1._writable.open(p, flag, mode, cb);
                            }
                            else {
                                // at this point we know the stats object we got is from
                                // the readable FS.
                                stats = Stats.clone(stats);
                                stats.mode = mode;
                                this$1._readable.readFile(p, null, getFlag('r'), function (readFileErr, data) {
                                    if (readFileErr) {
                                        return cb(readFileErr);
                                    }
                                    if (stats.size === -1) {
                                        stats.size = data.length;
                                    }
                                    var f = new OverlayFile(this$1, p, flag, stats, data);
                                    cb(null, f);
                                });
                            }
                        });
                    default:
                        return cb(ApiError.EEXIST(p));
                }
            }
            else {
                switch (flag.pathNotExistsAction()) {
                    case ActionType.CREATE_FILE:
                        return this$1.createParentDirectoriesAsync(p, function (err) {
                            if (err) {
                                return cb(err);
                            }
                            return this$1._writable.open(p, flag, mode, cb);
                        });
                    default:
                        return cb(ApiError.ENOENT(p));
                }
            }
        });
    };
    UnlockedOverlayFS.prototype.openSync = function openSync (p, flag, mode) {
        this.checkInitialized();
        this.checkPath(p);
        if (p === deletionLogPath) {
            throw ApiError.EPERM('Cannot open deletion log.');
        }
        if (this.existsSync(p)) {
            switch (flag.pathExistsAction()) {
                case ActionType.TRUNCATE_FILE:
                    this.createParentDirectories(p);
                    return this._writable.openSync(p, flag, mode);
                case ActionType.NOP:
                    if (this._writable.existsSync(p)) {
                        return this._writable.openSync(p, flag, mode);
                    }
                    else {
                        // Create an OverlayFile.
                        var buf = this._readable.readFileSync(p, null, getFlag('r'));
                        var stats = Stats.clone(this._readable.statSync(p, false));
                        stats.mode = mode;
                        return new OverlayFile(this, p, flag, stats, buf);
                    }
                default:
                    throw ApiError.EEXIST(p);
            }
        }
        else {
            switch (flag.pathNotExistsAction()) {
                case ActionType.CREATE_FILE:
                    this.createParentDirectories(p);
                    return this._writable.openSync(p, flag, mode);
                default:
                    throw ApiError.ENOENT(p);
            }
        }
    };
    UnlockedOverlayFS.prototype.unlink = function unlink (p, cb) {
        var this$1 = this;

        if (!this.checkInitAsync(cb) || this.checkPathAsync(p, cb)) {
            return;
        }
        this.exists(p, function (exists) {
            if (!exists) {
                return cb(ApiError.ENOENT(p));
            }
            this$1._writable.exists(p, function (writableExists) {
                if (writableExists) {
                    return this$1._writable.unlink(p, function (err) {
                        if (err) {
                            return cb(err);
                        }
                        this$1.exists(p, function (readableExists) {
                            if (readableExists) {
                                this$1.deletePath(p);
                            }
                            cb(null);
                        });
                    });
                }
                else {
                    // if this only exists on the readable FS, add it to the
                    // delete map.
                    this$1.deletePath(p);
                    cb(null);
                }
            });
        });
    };
    UnlockedOverlayFS.prototype.unlinkSync = function unlinkSync (p) {
        this.checkInitialized();
        this.checkPath(p);
        if (this.existsSync(p)) {
            if (this._writable.existsSync(p)) {
                this._writable.unlinkSync(p);
            }
            // if it still exists add to the delete log
            if (this.existsSync(p)) {
                this.deletePath(p);
            }
        }
        else {
            throw ApiError.ENOENT(p);
        }
    };
    UnlockedOverlayFS.prototype.rmdir = function rmdir (p, cb) {
        var this$1 = this;

        if (!this.checkInitAsync(cb)) {
            return;
        }
        var rmdirLower = function () {
            this$1.readdir(p, function (err, files) {
                if (err) {
                    return cb(err);
                }
                if (files.length) {
                    return cb(ApiError.ENOTEMPTY(p));
                }
                this$1.deletePath(p);
                cb(null);
            });
        };
        this.exists(p, function (exists) {
            if (!exists) {
                return cb(ApiError.ENOENT(p));
            }
            this$1._writable.exists(p, function (writableExists) {
                if (writableExists) {
                    this$1._writable.rmdir(p, function (err) {
                        if (err) {
                            return cb(err);
                        }
                        this$1._readable.exists(p, function (readableExists) {
                            if (readableExists) {
                                rmdirLower();
                            }
                            else {
                                cb();
                            }
                        });
                    });
                }
                else {
                    rmdirLower();
                }
            });
        });
    };
    UnlockedOverlayFS.prototype.rmdirSync = function rmdirSync (p) {
        this.checkInitialized();
        if (this.existsSync(p)) {
            if (this._writable.existsSync(p)) {
                this._writable.rmdirSync(p);
            }
            if (this.existsSync(p)) {
                // Check if directory is empty.
                if (this.readdirSync(p).length > 0) {
                    throw ApiError.ENOTEMPTY(p);
                }
                else {
                    this.deletePath(p);
                }
            }
        }
        else {
            throw ApiError.ENOENT(p);
        }
    };
    UnlockedOverlayFS.prototype.mkdir = function mkdir (p, mode, cb) {
        var this$1 = this;

        if (!this.checkInitAsync(cb)) {
            return;
        }
        this.exists(p, function (exists) {
            if (exists) {
                return cb(ApiError.EEXIST(p));
            }
            // The below will throw should any of the parent directories
            // fail to exist on _writable.
            this$1.createParentDirectoriesAsync(p, function (err) {
                if (err) {
                    return cb(err);
                }
                this$1._writable.mkdir(p, mode, cb);
            });
        });
    };
    UnlockedOverlayFS.prototype.mkdirSync = function mkdirSync (p, mode) {
        this.checkInitialized();
        if (this.existsSync(p)) {
            throw ApiError.EEXIST(p);
        }
        else {
            // The below will throw should any of the parent directories fail to exist
            // on _writable.
            this.createParentDirectories(p);
            this._writable.mkdirSync(p, mode);
        }
    };
    UnlockedOverlayFS.prototype.readdir = function readdir (p, cb) {
        var this$1 = this;

        if (!this.checkInitAsync(cb)) {
            return;
        }
        this.stat(p, false, function (err, dirStats) {
            if (err) {
                return cb(err);
            }
            if (!dirStats.isDirectory()) {
                return cb(ApiError.ENOTDIR(p));
            }
            this$1._writable.readdir(p, function (err, wFiles) {
                if (err && err.code !== 'ENOENT') {
                    return cb(err);
                }
                else if (err || !wFiles) {
                    wFiles = [];
                }
                this$1._readable.readdir(p, function (err, rFiles) {
                    // if the directory doesn't exist on the lower FS set rFiles
                    // here to simplify the following code.
                    if (err || !rFiles) {
                        rFiles = [];
                    }
                    // Readdir in both, check delete log on read-only file system's files, merge, return.
                    var seenMap = {};
                    var filtered = wFiles.concat(rFiles.filter(function (fPath) { return !this$1._deletedFiles[(p + "/" + fPath)]; })).filter(function (fPath) {
                        // Remove duplicates.
                        var result = !seenMap[fPath];
                        seenMap[fPath] = true;
                        return result;
                    });
                    cb(null, filtered);
                });
            });
        });
    };
    UnlockedOverlayFS.prototype.readdirSync = function readdirSync (p) {
        var this$1 = this;

        this.checkInitialized();
        var dirStats = this.statSync(p, false);
        if (!dirStats.isDirectory()) {
            throw ApiError.ENOTDIR(p);
        }
        // Readdir in both, check delete log on RO file system's listing, merge, return.
        var contents = [];
        try {
            contents = contents.concat(this._writable.readdirSync(p));
        }
        catch (e) {
            // NOP.
        }
        try {
            contents = contents.concat(this._readable.readdirSync(p).filter(function (fPath) { return !this$1._deletedFiles[(p + "/" + fPath)]; }));
        }
        catch (e) {
            // NOP.
        }
        var seenMap = {};
        return contents.filter(function (fileP) {
            var result = !seenMap[fileP];
            seenMap[fileP] = true;
            return result;
        });
    };
    UnlockedOverlayFS.prototype.exists = function exists (p, cb) {
        var this$1 = this;

        // Cannot pass an error back to callback, so throw an exception instead
        // if not initialized.
        this.checkInitialized();
        this._writable.exists(p, function (existsWritable) {
            if (existsWritable) {
                return cb(true);
            }
            this$1._readable.exists(p, function (existsReadable) {
                cb(existsReadable && this$1._deletedFiles[p] !== true);
            });
        });
    };
    UnlockedOverlayFS.prototype.existsSync = function existsSync (p) {
        this.checkInitialized();
        return this._writable.existsSync(p) || (this._readable.existsSync(p) && this._deletedFiles[p] !== true);
    };
    UnlockedOverlayFS.prototype.chmod = function chmod (p, isLchmod, mode, cb) {
        var this$1 = this;

        if (!this.checkInitAsync(cb)) {
            return;
        }
        this.operateOnWritableAsync(p, function (err) {
            if (err) {
                return cb(err);
            }
            else {
                this$1._writable.chmod(p, isLchmod, mode, cb);
            }
        });
    };
    UnlockedOverlayFS.prototype.chmodSync = function chmodSync (p, isLchmod, mode) {
        var this$1 = this;

        this.checkInitialized();
        this.operateOnWritable(p, function () {
            this$1._writable.chmodSync(p, isLchmod, mode);
        });
    };
    UnlockedOverlayFS.prototype.chown = function chown (p, isLchmod, uid, gid, cb) {
        var this$1 = this;

        if (!this.checkInitAsync(cb)) {
            return;
        }
        this.operateOnWritableAsync(p, function (err) {
            if (err) {
                return cb(err);
            }
            else {
                this$1._writable.chown(p, isLchmod, uid, gid, cb);
            }
        });
    };
    UnlockedOverlayFS.prototype.chownSync = function chownSync (p, isLchown, uid, gid) {
        var this$1 = this;

        this.checkInitialized();
        this.operateOnWritable(p, function () {
            this$1._writable.chownSync(p, isLchown, uid, gid);
        });
    };
    UnlockedOverlayFS.prototype.utimes = function utimes (p, atime, mtime, cb) {
        var this$1 = this;

        if (!this.checkInitAsync(cb)) {
            return;
        }
        this.operateOnWritableAsync(p, function (err) {
            if (err) {
                return cb(err);
            }
            else {
                this$1._writable.utimes(p, atime, mtime, cb);
            }
        });
    };
    UnlockedOverlayFS.prototype.utimesSync = function utimesSync (p, atime, mtime) {
        var this$1 = this;

        this.checkInitialized();
        this.operateOnWritable(p, function () {
            this$1._writable.utimesSync(p, atime, mtime);
        });
    };
    UnlockedOverlayFS.prototype.deletePath = function deletePath (p) {
        this._deletedFiles[p] = true;
        this.updateLog(("d" + p + "\n"));
    };
    UnlockedOverlayFS.prototype.updateLog = function updateLog (addition) {
        var this$1 = this;

        this._deleteLog += addition;
        if (this._deleteLogUpdatePending) {
            this._deleteLogUpdateNeeded = true;
        }
        else {
            this._deleteLogUpdatePending = true;
            this._writable.writeFile(deletionLogPath, this._deleteLog, 'utf8', FileFlag.getFileFlag('w'), 420, function (e) {
                this$1._deleteLogUpdatePending = false;
                if (e) {
                    this$1._deleteLogError = e;
                }
                else if (this$1._deleteLogUpdateNeeded) {
                    this$1._deleteLogUpdateNeeded = false;
                    this$1.updateLog('');
                }
            });
        }
    };
    UnlockedOverlayFS.prototype._reparseDeletionLog = function _reparseDeletionLog () {
        var this$1 = this;

        this._deletedFiles = {};
        this._deleteLog.split('\n').forEach(function (path$$1) {
            // If the log entry begins w/ 'd', it's a deletion.
            this$1._deletedFiles[path$$1.slice(1)] = path$$1.slice(0, 1) === 'd';
        });
    };
    UnlockedOverlayFS.prototype.checkInitialized = function checkInitialized () {
        if (!this._isInitialized) {
            throw new ApiError(ErrorCode.EPERM, "OverlayFS is not initialized. Please initialize OverlayFS using its initialize() method before using it.");
        }
        else if (this._deleteLogError !== null) {
            var e = this._deleteLogError;
            this._deleteLogError = null;
            throw e;
        }
    };
    UnlockedOverlayFS.prototype.checkInitAsync = function checkInitAsync (cb) {
        if (!this._isInitialized) {
            cb(new ApiError(ErrorCode.EPERM, "OverlayFS is not initialized. Please initialize OverlayFS using its initialize() method before using it."));
            return false;
        }
        else if (this._deleteLogError !== null) {
            var e = this._deleteLogError;
            this._deleteLogError = null;
            cb(e);
            return false;
        }
        return true;
    };
    UnlockedOverlayFS.prototype.checkPath = function checkPath (p) {
        if (p === deletionLogPath) {
            throw ApiError.EPERM(p);
        }
    };
    UnlockedOverlayFS.prototype.checkPathAsync = function checkPathAsync (p, cb) {
        if (p === deletionLogPath) {
            cb(ApiError.EPERM(p));
            return true;
        }
        return false;
    };
    UnlockedOverlayFS.prototype.createParentDirectoriesAsync = function createParentDirectoriesAsync (p, cb) {
        var parent = path.dirname(p);
        var toCreate = [];
        var self = this;
        this._writable.stat(parent, false, statDone);
        function statDone(err, stat) {
            if (err) {
                toCreate.push(parent);
                parent = path.dirname(parent);
                self._writable.stat(parent, false, statDone);
            }
            else {
                createParents();
            }
        }
        function createParents() {
            if (!toCreate.length) {
                return cb();
            }
            var dir = toCreate.pop();
            self._readable.stat(dir, false, function (err, stats) {
                // stop if we couldn't read the dir
                if (!stats) {
                    return cb();
                }
                self._writable.mkdir(dir, stats.mode, function (err) {
                    if (err) {
                        return cb(err);
                    }
                    createParents();
                });
            });
        }
    };
    /**
     * With the given path, create the needed parent directories on the writable storage
     * should they not exist. Use modes from the read-only storage.
     */
    UnlockedOverlayFS.prototype.createParentDirectories = function createParentDirectories (p) {
        var this$1 = this;

        var parent = path.dirname(p), toCreate = [];
        while (!this._writable.existsSync(parent)) {
            toCreate.push(parent);
            parent = path.dirname(parent);
        }
        toCreate = toCreate.reverse();
        toCreate.forEach(function (p) {
            this$1._writable.mkdirSync(p, this$1.statSync(p, false).mode);
        });
    };
    /**
     * Helper function:
     * - Ensures p is on writable before proceeding. Throws an error if it doesn't exist.
     * - Calls f to perform operation on writable.
     */
    UnlockedOverlayFS.prototype.operateOnWritable = function operateOnWritable (p, f) {
        if (this.existsSync(p)) {
            if (!this._writable.existsSync(p)) {
                // File is on readable storage. Copy to writable storage before
                // changing its mode.
                this.copyToWritable(p);
            }
            f();
        }
        else {
            throw ApiError.ENOENT(p);
        }
    };
    UnlockedOverlayFS.prototype.operateOnWritableAsync = function operateOnWritableAsync (p, cb) {
        var this$1 = this;

        this.exists(p, function (exists) {
            if (!exists) {
                return cb(ApiError.ENOENT(p));
            }
            this$1._writable.exists(p, function (existsWritable) {
                if (existsWritable) {
                    cb();
                }
                else {
                    return this$1.copyToWritableAsync(p, cb);
                }
            });
        });
    };
    /**
     * Copy from readable to writable storage.
     * PRECONDITION: File does not exist on writable storage.
     */
    UnlockedOverlayFS.prototype.copyToWritable = function copyToWritable (p) {
        var pStats = this.statSync(p, false);
        if (pStats.isDirectory()) {
            this._writable.mkdirSync(p, pStats.mode);
        }
        else {
            this.writeFileSync(p, this._readable.readFileSync(p, null, getFlag('r')), null, getFlag('w'), this.statSync(p, false).mode);
        }
    };
    UnlockedOverlayFS.prototype.copyToWritableAsync = function copyToWritableAsync (p, cb) {
        var this$1 = this;

        this.stat(p, false, function (err, pStats) {
            if (err) {
                return cb(err);
            }
            if (pStats.isDirectory()) {
                return this$1._writable.mkdir(p, pStats.mode, cb);
            }
            // need to copy file.
            this$1._readable.readFile(p, null, getFlag('r'), function (err, data) {
                if (err) {
                    return cb(err);
                }
                this$1.writeFile(p, data, null, getFlag('w'), pStats.mode, cb);
            });
        });
    };

    return UnlockedOverlayFS;
}(BaseFileSystem));
/**
 * OverlayFS makes a read-only filesystem writable by storing writes on a second,
 * writable file system. Deletes are persisted via metadata stored on the writable
 * file system.
 */
var OverlayFS = (function (LockedFS$$1) {
    function OverlayFS(writable, readable) {
        LockedFS$$1.call(this, new UnlockedOverlayFS(writable, readable));
    }

    if ( LockedFS$$1 ) OverlayFS.__proto__ = LockedFS$$1;
    OverlayFS.prototype = Object.create( LockedFS$$1 && LockedFS$$1.prototype );
    OverlayFS.prototype.constructor = OverlayFS;
    /**
     * Constructs and initializes an OverlayFS instance with the given options.
     */
    OverlayFS.Create = function Create (opts, cb) {
        try {
            var fs = new OverlayFS(opts.writable, opts.readable);
            fs._initialize(function (e) {
                cb(e, fs);
            });
        }
        catch (e) {
            cb(e);
        }
    };
    OverlayFS.isAvailable = function isAvailable () {
        return UnlockedOverlayFS.isAvailable();
    };
    OverlayFS.prototype.getOverlayedFileSystems = function getOverlayedFileSystems () {
        return LockedFS$$1.prototype.getFSUnlocked.call(this).getOverlayedFileSystems();
    };
    OverlayFS.prototype.unwrap = function unwrap () {
        return LockedFS$$1.prototype.getFSUnlocked.call(this);
    };
    OverlayFS.prototype._initialize = function _initialize (cb) {
        LockedFS$$1.prototype.getFSUnlocked.call(this)._initialize(cb);
    };

    return OverlayFS;
}(LockedFS));

OverlayFS.Name = "OverlayFS";
OverlayFS.Options = {
    writable: {
        type: "object",
        description: "The file system to write modified files to."
    },
    readable: {
        type: "object",
        description: "The file system that initially populates this file system."
    }
};

/**
 * @hidden
 */
var SpecialArgType;
(function (SpecialArgType) {
    // Callback
    SpecialArgType[SpecialArgType["CB"] = 0] = "CB";
    // File descriptor
    SpecialArgType[SpecialArgType["FD"] = 1] = "FD";
    // API error
    SpecialArgType[SpecialArgType["API_ERROR"] = 2] = "API_ERROR";
    // Stats object
    SpecialArgType[SpecialArgType["STATS"] = 3] = "STATS";
    // Initial probe for file system information.
    SpecialArgType[SpecialArgType["PROBE"] = 4] = "PROBE";
    // FileFlag object.
    SpecialArgType[SpecialArgType["FILEFLAG"] = 5] = "FILEFLAG";
    // Buffer object.
    SpecialArgType[SpecialArgType["BUFFER"] = 6] = "BUFFER";
    // Generic Error object.
    SpecialArgType[SpecialArgType["ERROR"] = 7] = "ERROR";
})(SpecialArgType || (SpecialArgType = {}));
/**
 * Converts callback arguments into ICallbackArgument objects, and back
 * again.
 * @hidden
 */
var CallbackArgumentConverter = function CallbackArgumentConverter() {
    this._callbacks = {};
    this._nextId = 0;
};
CallbackArgumentConverter.prototype.toRemoteArg = function toRemoteArg (cb) {
    var id = this._nextId++;
    this._callbacks[id] = cb;
    return {
        type: SpecialArgType.CB,
        id: id
    };
};
CallbackArgumentConverter.prototype.toLocalArg = function toLocalArg (id) {
    var cb = this._callbacks[id];
    delete this._callbacks[id];
    return cb;
};
/**
 * @hidden
 */
var FileDescriptorArgumentConverter = function FileDescriptorArgumentConverter() {
    this._fileDescriptors = {};
    this._nextId = 0;
};
FileDescriptorArgumentConverter.prototype.toRemoteArg = function toRemoteArg (fd, p, flag, cb) {
    var id = this._nextId++;
    var data;
    var stat;
    this._fileDescriptors[id] = fd;
    // Extract needed information asynchronously.
    fd.stat(function (err, stats) {
        if (err) {
            cb(err);
        }
        else {
            stat = bufferToTransferrableObject(stats.toBuffer());
            // If it's a readable flag, we need to grab contents.
            if (flag.isReadable()) {
                fd.read(Buffer.alloc(stats.size), 0, stats.size, 0, function (err, bytesRead, buff) {
                    if (err) {
                        cb(err);
                    }
                    else {
                        data = bufferToTransferrableObject(buff);
                        cb(null, {
                            type: SpecialArgType.FD,
                            id: id,
                            data: data,
                            stat: stat,
                            path: p,
                            flag: flag.getFlagString()
                        });
                    }
                });
            }
            else {
                // File is not readable, which means writing to it will append or
                // truncate/replace existing contents. Return an empty arraybuffer.
                cb(null, {
                    type: SpecialArgType.FD,
                    id: id,
                    data: new ArrayBuffer(0),
                    stat: stat,
                    path: p,
                    flag: flag.getFlagString()
                });
            }
        }
    });
};
FileDescriptorArgumentConverter.prototype.applyFdAPIRequest = function applyFdAPIRequest (request, cb) {
        var this$1 = this;

    var fdArg = request.args[0];
    this._applyFdChanges(fdArg, function (err, fd) {
        if (err) {
            cb(err);
        }
        else {
            // Apply method on now-changed file descriptor.
            fd[request.method](function (e) {
                if (request.method === 'close') {
                    delete this$1._fileDescriptors[fdArg.id];
                }
                cb(e);
            });
        }
    });
};
FileDescriptorArgumentConverter.prototype._applyFdChanges = function _applyFdChanges (remoteFd, cb) {
    var fd = this._fileDescriptors[remoteFd.id], data = transferrableObjectToBuffer(remoteFd.data), remoteStats = Stats.fromBuffer(transferrableObjectToBuffer(remoteFd.stat));
    // Write data if the file is writable.
    var flag = FileFlag.getFileFlag(remoteFd.flag);
    if (flag.isWriteable()) {
        // Appendable: Write to end of file.
        // Writeable: Replace entire contents of file.
        fd.write(data, 0, data.length, flag.isAppendable() ? fd.getPos() : 0, function (e) {
            function applyStatChanges() {
                // Check if mode changed.
                fd.stat(function (e, stats) {
                    if (e) {
                        cb(e);
                    }
                    else {
                        if (stats.mode !== remoteStats.mode) {
                            fd.chmod(remoteStats.mode, function (e) {
                                cb(e, fd);
                            });
                        }
                        else {
                            cb(e, fd);
                        }
                    }
                });
            }
            if (e) {
                cb(e);
            }
            else {
                // If writeable & not appendable, we need to ensure file contents are
                // identical to those from the remote FD. Thus, we truncate to the
                // length of the remote file.
                if (!flag.isAppendable()) {
                    fd.truncate(data.length, function () {
                        applyStatChanges();
                    });
                }
                else {
                    applyStatChanges();
                }
            }
        });
    }
    else {
        cb(null, fd);
    }
};
/**
 * @hidden
 */
function apiErrorLocal2Remote(e) {
    return {
        type: SpecialArgType.API_ERROR,
        errorData: bufferToTransferrableObject(e.writeToBuffer())
    };
}
/**
 * @hidden
 */
function apiErrorRemote2Local(e) {
    return ApiError.fromBuffer(transferrableObjectToBuffer(e.errorData));
}
/**
 * @hidden
 */
function errorLocal2Remote(e) {
    return {
        type: SpecialArgType.ERROR,
        name: e.name,
        message: e.message,
        stack: e.stack
    };
}
/**
 * @hidden
 */
function errorRemote2Local(e) {
    var cnstr = toExport[e.name];
    if (typeof (cnstr) !== 'function') {
        cnstr = Error;
    }
    var err = new cnstr(e.message);
    err.stack = e.stack;
    return err;
}
/**
 * @hidden
 */
function statsLocal2Remote(stats) {
    return {
        type: SpecialArgType.STATS,
        statsData: bufferToTransferrableObject(stats.toBuffer())
    };
}
/**
 * @hidden
 */
function statsRemote2Local(stats) {
    return Stats.fromBuffer(transferrableObjectToBuffer(stats.statsData));
}
/**
 * @hidden
 */
function fileFlagLocal2Remote(flag) {
    return {
        type: SpecialArgType.FILEFLAG,
        flagStr: flag.getFlagString()
    };
}
/**
 * @hidden
 */
function fileFlagRemote2Local(remoteFlag) {
    return FileFlag.getFileFlag(remoteFlag.flagStr);
}
/**
 * @hidden
 */
function bufferToTransferrableObject(buff) {
    return buffer2ArrayBuffer(buff);
}
/**
 * @hidden
 */
function transferrableObjectToBuffer(buff) {
    return arrayBuffer2Buffer(buff);
}
/**
 * @hidden
 */
function bufferLocal2Remote(buff) {
    return {
        type: SpecialArgType.BUFFER,
        data: bufferToTransferrableObject(buff)
    };
}
/**
 * @hidden
 */
function bufferRemote2Local(buffArg) {
    return transferrableObjectToBuffer(buffArg.data);
}
/**
 * @hidden
 */
function isAPIRequest(data) {
    return data && typeof data === 'object' && data.hasOwnProperty('browserfsMessage') && data['browserfsMessage'];
}
/**
 * @hidden
 */
function isAPIResponse(data) {
    return data && typeof data === 'object' && data.hasOwnProperty('browserfsMessage') && data['browserfsMessage'];
}
/**
 * Represents a remote file in a different worker/thread.
 */
var WorkerFile = (function (PreloadFile$$1) {
    function WorkerFile(_fs, _path, _flag, _stat, remoteFdId, contents) {
        PreloadFile$$1.call(this, _fs, _path, _flag, _stat, contents);
        this._remoteFdId = remoteFdId;
    }

    if ( PreloadFile$$1 ) WorkerFile.__proto__ = PreloadFile$$1;
    WorkerFile.prototype = Object.create( PreloadFile$$1 && PreloadFile$$1.prototype );
    WorkerFile.prototype.constructor = WorkerFile;
    WorkerFile.prototype.getRemoteFdId = function getRemoteFdId () {
        return this._remoteFdId;
    };
    /**
     * @hidden
     */
    WorkerFile.prototype.toRemoteArg = function toRemoteArg () {
        return {
            type: SpecialArgType.FD,
            id: this._remoteFdId,
            data: bufferToTransferrableObject(this.getBuffer()),
            stat: bufferToTransferrableObject(this.getStats().toBuffer()),
            path: this.getPath(),
            flag: this.getFlag().getFlagString()
        };
    };
    WorkerFile.prototype.sync = function sync (cb) {
        this._syncClose('sync', cb);
    };
    WorkerFile.prototype.close = function close (cb) {
        this._syncClose('close', cb);
    };
    WorkerFile.prototype._syncClose = function _syncClose (type, cb) {
        var this$1 = this;

        if (this.isDirty()) {
            this._fs.syncClose(type, this, function (e) {
                if (!e) {
                    this$1.resetDirty();
                }
                cb(e);
            });
        }
        else {
            cb();
        }
    };

    return WorkerFile;
}(PreloadFile));
/**
 * WorkerFS lets you access a BrowserFS instance that is running in a different
 * JavaScript context (e.g. access BrowserFS in one of your WebWorkers, or
 * access BrowserFS running on the main page from a WebWorker).
 *
 * For example, to have a WebWorker access files in the main browser thread,
 * do the following:
 *
 * MAIN BROWSER THREAD:
 *
 * ```javascript
 *   // Listen for remote file system requests.
 *   BrowserFS.FileSystem.WorkerFS.attachRemoteListener(webWorkerObject);
 * ```
 *
 * WEBWORKER THREAD:
 *
 * ```javascript
 *   // Set the remote file system as the root file system.
 *   BrowserFS.configure({ fs: "WorkerFS", options: { worker: self }}, function(e) {
 *     // Ready!
 *   });
 * ```
 *
 * Note that synchronous operations are not permitted on the WorkerFS, regardless
 * of the configuration option of the remote FS.
 */
var WorkerFS = (function (BaseFileSystem$$1) {
    function WorkerFS(worker) {
        var this$1 = this;

        BaseFileSystem$$1.call(this);
        this._callbackConverter = new CallbackArgumentConverter();
        this._isInitialized = false;
        this._isReadOnly = false;
        this._supportLinks = false;
        this._supportProps = false;
        this._worker = worker;
        this._worker.addEventListener('message', function (e) {
            var resp = e.data;
            if (isAPIResponse(resp)) {
                var i;
                var args = resp.args;
                var fixedArgs = new Array(args.length);
                // Dispatch event to correct id.
                for (i = 0; i < fixedArgs.length; i++) {
                    fixedArgs[i] = this$1._argRemote2Local(args[i]);
                }
                this$1._callbackConverter.toLocalArg(resp.cbId).apply(null, fixedArgs);
            }
        });
    }

    if ( BaseFileSystem$$1 ) WorkerFS.__proto__ = BaseFileSystem$$1;
    WorkerFS.prototype = Object.create( BaseFileSystem$$1 && BaseFileSystem$$1.prototype );
    WorkerFS.prototype.constructor = WorkerFS;
    WorkerFS.Create = function Create (opts, cb) {
        var fs = new WorkerFS(opts.worker);
        fs._initialize(function () {
            cb(null, fs);
        });
    };
    WorkerFS.isAvailable = function isAvailable () {
        return typeof (importScripts) !== 'undefined' || typeof (Worker) !== 'undefined';
    };
    /**
     * Attaches a listener to the remote worker for file system requests.
     */
    WorkerFS.attachRemoteListener = function attachRemoteListener (worker) {
        var fdConverter = new FileDescriptorArgumentConverter();
        function argLocal2Remote(arg, requestArgs, cb) {
            switch (typeof arg) {
                case 'object':
                    if (arg instanceof Stats) {
                        cb(null, statsLocal2Remote(arg));
                    }
                    else if (arg instanceof ApiError) {
                        cb(null, apiErrorLocal2Remote(arg));
                    }
                    else if (arg instanceof BaseFile) {
                        // Pass in p and flags from original request.
                        cb(null, fdConverter.toRemoteArg(arg, requestArgs[0], requestArgs[1], cb));
                    }
                    else if (arg instanceof FileFlag) {
                        cb(null, fileFlagLocal2Remote(arg));
                    }
                    else if (arg instanceof Buffer) {
                        cb(null, bufferLocal2Remote(arg));
                    }
                    else if (arg instanceof Error) {
                        cb(null, errorLocal2Remote(arg));
                    }
                    else {
                        cb(null, arg);
                    }
                    break;
                default:
                    cb(null, arg);
                    break;
            }
        }
        function argRemote2Local(arg, fixedRequestArgs) {
            if (!arg) {
                return arg;
            }
            switch (typeof arg) {
                case 'object':
                    if (typeof arg['type'] === 'number') {
                        var specialArg = arg;
                        switch (specialArg.type) {
                            case SpecialArgType.CB:
                                var cbId = arg.id;
                                return function () {
                                    var arguments$1 = arguments;

                                    var i;
                                    var fixedArgs = new Array(arguments.length);
                                    var message, countdown = arguments.length;
                                    function abortAndSendError(err) {
                                        if (countdown > 0) {
                                            countdown = -1;
                                            message = {
                                                browserfsMessage: true,
                                                cbId: cbId,
                                                args: [apiErrorLocal2Remote(err)]
                                            };
                                            worker.postMessage(message);
                                        }
                                    }
                                    for (i = 0; i < arguments.length; i++) {
                                        // Capture i and argument.
                                        (function (i, arg) {
                                            argLocal2Remote(arg, fixedRequestArgs, function (err, fixedArg) {
                                                fixedArgs[i] = fixedArg;
                                                if (err) {
                                                    abortAndSendError(err);
                                                }
                                                else if (--countdown === 0) {
                                                    message = {
                                                        browserfsMessage: true,
                                                        cbId: cbId,
                                                        args: fixedArgs
                                                    };
                                                    worker.postMessage(message);
                                                }
                                            });
                                        })(i, arguments$1[i]);
                                    }
                                    if (arguments.length === 0) {
                                        message = {
                                            browserfsMessage: true,
                                            cbId: cbId,
                                            args: fixedArgs
                                        };
                                        worker.postMessage(message);
                                    }
                                };
                            case SpecialArgType.API_ERROR:
                                return apiErrorRemote2Local(specialArg);
                            case SpecialArgType.STATS:
                                return statsRemote2Local(specialArg);
                            case SpecialArgType.FILEFLAG:
                                return fileFlagRemote2Local(specialArg);
                            case SpecialArgType.BUFFER:
                                return bufferRemote2Local(specialArg);
                            case SpecialArgType.ERROR:
                                return errorRemote2Local(specialArg);
                            default:
                                // No idea what this is.
                                return arg;
                        }
                    }
                    else {
                        return arg;
                    }
                default:
                    return arg;
            }
        }
        worker.addEventListener('message', function (e) {
            var request = e.data;
            if (isAPIRequest(request)) {
                var args = request.args, fixedArgs = new Array(args.length);
                switch (request.method) {
                    case 'close':
                    case 'sync':
                        (function () {
                            // File descriptor-relative methods.
                            var remoteCb = args[1];
                            fdConverter.applyFdAPIRequest(request, function (err) {
                                // Send response.
                                var response = {
                                    browserfsMessage: true,
                                    cbId: remoteCb.id,
                                    args: err ? [apiErrorLocal2Remote(err)] : []
                                };
                                worker.postMessage(response);
                            });
                        })();
                        break;
                    case 'probe':
                        (function () {
                            var rootFs = _fsMock.getRootFS(), remoteCb = args[1], probeResponse = {
                                type: SpecialArgType.PROBE,
                                isReadOnly: rootFs.isReadOnly(),
                                supportsLinks: rootFs.supportsLinks(),
                                supportsProps: rootFs.supportsProps()
                            }, response = {
                                browserfsMessage: true,
                                cbId: remoteCb.id,
                                args: [probeResponse]
                            };
                            worker.postMessage(response);
                        })();
                        break;
                    default:
                        // File system methods.
                        for (var i = 0; i < args.length; i++) {
                            fixedArgs[i] = argRemote2Local(args[i], fixedArgs);
                        }
                        var rootFS = _fsMock.getRootFS();
                        rootFS[request.method].apply(rootFS, fixedArgs);
                        break;
                }
            }
        });
    };
    WorkerFS.prototype.getName = function getName () {
        return WorkerFS.Name;
    };
    WorkerFS.prototype.isReadOnly = function isReadOnly () { return this._isReadOnly; };
    WorkerFS.prototype.supportsSynch = function supportsSynch () { return false; };
    WorkerFS.prototype.supportsLinks = function supportsLinks () { return this._supportLinks; };
    WorkerFS.prototype.supportsProps = function supportsProps () { return this._supportProps; };
    WorkerFS.prototype.rename = function rename (oldPath, newPath, cb) {
        this._rpc('rename', arguments);
    };
    WorkerFS.prototype.stat = function stat (p, isLstat, cb) {
        this._rpc('stat', arguments);
    };
    WorkerFS.prototype.open = function open (p, flag, mode, cb) {
        this._rpc('open', arguments);
    };
    WorkerFS.prototype.unlink = function unlink (p, cb) {
        this._rpc('unlink', arguments);
    };
    WorkerFS.prototype.rmdir = function rmdir (p, cb) {
        this._rpc('rmdir', arguments);
    };
    WorkerFS.prototype.mkdir = function mkdir (p, mode, cb) {
        this._rpc('mkdir', arguments);
    };
    WorkerFS.prototype.readdir = function readdir (p, cb) {
        this._rpc('readdir', arguments);
    };
    WorkerFS.prototype.exists = function exists (p, cb) {
        this._rpc('exists', arguments);
    };
    WorkerFS.prototype.realpath = function realpath (p, cache, cb) {
        this._rpc('realpath', arguments);
    };
    WorkerFS.prototype.truncate = function truncate (p, len, cb) {
        this._rpc('truncate', arguments);
    };
    WorkerFS.prototype.readFile = function readFile (fname, encoding, flag, cb) {
        this._rpc('readFile', arguments);
    };
    WorkerFS.prototype.writeFile = function writeFile (fname, data, encoding, flag, mode, cb) {
        this._rpc('writeFile', arguments);
    };
    WorkerFS.prototype.appendFile = function appendFile (fname, data, encoding, flag, mode, cb) {
        this._rpc('appendFile', arguments);
    };
    WorkerFS.prototype.chmod = function chmod (p, isLchmod, mode, cb) {
        this._rpc('chmod', arguments);
    };
    WorkerFS.prototype.chown = function chown (p, isLchown, uid, gid, cb) {
        this._rpc('chown', arguments);
    };
    WorkerFS.prototype.utimes = function utimes (p, atime, mtime, cb) {
        this._rpc('utimes', arguments);
    };
    WorkerFS.prototype.link = function link (srcpath, dstpath, cb) {
        this._rpc('link', arguments);
    };
    WorkerFS.prototype.symlink = function symlink (srcpath, dstpath, type, cb) {
        this._rpc('symlink', arguments);
    };
    WorkerFS.prototype.readlink = function readlink (p, cb) {
        this._rpc('readlink', arguments);
    };
    WorkerFS.prototype.syncClose = function syncClose (method, fd, cb) {
        this._worker.postMessage({
            browserfsMessage: true,
            method: method,
            args: [fd.toRemoteArg(), this._callbackConverter.toRemoteArg(cb)]
        });
    };
    /**
     * Called once both local and remote sides are set up.
     */
    WorkerFS.prototype._initialize = function _initialize (cb) {
        var this$1 = this;

        if (!this._isInitialized) {
            var message = {
                browserfsMessage: true,
                method: 'probe',
                args: [this._argLocal2Remote(emptyBuffer()), this._callbackConverter.toRemoteArg(function (probeResponse) {
                        this$1._isInitialized = true;
                        this$1._isReadOnly = probeResponse.isReadOnly;
                        this$1._supportLinks = probeResponse.supportsLinks;
                        this$1._supportProps = probeResponse.supportsProps;
                        cb();
                    })]
            };
            this._worker.postMessage(message);
        }
        else {
            cb();
        }
    };
    WorkerFS.prototype._argRemote2Local = function _argRemote2Local (arg) {
        if (!arg) {
            return arg;
        }
        switch (typeof arg) {
            case 'object':
                if (typeof arg['type'] === 'number') {
                    var specialArg = arg;
                    switch (specialArg.type) {
                        case SpecialArgType.API_ERROR:
                            return apiErrorRemote2Local(specialArg);
                        case SpecialArgType.FD:
                            var fdArg = specialArg;
                            return new WorkerFile(this, fdArg.path, FileFlag.getFileFlag(fdArg.flag), Stats.fromBuffer(transferrableObjectToBuffer(fdArg.stat)), fdArg.id, transferrableObjectToBuffer(fdArg.data));
                        case SpecialArgType.STATS:
                            return statsRemote2Local(specialArg);
                        case SpecialArgType.FILEFLAG:
                            return fileFlagRemote2Local(specialArg);
                        case SpecialArgType.BUFFER:
                            return bufferRemote2Local(specialArg);
                        case SpecialArgType.ERROR:
                            return errorRemote2Local(specialArg);
                        default:
                            return arg;
                    }
                }
                else {
                    return arg;
                }
            default:
                return arg;
        }
    };
    WorkerFS.prototype._rpc = function _rpc (methodName, args) {
        var this$1 = this;

        var fixedArgs = new Array(args.length);
        for (var i = 0; i < args.length; i++) {
            fixedArgs[i] = this$1._argLocal2Remote(args[i]);
        }
        var message = {
            browserfsMessage: true,
            method: methodName,
            args: fixedArgs
        };
        this._worker.postMessage(message);
    };
    /**
     * Converts a local argument into a remote argument. Public so WorkerFile objects can call it.
     */
    WorkerFS.prototype._argLocal2Remote = function _argLocal2Remote (arg) {
        if (!arg) {
            return arg;
        }
        switch (typeof arg) {
            case "object":
                if (arg instanceof Stats) {
                    return statsLocal2Remote(arg);
                }
                else if (arg instanceof ApiError) {
                    return apiErrorLocal2Remote(arg);
                }
                else if (arg instanceof WorkerFile) {
                    return arg.toRemoteArg();
                }
                else if (arg instanceof FileFlag) {
                    return fileFlagLocal2Remote(arg);
                }
                else if (arg instanceof Buffer) {
                    return bufferLocal2Remote(arg);
                }
                else if (arg instanceof Error) {
                    return errorLocal2Remote(arg);
                }
                else {
                    return "Unknown argument";
                }
            case "function":
                return this._callbackConverter.toRemoteArg(arg);
            default:
                return arg;
        }
    };

    return WorkerFS;
}(BaseFileSystem));

WorkerFS.Name = "WorkerFS";
WorkerFS.Options = {
    worker: {
        type: "object",
        description: "The target worker that you want to connect to, or the current worker if in a worker context.",
        validator: function (v, cb) {
            // Check for a `postMessage` function.
            if (v['postMessage']) {
                cb();
            }
            else {
                cb(new ApiError(ErrorCode.EINVAL, "option must be a Web Worker instance."));
            }
        }
    }
};

/**
 * Contains utility methods for performing a variety of tasks with
 * XmlHttpRequest across browsers.
 */
var xhrIsAvailable = (typeof (XMLHttpRequest) !== "undefined" && XMLHttpRequest !== null);
function asyncDownloadFileModern(p, type, cb) {
    var req = new XMLHttpRequest();
    req.open('GET', p, true);
    var jsonSupported = true;
    switch (type) {
        case 'buffer':
            req.responseType = 'arraybuffer';
            break;
        case 'json':
            // Some browsers don't support the JSON response type.
            // They either reset responseType, or throw an exception.
            // @see https://github.com/Modernizr/Modernizr/blob/master/src/testXhrType.js
            try {
                req.responseType = 'json';
                jsonSupported = req.responseType === 'json';
            }
            catch (e) {
                jsonSupported = false;
            }
            break;
        default:
            return cb(new ApiError(ErrorCode.EINVAL, "Invalid download type: " + type));
    }
    req.onreadystatechange = function (e) {
        if (req.readyState === 4) {
            if (req.status === 200) {
                switch (type) {
                    case 'buffer':
                        // XXX: WebKit-based browsers return *null* when XHRing an empty file.
                        return cb(null, req.response ? Buffer.from(req.response) : emptyBuffer());
                    case 'json':
                        if (jsonSupported) {
                            return cb(null, req.response);
                        }
                        else {
                            return cb(null, JSON.parse(req.responseText));
                        }
                }
            }
            else {
                return cb(new ApiError(ErrorCode.EIO, ("XHR error: response returned code " + (req.status))));
            }
        }
    };
    req.send();
}
function syncDownloadFileModern(p, type) {
    var req = new XMLHttpRequest();
    req.open('GET', p, false);
    // On most platforms, we cannot set the responseType of synchronous downloads.
    // @todo Test for this; IE10 allows this, as do older versions of Chrome/FF.
    var data = null;
    var err = null;
    // Classic hack to download binary data as a string.
    req.overrideMimeType('text/plain; charset=x-user-defined');
    req.onreadystatechange = function (e) {
        if (req.readyState === 4) {
            if (req.status === 200) {
                switch (type) {
                    case 'buffer':
                        // Convert the text into a buffer.
                        var text = req.responseText;
                        data = Buffer.alloc(text.length);
                        // Throw away the upper bits of each character.
                        for (var i = 0; i < text.length; i++) {
                            // This will automatically throw away the upper bit of each
                            // character for us.
                            data[i] = text.charCodeAt(i);
                        }
                        return;
                    case 'json':
                        data = JSON.parse(req.responseText);
                        return;
                }
            }
            else {
                err = new ApiError(ErrorCode.EIO, ("XHR error: response returned code " + (req.status)));
                return;
            }
        }
    };
    req.send();
    if (err) {
        throw err;
    }
    return data;
}
function syncDownloadFileIE10(p, type) {
    var req = new XMLHttpRequest();
    req.open('GET', p, false);
    switch (type) {
        case 'buffer':
            req.responseType = 'arraybuffer';
            break;
        case 'json':
            // IE10 does not support the JSON type.
            break;
        default:
            throw new ApiError(ErrorCode.EINVAL, "Invalid download type: " + type);
    }
    var data;
    var err;
    req.onreadystatechange = function (e) {
        if (req.readyState === 4) {
            if (req.status === 200) {
                switch (type) {
                    case 'buffer':
                        data = Buffer.from(req.response);
                        break;
                    case 'json':
                        data = JSON.parse(req.response);
                        break;
                }
            }
            else {
                err = new ApiError(ErrorCode.EIO, ("XHR error: response returned code " + (req.status)));
            }
        }
    };
    req.send();
    if (err) {
        throw err;
    }
    return data;
}
/**
 * @hidden
 */
function getFileSize(async, p, cb) {
    var req = new XMLHttpRequest();
    req.open('HEAD', p, async);
    req.onreadystatechange = function (e) {
        if (req.readyState === 4) {
            if (req.status === 200) {
                try {
                    return cb(null, parseInt(req.getResponseHeader('Content-Length') || '-1', 10));
                }
                catch (e) {
                    // In the event that the header isn't present or there is an error...
                    return cb(new ApiError(ErrorCode.EIO, "XHR HEAD error: Could not read content-length."));
                }
            }
            else {
                return cb(new ApiError(ErrorCode.EIO, ("XHR HEAD error: response returned code " + (req.status))));
            }
        }
    };
    req.send();
}
/**
 * Asynchronously download a file as a buffer or a JSON object.
 * Note that the third function signature with a non-specialized type is
 * invalid, but TypeScript requires it when you specialize string arguments to
 * constants.
 * @hidden
 */
var asyncDownloadFile = asyncDownloadFileModern;
/**
 * Synchronously download a file as a buffer or a JSON object.
 * Note that the third function signature with a non-specialized type is
 * invalid, but TypeScript requires it when you specialize string arguments to
 * constants.
 * @hidden
 */
var syncDownloadFile = (isIE && typeof Blob !== 'undefined') ? syncDownloadFileIE10 : syncDownloadFileModern;
/**
 * Synchronously retrieves the size of the given file in bytes.
 * @hidden
 */
function getFileSizeSync(p) {
    var rv = -1;
    getFileSize(false, p, function (err, size) {
        if (err) {
            throw err;
        }
        rv = size;
    });
    return rv;
}
/**
 * Asynchronously retrieves the size of the given file in bytes.
 * @hidden
 */
function getFileSizeAsync(p, cb) {
    getFileSize(true, p, cb);
}

/**
 * Contains utility methods using 'fetch'.
 */
var fetchIsAvailable = (typeof (fetch) !== "undefined" && fetch !== null);
function fetchFileAsync(p, type, cb) {
    var request;
    try {
        request = fetch(p);
    }
    catch (e) {
        // XXX: fetch will throw a TypeError if the URL has credentials in it
        return cb(new ApiError(ErrorCode.EINVAL, e.message));
    }
    request
        .then(function (res) {
        if (!res.ok) {
            return cb(new ApiError(ErrorCode.EIO, ("fetch error: response returned code " + (res.status))));
        }
        else {
            switch (type) {
                case 'buffer':
                    res.arrayBuffer()
                        .then(function (buf) { return cb(null, Buffer.from(buf)); })
                        .catch(function (err) { return cb(new ApiError(ErrorCode.EIO, err.message)); });
                    break;
                case 'json':
                    res.json()
                        .then(function (json) { return cb(null, json); })
                        .catch(function (err) { return cb(new ApiError(ErrorCode.EIO, err.message)); });
                    break;
                default:
                    cb(new ApiError(ErrorCode.EINVAL, "Invalid download type: " + type));
            }
        }
    })
        .catch(function (err) { return cb(new ApiError(ErrorCode.EIO, err.message)); });
}
/**
 * Asynchronously retrieves the size of the given file in bytes.
 * @hidden
 */
function fetchFileSizeAsync(p, cb) {
    fetch(p, { method: 'HEAD' })
        .then(function (res) {
        if (!res.ok) {
            return cb(new ApiError(ErrorCode.EIO, ("fetch HEAD error: response returned code " + (res.status))));
        }
        else {
            return cb(null, parseInt(res.headers.get('Content-Length') || '-1', 10));
        }
    })
        .catch(function (err) { return cb(new ApiError(ErrorCode.EIO, err.message)); });
}

/**
 * A simple class for storing a filesystem index. Assumes that all paths passed
 * to it are *absolute* paths.
 *
 * Can be used as a partial or a full index, although care must be taken if used
 * for the former purpose, especially when directories are concerned.
 */
var FileIndex = function FileIndex() {
    // _index is a single-level key,value store that maps *directory* paths to
    // DirInodes. File information is only contained in DirInodes themselves.
    this._index = {};
    // Create the root directory.
    this.addPath('/', new DirInode());
};
/**
 * Static method for constructing indices from a JSON listing.
 * @param listing Directory listing generated by tools/XHRIndexer.coffee
 * @return A new FileIndex object.
 */
FileIndex.fromListing = function fromListing (listing) {
    var idx = new FileIndex();
    // Add a root DirNode.
    var rootInode = new DirInode();
    idx._index['/'] = rootInode;
    var queue = [['', listing, rootInode]];
    while (queue.length > 0) {
        var inode = (void 0);
        var next = queue.pop();
        var pwd = next[0];
        var tree = next[1];
        var parent = next[2];
        for (var node in tree) {
            if (tree.hasOwnProperty(node)) {
                var children = tree[node];
                var name = pwd + "/" + node;
                if (children) {
                    idx._index[name] = inode = new DirInode();
                    queue.push([name, children, inode]);
                }
                else {
                    // This inode doesn't have correct size information, noted with -1.
                    inode = new FileInode(new Stats(FileType.FILE, -1, 0x16D));
                }
                if (parent) {
                    parent._ls[node] = inode;
                }
            }
        }
    }
    return idx;
};
/**
 * Runs the given function over all files in the index.
 */
FileIndex.prototype.fileIterator = function fileIterator (cb) {
        var this$1 = this;

    for (var path$$1 in this$1._index) {
        if (this$1._index.hasOwnProperty(path$$1)) {
            var dir = this$1._index[path$$1];
            var files = dir.getListing();
            for (var i = 0, list = files; i < list.length; i += 1) {
                var file = list[i];

                    var item = dir.getItem(file);
                if (isFileInode(item)) {
                    cb(item.getData());
                }
            }
        }
    }
};
/**
 * Adds the given absolute path to the index if it is not already in the index.
 * Creates any needed parent directories.
 * @param path The path to add to the index.
 * @param inode The inode for the
 *   path to add.
 * @return 'True' if it was added or already exists, 'false' if there
 *   was an issue adding it (e.g. item in path is a file, item exists but is
 *   different).
 * @todo If adding fails and implicitly creates directories, we do not clean up
 *   the new empty directories.
 */
FileIndex.prototype.addPath = function addPath (path$$1, inode) {
    if (!inode) {
        throw new Error('Inode must be specified');
    }
    if (path$$1[0] !== '/') {
        throw new Error('Path must be absolute, got: ' + path$$1);
    }
    // Check if it already exists.
    if (this._index.hasOwnProperty(path$$1)) {
        return this._index[path$$1] === inode;
    }
    var splitPath = this._split_path(path$$1);
    var dirpath = splitPath[0];
    var itemname = splitPath[1];
    // Try to add to its parent directory first.
    var parent = this._index[dirpath];
    if (parent === undefined && path$$1 !== '/') {
        // Create parent.
        parent = new DirInode();
        if (!this.addPath(dirpath, parent)) {
            return false;
        }
    }
    // Add myself to my parent.
    if (path$$1 !== '/') {
        if (!parent.addItem(itemname, inode)) {
            return false;
        }
    }
    // If I'm a directory, add myself to the index.
    if (isDirInode(inode)) {
        this._index[path$$1] = inode;
    }
    return true;
};
/**
 * Adds the given absolute path to the index if it is not already in the index.
 * The path is added without special treatment (no joining of adjacent separators, etc).
 * Creates any needed parent directories.
 * @param path The path to add to the index.
 * @param inode The inode for the
 *   path to add.
 * @return 'True' if it was added or already exists, 'false' if there
 *   was an issue adding it (e.g. item in path is a file, item exists but is
 *   different).
 * @todo If adding fails and implicitly creates directories, we do not clean up
 *   the new empty directories.
 */
FileIndex.prototype.addPathFast = function addPathFast (path$$1, inode) {
    var itemNameMark = path$$1.lastIndexOf('/');
    var parentPath = itemNameMark === 0 ? "/" : path$$1.substring(0, itemNameMark);
    var itemName = path$$1.substring(itemNameMark + 1);
    // Try to add to its parent directory first.
    var parent = this._index[parentPath];
    if (parent === undefined) {
        // Create parent.
        parent = new DirInode();
        this.addPathFast(parentPath, parent);
    }
    if (!parent.addItem(itemName, inode)) {
        return false;
    }
    // If adding a directory, add to the index as well.
    if (inode.isDir()) {
        this._index[path$$1] = inode;
    }
    return true;
};
/**
 * Removes the given path. Can be a file or a directory.
 * @return The removed item,
 *   or null if it did not exist.
 */
FileIndex.prototype.removePath = function removePath (path$$1) {
        var this$1 = this;

    var splitPath = this._split_path(path$$1);
    var dirpath = splitPath[0];
    var itemname = splitPath[1];
    // Try to remove it from its parent directory first.
    var parent = this._index[dirpath];
    if (parent === undefined) {
        return null;
    }
    // Remove myself from my parent.
    var inode = parent.remItem(itemname);
    if (inode === null) {
        return null;
    }
    // If I'm a directory, remove myself from the index, and remove my children.
    if (isDirInode(inode)) {
        var children = inode.getListing();
        for (var i = 0, list = children; i < list.length; i += 1) {
            var child = list[i];

                this$1.removePath(path$$1 + '/' + child);
        }
        // Remove the directory from the index, unless it's the root.
        if (path$$1 !== '/') {
            delete this._index[path$$1];
        }
    }
    return inode;
};
/**
 * Retrieves the directory listing of the given path.
 * @return An array of files in the given path, or 'null' if it does not exist.
 */
FileIndex.prototype.ls = function ls (path$$1) {
    var item = this._index[path$$1];
    if (item === undefined) {
        return null;
    }
    return item.getListing();
};
/**
 * Returns the inode of the given item.
 * @return Returns null if the item does not exist.
 */
FileIndex.prototype.getInode = function getInode (path$$1) {
    var splitPath = this._split_path(path$$1);
    var dirpath = splitPath[0];
    var itemname = splitPath[1];
    // Retrieve from its parent directory.
    var parent = this._index[dirpath];
    if (parent === undefined) {
        return null;
    }
    // Root case
    if (dirpath === path$$1) {
        return parent;
    }
    return parent.getItem(itemname);
};
/**
 * Split into a (directory path, item name) pair
 */
FileIndex.prototype._split_path = function _split_path (p) {
    var dirpath = path.dirname(p);
    var itemname = p.substr(dirpath.length + (dirpath === "/" ? 0 : 1));
    return [dirpath, itemname];
};
/**
 * Inode for a file. Stores an arbitrary (filesystem-specific) data payload.
 */
var FileInode = function FileInode(data) {
    this.data = data;
};
FileInode.prototype.isFile = function isFile () { return true; };
FileInode.prototype.isDir = function isDir () { return false; };
FileInode.prototype.getData = function getData () { return this.data; };
FileInode.prototype.setData = function setData (data) { this.data = data; };
/**
 * Inode for a directory. Currently only contains the directory listing.
 */
var DirInode = function DirInode(data) {
    if ( data === void 0 ) data = null;

    this.data = data;
    this._ls = {};
};
DirInode.prototype.isFile = function isFile () {
    return false;
};
DirInode.prototype.isDir = function isDir () {
    return true;
};
DirInode.prototype.getData = function getData () { return this.data; };
/**
 * Return a Stats object for this inode.
 * @todo Should probably remove this at some point. This isn't the
 *   responsibility of the FileIndex.
 */
DirInode.prototype.getStats = function getStats () {
    return new Stats(FileType.DIRECTORY, 4096, 0x16D);
};
/**
 * Returns the directory listing for this directory. Paths in the directory are
 * relative to the directory's path.
 * @return The directory listing for this directory.
 */
DirInode.prototype.getListing = function getListing () {
    return Object.keys(this._ls);
};
/**
 * Returns the inode for the indicated item, or null if it does not exist.
 * @param p Name of item in this directory.
 */
DirInode.prototype.getItem = function getItem (p) {
    var item = this._ls[p];
    return item ? item : null;
};
/**
 * Add the given item to the directory listing. Note that the given inode is
 * not copied, and will be mutated by the DirInode if it is a DirInode.
 * @param p Item name to add to the directory listing.
 * @param inode The inode for the
 *   item to add to the directory inode.
 * @return True if it was added, false if it already existed.
 */
DirInode.prototype.addItem = function addItem (p, inode) {
    if (p in this._ls) {
        return false;
    }
    this._ls[p] = inode;
    return true;
};
/**
 * Removes the given item from the directory listing.
 * @param p Name of item to remove from the directory listing.
 * @return Returns the item
 *   removed, or null if the item did not exist.
 */
DirInode.prototype.remItem = function remItem (p) {
    var item = this._ls[p];
    if (item === undefined) {
        return null;
    }
    delete this._ls[p];
    return item;
};
/**
 * @hidden
 */
function isFileInode(inode) {
    return !!inode && inode.isFile();
}
/**
 * @hidden
 */
function isDirInode(inode) {
    return !!inode && inode.isDir();
}

/**
 * Try to convert the given buffer into a string, and pass it to the callback.
 * Optimization that removes the needed try/catch into a helper function, as
 * this is an uncommon case.
 * @hidden
 */
function tryToString(buff, encoding, cb) {
    try {
        cb(null, buff.toString(encoding));
    }
    catch (e) {
        cb(e);
    }
}
function syncNotAvailableError() {
    throw new ApiError(ErrorCode.ENOTSUP, "Synchronous HTTP download methods are not available in this environment.");
}
/**
 * A simple filesystem backed by HTTP downloads. You must create a directory listing using the
 * `make_http_index` tool provided by BrowserFS.
 *
 * If you install BrowserFS globally with `npm i -g browserfs`, you can generate a listing by
 * running `make_http_index` in your terminal in the directory you would like to index:
 *
 * ```
 * make_http_index > index.json
 * ```
 *
 * Listings objects look like the following:
 *
 * ```json
 * {
 *   "home": {
 *     "jvilk": {
 *       "someFile.txt": null,
 *       "someDir": {
 *         // Empty directory
 *       }
 *     }
 *   }
 * }
 * ```
 *
 * *This example has the folder `/home/jvilk` with subfile `someFile.txt` and subfolder `someDir`.*
 */
var HTTPRequest = (function (BaseFileSystem$$1) {
    function HTTPRequest(index, prefixUrl, preferXHR) {
        if ( prefixUrl === void 0 ) prefixUrl = '';
        if ( preferXHR === void 0 ) preferXHR = false;

        BaseFileSystem$$1.call(this);
        // prefix_url must end in a directory separator.
        if (prefixUrl.length > 0 && prefixUrl.charAt(prefixUrl.length - 1) !== '/') {
            prefixUrl = prefixUrl + '/';
        }
        this.prefixUrl = prefixUrl;
        this._index = FileIndex.fromListing(index);
        if (fetchIsAvailable && (!preferXHR || !xhrIsAvailable)) {
            this._requestFileAsyncInternal = fetchFileAsync;
            this._requestFileSizeAsyncInternal = fetchFileSizeAsync;
        }
        else {
            this._requestFileAsyncInternal = asyncDownloadFile;
            this._requestFileSizeAsyncInternal = getFileSizeAsync;
        }
        if (xhrIsAvailable) {
            this._requestFileSyncInternal = syncDownloadFile;
            this._requestFileSizeSyncInternal = getFileSizeSync;
        }
        else {
            this._requestFileSyncInternal = syncNotAvailableError;
            this._requestFileSizeSyncInternal = syncNotAvailableError;
        }
    }

    if ( BaseFileSystem$$1 ) HTTPRequest.__proto__ = BaseFileSystem$$1;
    HTTPRequest.prototype = Object.create( BaseFileSystem$$1 && BaseFileSystem$$1.prototype );
    HTTPRequest.prototype.constructor = HTTPRequest;
    /**
     * Construct an HTTPRequest file system backend with the given options.
     */
    HTTPRequest.Create = function Create (opts, cb) {
        if (opts.index === undefined) {
            opts.index = "index.json";
        }
        if (typeof (opts.index) === "string") {
            asyncDownloadFile(opts.index, "json", function (e, data) {
                if (e) {
                    cb(e);
                }
                else {
                    cb(null, new HTTPRequest(data, opts.baseUrl));
                }
            });
        }
        else {
            cb(null, new HTTPRequest(opts.index, opts.baseUrl));
        }
    };
    HTTPRequest.isAvailable = function isAvailable () {
        return xhrIsAvailable || fetchIsAvailable;
    };
    HTTPRequest.prototype.empty = function empty () {
        this._index.fileIterator(function (file) {
            file.fileData = null;
        });
    };
    HTTPRequest.prototype.getName = function getName () {
        return HTTPRequest.Name;
    };
    HTTPRequest.prototype.diskSpace = function diskSpace (path$$1, cb) {
        // Read-only file system. We could calculate the total space, but that's not
        // important right now.
        cb(0, 0);
    };
    HTTPRequest.prototype.isReadOnly = function isReadOnly () {
        return true;
    };
    HTTPRequest.prototype.supportsLinks = function supportsLinks () {
        return false;
    };
    HTTPRequest.prototype.supportsProps = function supportsProps () {
        return false;
    };
    HTTPRequest.prototype.supportsSynch = function supportsSynch () {
        // Synchronous operations are only available via the XHR interface for now.
        return xhrIsAvailable;
    };
    /**
     * Special HTTPFS function: Preload the given file into the index.
     * @param [String] path
     * @param [BrowserFS.Buffer] buffer
     */
    HTTPRequest.prototype.preloadFile = function preloadFile (path$$1, buffer$$1) {
        var inode = this._index.getInode(path$$1);
        if (isFileInode(inode)) {
            if (inode === null) {
                throw ApiError.ENOENT(path$$1);
            }
            var stats = inode.getData();
            stats.size = buffer$$1.length;
            stats.fileData = buffer$$1;
        }
        else {
            throw ApiError.EISDIR(path$$1);
        }
    };
    HTTPRequest.prototype.stat = function stat (path$$1, isLstat, cb) {
        var inode = this._index.getInode(path$$1);
        if (inode === null) {
            return cb(ApiError.ENOENT(path$$1));
        }
        var stats;
        if (isFileInode(inode)) {
            stats = inode.getData();
            // At this point, a non-opened file will still have default stats from the listing.
            if (stats.size < 0) {
                this._requestFileSizeAsync(path$$1, function (e, size) {
                    if (e) {
                        return cb(e);
                    }
                    stats.size = size;
                    cb(null, Stats.clone(stats));
                });
            }
            else {
                cb(null, Stats.clone(stats));
            }
        }
        else if (isDirInode(inode)) {
            stats = inode.getStats();
            cb(null, stats);
        }
        else {
            cb(ApiError.FileError(ErrorCode.EINVAL, path$$1));
        }
    };
    HTTPRequest.prototype.statSync = function statSync (path$$1, isLstat) {
        var inode = this._index.getInode(path$$1);
        if (inode === null) {
            throw ApiError.ENOENT(path$$1);
        }
        var stats;
        if (isFileInode(inode)) {
            stats = inode.getData();
            // At this point, a non-opened file will still have default stats from the listing.
            if (stats.size < 0) {
                stats.size = this._requestFileSizeSync(path$$1);
            }
        }
        else if (isDirInode(inode)) {
            stats = inode.getStats();
        }
        else {
            throw ApiError.FileError(ErrorCode.EINVAL, path$$1);
        }
        return stats;
    };
    HTTPRequest.prototype.open = function open (path$$1, flags, mode, cb) {
        // INVARIANT: You can't write to files on this file system.
        if (flags.isWriteable()) {
            return cb(new ApiError(ErrorCode.EPERM, path$$1));
        }
        var self = this;
        // Check if the path exists, and is a file.
        var inode = this._index.getInode(path$$1);
        if (inode === null) {
            return cb(ApiError.ENOENT(path$$1));
        }
        if (isFileInode(inode)) {
            var stats = inode.getData();
            switch (flags.pathExistsAction()) {
                case ActionType.THROW_EXCEPTION:
                case ActionType.TRUNCATE_FILE:
                    return cb(ApiError.EEXIST(path$$1));
                case ActionType.NOP:
                    // Use existing file contents.
                    // XXX: Uh, this maintains the previously-used flag.
                    if (stats.fileData) {
                        return cb(null, new NoSyncFile(self, path$$1, flags, Stats.clone(stats), stats.fileData));
                    }
                    // @todo be lazier about actually requesting the file
                    this._requestFileAsync(path$$1, 'buffer', function (err, buffer$$1) {
                        if (err) {
                            return cb(err);
                        }
                        // we don't initially have file sizes
                        stats.size = buffer$$1.length;
                        stats.fileData = buffer$$1;
                        return cb(null, new NoSyncFile(self, path$$1, flags, Stats.clone(stats), buffer$$1));
                    });
                    break;
                default:
                    return cb(new ApiError(ErrorCode.EINVAL, 'Invalid FileMode object.'));
            }
        }
        else {
            return cb(ApiError.EISDIR(path$$1));
        }
    };
    HTTPRequest.prototype.openSync = function openSync (path$$1, flags, mode) {
        // INVARIANT: You can't write to files on this file system.
        if (flags.isWriteable()) {
            throw new ApiError(ErrorCode.EPERM, path$$1);
        }
        // Check if the path exists, and is a file.
        var inode = this._index.getInode(path$$1);
        if (inode === null) {
            throw ApiError.ENOENT(path$$1);
        }
        if (isFileInode(inode)) {
            var stats = inode.getData();
            switch (flags.pathExistsAction()) {
                case ActionType.THROW_EXCEPTION:
                case ActionType.TRUNCATE_FILE:
                    throw ApiError.EEXIST(path$$1);
                case ActionType.NOP:
                    // Use existing file contents.
                    // XXX: Uh, this maintains the previously-used flag.
                    if (stats.fileData) {
                        return new NoSyncFile(this, path$$1, flags, Stats.clone(stats), stats.fileData);
                    }
                    // @todo be lazier about actually requesting the file
                    var buffer$$1 = this._requestFileSync(path$$1, 'buffer');
                    // we don't initially have file sizes
                    stats.size = buffer$$1.length;
                    stats.fileData = buffer$$1;
                    return new NoSyncFile(this, path$$1, flags, Stats.clone(stats), buffer$$1);
                default:
                    throw new ApiError(ErrorCode.EINVAL, 'Invalid FileMode object.');
            }
        }
        else {
            throw ApiError.EISDIR(path$$1);
        }
    };
    HTTPRequest.prototype.readdir = function readdir (path$$1, cb) {
        try {
            cb(null, this.readdirSync(path$$1));
        }
        catch (e) {
            cb(e);
        }
    };
    HTTPRequest.prototype.readdirSync = function readdirSync (path$$1) {
        // Check if it exists.
        var inode = this._index.getInode(path$$1);
        if (inode === null) {
            throw ApiError.ENOENT(path$$1);
        }
        else if (isDirInode(inode)) {
            return inode.getListing();
        }
        else {
            throw ApiError.ENOTDIR(path$$1);
        }
    };
    /**
     * We have the entire file as a buffer; optimize readFile.
     */
    HTTPRequest.prototype.readFile = function readFile (fname, encoding, flag, cb) {
        // Wrap cb in file closing code.
        var oldCb = cb;
        // Get file.
        this.open(fname, flag, 0x1a4, function (err, fd) {
            if (err) {
                return cb(err);
            }
            cb = function (err, arg) {
                fd.close(function (err2) {
                    if (!err) {
                        err = err2;
                    }
                    return oldCb(err, arg);
                });
            };
            var fdCast = fd;
            var fdBuff = fdCast.getBuffer();
            if (encoding === null) {
                cb(err, copyingSlice(fdBuff));
            }
            else {
                tryToString(fdBuff, encoding, cb);
            }
        });
    };
    /**
     * Specially-optimized readfile.
     */
    HTTPRequest.prototype.readFileSync = function readFileSync (fname, encoding, flag) {
        // Get file.
        var fd = this.openSync(fname, flag, 0x1a4);
        try {
            var fdCast = fd;
            var fdBuff = fdCast.getBuffer();
            if (encoding === null) {
                return copyingSlice(fdBuff);
            }
            return fdBuff.toString(encoding);
        }
        finally {
            fd.closeSync();
        }
    };
    HTTPRequest.prototype._getHTTPPath = function _getHTTPPath (filePath) {
        if (filePath.charAt(0) === '/') {
            filePath = filePath.slice(1);
        }
        return this.prefixUrl + filePath;
    };
    HTTPRequest.prototype._requestFileAsync = function _requestFileAsync (p, type, cb) {
        this._requestFileAsyncInternal(this._getHTTPPath(p), type, cb);
    };
    HTTPRequest.prototype._requestFileSync = function _requestFileSync (p, type) {
        return this._requestFileSyncInternal(this._getHTTPPath(p), type);
    };
    /**
     * Only requests the HEAD content, for the file size.
     */
    HTTPRequest.prototype._requestFileSizeAsync = function _requestFileSizeAsync (path$$1, cb) {
        this._requestFileSizeAsyncInternal(this._getHTTPPath(path$$1), cb);
    };
    HTTPRequest.prototype._requestFileSizeSync = function _requestFileSizeSync (path$$1) {
        return this._requestFileSizeSyncInternal(this._getHTTPPath(path$$1));
    };

    return HTTPRequest;
}(BaseFileSystem));

HTTPRequest.Name = "HTTPRequest";
HTTPRequest.Options = {
    index: {
        type: ["string", "object"],
        optional: true,
        description: "URL to a file index as a JSON file or the file index object itself, generated with the make_http_index script. Defaults to `index.json`."
    },
    baseUrl: {
        type: "string",
        optional: true,
        description: "Used as the URL prefix for fetched files. Default: Fetch files relative to the index."
    },
    preferXHR: {
        type: "boolean",
        optional: true,
        description: "Whether to prefer XmlHttpRequest or fetch for async operations if both are available. Default: false"
    }
};

/**
 * (Nonstandard) String utility function for 8-bit ASCII with the extended
 * character set. Unlike the ASCII above, we do not mask the high bits.
 *
 * Placed into a separate file so it can be used with other Buffer implementations.
 * @see http://en.wikipedia.org/wiki/Extended_ASCII
 */
var ExtendedASCII = function ExtendedASCII () {};

ExtendedASCII.str2byte = function str2byte (str, buf) {
    var length = str.length > buf.length ? buf.length : str.length;
    for (var i = 0; i < length; i++) {
        var charCode = str.charCodeAt(i);
        if (charCode > 0x7F) {
            // Check if extended ASCII.
            var charIdx = ExtendedASCII.extendedChars.indexOf(str.charAt(i));
            if (charIdx > -1) {
                charCode = charIdx + 0x80;
            }
            // Otherwise, keep it as-is.
        }
        buf[charCode] = i;
    }
    return length;
};
ExtendedASCII.byte2str = function byte2str (buff) {
    var chars = new Array(buff.length);
    for (var i = 0; i < buff.length; i++) {
        var charCode = buff[i];
        if (charCode > 0x7F) {
            chars[i] = ExtendedASCII.extendedChars[charCode - 128];
        }
        else {
            chars[i] = String.fromCharCode(charCode);
        }
    }
    return chars.join('');
};
ExtendedASCII.byteLength = function byteLength (str) { return str.length; };

ExtendedASCII.extendedChars = ['\u00C7', '\u00FC', '\u00E9', '\u00E2', '\u00E4',
    '\u00E0', '\u00E5', '\u00E7', '\u00EA', '\u00EB', '\u00E8', '\u00EF',
    '\u00EE', '\u00EC', '\u00C4', '\u00C5', '\u00C9', '\u00E6', '\u00C6',
    '\u00F4', '\u00F6', '\u00F2', '\u00FB', '\u00F9', '\u00FF', '\u00D6',
    '\u00DC', '\u00F8', '\u00A3', '\u00D8', '\u00D7', '\u0192', '\u00E1',
    '\u00ED', '\u00F3', '\u00FA', '\u00F1', '\u00D1', '\u00AA', '\u00BA',
    '\u00BF', '\u00AE', '\u00AC', '\u00BD', '\u00BC', '\u00A1', '\u00AB',
    '\u00BB', '_', '_', '_', '\u00A6', '\u00A6', '\u00C1', '\u00C2', '\u00C0',
    '\u00A9', '\u00A6', '\u00A6', '+', '+', '\u00A2', '\u00A5', '+', '+', '-',
    '-', '+', '-', '+', '\u00E3', '\u00C3', '+', '+', '-', '-', '\u00A6', '-',
    '+', '\u00A4', '\u00F0', '\u00D0', '\u00CA', '\u00CB', '\u00C8', 'i',
    '\u00CD', '\u00CE', '\u00CF', '+', '+', '_', '_', '\u00A6', '\u00CC', '_',
    '\u00D3', '\u00DF', '\u00D4', '\u00D2', '\u00F5', '\u00D5', '\u00B5',
    '\u00FE', '\u00DE', '\u00DA', '\u00DB', '\u00D9', '\u00FD', '\u00DD',
    '\u00AF', '\u00B4', '\u00AD', '\u00B1', '_', '\u00BE', '\u00B6', '\u00A7',
    '\u00F7', '\u00B8', '\u00B0', '\u00A8', '\u00B7', '\u00B9', '\u00B3',
    '\u00B2', '_', ' '];

/**
 * @hidden
 */
var inflateRaw = __webpack_require__(35).inflateRaw;
/**
 * Maps CompressionMethod => function that decompresses.
 * @hidden
 */
var decompressionMethods = {};
/**
 * 4.4.2.2: Indicates the compatibiltiy of a file's external attributes.
 */
var ExternalFileAttributeType;
(function (ExternalFileAttributeType) {
    ExternalFileAttributeType[ExternalFileAttributeType["MSDOS"] = 0] = "MSDOS";
    ExternalFileAttributeType[ExternalFileAttributeType["AMIGA"] = 1] = "AMIGA";
    ExternalFileAttributeType[ExternalFileAttributeType["OPENVMS"] = 2] = "OPENVMS";
    ExternalFileAttributeType[ExternalFileAttributeType["UNIX"] = 3] = "UNIX";
    ExternalFileAttributeType[ExternalFileAttributeType["VM_CMS"] = 4] = "VM_CMS";
    ExternalFileAttributeType[ExternalFileAttributeType["ATARI_ST"] = 5] = "ATARI_ST";
    ExternalFileAttributeType[ExternalFileAttributeType["OS2_HPFS"] = 6] = "OS2_HPFS";
    ExternalFileAttributeType[ExternalFileAttributeType["MAC"] = 7] = "MAC";
    ExternalFileAttributeType[ExternalFileAttributeType["Z_SYSTEM"] = 8] = "Z_SYSTEM";
    ExternalFileAttributeType[ExternalFileAttributeType["CP_M"] = 9] = "CP_M";
    ExternalFileAttributeType[ExternalFileAttributeType["NTFS"] = 10] = "NTFS";
    ExternalFileAttributeType[ExternalFileAttributeType["MVS"] = 11] = "MVS";
    ExternalFileAttributeType[ExternalFileAttributeType["VSE"] = 12] = "VSE";
    ExternalFileAttributeType[ExternalFileAttributeType["ACORN_RISC"] = 13] = "ACORN_RISC";
    ExternalFileAttributeType[ExternalFileAttributeType["VFAT"] = 14] = "VFAT";
    ExternalFileAttributeType[ExternalFileAttributeType["ALT_MVS"] = 15] = "ALT_MVS";
    ExternalFileAttributeType[ExternalFileAttributeType["BEOS"] = 16] = "BEOS";
    ExternalFileAttributeType[ExternalFileAttributeType["TANDEM"] = 17] = "TANDEM";
    ExternalFileAttributeType[ExternalFileAttributeType["OS_400"] = 18] = "OS_400";
    ExternalFileAttributeType[ExternalFileAttributeType["OSX"] = 19] = "OSX";
})(ExternalFileAttributeType || (ExternalFileAttributeType = {}));
/**
 * 4.4.5
 */
var CompressionMethod;
(function (CompressionMethod) {
    CompressionMethod[CompressionMethod["STORED"] = 0] = "STORED";
    CompressionMethod[CompressionMethod["SHRUNK"] = 1] = "SHRUNK";
    CompressionMethod[CompressionMethod["REDUCED_1"] = 2] = "REDUCED_1";
    CompressionMethod[CompressionMethod["REDUCED_2"] = 3] = "REDUCED_2";
    CompressionMethod[CompressionMethod["REDUCED_3"] = 4] = "REDUCED_3";
    CompressionMethod[CompressionMethod["REDUCED_4"] = 5] = "REDUCED_4";
    CompressionMethod[CompressionMethod["IMPLODE"] = 6] = "IMPLODE";
    CompressionMethod[CompressionMethod["DEFLATE"] = 8] = "DEFLATE";
    CompressionMethod[CompressionMethod["DEFLATE64"] = 9] = "DEFLATE64";
    CompressionMethod[CompressionMethod["TERSE_OLD"] = 10] = "TERSE_OLD";
    CompressionMethod[CompressionMethod["BZIP2"] = 12] = "BZIP2";
    CompressionMethod[CompressionMethod["LZMA"] = 14] = "LZMA";
    CompressionMethod[CompressionMethod["TERSE_NEW"] = 18] = "TERSE_NEW";
    CompressionMethod[CompressionMethod["LZ77"] = 19] = "LZ77";
    CompressionMethod[CompressionMethod["WAVPACK"] = 97] = "WAVPACK";
    CompressionMethod[CompressionMethod["PPMD"] = 98] = "PPMD"; // PPMd version I, Rev 1
})(CompressionMethod || (CompressionMethod = {}));
/**
 * Converts the input time and date in MS-DOS format into a JavaScript Date
 * object.
 * @hidden
 */
function msdos2date(time, date) {
    // MS-DOS Date
    // |0 0 0 0  0|0 0 0  0|0 0 0  0 0 0 0
    //   D (1-31)  M (1-23)  Y (from 1980)
    var day = date & 0x1F;
    // JS date is 0-indexed, DOS is 1-indexed.
    var month = ((date >> 5) & 0xF) - 1;
    var year = (date >> 9) + 1980;
    // MS DOS Time
    // |0 0 0 0  0|0 0 0  0 0 0|0  0 0 0 0
    //    Second      Minute       Hour
    var second = time & 0x1F;
    var minute = (time >> 5) & 0x3F;
    var hour = time >> 11;
    return new Date(year, month, day, hour, minute, second);
}
/**
 * Safely returns the string from the buffer, even if it is 0 bytes long.
 * (Normally, calling toString() on a buffer with start === end causes an
 * exception).
 * @hidden
 */
function safeToString(buff, useUTF8, start, length) {
    if (length === 0) {
        return "";
    }
    else if (useUTF8) {
        return buff.toString('utf8', start, start + length);
    }
    else {
        return ExtendedASCII.byte2str(buff.slice(start, start + length));
    }
}
/*
   4.3.6 Overall .ZIP file format:

      [local file header 1]
      [encryption header 1]
      [file data 1]
      [data descriptor 1]
      .
      .
      .
      [local file header n]
      [encryption header n]
      [file data n]
      [data descriptor n]
      [archive decryption header]
      [archive extra data record]
      [central directory header 1]
      .
      .
      .
      [central directory header n]
      [zip64 end of central directory record]
      [zip64 end of central directory locator]
      [end of central directory record]
*/
/**
 * 4.3.7  Local file header:
 *
 *     local file header signature     4 bytes  (0x04034b50)
 *     version needed to extract       2 bytes
 *     general purpose bit flag        2 bytes
 *     compression method              2 bytes
 *    last mod file time              2 bytes
 *    last mod file date              2 bytes
 *    crc-32                          4 bytes
 *    compressed size                 4 bytes
 *    uncompressed size               4 bytes
 *    file name length                2 bytes
 *    extra field length              2 bytes
 *
 *    file name (variable size)
 *    extra field (variable size)
 */
var FileHeader = function FileHeader(data) {
     this.data = data;
     if (data.readUInt32LE(0) !== 0x04034b50) {
         throw new ApiError(ErrorCode.EINVAL, "Invalid Zip file: Local file header has invalid signature: " + this.data.readUInt32LE(0));
     }
 };
 FileHeader.prototype.versionNeeded = function versionNeeded () { return this.data.readUInt16LE(4); };
 FileHeader.prototype.flags = function flags () { return this.data.readUInt16LE(6); };
 FileHeader.prototype.compressionMethod = function compressionMethod () { return this.data.readUInt16LE(8); };
 FileHeader.prototype.lastModFileTime = function lastModFileTime () {
     // Time and date is in MS-DOS format.
     return msdos2date(this.data.readUInt16LE(10), this.data.readUInt16LE(12));
 };
 FileHeader.prototype.rawLastModFileTime = function rawLastModFileTime () {
     return this.data.readUInt32LE(10);
 };
 FileHeader.prototype.crc32 = function crc32 () { return this.data.readUInt32LE(14); };
 /**
  * These two values are COMPLETELY USELESS.
  *
  * Section 4.4.9:
  *If bit 3 of the general purpose bit flag is set,
  *these fields are set to zero in the local header and the
  *correct values are put in the data descriptor and
  *in the central directory.
  *
  * So we'll just use the central directory's values.
  */
 // public compressedSize(): number { return this.data.readUInt32LE(18); }
 // public uncompressedSize(): number { return this.data.readUInt32LE(22); }
 FileHeader.prototype.fileNameLength = function fileNameLength () { return this.data.readUInt16LE(26); };
 FileHeader.prototype.extraFieldLength = function extraFieldLength () { return this.data.readUInt16LE(28); };
 FileHeader.prototype.fileName = function fileName () {
     return safeToString(this.data, this.useUTF8(), 30, this.fileNameLength());
 };
 FileHeader.prototype.extraField = function extraField () {
     var start = 30 + this.fileNameLength();
     return this.data.slice(start, start + this.extraFieldLength());
 };
 FileHeader.prototype.totalSize = function totalSize () { return 30 + this.fileNameLength() + this.extraFieldLength(); };
 FileHeader.prototype.useUTF8 = function useUTF8 () { return (this.flags() & 0x800) === 0x800; };
/**
 * 4.3.8  File data
 *
 *   Immediately following the local header for a file
 *   SHOULD be placed the compressed or stored data for the file.
 *   If the file is encrypted, the encryption header for the file
 *   SHOULD be placed after the local header and before the file
 *   data. The series of [local file header][encryption header]
 *   [file data][data descriptor] repeats for each file in the
 *   .ZIP archive.
 *
 *   Zero-byte files, directories, and other file types that
 *   contain no content MUST not include file data.
 */
var FileData = function FileData(header, record, data) {
     this.header = header;
     this.record = record;
     this.data = data;
 };
 FileData.prototype.decompress = function decompress () {
     // Check the compression
     var compressionMethod = this.header.compressionMethod();
     var fcn = decompressionMethods[compressionMethod];
     if (fcn) {
         return fcn(this.data, this.record.compressedSize(), this.record.uncompressedSize(), this.record.flag());
     }
     else {
         var name = CompressionMethod[compressionMethod];
         if (!name) {
             name = "Unknown: " + compressionMethod;
         }
         throw new ApiError(ErrorCode.EINVAL, ("Invalid compression method on file '" + (this.header.fileName()) + "': " + name));
     }
 };
 FileData.prototype.getHeader = function getHeader () {
     return this.header;
 };
 FileData.prototype.getRecord = function getRecord () {
     return this.record;
 };
 FileData.prototype.getRawData = function getRawData () {
     return this.data;
 };
/**
 * 4.3.9  Data descriptor:
 *
 *    crc-32                          4 bytes
 *    compressed size                 4 bytes
 *    uncompressed size               4 bytes
 */
var DataDescriptor = function DataDescriptor(data) {
     this.data = data;
 };
 DataDescriptor.prototype.crc32 = function crc32 () { return this.data.readUInt32LE(0); };
 DataDescriptor.prototype.compressedSize = function compressedSize () { return this.data.readUInt32LE(4); };
 DataDescriptor.prototype.uncompressedSize = function uncompressedSize () { return this.data.readUInt32LE(8); };
/*
` 4.3.10  Archive decryption header:

      4.3.10.1 The Archive Decryption Header is introduced in version 6.2
      of the ZIP format specification.  This record exists in support
      of the Central Directory Encryption Feature implemented as part of
      the Strong Encryption Specification as described in this document.
      When the Central Directory Structure is encrypted, this decryption
      header MUST precede the encrypted data segment.
 */
/**
 * 4.3.11  Archive extra data record:
 *
 *      archive extra data signature    4 bytes  (0x08064b50)
 *      extra field length              4 bytes
 *      extra field data                (variable size)
 *
 *    4.3.11.1 The Archive Extra Data Record is introduced in version 6.2
 *    of the ZIP format specification.  This record MAY be used in support
 *    of the Central Directory Encryption Feature implemented as part of
 *    the Strong Encryption Specification as described in this document.
 *    When present, this record MUST immediately precede the central
 *    directory data structure.
 */
var ArchiveExtraDataRecord = function ArchiveExtraDataRecord(data) {
     this.data = data;
     if (this.data.readUInt32LE(0) !== 0x08064b50) {
         throw new ApiError(ErrorCode.EINVAL, "Invalid archive extra data record signature: " + this.data.readUInt32LE(0));
     }
 };
 ArchiveExtraDataRecord.prototype.length = function length () { return this.data.readUInt32LE(4); };
 ArchiveExtraDataRecord.prototype.extraFieldData = function extraFieldData () { return this.data.slice(8, 8 + this.length()); };
/**
 * 4.3.13 Digital signature:
 *
 *      header signature                4 bytes  (0x05054b50)
 *      size of data                    2 bytes
 *      signature data (variable size)
 *
 *    With the introduction of the Central Directory Encryption
 *    feature in version 6.2 of this specification, the Central
 *    Directory Structure MAY be stored both compressed and encrypted.
 *    Although not required, it is assumed when encrypting the
 *    Central Directory Structure, that it will be compressed
 *    for greater storage efficiency.  Information on the
 *    Central Directory Encryption feature can be found in the section
 *    describing the Strong Encryption Specification. The Digital
 *    Signature record will be neither compressed nor encrypted.
 */
var DigitalSignature = function DigitalSignature(data) {
     this.data = data;
     if (this.data.readUInt32LE(0) !== 0x05054b50) {
         throw new ApiError(ErrorCode.EINVAL, "Invalid digital signature signature: " + this.data.readUInt32LE(0));
     }
 };
 DigitalSignature.prototype.size = function size () { return this.data.readUInt16LE(4); };
 DigitalSignature.prototype.signatureData = function signatureData () { return this.data.slice(6, 6 + this.size()); };
/**
 * 4.3.12  Central directory structure:
 *
 *  central file header signature   4 bytes  (0x02014b50)
 *  version made by                 2 bytes
 *  version needed to extract       2 bytes
 *  general purpose bit flag        2 bytes
 *  compression method              2 bytes
 *  last mod file time              2 bytes
 *  last mod file date              2 bytes
 *  crc-32                          4 bytes
 *  compressed size                 4 bytes
 *  uncompressed size               4 bytes
 *  file name length                2 bytes
 *  extra field length              2 bytes
 *  file comment length             2 bytes
 *  disk number start               2 bytes
 *  internal file attributes        2 bytes
 *  external file attributes        4 bytes
 *  relative offset of local header 4 bytes
 *
 *  file name (variable size)
 *  extra field (variable size)
 *  file comment (variable size)
 */
var CentralDirectory = function CentralDirectory(zipData, data) {
     this.zipData = zipData;
     this.data = data;
     // Sanity check.
     if (this.data.readUInt32LE(0) !== 0x02014b50) {
         throw new ApiError(ErrorCode.EINVAL, ("Invalid Zip file: Central directory record has invalid signature: " + (this.data.readUInt32LE(0))));
     }
     this._filename = this.produceFilename();
 };
 CentralDirectory.prototype.versionMadeBy = function versionMadeBy () { return this.data.readUInt16LE(4); };
 CentralDirectory.prototype.versionNeeded = function versionNeeded () { return this.data.readUInt16LE(6); };
 CentralDirectory.prototype.flag = function flag () { return this.data.readUInt16LE(8); };
 CentralDirectory.prototype.compressionMethod = function compressionMethod () { return this.data.readUInt16LE(10); };
 CentralDirectory.prototype.lastModFileTime = function lastModFileTime () {
     // Time and date is in MS-DOS format.
     return msdos2date(this.data.readUInt16LE(12), this.data.readUInt16LE(14));
 };
 CentralDirectory.prototype.rawLastModFileTime = function rawLastModFileTime () {
     return this.data.readUInt32LE(12);
 };
 CentralDirectory.prototype.crc32 = function crc32 () { return this.data.readUInt32LE(16); };
 CentralDirectory.prototype.compressedSize = function compressedSize () { return this.data.readUInt32LE(20); };
 CentralDirectory.prototype.uncompressedSize = function uncompressedSize () { return this.data.readUInt32LE(24); };
 CentralDirectory.prototype.fileNameLength = function fileNameLength () { return this.data.readUInt16LE(28); };
 CentralDirectory.prototype.extraFieldLength = function extraFieldLength () { return this.data.readUInt16LE(30); };
 CentralDirectory.prototype.fileCommentLength = function fileCommentLength () { return this.data.readUInt16LE(32); };
 CentralDirectory.prototype.diskNumberStart = function diskNumberStart () { return this.data.readUInt16LE(34); };
 CentralDirectory.prototype.internalAttributes = function internalAttributes () { return this.data.readUInt16LE(36); };
 CentralDirectory.prototype.externalAttributes = function externalAttributes () { return this.data.readUInt32LE(38); };
 CentralDirectory.prototype.headerRelativeOffset = function headerRelativeOffset () { return this.data.readUInt32LE(42); };
 CentralDirectory.prototype.produceFilename = function produceFilename () {
     /*
       4.4.17.1 claims:
       * All slashes are forward ('/') slashes.
       * Filename doesn't begin with a slash.
       * No drive letters or any nonsense like that.
       * If filename is missing, the input came from standard input.
    
       Unfortunately, this isn't true in practice. Some Windows zip utilities use
       a backslash here, but the correct Unix-style path in file headers.
    
       To avoid seeking all over the file to recover the known-good filenames
       from file headers, we simply convert '/' to '\' here.
     */
     var fileName = safeToString(this.data, this.useUTF8(), 46, this.fileNameLength());
     return fileName.replace(/\\/g, "/");
 };
 CentralDirectory.prototype.fileName = function fileName () {
     return this._filename;
 };
 CentralDirectory.prototype.rawFileName = function rawFileName () {
     return this.data.slice(46, 46 + this.fileNameLength());
 };
 CentralDirectory.prototype.extraField = function extraField () {
     var start = 44 + this.fileNameLength();
     return this.data.slice(start, start + this.extraFieldLength());
 };
 CentralDirectory.prototype.fileComment = function fileComment () {
     var start = 46 + this.fileNameLength() + this.extraFieldLength();
     return safeToString(this.data, this.useUTF8(), start, this.fileCommentLength());
 };
 CentralDirectory.prototype.rawFileComment = function rawFileComment () {
     var start = 46 + this.fileNameLength() + this.extraFieldLength();
     return this.data.slice(start, start + this.fileCommentLength());
 };
 CentralDirectory.prototype.totalSize = function totalSize () {
     return 46 + this.fileNameLength() + this.extraFieldLength() + this.fileCommentLength();
 };
 CentralDirectory.prototype.isDirectory = function isDirectory () {
     // NOTE: This assumes that the zip file implementation uses the lower byte
     //    of external attributes for DOS attributes for
     //    backwards-compatibility. This is not mandated, but appears to be
     //    commonplace.
     //    According to the spec, the layout of external attributes is
     //    platform-dependent.
     //    If that fails, we also check if the name of the file ends in '/',
     //    which is what Java's ZipFile implementation does.
     var fileName = this.fileName();
     return (this.externalAttributes() & 0x10 ? true : false) || (fileName.charAt(fileName.length - 1) === '/');
 };
 CentralDirectory.prototype.isFile = function isFile () { return !this.isDirectory(); };
 CentralDirectory.prototype.useUTF8 = function useUTF8 () { return (this.flag() & 0x800) === 0x800; };
 CentralDirectory.prototype.isEncrypted = function isEncrypted () { return (this.flag() & 0x1) === 0x1; };
 CentralDirectory.prototype.getFileData = function getFileData () {
     // Need to grab the header before we can figure out where the actual
     // compressed data starts.
     var start = this.headerRelativeOffset();
     var header = new FileHeader(this.zipData.slice(start));
     return new FileData(header, this, this.zipData.slice(start + header.totalSize()));
 };
 CentralDirectory.prototype.getData = function getData () {
     return this.getFileData().decompress();
 };
 CentralDirectory.prototype.getRawData = function getRawData () {
     return this.getFileData().getRawData();
 };
 CentralDirectory.prototype.getStats = function getStats () {
     return new Stats(FileType.FILE, this.uncompressedSize(), 0x16D, new Date(), this.lastModFileTime());
 };
/**
 * 4.3.16: end of central directory record
 *  end of central dir signature    4 bytes  (0x06054b50)
 *  number of this disk             2 bytes
 *  number of the disk with the
 *  start of the central directory  2 bytes
 *  total number of entries in the
 *  central directory on this disk  2 bytes
 *  total number of entries in
 *  the central directory           2 bytes
 *  size of the central directory   4 bytes
 *  offset of start of central
 *  directory with respect to
 *  the starting disk number        4 bytes
 *  .ZIP file comment length        2 bytes
 *  .ZIP file comment       (variable size)
 */
var EndOfCentralDirectory = function EndOfCentralDirectory(data) {
     this.data = data;
     if (this.data.readUInt32LE(0) !== 0x06054b50) {
         throw new ApiError(ErrorCode.EINVAL, ("Invalid Zip file: End of central directory record has invalid signature: " + (this.data.readUInt32LE(0))));
     }
 };
 EndOfCentralDirectory.prototype.diskNumber = function diskNumber () { return this.data.readUInt16LE(4); };
 EndOfCentralDirectory.prototype.cdDiskNumber = function cdDiskNumber () { return this.data.readUInt16LE(6); };
 EndOfCentralDirectory.prototype.cdDiskEntryCount = function cdDiskEntryCount () { return this.data.readUInt16LE(8); };
 EndOfCentralDirectory.prototype.cdTotalEntryCount = function cdTotalEntryCount () { return this.data.readUInt16LE(10); };
 EndOfCentralDirectory.prototype.cdSize = function cdSize () { return this.data.readUInt32LE(12); };
 EndOfCentralDirectory.prototype.cdOffset = function cdOffset () { return this.data.readUInt32LE(16); };
 EndOfCentralDirectory.prototype.cdZipCommentLength = function cdZipCommentLength () { return this.data.readUInt16LE(20); };
 EndOfCentralDirectory.prototype.cdZipComment = function cdZipComment () {
     // Assuming UTF-8. The specification doesn't specify.
     return safeToString(this.data, true, 22, this.cdZipCommentLength());
 };
 EndOfCentralDirectory.prototype.rawCdZipComment = function rawCdZipComment () {
     return this.data.slice(22, 22 + this.cdZipCommentLength());
 };
/**
 * Contains the table of contents of a Zip file.
 */
var ZipTOC = function ZipTOC(index, directoryEntries, eocd, data) {
     this.index = index;
     this.directoryEntries = directoryEntries;
     this.eocd = eocd;
     this.data = data;
 };
/**
 * Zip file-backed filesystem
 * Implemented according to the standard:
 * http://www.pkware.com/documents/casestudies/APPNOTE.TXT
 *
 * While there are a few zip libraries for JavaScript (e.g. JSZip and zip.js),
 * they are not a good match for BrowserFS. In particular, these libraries
 * perform a lot of unneeded data copying, and eagerly decompress every file
 * in the zip file upon loading to check the CRC32. They also eagerly decode
 * strings. Furthermore, these libraries duplicate functionality already present
 * in BrowserFS (e.g. UTF-8 decoding and binary data manipulation).
 *
 * This filesystem takes advantage of BrowserFS's Buffer implementation, which
 * efficiently represents the zip file in memory (in both ArrayBuffer-enabled
 * browsers *and* non-ArrayBuffer browsers), and which can neatly be 'sliced'
 * without copying data. Each struct defined in the standard is represented with
 * a buffer slice pointing to an offset in the zip file, and has getters for
 * each field. As we anticipate that this data will not be read often, we choose
 * not to store each struct field in the JavaScript object; instead, to reduce
 * memory consumption, we retrieve it directly from the binary data each time it
 * is requested.
 *
 * When the filesystem is instantiated, we determine the directory structure
 * of the zip file as quickly as possible. We lazily decompress and check the
 * CRC32 of files. We do not cache decompressed files; if this is a desired
 * feature, it is best implemented as a generic file system wrapper that can
 * cache data from arbitrary file systems.
 *
 * For inflation, we use `pako`'s implementation:
 * https://github.com/nodeca/pako
 *
 * Current limitations:
 * * No encryption.
 * * No ZIP64 support.
 * * Read-only.
 *   Write support would require that we:
 *   - Keep track of changed/new files.
 *   - Compress changed files, and generate appropriate metadata for each.
 *   - Update file offsets for other files in the zip file.
 *   - Stream it out to a location.
 *   This isn't that bad, so we might do this at a later date.
 */
var ZipFS = (function (SynchronousFileSystem$$1) {
   function ZipFS(input, name) {
        if ( name === void 0 ) name = '';

        SynchronousFileSystem$$1.call(this);
        this.name = name;
        this._index = new FileIndex();
        this._directoryEntries = [];
        this._eocd = null;
        this._index = input.index;
        this._directoryEntries = input.directoryEntries;
        this._eocd = input.eocd;
        this.data = input.data;
    }

   if ( SynchronousFileSystem$$1 ) ZipFS.__proto__ = SynchronousFileSystem$$1;
   ZipFS.prototype = Object.create( SynchronousFileSystem$$1 && SynchronousFileSystem$$1.prototype );
   ZipFS.prototype.constructor = ZipFS;
    /**
     * Constructs a ZipFS instance with the given options.
     */
    ZipFS.Create = function Create (opts, cb) {
        try {
            ZipFS._computeIndex(opts.zipData, function (e, zipTOC) {
                if (zipTOC) {
                    var fs = new ZipFS(zipTOC, opts.name);
                    cb(null, fs);
                }
                else {
                    cb(e);
                }
            });
        }
        catch (e) {
            cb(e);
        }
    };
    ZipFS.isAvailable = function isAvailable () { return true; };
    ZipFS.RegisterDecompressionMethod = function RegisterDecompressionMethod (m, fcn) {
        decompressionMethods[m] = fcn;
    };
    /**
     * Locates the end of central directory record at the end of the file.
     * Throws an exception if it cannot be found.
     */
    ZipFS._getEOCD = function _getEOCD (data) {
        // Unfortunately, the comment is variable size and up to 64K in size.
        // We assume that the magic signature does not appear in the comment, and
        // in the bytes between the comment and the signature. Other ZIP
        // implementations make this same assumption, since the alternative is to
        // read thread every entry in the file to get to it. :(
        // These are *negative* offsets from the end of the file.
        var startOffset = 22;
        var endOffset = Math.min(startOffset + 0xFFFF, data.length - 1);
        // There's not even a byte alignment guarantee on the comment so we need to
        // search byte by byte. *grumble grumble*
        for (var i = startOffset; i < endOffset; i++) {
            // Magic number: EOCD Signature
            if (data.readUInt32LE(data.length - i) === 0x06054b50) {
                return new EndOfCentralDirectory(data.slice(data.length - i));
            }
        }
        throw new ApiError(ErrorCode.EINVAL, "Invalid ZIP file: Could not locate End of Central Directory signature.");
    };
    ZipFS._addToIndex = function _addToIndex (cd, index) {
        // Paths must be absolute, yet zip file paths are always relative to the
        // zip root. So we append '/' and call it a day.
        var filename = cd.fileName();
        if (filename.charAt(0) === '/') {
            throw new ApiError(ErrorCode.EPERM, "Unexpectedly encountered an absolute path in a zip file. Please file a bug.");
        }
        // XXX: For the file index, strip the trailing '/'.
        if (filename.charAt(filename.length - 1) === '/') {
            filename = filename.substr(0, filename.length - 1);
        }
        if (cd.isDirectory()) {
            index.addPathFast('/' + filename, new DirInode(cd));
        }
        else {
            index.addPathFast('/' + filename, new FileInode(cd));
        }
    };
    ZipFS._computeIndex = function _computeIndex (data, cb) {
        try {
            var index = new FileIndex();
            var eocd = ZipFS._getEOCD(data);
            if (eocd.diskNumber() !== eocd.cdDiskNumber()) {
                return cb(new ApiError(ErrorCode.EINVAL, "ZipFS does not support spanned zip files."));
            }
            var cdPtr = eocd.cdOffset();
            if (cdPtr === 0xFFFFFFFF) {
                return cb(new ApiError(ErrorCode.EINVAL, "ZipFS does not support Zip64."));
            }
            var cdEnd = cdPtr + eocd.cdSize();
            ZipFS._computeIndexResponsive(data, index, cdPtr, cdEnd, cb, [], eocd);
        }
        catch (e) {
            cb(e);
        }
    };
    ZipFS._computeIndexResponsiveTrampoline = function _computeIndexResponsiveTrampoline (data, index, cdPtr, cdEnd, cb, cdEntries, eocd) {
        try {
            ZipFS._computeIndexResponsive(data, index, cdPtr, cdEnd, cb, cdEntries, eocd);
        }
        catch (e) {
            cb(e);
        }
    };
    ZipFS._computeIndexResponsive = function _computeIndexResponsive (data, index, cdPtr, cdEnd, cb, cdEntries, eocd) {
        if (cdPtr < cdEnd) {
            var count = 0;
            while (count++ < 200 && cdPtr < cdEnd) {
                var cd = new CentralDirectory(data, data.slice(cdPtr));
                ZipFS._addToIndex(cd, index);
                cdPtr += cd.totalSize();
                cdEntries.push(cd);
            }
            setImmediate$1(function () {
                ZipFS._computeIndexResponsiveTrampoline(data, index, cdPtr, cdEnd, cb, cdEntries, eocd);
            });
        }
        else {
            cb(null, new ZipTOC(index, cdEntries, eocd, data));
        }
    };
    ZipFS.prototype.getName = function getName () {
        return ZipFS.Name + (this.name !== '' ? (" " + (this.name)) : '');
    };
    /**
     * Get the CentralDirectory object for the given path.
     */
    ZipFS.prototype.getCentralDirectoryEntry = function getCentralDirectoryEntry (path$$1) {
        var inode = this._index.getInode(path$$1);
        if (inode === null) {
            throw ApiError.ENOENT(path$$1);
        }
        if (isFileInode(inode)) {
            return inode.getData();
        }
        else if (isDirInode(inode)) {
            return inode.getData();
        }
        else {
            // Should never occur.
            throw ApiError.EPERM(("Invalid inode: " + inode));
        }
    };
    ZipFS.prototype.getCentralDirectoryEntryAt = function getCentralDirectoryEntryAt (index) {
        var dirEntry = this._directoryEntries[index];
        if (!dirEntry) {
            throw new RangeError(("Invalid directory index: " + index + "."));
        }
        return dirEntry;
    };
    ZipFS.prototype.getNumberOfCentralDirectoryEntries = function getNumberOfCentralDirectoryEntries () {
        return this._directoryEntries.length;
    };
    ZipFS.prototype.getEndOfCentralDirectory = function getEndOfCentralDirectory () {
        return this._eocd;
    };
    ZipFS.prototype.diskSpace = function diskSpace (path$$1, cb) {
        // Read-only file system.
        cb(this.data.length, 0);
    };
    ZipFS.prototype.isReadOnly = function isReadOnly () {
        return true;
    };
    ZipFS.prototype.supportsLinks = function supportsLinks () {
        return false;
    };
    ZipFS.prototype.supportsProps = function supportsProps () {
        return false;
    };
    ZipFS.prototype.supportsSynch = function supportsSynch () {
        return true;
    };
    ZipFS.prototype.statSync = function statSync (path$$1, isLstat) {
        var inode = this._index.getInode(path$$1);
        if (inode === null) {
            throw ApiError.ENOENT(path$$1);
        }
        var stats;
        if (isFileInode(inode)) {
            stats = inode.getData().getStats();
        }
        else if (isDirInode(inode)) {
            stats = inode.getStats();
        }
        else {
            throw new ApiError(ErrorCode.EINVAL, "Invalid inode.");
        }
        return stats;
    };
    ZipFS.prototype.openSync = function openSync (path$$1, flags, mode) {
        // INVARIANT: Cannot write to RO file systems.
        if (flags.isWriteable()) {
            throw new ApiError(ErrorCode.EPERM, path$$1);
        }
        // Check if the path exists, and is a file.
        var inode = this._index.getInode(path$$1);
        if (!inode) {
            throw ApiError.ENOENT(path$$1);
        }
        else if (isFileInode(inode)) {
            var cdRecord = inode.getData();
            var stats = cdRecord.getStats();
            switch (flags.pathExistsAction()) {
                case ActionType.THROW_EXCEPTION:
                case ActionType.TRUNCATE_FILE:
                    throw ApiError.EEXIST(path$$1);
                case ActionType.NOP:
                    return new NoSyncFile(this, path$$1, flags, stats, cdRecord.getData());
                default:
                    throw new ApiError(ErrorCode.EINVAL, 'Invalid FileMode object.');
            }
        }
        else {
            throw ApiError.EISDIR(path$$1);
        }
    };
    ZipFS.prototype.readdirSync = function readdirSync (path$$1) {
        // Check if it exists.
        var inode = this._index.getInode(path$$1);
        if (!inode) {
            throw ApiError.ENOENT(path$$1);
        }
        else if (isDirInode(inode)) {
            return inode.getListing();
        }
        else {
            throw ApiError.ENOTDIR(path$$1);
        }
    };
    /**
     * Specially-optimized readfile.
     */
    ZipFS.prototype.readFileSync = function readFileSync (fname, encoding, flag) {
        // Get file.
        var fd = this.openSync(fname, flag, 0x1a4);
        try {
            var fdCast = fd;
            var fdBuff = fdCast.getBuffer();
            if (encoding === null) {
                return copyingSlice(fdBuff);
            }
            return fdBuff.toString(encoding);
        }
        finally {
            fd.closeSync();
        }
    };

   return ZipFS;
}(SynchronousFileSystem));

ZipFS.Name = "ZipFS";
ZipFS.Options = {
    zipData: {
        type: "object",
        description: "The zip file as a Buffer object.",
        validator: bufferValidator
    },
    name: {
        type: "string",
        optional: true,
        description: "The name of the zip file (optional)."
    }
};
ZipFS.CompressionMethod = CompressionMethod;
ZipFS.RegisterDecompressionMethod(CompressionMethod.DEFLATE, function (data, compressedSize, uncompressedSize) {
    return arrayish2Buffer(inflateRaw(data.slice(0, compressedSize), { chunkSize: uncompressedSize }));
});
ZipFS.RegisterDecompressionMethod(CompressionMethod.STORED, function (data, compressedSize, uncompressedSize) {
    return copyingSlice(data, 0, uncompressedSize);
});

/**
 * @hidden
 */
var rockRidgeIdentifier = "IEEE_P1282";
/**
 * @hidden
 */
function getASCIIString(data, startIndex, length) {
    return data.toString('ascii', startIndex, startIndex + length).trim();
}
/**
 * @hidden
 */
function getJolietString(data, startIndex, length) {
    if (length === 1) {
        // Special: Root, parent, current directory are still a single byte.
        return String.fromCharCode(data[startIndex]);
    }
    // UTF16-BE, which isn't natively supported by NodeJS Buffers.
    // Length should be even, but pessimistically floor just in case.
    var pairs = Math.floor(length / 2);
    var chars = new Array(pairs);
    for (var i = 0; i < pairs; i++) {
        var pos = startIndex + (i << 1);
        chars[i] = String.fromCharCode(data[pos + 1] | (data[pos] << 8));
    }
    return chars.join('');
}
/**
 * @hidden
 */
function getDate(data, startIndex) {
    var year = parseInt(getASCIIString(data, startIndex, 4), 10);
    var mon = parseInt(getASCIIString(data, startIndex + 4, 2), 10);
    var day = parseInt(getASCIIString(data, startIndex + 6, 2), 10);
    var hour = parseInt(getASCIIString(data, startIndex + 8, 2), 10);
    var min = parseInt(getASCIIString(data, startIndex + 10, 2), 10);
    var sec = parseInt(getASCIIString(data, startIndex + 12, 2), 10);
    var hundrethsSec = parseInt(getASCIIString(data, startIndex + 14, 2), 10);
    // Last is a time-zone offset, but JavaScript dates don't support time zones well.
    return new Date(year, mon, day, hour, min, sec, hundrethsSec * 100);
}
/**
 * @hidden
 */
function getShortFormDate(data, startIndex) {
    var yearsSince1900 = data[startIndex];
    var month = data[startIndex + 1];
    var day = data[startIndex + 2];
    var hour = data[startIndex + 3];
    var minute = data[startIndex + 4];
    var second = data[startIndex + 5];
    // JavaScript's Date support isn't so great; ignore timezone.
    // const offsetFromGMT = this._data[24];
    return new Date(yearsSince1900, month - 1, day, hour, minute, second);
}
/**
 * @hidden
 */
function constructSystemUseEntry(bigData, i) {
    var data = bigData.slice(i);
    var sue = new SystemUseEntry(data);
    switch (sue.signatureWord()) {
        case 17221 /* CE */:
            return new CEEntry(data);
        case 20548 /* PD */:
            return new PDEntry(data);
        case 21328 /* SP */:
            return new SPEntry(data);
        case 21332 /* ST */:
            return new STEntry(data);
        case 17746 /* ER */:
            return new EREntry(data);
        case 17747 /* ES */:
            return new ESEntry(data);
        case 20568 /* PX */:
            return new PXEntry(data);
        case 20558 /* PN */:
            return new PNEntry(data);
        case 21324 /* SL */:
            return new SLEntry(data);
        case 20045 /* NM */:
            return new NMEntry(data);
        case 17228 /* CL */:
            return new CLEntry(data);
        case 20556 /* PL */:
            return new PLEntry(data);
        case 21061 /* RE */:
            return new REEntry(data);
        case 21574 /* TF */:
            return new TFEntry(data);
        case 21318 /* SF */:
            return new SFEntry(data);
        case 21074 /* RR */:
            return new RREntry(data);
        default:
            return sue;
    }
}
/**
 * @hidden
 */
function constructSystemUseEntries(data, i, len, isoData) {
    // If the remaining allocated space following the last recorded System Use Entry in a System
    // Use field or Continuation Area is less than four bytes long, it cannot contain a System
    // Use Entry and shall be ignored
    len = len - 4;
    var entries = new Array();
    while (i < len) {
        var entry = constructSystemUseEntry(data, i);
        var length = entry.length();
        if (length === 0) {
            // Invalid SU section; prevent infinite loop.
            return entries;
        }
        i += length;
        if (entry instanceof STEntry) {
            // ST indicates the end of entries.
            break;
        }
        if (entry instanceof CEEntry) {
            entries = entries.concat(entry.getEntries(isoData));
        }
        else {
            entries.push(entry);
        }
    }
    return entries;
}
/**
 * @hidden
 */
var VolumeDescriptor = function VolumeDescriptor(data) {
    this._data = data;
};
VolumeDescriptor.prototype.type = function type () {
    return this._data[0];
};
VolumeDescriptor.prototype.standardIdentifier = function standardIdentifier () {
    return getASCIIString(this._data, 1, 5);
};
VolumeDescriptor.prototype.version = function version () {
    return this._data[6];
};
VolumeDescriptor.prototype.data = function data () {
    return this._data.slice(7, 2048);
};
/**
 * @hidden
 */
var PrimaryOrSupplementaryVolumeDescriptor = (function (VolumeDescriptor) {
    function PrimaryOrSupplementaryVolumeDescriptor(data) {
        VolumeDescriptor.call(this, data);
        this._root = null;
    }

    if ( VolumeDescriptor ) PrimaryOrSupplementaryVolumeDescriptor.__proto__ = VolumeDescriptor;
    PrimaryOrSupplementaryVolumeDescriptor.prototype = Object.create( VolumeDescriptor && VolumeDescriptor.prototype );
    PrimaryOrSupplementaryVolumeDescriptor.prototype.constructor = PrimaryOrSupplementaryVolumeDescriptor;
    PrimaryOrSupplementaryVolumeDescriptor.prototype.systemIdentifier = function systemIdentifier () {
        return this._getString32(8);
    };
    PrimaryOrSupplementaryVolumeDescriptor.prototype.volumeIdentifier = function volumeIdentifier () {
        return this._getString32(40);
    };
    PrimaryOrSupplementaryVolumeDescriptor.prototype.volumeSpaceSize = function volumeSpaceSize () {
        return this._data.readUInt32LE(80);
    };
    PrimaryOrSupplementaryVolumeDescriptor.prototype.volumeSetSize = function volumeSetSize () {
        return this._data.readUInt16LE(120);
    };
    PrimaryOrSupplementaryVolumeDescriptor.prototype.volumeSequenceNumber = function volumeSequenceNumber () {
        return this._data.readUInt16LE(124);
    };
    PrimaryOrSupplementaryVolumeDescriptor.prototype.logicalBlockSize = function logicalBlockSize () {
        return this._data.readUInt16LE(128);
    };
    PrimaryOrSupplementaryVolumeDescriptor.prototype.pathTableSize = function pathTableSize () {
        return this._data.readUInt32LE(132);
    };
    PrimaryOrSupplementaryVolumeDescriptor.prototype.locationOfTypeLPathTable = function locationOfTypeLPathTable () {
        return this._data.readUInt32LE(140);
    };
    PrimaryOrSupplementaryVolumeDescriptor.prototype.locationOfOptionalTypeLPathTable = function locationOfOptionalTypeLPathTable () {
        return this._data.readUInt32LE(144);
    };
    PrimaryOrSupplementaryVolumeDescriptor.prototype.locationOfTypeMPathTable = function locationOfTypeMPathTable () {
        return this._data.readUInt32BE(148);
    };
    PrimaryOrSupplementaryVolumeDescriptor.prototype.locationOfOptionalTypeMPathTable = function locationOfOptionalTypeMPathTable () {
        return this._data.readUInt32BE(152);
    };
    PrimaryOrSupplementaryVolumeDescriptor.prototype.rootDirectoryEntry = function rootDirectoryEntry (isoData) {
        if (this._root === null) {
            this._root = this._constructRootDirectoryRecord(this._data.slice(156));
            this._root.rootCheckForRockRidge(isoData);
        }
        return this._root;
    };
    PrimaryOrSupplementaryVolumeDescriptor.prototype.volumeSetIdentifier = function volumeSetIdentifier () {
        return this._getString(190, 128);
    };
    PrimaryOrSupplementaryVolumeDescriptor.prototype.publisherIdentifier = function publisherIdentifier () {
        return this._getString(318, 128);
    };
    PrimaryOrSupplementaryVolumeDescriptor.prototype.dataPreparerIdentifier = function dataPreparerIdentifier () {
        return this._getString(446, 128);
    };
    PrimaryOrSupplementaryVolumeDescriptor.prototype.applicationIdentifier = function applicationIdentifier () {
        return this._getString(574, 128);
    };
    PrimaryOrSupplementaryVolumeDescriptor.prototype.copyrightFileIdentifier = function copyrightFileIdentifier () {
        return this._getString(702, 38);
    };
    PrimaryOrSupplementaryVolumeDescriptor.prototype.abstractFileIdentifier = function abstractFileIdentifier () {
        return this._getString(740, 36);
    };
    PrimaryOrSupplementaryVolumeDescriptor.prototype.bibliographicFileIdentifier = function bibliographicFileIdentifier () {
        return this._getString(776, 37);
    };
    PrimaryOrSupplementaryVolumeDescriptor.prototype.volumeCreationDate = function volumeCreationDate () {
        return getDate(this._data, 813);
    };
    PrimaryOrSupplementaryVolumeDescriptor.prototype.volumeModificationDate = function volumeModificationDate () {
        return getDate(this._data, 830);
    };
    PrimaryOrSupplementaryVolumeDescriptor.prototype.volumeExpirationDate = function volumeExpirationDate () {
        return getDate(this._data, 847);
    };
    PrimaryOrSupplementaryVolumeDescriptor.prototype.volumeEffectiveDate = function volumeEffectiveDate () {
        return getDate(this._data, 864);
    };
    PrimaryOrSupplementaryVolumeDescriptor.prototype.fileStructureVersion = function fileStructureVersion () {
        return this._data[881];
    };
    PrimaryOrSupplementaryVolumeDescriptor.prototype.applicationUsed = function applicationUsed () {
        return this._data.slice(883, 883 + 512);
    };
    PrimaryOrSupplementaryVolumeDescriptor.prototype.reserved = function reserved () {
        return this._data.slice(1395, 1395 + 653);
    };
    PrimaryOrSupplementaryVolumeDescriptor.prototype._getString32 = function _getString32 (idx) {
        return this._getString(idx, 32);
    };

    return PrimaryOrSupplementaryVolumeDescriptor;
}(VolumeDescriptor));
/**
 * @hidden
 */
var PrimaryVolumeDescriptor = (function (PrimaryOrSupplementaryVolumeDescriptor) {
    function PrimaryVolumeDescriptor(data) {
        PrimaryOrSupplementaryVolumeDescriptor.call(this, data);
        if (this.type() !== 1 /* PrimaryVolumeDescriptor */) {
            throw new ApiError(ErrorCode.EIO, "Invalid primary volume descriptor.");
        }
    }

    if ( PrimaryOrSupplementaryVolumeDescriptor ) PrimaryVolumeDescriptor.__proto__ = PrimaryOrSupplementaryVolumeDescriptor;
    PrimaryVolumeDescriptor.prototype = Object.create( PrimaryOrSupplementaryVolumeDescriptor && PrimaryOrSupplementaryVolumeDescriptor.prototype );
    PrimaryVolumeDescriptor.prototype.constructor = PrimaryVolumeDescriptor;
    PrimaryVolumeDescriptor.prototype.name = function name () {
        return "ISO9660";
    };
    PrimaryVolumeDescriptor.prototype._constructRootDirectoryRecord = function _constructRootDirectoryRecord (data) {
        return new ISODirectoryRecord(data, -1);
    };
    PrimaryVolumeDescriptor.prototype._getString = function _getString (idx, len) {
        return this._getString(idx, len);
    };

    return PrimaryVolumeDescriptor;
}(PrimaryOrSupplementaryVolumeDescriptor));
/**
 * @hidden
 */
var SupplementaryVolumeDescriptor = (function (PrimaryOrSupplementaryVolumeDescriptor) {
    function SupplementaryVolumeDescriptor(data) {
        PrimaryOrSupplementaryVolumeDescriptor.call(this, data);
        if (this.type() !== 2 /* SupplementaryVolumeDescriptor */) {
            throw new ApiError(ErrorCode.EIO, "Invalid supplementary volume descriptor.");
        }
        var escapeSequence = this.escapeSequence();
        var third = escapeSequence[2];
        // Third character identifies what 'level' of the UCS specification to follow.
        // We ignore it.
        if (escapeSequence[0] !== 0x25 || escapeSequence[1] !== 0x2F ||
            (third !== 0x40 && third !== 0x43 && third !== 0x45)) {
            throw new ApiError(ErrorCode.EIO, ("Unrecognized escape sequence for SupplementaryVolumeDescriptor: " + (escapeSequence.toString())));
        }
    }

    if ( PrimaryOrSupplementaryVolumeDescriptor ) SupplementaryVolumeDescriptor.__proto__ = PrimaryOrSupplementaryVolumeDescriptor;
    SupplementaryVolumeDescriptor.prototype = Object.create( PrimaryOrSupplementaryVolumeDescriptor && PrimaryOrSupplementaryVolumeDescriptor.prototype );
    SupplementaryVolumeDescriptor.prototype.constructor = SupplementaryVolumeDescriptor;
    SupplementaryVolumeDescriptor.prototype.name = function name () {
        return "Joliet";
    };
    SupplementaryVolumeDescriptor.prototype.escapeSequence = function escapeSequence () {
        return this._data.slice(88, 120);
    };
    SupplementaryVolumeDescriptor.prototype._constructRootDirectoryRecord = function _constructRootDirectoryRecord (data) {
        return new JolietDirectoryRecord(data, -1);
    };
    SupplementaryVolumeDescriptor.prototype._getString = function _getString (idx, len) {
        return getJolietString(this._data, idx, len);
    };

    return SupplementaryVolumeDescriptor;
}(PrimaryOrSupplementaryVolumeDescriptor));
/**
 * @hidden
 */
var DirectoryRecord = function DirectoryRecord(data, rockRidgeOffset) {
    this._suEntries = null;
    this._fileOrDir = null;
    this._data = data;
    this._rockRidgeOffset = rockRidgeOffset;
};
DirectoryRecord.prototype.hasRockRidge = function hasRockRidge () {
    return this._rockRidgeOffset > -1;
};
DirectoryRecord.prototype.getRockRidgeOffset = function getRockRidgeOffset () {
    return this._rockRidgeOffset;
};
/**
 * !!ONLY VALID ON ROOT NODE!!
 * Checks if Rock Ridge is enabled, and sets the offset.
 */
DirectoryRecord.prototype.rootCheckForRockRidge = function rootCheckForRockRidge (isoData) {
    var dir = this.getDirectory(isoData);
    this._rockRidgeOffset = dir.getDotEntry(isoData)._getRockRidgeOffset(isoData);
    if (this._rockRidgeOffset > -1) {
        // Wipe out directory. Start over with RR knowledge.
        this._fileOrDir = null;
    }
};
DirectoryRecord.prototype.length = function length () {
    return this._data[0];
};
DirectoryRecord.prototype.extendedAttributeRecordLength = function extendedAttributeRecordLength () {
    return this._data[1];
};
DirectoryRecord.prototype.lba = function lba () {
    return this._data.readUInt32LE(2) * 2048;
};
DirectoryRecord.prototype.dataLength = function dataLength () {
    return this._data.readUInt32LE(10);
};
DirectoryRecord.prototype.recordingDate = function recordingDate () {
    return getShortFormDate(this._data, 18);
};
DirectoryRecord.prototype.fileFlags = function fileFlags () {
    return this._data[25];
};
DirectoryRecord.prototype.fileUnitSize = function fileUnitSize () {
    return this._data[26];
};
DirectoryRecord.prototype.interleaveGapSize = function interleaveGapSize () {
    return this._data[27];
};
DirectoryRecord.prototype.volumeSequenceNumber = function volumeSequenceNumber () {
    return this._data.readUInt16LE(28);
};
DirectoryRecord.prototype.identifier = function identifier () {
    return this._getString(33, this._data[32]);
};
DirectoryRecord.prototype.fileName = function fileName (isoData) {
    if (this.hasRockRidge()) {
        var fn = this._rockRidgeFilename(isoData);
        if (fn !== null) {
            return fn;
        }
    }
    var ident = this.identifier();
    if (this.isDirectory(isoData)) {
        return ident;
    }
    // Files:
    // - MUST have 0x2E (.) separating the name from the extension
    // - MUST have 0x3B (;) separating the file name and extension from the version
    // Gets expanded to two-byte char in Unicode directory records.
    var versionSeparator = ident.indexOf(';');
    if (versionSeparator === -1) {
        // Some Joliet filenames lack the version separator, despite the standard
        // specifying that it should be there.
        return ident;
    }
    else if (ident[versionSeparator - 1] === '.') {
        // Empty extension. Do not include '.' in the filename.
        return ident.slice(0, versionSeparator - 1);
    }
    else {
        // Include up to version separator.
        return ident.slice(0, versionSeparator);
    }
};
DirectoryRecord.prototype.isDirectory = function isDirectory (isoData) {
    var rv = !!(this.fileFlags() & 2 /* Directory */);
    // If it lacks the Directory flag, it may still be a directory if we've exceeded the directory
    // depth limit. Rock Ridge marks these as files and adds a special attribute.
    if (!rv && this.hasRockRidge()) {
        rv = this.getSUEntries(isoData).filter(function (e) { return e instanceof CLEntry; }).length > 0;
    }
    return rv;
};
DirectoryRecord.prototype.isSymlink = function isSymlink (isoData) {
    return this.hasRockRidge() && this.getSUEntries(isoData).filter(function (e) { return e instanceof SLEntry; }).length > 0;
};
DirectoryRecord.prototype.getSymlinkPath = function getSymlinkPath (isoData) {
    var p = "";
    var entries = this.getSUEntries(isoData);
    var getStr = this._getGetString();
    for (var i = 0, list = entries; i < list.length; i += 1) {
        var entry = list[i];

            if (entry instanceof SLEntry) {
            var components = entry.componentRecords();
            for (var i$1 = 0, list$1 = components; i$1 < list$1.length; i$1 += 1) {
                var component = list$1[i$1];

                    var flags = component.flags();
                if (flags & 2 /* CURRENT */) {
                    p += "./";
                }
                else if (flags & 4 /* PARENT */) {
                    p += "../";
                }
                else if (flags & 8 /* ROOT */) {
                    p += "/";
                }
                else {
                    p += component.content(getStr);
                    if (!(flags & 1 /* CONTINUE */)) {
                        p += '/';
                    }
                }
            }
            if (!entry.continueFlag()) {
                // We are done with this link.
                break;
            }
        }
    }
    if (p.length > 1 && p[p.length - 1] === '/') {
        // Trim trailing '/'.
        return p.slice(0, p.length - 1);
    }
    else {
        return p;
    }
};
DirectoryRecord.prototype.getFile = function getFile (isoData) {
    if (this.isDirectory(isoData)) {
        throw new Error("Tried to get a File from a directory.");
    }
    if (this._fileOrDir === null) {
        this._fileOrDir = isoData.slice(this.lba(), this.lba() + this.dataLength());
    }
    return this._fileOrDir;
};
DirectoryRecord.prototype.getDirectory = function getDirectory (isoData) {
    if (!this.isDirectory(isoData)) {
        throw new Error("Tried to get a Directory from a file.");
    }
    if (this._fileOrDir === null) {
        this._fileOrDir = this._constructDirectory(isoData);
    }
    return this._fileOrDir;
};
DirectoryRecord.prototype.getSUEntries = function getSUEntries (isoData) {
    if (!this._suEntries) {
        this._constructSUEntries(isoData);
    }
    return this._suEntries;
};
DirectoryRecord.prototype._rockRidgeFilename = function _rockRidgeFilename (isoData) {
    var nmEntries = this.getSUEntries(isoData).filter(function (e) { return e instanceof NMEntry; });
    if (nmEntries.length === 0 || nmEntries[0].flags() & (2 /* CURRENT */ | 4 /* PARENT */)) {
        return null;
    }
    var str = '';
    var getString = this._getGetString();
    for (var i = 0, list = nmEntries; i < list.length; i += 1) {
        var e = list[i];

            str += e.name(getString);
        if (!(e.flags() & 1 /* CONTINUE */)) {
            break;
        }
    }
    return str;
};
DirectoryRecord.prototype._constructSUEntries = function _constructSUEntries (isoData) {
    var i = 33 + this._data[32];
    if (i % 2 === 1) {
        // Skip padding field.
        i++;
    }
    i += this._rockRidgeOffset;
    this._suEntries = constructSystemUseEntries(this._data, i, this.length(), isoData);
};
/**
 * !!ONLY VALID ON FIRST ENTRY OF ROOT DIRECTORY!!
 * Returns -1 if rock ridge is not enabled. Otherwise, returns the offset
 * at which system use fields begin.
 */
DirectoryRecord.prototype._getRockRidgeOffset = function _getRockRidgeOffset (isoData) {
    // In the worst case, we get some garbage SU entries.
    // Fudge offset to 0 before proceeding.
    this._rockRidgeOffset = 0;
    var suEntries = this.getSUEntries(isoData);
    if (suEntries.length > 0) {
        var spEntry = suEntries[0];
        if (spEntry instanceof SPEntry && spEntry.checkBytesPass()) {
            // SUSP is in use.
            for (var i = 1; i < suEntries.length; i++) {
                var entry = suEntries[i];
                if (entry instanceof RREntry || (entry instanceof EREntry && entry.extensionIdentifier() === rockRidgeIdentifier)) {
                    // Rock Ridge is in use!
                    return spEntry.bytesSkipped();
                }
            }
        }
    }
    // Failed.
    this._rockRidgeOffset = -1;
    return -1;
};
/**
 * @hidden
 */
var ISODirectoryRecord = (function (DirectoryRecord) {
    function ISODirectoryRecord(data, rockRidgeOffset) {
        DirectoryRecord.call(this, data, rockRidgeOffset);
    }

    if ( DirectoryRecord ) ISODirectoryRecord.__proto__ = DirectoryRecord;
    ISODirectoryRecord.prototype = Object.create( DirectoryRecord && DirectoryRecord.prototype );
    ISODirectoryRecord.prototype.constructor = ISODirectoryRecord;
    ISODirectoryRecord.prototype._getString = function _getString (i, len) {
        return getASCIIString(this._data, i, len);
    };
    ISODirectoryRecord.prototype._constructDirectory = function _constructDirectory (isoData) {
        return new ISODirectory(this, isoData);
    };
    ISODirectoryRecord.prototype._getGetString = function _getGetString () {
        return getASCIIString;
    };

    return ISODirectoryRecord;
}(DirectoryRecord));
/**
 * @hidden
 */
var JolietDirectoryRecord = (function (DirectoryRecord) {
    function JolietDirectoryRecord(data, rockRidgeOffset) {
        DirectoryRecord.call(this, data, rockRidgeOffset);
    }

    if ( DirectoryRecord ) JolietDirectoryRecord.__proto__ = DirectoryRecord;
    JolietDirectoryRecord.prototype = Object.create( DirectoryRecord && DirectoryRecord.prototype );
    JolietDirectoryRecord.prototype.constructor = JolietDirectoryRecord;
    JolietDirectoryRecord.prototype._getString = function _getString (i, len) {
        return getJolietString(this._data, i, len);
    };
    JolietDirectoryRecord.prototype._constructDirectory = function _constructDirectory (isoData) {
        return new JolietDirectory(this, isoData);
    };
    JolietDirectoryRecord.prototype._getGetString = function _getGetString () {
        return getJolietString;
    };

    return JolietDirectoryRecord;
}(DirectoryRecord));
/**
 * @hidden
 */
var SystemUseEntry = function SystemUseEntry(data) {
    this._data = data;
};
SystemUseEntry.prototype.signatureWord = function signatureWord () {
    return this._data.readUInt16BE(0);
};
SystemUseEntry.prototype.signatureWordString = function signatureWordString () {
    return getASCIIString(this._data, 0, 2);
};
SystemUseEntry.prototype.length = function length () {
    return this._data[2];
};
SystemUseEntry.prototype.suVersion = function suVersion () {
    return this._data[3];
};
/**
 * Continuation entry.
 * @hidden
 */
var CEEntry = (function (SystemUseEntry) {
    function CEEntry(data) {
        SystemUseEntry.call(this, data);
        this._entries = null;
    }

    if ( SystemUseEntry ) CEEntry.__proto__ = SystemUseEntry;
    CEEntry.prototype = Object.create( SystemUseEntry && SystemUseEntry.prototype );
    CEEntry.prototype.constructor = CEEntry;
    /**
     * Logical block address of the continuation area.
     */
    CEEntry.prototype.continuationLba = function continuationLba () {
        return this._data.readUInt32LE(4);
    };
    /**
     * Offset into the logical block.
     */
    CEEntry.prototype.continuationLbaOffset = function continuationLbaOffset () {
        return this._data.readUInt32LE(12);
    };
    /**
     * Length of the continuation area.
     */
    CEEntry.prototype.continuationLength = function continuationLength () {
        return this._data.readUInt32LE(20);
    };
    CEEntry.prototype.getEntries = function getEntries (isoData) {
        if (!this._entries) {
            var start = this.continuationLba() * 2048 + this.continuationLbaOffset();
            this._entries = constructSystemUseEntries(isoData, start, this.continuationLength(), isoData);
        }
        return this._entries;
    };

    return CEEntry;
}(SystemUseEntry));
/**
 * Padding entry.
 * @hidden
 */
var PDEntry = (function (SystemUseEntry) {
    function PDEntry(data) {
        SystemUseEntry.call(this, data);
    }

    if ( SystemUseEntry ) PDEntry.__proto__ = SystemUseEntry;
    PDEntry.prototype = Object.create( SystemUseEntry && SystemUseEntry.prototype );
    PDEntry.prototype.constructor = PDEntry;

    return PDEntry;
}(SystemUseEntry));
/**
 * Identifies that SUSP is in-use.
 * @hidden
 */
var SPEntry = (function (SystemUseEntry) {
    function SPEntry(data) {
        SystemUseEntry.call(this, data);
    }

    if ( SystemUseEntry ) SPEntry.__proto__ = SystemUseEntry;
    SPEntry.prototype = Object.create( SystemUseEntry && SystemUseEntry.prototype );
    SPEntry.prototype.constructor = SPEntry;
    SPEntry.prototype.checkBytesPass = function checkBytesPass () {
        return this._data[4] === 0xBE && this._data[5] === 0xEF;
    };
    SPEntry.prototype.bytesSkipped = function bytesSkipped () {
        return this._data[6];
    };

    return SPEntry;
}(SystemUseEntry));
/**
 * Identifies the end of the SUSP entries.
 * @hidden
 */
var STEntry = (function (SystemUseEntry) {
    function STEntry(data) {
        SystemUseEntry.call(this, data);
    }

    if ( SystemUseEntry ) STEntry.__proto__ = SystemUseEntry;
    STEntry.prototype = Object.create( SystemUseEntry && SystemUseEntry.prototype );
    STEntry.prototype.constructor = STEntry;

    return STEntry;
}(SystemUseEntry));
/**
 * Specifies system-specific extensions to SUSP.
 * @hidden
 */
var EREntry = (function (SystemUseEntry) {
    function EREntry(data) {
        SystemUseEntry.call(this, data);
    }

    if ( SystemUseEntry ) EREntry.__proto__ = SystemUseEntry;
    EREntry.prototype = Object.create( SystemUseEntry && SystemUseEntry.prototype );
    EREntry.prototype.constructor = EREntry;
    EREntry.prototype.identifierLength = function identifierLength () {
        return this._data[4];
    };
    EREntry.prototype.descriptorLength = function descriptorLength () {
        return this._data[5];
    };
    EREntry.prototype.sourceLength = function sourceLength () {
        return this._data[6];
    };
    EREntry.prototype.extensionVersion = function extensionVersion () {
        return this._data[7];
    };
    EREntry.prototype.extensionIdentifier = function extensionIdentifier () {
        return getASCIIString(this._data, 8, this.identifierLength());
    };
    EREntry.prototype.extensionDescriptor = function extensionDescriptor () {
        return getASCIIString(this._data, 8 + this.identifierLength(), this.descriptorLength());
    };
    EREntry.prototype.extensionSource = function extensionSource () {
        return getASCIIString(this._data, 8 + this.identifierLength() + this.descriptorLength(), this.sourceLength());
    };

    return EREntry;
}(SystemUseEntry));
/**
 * @hidden
 */
var ESEntry = (function (SystemUseEntry) {
    function ESEntry(data) {
        SystemUseEntry.call(this, data);
    }

    if ( SystemUseEntry ) ESEntry.__proto__ = SystemUseEntry;
    ESEntry.prototype = Object.create( SystemUseEntry && SystemUseEntry.prototype );
    ESEntry.prototype.constructor = ESEntry;
    ESEntry.prototype.extensionSequence = function extensionSequence () {
        return this._data[4];
    };

    return ESEntry;
}(SystemUseEntry));
/**
 * RockRidge: Marks that RockRidge is in use [deprecated]
 * @hidden
 */
var RREntry = (function (SystemUseEntry) {
    function RREntry(data) {
        SystemUseEntry.call(this, data);
    }

    if ( SystemUseEntry ) RREntry.__proto__ = SystemUseEntry;
    RREntry.prototype = Object.create( SystemUseEntry && SystemUseEntry.prototype );
    RREntry.prototype.constructor = RREntry;

    return RREntry;
}(SystemUseEntry));
/**
 * RockRidge: Records POSIX file attributes.
 * @hidden
 */
var PXEntry = (function (SystemUseEntry) {
    function PXEntry(data) {
        SystemUseEntry.call(this, data);
    }

    if ( SystemUseEntry ) PXEntry.__proto__ = SystemUseEntry;
    PXEntry.prototype = Object.create( SystemUseEntry && SystemUseEntry.prototype );
    PXEntry.prototype.constructor = PXEntry;
    PXEntry.prototype.mode = function mode () {
        return this._data.readUInt32LE(4);
    };
    PXEntry.prototype.fileLinks = function fileLinks () {
        return this._data.readUInt32LE(12);
    };
    PXEntry.prototype.uid = function uid () {
        return this._data.readUInt32LE(20);
    };
    PXEntry.prototype.gid = function gid () {
        return this._data.readUInt32LE(28);
    };
    PXEntry.prototype.inode = function inode () {
        return this._data.readUInt32LE(36);
    };

    return PXEntry;
}(SystemUseEntry));
/**
 * RockRidge: Records POSIX device number.
 * @hidden
 */
var PNEntry = (function (SystemUseEntry) {
    function PNEntry(data) {
        SystemUseEntry.call(this, data);
    }

    if ( SystemUseEntry ) PNEntry.__proto__ = SystemUseEntry;
    PNEntry.prototype = Object.create( SystemUseEntry && SystemUseEntry.prototype );
    PNEntry.prototype.constructor = PNEntry;
    PNEntry.prototype.devTHigh = function devTHigh () {
        return this._data.readUInt32LE(4);
    };
    PNEntry.prototype.devTLow = function devTLow () {
        return this._data.readUInt32LE(12);
    };

    return PNEntry;
}(SystemUseEntry));
/**
 * RockRidge: Records symbolic link
 * @hidden
 */
var SLEntry = (function (SystemUseEntry) {
    function SLEntry(data) {
        SystemUseEntry.call(this, data);
    }

    if ( SystemUseEntry ) SLEntry.__proto__ = SystemUseEntry;
    SLEntry.prototype = Object.create( SystemUseEntry && SystemUseEntry.prototype );
    SLEntry.prototype.constructor = SLEntry;
    SLEntry.prototype.flags = function flags () {
        return this._data[4];
    };
    SLEntry.prototype.continueFlag = function continueFlag () {
        return this.flags() & 0x1;
    };
    SLEntry.prototype.componentRecords = function componentRecords () {
        var this$1 = this;

        var records = new Array();
        var i = 5;
        while (i < this.length()) {
            var record = new SLComponentRecord(this$1._data.slice(i));
            records.push(record);
            i += record.length();
        }
        return records;
    };

    return SLEntry;
}(SystemUseEntry));
/**
 * @hidden
 */
var SLComponentRecord = function SLComponentRecord(data) {
    this._data = data;
};
SLComponentRecord.prototype.flags = function flags () {
    return this._data[0];
};
SLComponentRecord.prototype.length = function length () {
    return 2 + this.componentLength();
};
SLComponentRecord.prototype.componentLength = function componentLength () {
    return this._data[1];
};
SLComponentRecord.prototype.content = function content (getString) {
    return getString(this._data, 2, this.componentLength());
};
/**
 * RockRidge: Records alternate file name
 * @hidden
 */
var NMEntry = (function (SystemUseEntry) {
    function NMEntry(data) {
        SystemUseEntry.call(this, data);
    }

    if ( SystemUseEntry ) NMEntry.__proto__ = SystemUseEntry;
    NMEntry.prototype = Object.create( SystemUseEntry && SystemUseEntry.prototype );
    NMEntry.prototype.constructor = NMEntry;
    NMEntry.prototype.flags = function flags () {
        return this._data[4];
    };
    NMEntry.prototype.name = function name (getString) {
        return getString(this._data, 5, this.length() - 5);
    };

    return NMEntry;
}(SystemUseEntry));
/**
 * RockRidge: Records child link
 * @hidden
 */
var CLEntry = (function (SystemUseEntry) {
    function CLEntry(data) {
        SystemUseEntry.call(this, data);
    }

    if ( SystemUseEntry ) CLEntry.__proto__ = SystemUseEntry;
    CLEntry.prototype = Object.create( SystemUseEntry && SystemUseEntry.prototype );
    CLEntry.prototype.constructor = CLEntry;
    CLEntry.prototype.childDirectoryLba = function childDirectoryLba () {
        return this._data.readUInt32LE(4);
    };

    return CLEntry;
}(SystemUseEntry));
/**
 * RockRidge: Records parent link.
 * @hidden
 */
var PLEntry = (function (SystemUseEntry) {
    function PLEntry(data) {
        SystemUseEntry.call(this, data);
    }

    if ( SystemUseEntry ) PLEntry.__proto__ = SystemUseEntry;
    PLEntry.prototype = Object.create( SystemUseEntry && SystemUseEntry.prototype );
    PLEntry.prototype.constructor = PLEntry;
    PLEntry.prototype.parentDirectoryLba = function parentDirectoryLba () {
        return this._data.readUInt32LE(4);
    };

    return PLEntry;
}(SystemUseEntry));
/**
 * RockRidge: Records relocated directory.
 * @hidden
 */
var REEntry = (function (SystemUseEntry) {
    function REEntry(data) {
        SystemUseEntry.call(this, data);
    }

    if ( SystemUseEntry ) REEntry.__proto__ = SystemUseEntry;
    REEntry.prototype = Object.create( SystemUseEntry && SystemUseEntry.prototype );
    REEntry.prototype.constructor = REEntry;

    return REEntry;
}(SystemUseEntry));
/**
 * RockRidge: Records file timestamps
 * @hidden
 */
var TFEntry = (function (SystemUseEntry) {
    function TFEntry(data) {
        SystemUseEntry.call(this, data);
    }

    if ( SystemUseEntry ) TFEntry.__proto__ = SystemUseEntry;
    TFEntry.prototype = Object.create( SystemUseEntry && SystemUseEntry.prototype );
    TFEntry.prototype.constructor = TFEntry;
    TFEntry.prototype.flags = function flags () {
        return this._data[4];
    };
    TFEntry.prototype.creation = function creation () {
        if (this.flags() & 1 /* CREATION */) {
            if (this._longFormDates()) {
                return getDate(this._data, 5);
            }
            else {
                return getShortFormDate(this._data, 5);
            }
        }
        else {
            return null;
        }
    };
    TFEntry.prototype.modify = function modify () {
        if (this.flags() & 2 /* MODIFY */) {
            var previousDates = (this.flags() & 1 /* CREATION */) ? 1 : 0;
            if (this._longFormDates) {
                return getDate(this._data, 5 + (previousDates * 17));
            }
            else {
                return getShortFormDate(this._data, 5 + (previousDates * 7));
            }
        }
        else {
            return null;
        }
    };
    TFEntry.prototype.access = function access () {
        if (this.flags() & 4 /* ACCESS */) {
            var previousDates = (this.flags() & 1 /* CREATION */) ? 1 : 0;
            previousDates += (this.flags() & 2 /* MODIFY */) ? 1 : 0;
            if (this._longFormDates) {
                return getDate(this._data, 5 + (previousDates * 17));
            }
            else {
                return getShortFormDate(this._data, 5 + (previousDates * 7));
            }
        }
        else {
            return null;
        }
    };
    TFEntry.prototype.backup = function backup () {
        if (this.flags() & 16 /* BACKUP */) {
            var previousDates = (this.flags() & 1 /* CREATION */) ? 1 : 0;
            previousDates += (this.flags() & 2 /* MODIFY */) ? 1 : 0;
            previousDates += (this.flags() & 4 /* ACCESS */) ? 1 : 0;
            if (this._longFormDates) {
                return getDate(this._data, 5 + (previousDates * 17));
            }
            else {
                return getShortFormDate(this._data, 5 + (previousDates * 7));
            }
        }
        else {
            return null;
        }
    };
    TFEntry.prototype.expiration = function expiration () {
        if (this.flags() & 32 /* EXPIRATION */) {
            var previousDates = (this.flags() & 1 /* CREATION */) ? 1 : 0;
            previousDates += (this.flags() & 2 /* MODIFY */) ? 1 : 0;
            previousDates += (this.flags() & 4 /* ACCESS */) ? 1 : 0;
            previousDates += (this.flags() & 16 /* BACKUP */) ? 1 : 0;
            if (this._longFormDates) {
                return getDate(this._data, 5 + (previousDates * 17));
            }
            else {
                return getShortFormDate(this._data, 5 + (previousDates * 7));
            }
        }
        else {
            return null;
        }
    };
    TFEntry.prototype.effective = function effective () {
        if (this.flags() & 64 /* EFFECTIVE */) {
            var previousDates = (this.flags() & 1 /* CREATION */) ? 1 : 0;
            previousDates += (this.flags() & 2 /* MODIFY */) ? 1 : 0;
            previousDates += (this.flags() & 4 /* ACCESS */) ? 1 : 0;
            previousDates += (this.flags() & 16 /* BACKUP */) ? 1 : 0;
            previousDates += (this.flags() & 32 /* EXPIRATION */) ? 1 : 0;
            if (this._longFormDates) {
                return getDate(this._data, 5 + (previousDates * 17));
            }
            else {
                return getShortFormDate(this._data, 5 + (previousDates * 7));
            }
        }
        else {
            return null;
        }
    };
    TFEntry.prototype._longFormDates = function _longFormDates () {
        return !!(this.flags() && 128 /* LONG_FORM */);
    };

    return TFEntry;
}(SystemUseEntry));
/**
 * RockRidge: File data in sparse format.
 * @hidden
 */
var SFEntry = (function (SystemUseEntry) {
    function SFEntry(data) {
        SystemUseEntry.call(this, data);
    }

    if ( SystemUseEntry ) SFEntry.__proto__ = SystemUseEntry;
    SFEntry.prototype = Object.create( SystemUseEntry && SystemUseEntry.prototype );
    SFEntry.prototype.constructor = SFEntry;
    SFEntry.prototype.virtualSizeHigh = function virtualSizeHigh () {
        return this._data.readUInt32LE(4);
    };
    SFEntry.prototype.virtualSizeLow = function virtualSizeLow () {
        return this._data.readUInt32LE(12);
    };
    SFEntry.prototype.tableDepth = function tableDepth () {
        return this._data[20];
    };

    return SFEntry;
}(SystemUseEntry));
/**
 * @hidden
 */
var Directory = function Directory(record, isoData) {
    var this$1 = this;

    this._fileList = [];
    this._fileMap = {};
    this._record = record;
    var i = record.lba();
    var iLimit = i + record.dataLength();
    if (!(record.fileFlags() & 2 /* Directory */)) {
        // Must have a CL entry.
        var cl = record.getSUEntries(isoData).filter(function (e) { return e instanceof CLEntry; })[0];
        i = cl.childDirectoryLba() * 2048;
        iLimit = Infinity;
    }
    while (i < iLimit) {
        var len = isoData[i];
        // Zero-padding between sectors.
        // TODO: Could optimize this to seek to nearest-sector upon
        // seeing a 0.
        if (len === 0) {
            i++;
            continue;
        }
        var r = this$1._constructDirectoryRecord(isoData.slice(i));
        var fname = r.fileName(isoData);
        // Skip '.' and '..' entries.
        if (fname !== '\u0000' && fname !== '\u0001') {
            // Skip relocated entries.
            if (!r.hasRockRidge() || r.getSUEntries(isoData).filter(function (e) { return e instanceof REEntry; }).length === 0) {
                this$1._fileMap[fname] = r;
                this$1._fileList.push(fname);
            }
        }
        else if (iLimit === Infinity) {
            // First entry contains needed data.
            iLimit = i + r.dataLength();
        }
        i += r.length();
    }
};
/**
 * Get the record with the given name.
 * Returns undefined if not present.
 */
Directory.prototype.getRecord = function getRecord (name) {
    return this._fileMap[name];
};
Directory.prototype.getFileList = function getFileList () {
    return this._fileList;
};
Directory.prototype.getDotEntry = function getDotEntry (isoData) {
    return this._constructDirectoryRecord(isoData.slice(this._record.lba()));
};
/**
 * @hidden
 */
var ISODirectory = (function (Directory) {
    function ISODirectory(record, isoData) {
        Directory.call(this, record, isoData);
    }

    if ( Directory ) ISODirectory.__proto__ = Directory;
    ISODirectory.prototype = Object.create( Directory && Directory.prototype );
    ISODirectory.prototype.constructor = ISODirectory;
    ISODirectory.prototype._constructDirectoryRecord = function _constructDirectoryRecord (data) {
        return new ISODirectoryRecord(data, this._record.getRockRidgeOffset());
    };

    return ISODirectory;
}(Directory));
/**
 * @hidden
 */
var JolietDirectory = (function (Directory) {
    function JolietDirectory(record, isoData) {
        Directory.call(this, record, isoData);
    }

    if ( Directory ) JolietDirectory.__proto__ = Directory;
    JolietDirectory.prototype = Object.create( Directory && Directory.prototype );
    JolietDirectory.prototype.constructor = JolietDirectory;
    JolietDirectory.prototype._constructDirectoryRecord = function _constructDirectoryRecord (data) {
        return new JolietDirectoryRecord(data, this._record.getRockRidgeOffset());
    };

    return JolietDirectory;
}(Directory));
/**
 * Mounts an ISO file as a read-only file system.
 *
 * Supports:
 * * Vanilla ISO9660 ISOs
 * * Microsoft Joliet and Rock Ridge extensions to the ISO9660 standard
 */
var IsoFS = (function (SynchronousFileSystem$$1) {
    function IsoFS(data, name) {
        var this$1 = this;
        if ( name === void 0 ) name = "";

        SynchronousFileSystem$$1.call(this);
        this._data = data;
        // Skip first 16 sectors.
        var vdTerminatorFound = false;
        var i = 16 * 2048;
        var candidateVDs = new Array();
        while (!vdTerminatorFound) {
            var slice = data.slice(i);
            var vd = new VolumeDescriptor(slice);
            switch (vd.type()) {
                case 1 /* PrimaryVolumeDescriptor */:
                    candidateVDs.push(new PrimaryVolumeDescriptor(slice));
                    break;
                case 2 /* SupplementaryVolumeDescriptor */:
                    candidateVDs.push(new SupplementaryVolumeDescriptor(slice));
                    break;
                case 255 /* VolumeDescriptorSetTerminator */:
                    vdTerminatorFound = true;
                    break;
            }
            i += 2048;
        }
        if (candidateVDs.length === 0) {
            throw new ApiError(ErrorCode.EIO, "Unable to find a suitable volume descriptor.");
        }
        candidateVDs.forEach(function (v) {
            // Take an SVD over a PVD.
            if (!this$1._pvd || this$1._pvd.type() !== 2 /* SupplementaryVolumeDescriptor */) {
                this$1._pvd = v;
            }
        });
        this._root = this._pvd.rootDirectoryEntry(data);
        this._name = name;
    }

    if ( SynchronousFileSystem$$1 ) IsoFS.__proto__ = SynchronousFileSystem$$1;
    IsoFS.prototype = Object.create( SynchronousFileSystem$$1 && SynchronousFileSystem$$1.prototype );
    IsoFS.prototype.constructor = IsoFS;
    /**
     * Creates an IsoFS instance with the given options.
     */
    IsoFS.Create = function Create (opts, cb) {
        try {
            cb(null, new IsoFS(opts.data, opts.name));
        }
        catch (e) {
            cb(e);
        }
    };
    IsoFS.isAvailable = function isAvailable () {
        return true;
    };
    IsoFS.prototype.getName = function getName () {
        var name = "IsoFS" + (this._name) + (this._pvd ? ("-" + (this._pvd.name())) : '');
        if (this._root && this._root.hasRockRidge()) {
            name += "-RockRidge";
        }
        return name;
    };
    IsoFS.prototype.diskSpace = function diskSpace (path$$1, cb) {
        // Read-only file system.
        cb(this._data.length, 0);
    };
    IsoFS.prototype.isReadOnly = function isReadOnly () {
        return true;
    };
    IsoFS.prototype.supportsLinks = function supportsLinks () {
        return false;
    };
    IsoFS.prototype.supportsProps = function supportsProps () {
        return false;
    };
    IsoFS.prototype.supportsSynch = function supportsSynch () {
        return true;
    };
    IsoFS.prototype.statSync = function statSync (p, isLstat) {
        var record = this._getDirectoryRecord(p);
        if (record === null) {
            throw ApiError.ENOENT(p);
        }
        return this._getStats(p, record);
    };
    IsoFS.prototype.openSync = function openSync (p, flags, mode) {
        // INVARIANT: Cannot write to RO file systems.
        if (flags.isWriteable()) {
            throw new ApiError(ErrorCode.EPERM, p);
        }
        // Check if the path exists, and is a file.
        var record = this._getDirectoryRecord(p);
        if (!record) {
            throw ApiError.ENOENT(p);
        }
        else if (record.isSymlink(this._data)) {
            return this.openSync(path.resolve(p, record.getSymlinkPath(this._data)), flags, mode);
        }
        else if (!record.isDirectory(this._data)) {
            var data = record.getFile(this._data);
            var stats = this._getStats(p, record);
            switch (flags.pathExistsAction()) {
                case ActionType.THROW_EXCEPTION:
                case ActionType.TRUNCATE_FILE:
                    throw ApiError.EEXIST(p);
                case ActionType.NOP:
                    return new NoSyncFile(this, p, flags, stats, data);
                default:
                    throw new ApiError(ErrorCode.EINVAL, 'Invalid FileMode object.');
            }
        }
        else {
            throw ApiError.EISDIR(p);
        }
    };
    IsoFS.prototype.readdirSync = function readdirSync (path$$1) {
        // Check if it exists.
        var record = this._getDirectoryRecord(path$$1);
        if (!record) {
            throw ApiError.ENOENT(path$$1);
        }
        else if (record.isDirectory(this._data)) {
            return record.getDirectory(this._data).getFileList().slice(0);
        }
        else {
            throw ApiError.ENOTDIR(path$$1);
        }
    };
    /**
     * Specially-optimized readfile.
     */
    IsoFS.prototype.readFileSync = function readFileSync (fname, encoding, flag) {
        // Get file.
        var fd = this.openSync(fname, flag, 0x1a4);
        try {
            var fdCast = fd;
            var fdBuff = fdCast.getBuffer();
            if (encoding === null) {
                return copyingSlice(fdBuff);
            }
            return fdBuff.toString(encoding);
        }
        finally {
            fd.closeSync();
        }
    };
    IsoFS.prototype._getDirectoryRecord = function _getDirectoryRecord (path$$1) {
        var this$1 = this;

        // Special case.
        if (path$$1 === '/') {
            return this._root;
        }
        var components = path$$1.split('/').slice(1);
        var dir = this._root;
        for (var i = 0, list = components; i < list.length; i += 1) {
            var component = list[i];

            if (dir.isDirectory(this$1._data)) {
                dir = dir.getDirectory(this$1._data).getRecord(component);
                if (!dir) {
                    return null;
                }
            }
            else {
                return null;
            }
        }
        return dir;
    };
    IsoFS.prototype._getStats = function _getStats (p, record) {
        if (record.isSymlink(this._data)) {
            var newP = path.resolve(p, record.getSymlinkPath(this._data));
            var dirRec = this._getDirectoryRecord(newP);
            if (!dirRec) {
                return null;
            }
            return this._getStats(newP, dirRec);
        }
        else {
            var len = record.dataLength();
            var mode = 0x16D;
            var date = record.recordingDate();
            var atime = date;
            var mtime = date;
            var ctime = date;
            if (record.hasRockRidge()) {
                var entries = record.getSUEntries(this._data);
                for (var i = 0, list = entries; i < list.length; i += 1) {
                    var entry = list[i];

                    if (entry instanceof PXEntry) {
                        mode = entry.mode();
                    }
                    else if (entry instanceof TFEntry) {
                        var flags = entry.flags();
                        if (flags & 4 /* ACCESS */) {
                            atime = entry.access();
                        }
                        if (flags & 2 /* MODIFY */) {
                            mtime = entry.modify();
                        }
                        if (flags & 1 /* CREATION */) {
                            ctime = entry.creation();
                        }
                    }
                }
            }
            // Mask out writeable flags. This is a RO file system.
            mode = mode & 0x16D;
            return new Stats(record.isDirectory(this._data) ? FileType.DIRECTORY : FileType.FILE, len, mode, atime, mtime, ctime);
        }
    };

    return IsoFS;
}(SynchronousFileSystem));

IsoFS.Name = "IsoFS";
IsoFS.Options = {
    data: {
        type: "object",
        description: "The ISO file in a buffer",
        validator: bufferValidator
    }
};

// Monkey-patch `Create` functions to check options before file system initialization.
[AsyncMirror, DropboxFileSystem, EmscriptenFileSystem, FolderAdapter, HTML5FS, InMemoryFileSystem, IndexedDBFileSystem, IsoFS, LocalStorageFileSystem, MountableFileSystem, OverlayFS, WorkerFS, HTTPRequest, ZipFS].forEach(function (fsType) {
    var create = fsType.Create;
    fsType.Create = function (opts, cb) {
        var oneArg = typeof (opts) === "function";
        var normalizedCb = oneArg ? opts : cb;
        var normalizedOpts = oneArg ? {} : opts;
        function wrappedCb(e) {
            if (e) {
                normalizedCb(e);
            }
            else {
                create.call(fsType, normalizedOpts, normalizedCb);
            }
        }
        checkOptions(fsType, normalizedOpts, wrappedCb);
    };
});
/**
 * @hidden
 */
var Backends = { AsyncMirror: AsyncMirror, Dropbox: DropboxFileSystem, Emscripten: EmscriptenFileSystem, FolderAdapter: FolderAdapter, HTML5FS: HTML5FS, InMemory: InMemoryFileSystem, IndexedDB: IndexedDBFileSystem, IsoFS: IsoFS, LocalStorage: LocalStorageFileSystem, MountableFileSystem: MountableFileSystem, OverlayFS: OverlayFS, WorkerFS: WorkerFS, HTTPRequest: HTTPRequest, XmlHttpRequest: HTTPRequest, ZipFS: ZipFS };

/**
 * BrowserFS's main module. This is exposed in the browser via the BrowserFS global.
 * Due to limitations in typedoc, we document these functions in ./typedoc.ts.
 */
if (process['initializeTTYs']) {
    process['initializeTTYs']();
}
/**
 * Installs BFSRequire as global `require`, a Node Buffer polyfill as the global `Buffer` variable,
 * and a Node process polyfill as the global `process` variable.
 */
function install(obj) {
    obj.Buffer = Buffer;
    obj.process = process;
    var oldRequire = obj.require ? obj.require : null;
    // Monkey-patch require for Node-style code.
    obj.require = function (arg) {
        var rv = BFSRequire(arg);
        if (!rv) {
            return oldRequire.apply(null, Array.prototype.slice.call(arguments, 0));
        }
        else {
            return rv;
        }
    };
}
/**
 * @hidden
 */
function registerFileSystem(name, fs) {
    Backends[name] = fs;
}
function BFSRequire(module) {
    switch (module) {
        case 'fs':
            return _fsMock;
        case 'path':
            return path;
        case 'buffer':
            // The 'buffer' module has 'Buffer' as a property.
            return buffer;
        case 'process':
            return process;
        case 'bfs_utils':
            return BFSUtils;
        default:
            return Backends[module];
    }
}
/**
 * Initializes BrowserFS with the given root file system.
 */
function initialize(rootfs) {
    return _fsMock.initialize(rootfs);
}
/**
 * Creates a file system with the given configuration, and initializes BrowserFS with it.
 * See the FileSystemConfiguration type for more info on the configuration object.
 */
function configure(config, cb) {
    getFileSystem(config, function (e, fs) {
        if (fs) {
            initialize(fs);
            cb();
        }
        else {
            cb(e);
        }
    });
}
/**
 * Retrieve a file system with the given configuration.
 * @param config A FileSystemConfiguration object. See FileSystemConfiguration for details.
 * @param cb Called when the file system is constructed, or when an error occurs.
 */
function getFileSystem(config, cb) {
    var fsName = config['fs'];
    if (!fsName) {
        return cb(new ApiError(ErrorCode.EPERM, 'Missing "fs" property on configuration object.'));
    }
    var options = config['options'];
    var waitCount = 0;
    var called = false;
    function finish() {
        if (!called) {
            called = true;
            var fsc = Backends[fsName];
            if (!fsc) {
                cb(new ApiError(ErrorCode.EPERM, ("File system " + fsName + " is not available in BrowserFS.")));
            }
            else {
                fsc.Create(options, cb);
            }
        }
    }
    if (options !== null && typeof (options) === "object") {
        var finishedIterating = false;
        var props = Object.keys(options).filter(function (k) { return k !== 'fs'; });
        // Check recursively if other fields have 'fs' properties.
        props.forEach(function (p) {
            var d = options[p];
            if (d !== null && typeof (d) === "object" && d['fs']) {
                waitCount++;
                getFileSystem(d, function (e, fs) {
                    waitCount--;
                    if (e) {
                        if (called) {
                            return;
                        }
                        called = true;
                        cb(e);
                    }
                    else {
                        options[p] = fs;
                        if (waitCount === 0 && finishedIterating) {
                            finish();
                        }
                    }
                });
            }
        });
        finishedIterating = true;
    }
    if (waitCount === 0) {
        finish();
    }
}

/**
 * BrowserFS's main entry point.
 * It installs all of the needed polyfills, and requires() the main module.
 */
// IE substr does not support negative indices
if ('ab'.substr(-1) !== 'b') {
    String.prototype.substr = function (substr) {
        return function (start, length) {
            // did we get a negative start, calculate how much it is from the
            // beginning of the string
            if (start < 0) {
                start = this.length + start;
            }
            // call the original function
            return substr.call(this, start, length);
        };
    }(String.prototype.substr);
}
// Polyfill for Uint8Array.prototype.slice.
// Safari and some other browsers do not define it.
if (typeof (ArrayBuffer) !== 'undefined' && typeof (Uint8Array) !== 'undefined') {
    if (!Uint8Array.prototype['slice']) {
        Uint8Array.prototype.slice = function (start, end) {
            if ( start === void 0 ) start = 0;
            if ( end === void 0 ) end = this.length;

            var self = this;
            if (start < 0) {
                start = this.length + start;
                if (start < 0) {
                    start = 0;
                }
            }
            if (end < 0) {
                end = this.length + end;
                if (end < 0) {
                    end = 0;
                }
            }
            if (end < start) {
                end = start;
            }
            return new Uint8Array(self.buffer, self.byteOffset + start, end - start);
        };
    }
}

exports.install = install;
exports.registerFileSystem = registerFileSystem;
exports.BFSRequire = BFSRequire;
exports.initialize = initialize;
exports.configure = configure;
exports.getFileSystem = getFileSystem;
exports.EmscriptenFS = BFSEmscriptenFS;
exports.FileSystem = Backends;
exports.Errors = api_error;
exports.setImmediate = setImmediate$1;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(9), __webpack_require__(5), __webpack_require__(2), __webpack_require__(34)(module)))

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function placeHoldersCount (b64) {
  var len = b64.length
  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // the number of equal signs (place holders)
  // if there are two placeholders, than the two characters before it
  // represent one byte
  // if there is only one, then the three characters before it represent 2 bytes
  // this is just a cheap hack to not do indexOf twice
  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0
}

function byteLength (b64) {
  // base64 is 4/3 + up to two characters of the original data
  return (b64.length * 3 / 4) - placeHoldersCount(b64)
}

function toByteArray (b64) {
  var i, l, tmp, placeHolders, arr
  var len = b64.length
  placeHolders = placeHoldersCount(b64)

  arr = new Arr((len * 3 / 4) - placeHolders)

  // if there are placeholders, only get up to the last complete 4 chars
  l = placeHolders > 0 ? len - 4 : len

  var L = 0

  for (i = 0; i < l; i += 4) {
    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]
    arr[L++] = (tmp >> 16) & 0xFF
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  if (placeHolders === 2) {
    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[L++] = tmp & 0xFF
  } else if (placeHolders === 1) {
    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var output = ''
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    output += lookup[tmp >> 2]
    output += lookup[(tmp << 4) & 0x3F]
    output += '=='
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])
    output += lookup[tmp >> 10]
    output += lookup[(tmp >> 4) & 0x3F]
    output += lookup[(tmp << 2) & 0x3F]
    output += '='
  }

  parts.push(output)

  return parts.join('')
}


/***/ }),
/* 21 */
/***/ (function(module, exports) {

exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}


/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(__dirname) {
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var events = __webpack_require__(6);
// Path depends on process. Avoid a circular reference by dynamically including path when we need it.
var path = null;
var Item = (function () {
    function Item(fun, array) {
        this.fun = fun;
        this.array = array;
    }
    Item.prototype.run = function () {
        this.fun.apply(null, this.array);
    };
    return Item;
}());
/**
 * Contains a queue of Items for process.nextTick.
 * Inspired by node-process: https://github.com/defunctzombie/node-process
 */
var NextTickQueue = (function () {
    function NextTickQueue() {
        this._queue = [];
        this._draining = false;
        // Used/assigned by the drainQueue function.
        this._currentQueue = null;
        this._queueIndex = -1;
    }
    NextTickQueue.prototype.push = function (item) {
        var _this = this;
        if (this._queue.push(item) === 1 && !this._draining) {
            setTimeout(function () { return _this._drainQueue(); }, 0);
        }
    };
    NextTickQueue.prototype._cleanUpNextTick = function () {
        this._draining = false;
        if (this._currentQueue && this._currentQueue.length) {
            this._queue = this._currentQueue.concat(this._queue);
        }
        else {
            this._queueIndex = -1;
        }
        if (this._queue.length) {
            this._drainQueue();
        }
    };
    NextTickQueue.prototype._drainQueue = function () {
        var _this = this;
        if (this._draining) {
            return;
        }
        // If an Item throws an unhandled exception, this function will clean things up.
        var timeout = setTimeout(function () { return _this._cleanUpNextTick(); });
        this._draining = true;
        var len = this._queue.length;
        while (len) {
            this._currentQueue = this._queue;
            this._queue = [];
            while (++this._queueIndex < len) {
                if (this._currentQueue) {
                    this._currentQueue[this._queueIndex].run();
                }
            }
            this._queueIndex = -1;
            len = this._queue.length;
        }
        this._currentQueue = null;
        this._draining = false;
        clearTimeout(timeout);
    };
    return NextTickQueue;
}());
/**
 * Partial implementation of Node's `process` module.
 * We implement the portions that are relevant for the filesystem.
 * @see http://nodejs.org/api/process.html
 * @class
 */
var Process = (function (_super) {
    __extends(Process, _super);
    function Process() {
        _super.apply(this, arguments);
        this.startTime = Date.now();
        this._cwd = '/';
        /**
         * Returns what platform you are running on.
         * @return [String]
         */
        this.platform = 'browser';
        this.argv = [];
        this.execArgv = [];
        this.stdout = null;
        this.stderr = null;
        this.stdin = null;
        this.domain = null;
        this._queue = new NextTickQueue();
        this.execPath = __dirname;
        this.env = {};
        this.exitCode = 0;
        this._gid = 1;
        this._uid = 1;
        this.version = 'v5.0';
        this.versions = {
            http_parser: '0.0',
            node: '5.0',
            v8: '0.0',
            uv: '0.0',
            zlib: '0.0',
            ares: '0.0',
            icu: '0.0',
            modules: '0',
            openssl: '0.0'
        };
        this.config = {
            target_defaults: { cflags: [],
                default_configuration: 'Release',
                defines: [],
                include_dirs: [],
                libraries: [] },
            variables: { clang: 0,
                host_arch: 'x32',
                node_install_npm: false,
                node_install_waf: false,
                node_prefix: '',
                node_shared_cares: false,
                node_shared_http_parser: false,
                node_shared_libuv: false,
                node_shared_zlib: false,
                node_shared_v8: false,
                node_use_dtrace: false,
                node_use_etw: false,
                node_use_openssl: false,
                node_shared_openssl: false,
                strict_aliasing: false,
                target_arch: 'x32',
                v8_use_snapshot: false,
                v8_no_strict_aliasing: 0,
                visibility: '' } };
        this.pid = (Math.random() * 1000) | 0;
        this.title = 'node';
        this.arch = 'x32';
        this._mask = 18;
        // Undefined in main thread. Worker-only.
        this.connected = undefined;
    }
    /**
     * Changes the current working directory.
     *
     * **Note**: BrowserFS does not validate that the directory actually exists.
     *
     * @example Usage example
     *   console.log('Starting directory: ' + process.cwd());
     *   process.chdir('/tmp');
     *   console.log('New directory: ' + process.cwd());
     * @param [String] dir The directory to change to.
     */
    Process.prototype.chdir = function (dir) {
        // XXX: Circular dependency hack.
        if (path === null) {
            path = __webpack_require__(13);
        }
        this._cwd = path.resolve(dir);
    };
    /**
     * Returns the current working directory.
     * @example Usage example
     *   console.log('Current directory: ' + process.cwd());
     * @return [String] The current working directory.
     */
    Process.prototype.cwd = function () {
        return this._cwd;
    };
    /**
     * Number of seconds BrowserFS has been running.
     * @return [Number]
     */
    Process.prototype.uptime = function () {
        return ((Date.now() - this.startTime) / 1000) | 0;
    };
    Process.prototype.nextTick = function (fun) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        this._queue.push(new Item(fun, args));
    };
    Process.prototype.abort = function () {
        this.emit('abort');
    };
    Process.prototype.exit = function (code) {
        this.exitCode = code;
        this.emit('exit', [code]);
    };
    Process.prototype.getgid = function () {
        return this._gid;
    };
    Process.prototype.setgid = function (gid) {
        if (typeof gid === 'number') {
            this._gid = gid;
        }
        else {
            this._gid = 1;
        }
    };
    Process.prototype.getuid = function () {
        return this._uid;
    };
    Process.prototype.setuid = function (uid) {
        if (typeof uid === 'number') {
            this._uid = uid;
        }
        else {
            this._uid = 1;
        }
    };
    Process.prototype.kill = function (pid, signal) {
        this.emit('kill', [pid, signal]);
    };
    Process.prototype.memoryUsage = function () {
        return { rss: 0, heapTotal: 0, heapUsed: 0 };
    };
    Process.prototype.umask = function (mask) {
        if (mask === void 0) { mask = this._mask; }
        var oldMask = this._mask;
        this._mask = mask;
        this.emit('umask', [mask]);
        return oldMask;
    };
    Process.prototype.hrtime = function () {
        var timeinfo;
        if (typeof performance !== 'undefined') {
            timeinfo = performance.now();
        }
        else if (Date['now']) {
            timeinfo = Date.now();
        }
        else {
            timeinfo = (new Date()).getTime();
        }
        var secs = (timeinfo / 1000) | 0;
        timeinfo -= secs * 1000;
        timeinfo = (timeinfo * 1000000) | 0;
        return [secs, timeinfo];
    };
    /**
     * [BFS only] Initialize the TTY devices.
     */
    Process.prototype.initializeTTYs = function () {
        // Guard against multiple invocations.
        if (this.stdout === null) {
            var TTY = __webpack_require__(23);
            this.stdout = new TTY();
            this.stderr = new TTY();
            this.stdin = new TTY();
        }
    };
    /**
     * Worker-only function; irrelevant here.
     */
    Process.prototype.disconnect = function () {
    };
    return Process;
}(events.EventEmitter));
module.exports = Process;

/* WEBPACK VAR INJECTION */}.call(exports, "/"))

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var stream = __webpack_require__(24);
var TTY = (function (_super) {
    __extends(TTY, _super);
    function TTY() {
        _super.call(this);
        this.isRaw = false;
        this.columns = 80;
        this.rows = 120;
        this.isTTY = true;
        this._bufferedWrites = [];
        this._waitingForWrites = false;
    }
    /**
     * Toggle raw mode.
     */
    TTY.prototype.setRawMode = function (mode) {
        if (this.isRaw !== mode) {
            this.isRaw = mode;
            // [BFS] TTY implementations can use this to change their event emitting
            //       patterns.
            this.emit('modeChange');
        }
    };
    /**
     * [BFS] Update the number of columns available on the terminal.
     */
    TTY.prototype.changeColumns = function (columns) {
        if (columns !== this.columns) {
            this.columns = columns;
            // Resize event.
            this.emit('resize');
        }
    };
    /**
     * [BFS] Update the number of rows available on the terminal.
     */
    TTY.prototype.changeRows = function (rows) {
        if (rows !== this.rows) {
            this.rows = rows;
            // Resize event.
            this.emit('resize');
        }
    };
    /**
     * Returns 'true' if the given object is a TTY.
     */
    TTY.isatty = function (fd) {
        return fd && fd instanceof TTY;
    };
    TTY.prototype._write = function (chunk, encoding, cb) {
        var error;
        try {
            var data;
            if (typeof (chunk) === 'string') {
                data = new Buffer(chunk, encoding);
            }
            else {
                data = chunk;
            }
            this._bufferedWrites.push(data);
            if (this._waitingForWrites) {
                this._read(1024);
            }
        }
        catch (e) {
            error = e;
        }
        finally {
            cb(error);
        }
    };
    TTY.prototype._read = function (size) {
        // Size is advisory -- we can ignore it.
        if (this._bufferedWrites.length === 0) {
            this._waitingForWrites = true;
        }
        else {
            while (this._bufferedWrites.length > 0) {
                this._waitingForWrites = this.push(this._bufferedWrites.shift());
                if (!this._waitingForWrites) {
                    break;
                }
            }
        }
    };
    return TTY;
}(stream.Duplex));
module.exports = TTY;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(9)))

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Stream;

var EE = __webpack_require__(6).EventEmitter;
var inherits = __webpack_require__(1);

inherits(Stream, EE);
Stream.Readable = __webpack_require__(10);
Stream.Writable = __webpack_require__(30);
Stream.Duplex = __webpack_require__(31);
Stream.Transform = __webpack_require__(32);
Stream.PassThrough = __webpack_require__(33);

// Backwards-compat with node 0.4.x
Stream.Stream = Stream;



// old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.

function Stream() {
  EE.call(this);
}

Stream.prototype.pipe = function(dest, options) {
  var source = this;

  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }

  source.on('data', ondata);

  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }

  dest.on('drain', ondrain);

  // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.
  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend);
    source.on('close', onclose);
  }

  var didOnEnd = false;
  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;

    dest.end();
  }


  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;

    if (typeof dest.destroy === 'function') dest.destroy();
  }

  // don't leave dangling pipes when there are errors.
  function onerror(er) {
    cleanup();
    if (EE.listenerCount(this, 'error') === 0) {
      throw er; // Unhandled stream error in pipe.
    }
  }

  source.on('error', onerror);
  dest.on('error', onerror);

  // remove all the event listeners that were added.
  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);

    source.removeListener('end', onend);
    source.removeListener('close', onclose);

    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);

    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);

    dest.removeListener('close', cleanup);
  }

  source.on('end', cleanup);
  source.on('close', cleanup);

  dest.on('close', cleanup);

  dest.emit('pipe', source);

  // Allow for unix-like usage: A.pipe(B).pipe(C)
  return dest;
};


/***/ }),
/* 25 */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};


/***/ }),
/* 26 */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*<replacement>*/

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Buffer = __webpack_require__(11).Buffer;
/*</replacement>*/

function copyBuffer(src, target, offset) {
  src.copy(target, offset);
}

module.exports = function () {
  function BufferList() {
    _classCallCheck(this, BufferList);

    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  BufferList.prototype.push = function push(v) {
    var entry = { data: v, next: null };
    if (this.length > 0) this.tail.next = entry;else this.head = entry;
    this.tail = entry;
    ++this.length;
  };

  BufferList.prototype.unshift = function unshift(v) {
    var entry = { data: v, next: this.head };
    if (this.length === 0) this.tail = entry;
    this.head = entry;
    ++this.length;
  };

  BufferList.prototype.shift = function shift() {
    if (this.length === 0) return;
    var ret = this.head.data;
    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
    --this.length;
    return ret;
  };

  BufferList.prototype.clear = function clear() {
    this.head = this.tail = null;
    this.length = 0;
  };

  BufferList.prototype.join = function join(s) {
    if (this.length === 0) return '';
    var p = this.head;
    var ret = '' + p.data;
    while (p = p.next) {
      ret += s + p.data;
    }return ret;
  };

  BufferList.prototype.concat = function concat(n) {
    if (this.length === 0) return Buffer.alloc(0);
    if (this.length === 1) return this.head.data;
    var ret = Buffer.allocUnsafe(n >>> 0);
    var p = this.head;
    var i = 0;
    while (p) {
      copyBuffer(p.data, ret, i);
      i += p.data.length;
      p = p.next;
    }
    return ret;
  };

  return BufferList;
}();

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {
/**
 * Module exports.
 */

module.exports = deprecate;

/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate (fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
}

/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */

function config (name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!global.localStorage) return false;
  } catch (_) {
    return false;
  }
  var val = global.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.



module.exports = PassThrough;

var Transform = __webpack_require__(18);

/*<replacement>*/
var util = __webpack_require__(3);
util.inherits = __webpack_require__(1);
/*</replacement>*/

util.inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);

  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(12);


/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(0);


/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(10).Transform


/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(10).PassThrough


/***/ }),
/* 34 */
/***/ (function(module, exports) {

module.exports = function(module) {
	if(!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if(!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";



var zlib_inflate = __webpack_require__(36);
var utils        = __webpack_require__(8);
var strings      = __webpack_require__(41);
var c            = __webpack_require__(42);
var msg          = __webpack_require__(43);
var ZStream      = __webpack_require__(44);
var GZheader     = __webpack_require__(45);

var toString = Object.prototype.toString;

/**
 * class Inflate
 *
 * Generic JS-style wrapper for zlib calls. If you don't need
 * streaming behaviour - use more simple functions: [[inflate]]
 * and [[inflateRaw]].
 **/

/* internal
 * inflate.chunks -> Array
 *
 * Chunks of output data, if [[Inflate#onData]] not overriden.
 **/

/**
 * Inflate.result -> Uint8Array|Array|String
 *
 * Uncompressed result, generated by default [[Inflate#onData]]
 * and [[Inflate#onEnd]] handlers. Filled after you push last chunk
 * (call [[Inflate#push]] with `Z_FINISH` / `true` param) or if you
 * push a chunk with explicit flush (call [[Inflate#push]] with
 * `Z_SYNC_FLUSH` param).
 **/

/**
 * Inflate.err -> Number
 *
 * Error code after inflate finished. 0 (Z_OK) on success.
 * Should be checked if broken data possible.
 **/

/**
 * Inflate.msg -> String
 *
 * Error message, if [[Inflate.err]] != 0
 **/


/**
 * new Inflate(options)
 * - options (Object): zlib inflate options.
 *
 * Creates new inflator instance with specified params. Throws exception
 * on bad params. Supported options:
 *
 * - `windowBits`
 * - `dictionary`
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Additional options, for internal needs:
 *
 * - `chunkSize` - size of generated data chunks (16K by default)
 * - `raw` (Boolean) - do raw inflate
 * - `to` (String) - if equal to 'string', then result will be converted
 *   from utf8 to utf16 (javascript) string. When string output requested,
 *   chunk length can differ from `chunkSize`, depending on content.
 *
 * By default, when no options set, autodetect deflate/gzip data format via
 * wrapper header.
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])
 *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);
 *
 * var inflate = new pako.Inflate({ level: 3});
 *
 * inflate.push(chunk1, false);
 * inflate.push(chunk2, true);  // true -> last chunk
 *
 * if (inflate.err) { throw new Error(inflate.err); }
 *
 * console.log(inflate.result);
 * ```
 **/
function Inflate(options) {
  if (!(this instanceof Inflate)) return new Inflate(options);

  this.options = utils.assign({
    chunkSize: 16384,
    windowBits: 0,
    to: ''
  }, options || {});

  var opt = this.options;

  // Force window size for `raw` data, if not set directly,
  // because we have no header for autodetect.
  if (opt.raw && (opt.windowBits >= 0) && (opt.windowBits < 16)) {
    opt.windowBits = -opt.windowBits;
    if (opt.windowBits === 0) { opt.windowBits = -15; }
  }

  // If `windowBits` not defined (and mode not raw) - set autodetect flag for gzip/deflate
  if ((opt.windowBits >= 0) && (opt.windowBits < 16) &&
      !(options && options.windowBits)) {
    opt.windowBits += 32;
  }

  // Gzip header has no info about windows size, we can do autodetect only
  // for deflate. So, if window size not set, force it to max when gzip possible
  if ((opt.windowBits > 15) && (opt.windowBits < 48)) {
    // bit 3 (16) -> gzipped data
    // bit 4 (32) -> autodetect gzip/deflate
    if ((opt.windowBits & 15) === 0) {
      opt.windowBits |= 15;
    }
  }

  this.err    = 0;      // error code, if happens (0 = Z_OK)
  this.msg    = '';     // error message
  this.ended  = false;  // used to avoid multiple onEnd() calls
  this.chunks = [];     // chunks of compressed data

  this.strm   = new ZStream();
  this.strm.avail_out = 0;

  var status  = zlib_inflate.inflateInit2(
    this.strm,
    opt.windowBits
  );

  if (status !== c.Z_OK) {
    throw new Error(msg[status]);
  }

  this.header = new GZheader();

  zlib_inflate.inflateGetHeader(this.strm, this.header);
}

/**
 * Inflate#push(data[, mode]) -> Boolean
 * - data (Uint8Array|Array|ArrayBuffer|String): input data
 * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.
 *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` meansh Z_FINISH.
 *
 * Sends input data to inflate pipe, generating [[Inflate#onData]] calls with
 * new output chunks. Returns `true` on success. The last data block must have
 * mode Z_FINISH (or `true`). That will flush internal pending buffers and call
 * [[Inflate#onEnd]]. For interim explicit flushes (without ending the stream) you
 * can use mode Z_SYNC_FLUSH, keeping the decompression context.
 *
 * On fail call [[Inflate#onEnd]] with error code and return false.
 *
 * We strongly recommend to use `Uint8Array` on input for best speed (output
 * format is detected automatically). Also, don't skip last param and always
 * use the same type in your code (boolean or number). That will improve JS speed.
 *
 * For regular `Array`-s make sure all elements are [0..255].
 *
 * ##### Example
 *
 * ```javascript
 * push(chunk, false); // push one of data chunks
 * ...
 * push(chunk, true);  // push last chunk
 * ```
 **/
Inflate.prototype.push = function (data, mode) {
  var strm = this.strm;
  var chunkSize = this.options.chunkSize;
  var dictionary = this.options.dictionary;
  var status, _mode;
  var next_out_utf8, tail, utf8str;
  var dict;

  // Flag to properly process Z_BUF_ERROR on testing inflate call
  // when we check that all output data was flushed.
  var allowBufError = false;

  if (this.ended) { return false; }
  _mode = (mode === ~~mode) ? mode : ((mode === true) ? c.Z_FINISH : c.Z_NO_FLUSH);

  // Convert data if needed
  if (typeof data === 'string') {
    // Only binary strings can be decompressed on practice
    strm.input = strings.binstring2buf(data);
  } else if (toString.call(data) === '[object ArrayBuffer]') {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }

  strm.next_in = 0;
  strm.avail_in = strm.input.length;

  do {
    if (strm.avail_out === 0) {
      strm.output = new utils.Buf8(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }

    status = zlib_inflate.inflate(strm, c.Z_NO_FLUSH);    /* no bad return value */

    if (status === c.Z_NEED_DICT && dictionary) {
      // Convert data if needed
      if (typeof dictionary === 'string') {
        dict = strings.string2buf(dictionary);
      } else if (toString.call(dictionary) === '[object ArrayBuffer]') {
        dict = new Uint8Array(dictionary);
      } else {
        dict = dictionary;
      }

      status = zlib_inflate.inflateSetDictionary(this.strm, dict);

    }

    if (status === c.Z_BUF_ERROR && allowBufError === true) {
      status = c.Z_OK;
      allowBufError = false;
    }

    if (status !== c.Z_STREAM_END && status !== c.Z_OK) {
      this.onEnd(status);
      this.ended = true;
      return false;
    }

    if (strm.next_out) {
      if (strm.avail_out === 0 || status === c.Z_STREAM_END || (strm.avail_in === 0 && (_mode === c.Z_FINISH || _mode === c.Z_SYNC_FLUSH))) {

        if (this.options.to === 'string') {

          next_out_utf8 = strings.utf8border(strm.output, strm.next_out);

          tail = strm.next_out - next_out_utf8;
          utf8str = strings.buf2string(strm.output, next_out_utf8);

          // move tail
          strm.next_out = tail;
          strm.avail_out = chunkSize - tail;
          if (tail) { utils.arraySet(strm.output, strm.output, next_out_utf8, tail, 0); }

          this.onData(utf8str);

        } else {
          this.onData(utils.shrinkBuf(strm.output, strm.next_out));
        }
      }
    }

    // When no more input data, we should check that internal inflate buffers
    // are flushed. The only way to do it when avail_out = 0 - run one more
    // inflate pass. But if output data not exists, inflate return Z_BUF_ERROR.
    // Here we set flag to process this error properly.
    //
    // NOTE. Deflate does not return error in this case and does not needs such
    // logic.
    if (strm.avail_in === 0 && strm.avail_out === 0) {
      allowBufError = true;
    }

  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== c.Z_STREAM_END);

  if (status === c.Z_STREAM_END) {
    _mode = c.Z_FINISH;
  }

  // Finalize on the last chunk.
  if (_mode === c.Z_FINISH) {
    status = zlib_inflate.inflateEnd(this.strm);
    this.onEnd(status);
    this.ended = true;
    return status === c.Z_OK;
  }

  // callback interim results if Z_SYNC_FLUSH.
  if (_mode === c.Z_SYNC_FLUSH) {
    this.onEnd(c.Z_OK);
    strm.avail_out = 0;
    return true;
  }

  return true;
};


/**
 * Inflate#onData(chunk) -> Void
 * - chunk (Uint8Array|Array|String): ouput data. Type of array depends
 *   on js engine support. When string output requested, each chunk
 *   will be string.
 *
 * By default, stores data blocks in `chunks[]` property and glue
 * those in `onEnd`. Override this handler, if you need another behaviour.
 **/
Inflate.prototype.onData = function (chunk) {
  this.chunks.push(chunk);
};


/**
 * Inflate#onEnd(status) -> Void
 * - status (Number): inflate status. 0 (Z_OK) on success,
 *   other if not.
 *
 * Called either after you tell inflate that the input stream is
 * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)
 * or if an error happened. By default - join collected chunks,
 * free memory and fill `results` / `err` properties.
 **/
Inflate.prototype.onEnd = function (status) {
  // On success - join
  if (status === c.Z_OK) {
    if (this.options.to === 'string') {
      // Glue & convert here, until we teach pako to send
      // utf8 alligned strings to onData
      this.result = this.chunks.join('');
    } else {
      this.result = utils.flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};


/**
 * inflate(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * Decompress `data` with inflate/ungzip and `options`. Autodetect
 * format via wrapper header by default. That's why we don't provide
 * separate `ungzip` method.
 *
 * Supported options are:
 *
 * - windowBits
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information.
 *
 * Sugar (options):
 *
 * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
 *   negative windowBits implicitly.
 * - `to` (String) - if equal to 'string', then result will be converted
 *   from utf8 to utf16 (javascript) string. When string output requested,
 *   chunk length can differ from `chunkSize`, depending on content.
 *
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , input = pako.deflate([1,2,3,4,5,6,7,8,9])
 *   , output;
 *
 * try {
 *   output = pako.inflate(input);
 * } catch (err)
 *   console.log(err);
 * }
 * ```
 **/
function inflate(input, options) {
  var inflator = new Inflate(options);

  inflator.push(input, true);

  // That will never happens, if you don't cheat with options :)
  if (inflator.err) { throw inflator.msg || msg[inflator.err]; }

  return inflator.result;
}


/**
 * inflateRaw(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * The same as [[inflate]], but creates raw data, without wrapper
 * (header and adler32 crc).
 **/
function inflateRaw(input, options) {
  options = options || {};
  options.raw = true;
  return inflate(input, options);
}


/**
 * ungzip(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * Just shortcut to [[inflate]], because it autodetects format
 * by header.content. Done for convenience.
 **/


exports.Inflate = Inflate;
exports.inflate = inflate;
exports.inflateRaw = inflateRaw;
exports.ungzip  = inflate;


/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

var utils         = __webpack_require__(8);
var adler32       = __webpack_require__(37);
var crc32         = __webpack_require__(38);
var inflate_fast  = __webpack_require__(39);
var inflate_table = __webpack_require__(40);

var CODES = 0;
var LENS = 1;
var DISTS = 2;

/* Public constants ==========================================================*/
/* ===========================================================================*/


/* Allowed flush values; see deflate() and inflate() below for details */
//var Z_NO_FLUSH      = 0;
//var Z_PARTIAL_FLUSH = 1;
//var Z_SYNC_FLUSH    = 2;
//var Z_FULL_FLUSH    = 3;
var Z_FINISH        = 4;
var Z_BLOCK         = 5;
var Z_TREES         = 6;


/* Return codes for the compression/decompression functions. Negative values
 * are errors, positive values are used for special but normal events.
 */
var Z_OK            = 0;
var Z_STREAM_END    = 1;
var Z_NEED_DICT     = 2;
//var Z_ERRNO         = -1;
var Z_STREAM_ERROR  = -2;
var Z_DATA_ERROR    = -3;
var Z_MEM_ERROR     = -4;
var Z_BUF_ERROR     = -5;
//var Z_VERSION_ERROR = -6;

/* The deflate compression method */
var Z_DEFLATED  = 8;


/* STATES ====================================================================*/
/* ===========================================================================*/


var    HEAD = 1;       /* i: waiting for magic header */
var    FLAGS = 2;      /* i: waiting for method and flags (gzip) */
var    TIME = 3;       /* i: waiting for modification time (gzip) */
var    OS = 4;         /* i: waiting for extra flags and operating system (gzip) */
var    EXLEN = 5;      /* i: waiting for extra length (gzip) */
var    EXTRA = 6;      /* i: waiting for extra bytes (gzip) */
var    NAME = 7;       /* i: waiting for end of file name (gzip) */
var    COMMENT = 8;    /* i: waiting for end of comment (gzip) */
var    HCRC = 9;       /* i: waiting for header crc (gzip) */
var    DICTID = 10;    /* i: waiting for dictionary check value */
var    DICT = 11;      /* waiting for inflateSetDictionary() call */
var        TYPE = 12;      /* i: waiting for type bits, including last-flag bit */
var        TYPEDO = 13;    /* i: same, but skip check to exit inflate on new block */
var        STORED = 14;    /* i: waiting for stored size (length and complement) */
var        COPY_ = 15;     /* i/o: same as COPY below, but only first time in */
var        COPY = 16;      /* i/o: waiting for input or output to copy stored block */
var        TABLE = 17;     /* i: waiting for dynamic block table lengths */
var        LENLENS = 18;   /* i: waiting for code length code lengths */
var        CODELENS = 19;  /* i: waiting for length/lit and distance code lengths */
var            LEN_ = 20;      /* i: same as LEN below, but only first time in */
var            LEN = 21;       /* i: waiting for length/lit/eob code */
var            LENEXT = 22;    /* i: waiting for length extra bits */
var            DIST = 23;      /* i: waiting for distance code */
var            DISTEXT = 24;   /* i: waiting for distance extra bits */
var            MATCH = 25;     /* o: waiting for output space to copy string */
var            LIT = 26;       /* o: waiting for output space to write literal */
var    CHECK = 27;     /* i: waiting for 32-bit check value */
var    LENGTH = 28;    /* i: waiting for 32-bit length (gzip) */
var    DONE = 29;      /* finished check, done -- remain here until reset */
var    BAD = 30;       /* got a data error -- remain here until reset */
var    MEM = 31;       /* got an inflate() memory error -- remain here until reset */
var    SYNC = 32;      /* looking for synchronization bytes to restart inflate() */

/* ===========================================================================*/



var ENOUGH_LENS = 852;
var ENOUGH_DISTS = 592;
//var ENOUGH =  (ENOUGH_LENS+ENOUGH_DISTS);

var MAX_WBITS = 15;
/* 32K LZ77 window */
var DEF_WBITS = MAX_WBITS;


function zswap32(q) {
  return  (((q >>> 24) & 0xff) +
          ((q >>> 8) & 0xff00) +
          ((q & 0xff00) << 8) +
          ((q & 0xff) << 24));
}


function InflateState() {
  this.mode = 0;             /* current inflate mode */
  this.last = false;          /* true if processing last block */
  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */
  this.havedict = false;      /* true if dictionary provided */
  this.flags = 0;             /* gzip header method and flags (0 if zlib) */
  this.dmax = 0;              /* zlib header max distance (INFLATE_STRICT) */
  this.check = 0;             /* protected copy of check value */
  this.total = 0;             /* protected copy of output count */
  // TODO: may be {}
  this.head = null;           /* where to save gzip header information */

  /* sliding window */
  this.wbits = 0;             /* log base 2 of requested window size */
  this.wsize = 0;             /* window size or zero if not using window */
  this.whave = 0;             /* valid bytes in the window */
  this.wnext = 0;             /* window write index */
  this.window = null;         /* allocated sliding window, if needed */

  /* bit accumulator */
  this.hold = 0;              /* input bit accumulator */
  this.bits = 0;              /* number of bits in "in" */

  /* for string and stored block copying */
  this.length = 0;            /* literal or length of data to copy */
  this.offset = 0;            /* distance back to copy string from */

  /* for table and code decoding */
  this.extra = 0;             /* extra bits needed */

  /* fixed and dynamic code tables */
  this.lencode = null;          /* starting table for length/literal codes */
  this.distcode = null;         /* starting table for distance codes */
  this.lenbits = 0;           /* index bits for lencode */
  this.distbits = 0;          /* index bits for distcode */

  /* dynamic table building */
  this.ncode = 0;             /* number of code length code lengths */
  this.nlen = 0;              /* number of length code lengths */
  this.ndist = 0;             /* number of distance code lengths */
  this.have = 0;              /* number of code lengths in lens[] */
  this.next = null;              /* next available space in codes[] */

  this.lens = new utils.Buf16(320); /* temporary storage for code lengths */
  this.work = new utils.Buf16(288); /* work area for code table building */

  /*
   because we don't have pointers in js, we use lencode and distcode directly
   as buffers so we don't need codes
  */
  //this.codes = new utils.Buf32(ENOUGH);       /* space for code tables */
  this.lendyn = null;              /* dynamic table for length/literal codes (JS specific) */
  this.distdyn = null;             /* dynamic table for distance codes (JS specific) */
  this.sane = 0;                   /* if false, allow invalid distance too far */
  this.back = 0;                   /* bits back of last unprocessed length/lit */
  this.was = 0;                    /* initial length of match */
}

function inflateResetKeep(strm) {
  var state;

  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  state = strm.state;
  strm.total_in = strm.total_out = state.total = 0;
  strm.msg = ''; /*Z_NULL*/
  if (state.wrap) {       /* to support ill-conceived Java test suite */
    strm.adler = state.wrap & 1;
  }
  state.mode = HEAD;
  state.last = 0;
  state.havedict = 0;
  state.dmax = 32768;
  state.head = null/*Z_NULL*/;
  state.hold = 0;
  state.bits = 0;
  //state.lencode = state.distcode = state.next = state.codes;
  state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);
  state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);

  state.sane = 1;
  state.back = -1;
  //Tracev((stderr, "inflate: reset\n"));
  return Z_OK;
}

function inflateReset(strm) {
  var state;

  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  state = strm.state;
  state.wsize = 0;
  state.whave = 0;
  state.wnext = 0;
  return inflateResetKeep(strm);

}

function inflateReset2(strm, windowBits) {
  var wrap;
  var state;

  /* get the state */
  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  state = strm.state;

  /* extract wrap request from windowBits parameter */
  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  }
  else {
    wrap = (windowBits >> 4) + 1;
    if (windowBits < 48) {
      windowBits &= 15;
    }
  }

  /* set number of window bits, free window if different */
  if (windowBits && (windowBits < 8 || windowBits > 15)) {
    return Z_STREAM_ERROR;
  }
  if (state.window !== null && state.wbits !== windowBits) {
    state.window = null;
  }

  /* update state and reset the rest of it */
  state.wrap = wrap;
  state.wbits = windowBits;
  return inflateReset(strm);
}

function inflateInit2(strm, windowBits) {
  var ret;
  var state;

  if (!strm) { return Z_STREAM_ERROR; }
  //strm.msg = Z_NULL;                 /* in case we return an error */

  state = new InflateState();

  //if (state === Z_NULL) return Z_MEM_ERROR;
  //Tracev((stderr, "inflate: allocated\n"));
  strm.state = state;
  state.window = null/*Z_NULL*/;
  ret = inflateReset2(strm, windowBits);
  if (ret !== Z_OK) {
    strm.state = null/*Z_NULL*/;
  }
  return ret;
}

function inflateInit(strm) {
  return inflateInit2(strm, DEF_WBITS);
}


/*
 Return state with length and distance decoding tables and index sizes set to
 fixed code decoding.  Normally this returns fixed tables from inffixed.h.
 If BUILDFIXED is defined, then instead this routine builds the tables the
 first time it's called, and returns those tables the first time and
 thereafter.  This reduces the size of the code by about 2K bytes, in
 exchange for a little execution time.  However, BUILDFIXED should not be
 used for threaded applications, since the rewriting of the tables and virgin
 may not be thread-safe.
 */
var virgin = true;

var lenfix, distfix; // We have no pointers in JS, so keep tables separate

function fixedtables(state) {
  /* build fixed huffman tables if first call (may not be thread safe) */
  if (virgin) {
    var sym;

    lenfix = new utils.Buf32(512);
    distfix = new utils.Buf32(32);

    /* literal/length table */
    sym = 0;
    while (sym < 144) { state.lens[sym++] = 8; }
    while (sym < 256) { state.lens[sym++] = 9; }
    while (sym < 280) { state.lens[sym++] = 7; }
    while (sym < 288) { state.lens[sym++] = 8; }

    inflate_table(LENS,  state.lens, 0, 288, lenfix,   0, state.work, { bits: 9 });

    /* distance table */
    sym = 0;
    while (sym < 32) { state.lens[sym++] = 5; }

    inflate_table(DISTS, state.lens, 0, 32,   distfix, 0, state.work, { bits: 5 });

    /* do this just once */
    virgin = false;
  }

  state.lencode = lenfix;
  state.lenbits = 9;
  state.distcode = distfix;
  state.distbits = 5;
}


/*
 Update the window with the last wsize (normally 32K) bytes written before
 returning.  If window does not exist yet, create it.  This is only called
 when a window is already in use, or when output has been written during this
 inflate call, but the end of the deflate stream has not been reached yet.
 It is also called to create a window for dictionary data when a dictionary
 is loaded.

 Providing output buffers larger than 32K to inflate() should provide a speed
 advantage, since only the last 32K of output is copied to the sliding window
 upon return from inflate(), and since all distances after the first 32K of
 output will fall in the output data, making match copies simpler and faster.
 The advantage may be dependent on the size of the processor's data caches.
 */
function updatewindow(strm, src, end, copy) {
  var dist;
  var state = strm.state;

  /* if it hasn't been done already, allocate space for the window */
  if (state.window === null) {
    state.wsize = 1 << state.wbits;
    state.wnext = 0;
    state.whave = 0;

    state.window = new utils.Buf8(state.wsize);
  }

  /* copy state->wsize or less output bytes into the circular window */
  if (copy >= state.wsize) {
    utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);
    state.wnext = 0;
    state.whave = state.wsize;
  }
  else {
    dist = state.wsize - state.wnext;
    if (dist > copy) {
      dist = copy;
    }
    //zmemcpy(state->window + state->wnext, end - copy, dist);
    utils.arraySet(state.window, src, end - copy, dist, state.wnext);
    copy -= dist;
    if (copy) {
      //zmemcpy(state->window, end - copy, copy);
      utils.arraySet(state.window, src, end - copy, copy, 0);
      state.wnext = copy;
      state.whave = state.wsize;
    }
    else {
      state.wnext += dist;
      if (state.wnext === state.wsize) { state.wnext = 0; }
      if (state.whave < state.wsize) { state.whave += dist; }
    }
  }
  return 0;
}

function inflate(strm, flush) {
  var state;
  var input, output;          // input/output buffers
  var next;                   /* next input INDEX */
  var put;                    /* next output INDEX */
  var have, left;             /* available input and output */
  var hold;                   /* bit buffer */
  var bits;                   /* bits in bit buffer */
  var _in, _out;              /* save starting available input and output */
  var copy;                   /* number of stored or match bytes to copy */
  var from;                   /* where to copy match bytes from */
  var from_source;
  var here = 0;               /* current decoding table entry */
  var here_bits, here_op, here_val; // paked "here" denormalized (JS specific)
  //var last;                   /* parent table entry */
  var last_bits, last_op, last_val; // paked "last" denormalized (JS specific)
  var len;                    /* length to copy for repeats, bits to drop */
  var ret;                    /* return code */
  var hbuf = new utils.Buf8(4);    /* buffer for gzip header crc calculation */
  var opts;

  var n; // temporary var for NEED_BITS

  var order = /* permutation of code lengths */
    [ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ];


  if (!strm || !strm.state || !strm.output ||
      (!strm.input && strm.avail_in !== 0)) {
    return Z_STREAM_ERROR;
  }

  state = strm.state;
  if (state.mode === TYPE) { state.mode = TYPEDO; }    /* skip check */


  //--- LOAD() ---
  put = strm.next_out;
  output = strm.output;
  left = strm.avail_out;
  next = strm.next_in;
  input = strm.input;
  have = strm.avail_in;
  hold = state.hold;
  bits = state.bits;
  //---

  _in = have;
  _out = left;
  ret = Z_OK;

  inf_leave: // goto emulation
  for (;;) {
    switch (state.mode) {
    case HEAD:
      if (state.wrap === 0) {
        state.mode = TYPEDO;
        break;
      }
      //=== NEEDBITS(16);
      while (bits < 16) {
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
      }
      //===//
      if ((state.wrap & 2) && hold === 0x8b1f) {  /* gzip header */
        state.check = 0/*crc32(0L, Z_NULL, 0)*/;
        //=== CRC2(state.check, hold);
        hbuf[0] = hold & 0xff;
        hbuf[1] = (hold >>> 8) & 0xff;
        state.check = crc32(state.check, hbuf, 2, 0);
        //===//

        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = FLAGS;
        break;
      }
      state.flags = 0;           /* expect zlib header */
      if (state.head) {
        state.head.done = false;
      }
      if (!(state.wrap & 1) ||   /* check if zlib header allowed */
        (((hold & 0xff)/*BITS(8)*/ << 8) + (hold >> 8)) % 31) {
        strm.msg = 'incorrect header check';
        state.mode = BAD;
        break;
      }
      if ((hold & 0x0f)/*BITS(4)*/ !== Z_DEFLATED) {
        strm.msg = 'unknown compression method';
        state.mode = BAD;
        break;
      }
      //--- DROPBITS(4) ---//
      hold >>>= 4;
      bits -= 4;
      //---//
      len = (hold & 0x0f)/*BITS(4)*/ + 8;
      if (state.wbits === 0) {
        state.wbits = len;
      }
      else if (len > state.wbits) {
        strm.msg = 'invalid window size';
        state.mode = BAD;
        break;
      }
      state.dmax = 1 << len;
      //Tracev((stderr, "inflate:   zlib header ok\n"));
      strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
      state.mode = hold & 0x200 ? DICTID : TYPE;
      //=== INITBITS();
      hold = 0;
      bits = 0;
      //===//
      break;
    case FLAGS:
      //=== NEEDBITS(16); */
      while (bits < 16) {
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
      }
      //===//
      state.flags = hold;
      if ((state.flags & 0xff) !== Z_DEFLATED) {
        strm.msg = 'unknown compression method';
        state.mode = BAD;
        break;
      }
      if (state.flags & 0xe000) {
        strm.msg = 'unknown header flags set';
        state.mode = BAD;
        break;
      }
      if (state.head) {
        state.head.text = ((hold >> 8) & 1);
      }
      if (state.flags & 0x0200) {
        //=== CRC2(state.check, hold);
        hbuf[0] = hold & 0xff;
        hbuf[1] = (hold >>> 8) & 0xff;
        state.check = crc32(state.check, hbuf, 2, 0);
        //===//
      }
      //=== INITBITS();
      hold = 0;
      bits = 0;
      //===//
      state.mode = TIME;
      /* falls through */
    case TIME:
      //=== NEEDBITS(32); */
      while (bits < 32) {
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
      }
      //===//
      if (state.head) {
        state.head.time = hold;
      }
      if (state.flags & 0x0200) {
        //=== CRC4(state.check, hold)
        hbuf[0] = hold & 0xff;
        hbuf[1] = (hold >>> 8) & 0xff;
        hbuf[2] = (hold >>> 16) & 0xff;
        hbuf[3] = (hold >>> 24) & 0xff;
        state.check = crc32(state.check, hbuf, 4, 0);
        //===
      }
      //=== INITBITS();
      hold = 0;
      bits = 0;
      //===//
      state.mode = OS;
      /* falls through */
    case OS:
      //=== NEEDBITS(16); */
      while (bits < 16) {
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
      }
      //===//
      if (state.head) {
        state.head.xflags = (hold & 0xff);
        state.head.os = (hold >> 8);
      }
      if (state.flags & 0x0200) {
        //=== CRC2(state.check, hold);
        hbuf[0] = hold & 0xff;
        hbuf[1] = (hold >>> 8) & 0xff;
        state.check = crc32(state.check, hbuf, 2, 0);
        //===//
      }
      //=== INITBITS();
      hold = 0;
      bits = 0;
      //===//
      state.mode = EXLEN;
      /* falls through */
    case EXLEN:
      if (state.flags & 0x0400) {
        //=== NEEDBITS(16); */
        while (bits < 16) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.length = hold;
        if (state.head) {
          state.head.extra_len = hold;
        }
        if (state.flags & 0x0200) {
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          state.check = crc32(state.check, hbuf, 2, 0);
          //===//
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
      }
      else if (state.head) {
        state.head.extra = null/*Z_NULL*/;
      }
      state.mode = EXTRA;
      /* falls through */
    case EXTRA:
      if (state.flags & 0x0400) {
        copy = state.length;
        if (copy > have) { copy = have; }
        if (copy) {
          if (state.head) {
            len = state.head.extra_len - state.length;
            if (!state.head.extra) {
              // Use untyped array for more conveniend processing later
              state.head.extra = new Array(state.head.extra_len);
            }
            utils.arraySet(
              state.head.extra,
              input,
              next,
              // extra field is limited to 65536 bytes
              // - no need for additional size check
              copy,
              /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
              len
            );
            //zmemcpy(state.head.extra + len, next,
            //        len + copy > state.head.extra_max ?
            //        state.head.extra_max - len : copy);
          }
          if (state.flags & 0x0200) {
            state.check = crc32(state.check, input, copy, next);
          }
          have -= copy;
          next += copy;
          state.length -= copy;
        }
        if (state.length) { break inf_leave; }
      }
      state.length = 0;
      state.mode = NAME;
      /* falls through */
    case NAME:
      if (state.flags & 0x0800) {
        if (have === 0) { break inf_leave; }
        copy = 0;
        do {
          // TODO: 2 or 1 bytes?
          len = input[next + copy++];
          /* use constant limit because in js we should not preallocate memory */
          if (state.head && len &&
              (state.length < 65536 /*state.head.name_max*/)) {
            state.head.name += String.fromCharCode(len);
          }
        } while (len && copy < have);

        if (state.flags & 0x0200) {
          state.check = crc32(state.check, input, copy, next);
        }
        have -= copy;
        next += copy;
        if (len) { break inf_leave; }
      }
      else if (state.head) {
        state.head.name = null;
      }
      state.length = 0;
      state.mode = COMMENT;
      /* falls through */
    case COMMENT:
      if (state.flags & 0x1000) {
        if (have === 0) { break inf_leave; }
        copy = 0;
        do {
          len = input[next + copy++];
          /* use constant limit because in js we should not preallocate memory */
          if (state.head && len &&
              (state.length < 65536 /*state.head.comm_max*/)) {
            state.head.comment += String.fromCharCode(len);
          }
        } while (len && copy < have);
        if (state.flags & 0x0200) {
          state.check = crc32(state.check, input, copy, next);
        }
        have -= copy;
        next += copy;
        if (len) { break inf_leave; }
      }
      else if (state.head) {
        state.head.comment = null;
      }
      state.mode = HCRC;
      /* falls through */
    case HCRC:
      if (state.flags & 0x0200) {
        //=== NEEDBITS(16); */
        while (bits < 16) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if (hold !== (state.check & 0xffff)) {
          strm.msg = 'header crc mismatch';
          state.mode = BAD;
          break;
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
      }
      if (state.head) {
        state.head.hcrc = ((state.flags >> 9) & 1);
        state.head.done = true;
      }
      strm.adler = state.check = 0;
      state.mode = TYPE;
      break;
    case DICTID:
      //=== NEEDBITS(32); */
      while (bits < 32) {
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
      }
      //===//
      strm.adler = state.check = zswap32(hold);
      //=== INITBITS();
      hold = 0;
      bits = 0;
      //===//
      state.mode = DICT;
      /* falls through */
    case DICT:
      if (state.havedict === 0) {
        //--- RESTORE() ---
        strm.next_out = put;
        strm.avail_out = left;
        strm.next_in = next;
        strm.avail_in = have;
        state.hold = hold;
        state.bits = bits;
        //---
        return Z_NEED_DICT;
      }
      strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
      state.mode = TYPE;
      /* falls through */
    case TYPE:
      if (flush === Z_BLOCK || flush === Z_TREES) { break inf_leave; }
      /* falls through */
    case TYPEDO:
      if (state.last) {
        //--- BYTEBITS() ---//
        hold >>>= bits & 7;
        bits -= bits & 7;
        //---//
        state.mode = CHECK;
        break;
      }
      //=== NEEDBITS(3); */
      while (bits < 3) {
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
      }
      //===//
      state.last = (hold & 0x01)/*BITS(1)*/;
      //--- DROPBITS(1) ---//
      hold >>>= 1;
      bits -= 1;
      //---//

      switch ((hold & 0x03)/*BITS(2)*/) {
      case 0:                             /* stored block */
        //Tracev((stderr, "inflate:     stored block%s\n",
        //        state.last ? " (last)" : ""));
        state.mode = STORED;
        break;
      case 1:                             /* fixed block */
        fixedtables(state);
        //Tracev((stderr, "inflate:     fixed codes block%s\n",
        //        state.last ? " (last)" : ""));
        state.mode = LEN_;             /* decode codes */
        if (flush === Z_TREES) {
          //--- DROPBITS(2) ---//
          hold >>>= 2;
          bits -= 2;
          //---//
          break inf_leave;
        }
        break;
      case 2:                             /* dynamic block */
        //Tracev((stderr, "inflate:     dynamic codes block%s\n",
        //        state.last ? " (last)" : ""));
        state.mode = TABLE;
        break;
      case 3:
        strm.msg = 'invalid block type';
        state.mode = BAD;
      }
      //--- DROPBITS(2) ---//
      hold >>>= 2;
      bits -= 2;
      //---//
      break;
    case STORED:
      //--- BYTEBITS() ---// /* go to byte boundary */
      hold >>>= bits & 7;
      bits -= bits & 7;
      //---//
      //=== NEEDBITS(32); */
      while (bits < 32) {
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
      }
      //===//
      if ((hold & 0xffff) !== ((hold >>> 16) ^ 0xffff)) {
        strm.msg = 'invalid stored block lengths';
        state.mode = BAD;
        break;
      }
      state.length = hold & 0xffff;
      //Tracev((stderr, "inflate:       stored length %u\n",
      //        state.length));
      //=== INITBITS();
      hold = 0;
      bits = 0;
      //===//
      state.mode = COPY_;
      if (flush === Z_TREES) { break inf_leave; }
      /* falls through */
    case COPY_:
      state.mode = COPY;
      /* falls through */
    case COPY:
      copy = state.length;
      if (copy) {
        if (copy > have) { copy = have; }
        if (copy > left) { copy = left; }
        if (copy === 0) { break inf_leave; }
        //--- zmemcpy(put, next, copy); ---
        utils.arraySet(output, input, next, copy, put);
        //---//
        have -= copy;
        next += copy;
        left -= copy;
        put += copy;
        state.length -= copy;
        break;
      }
      //Tracev((stderr, "inflate:       stored end\n"));
      state.mode = TYPE;
      break;
    case TABLE:
      //=== NEEDBITS(14); */
      while (bits < 14) {
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
      }
      //===//
      state.nlen = (hold & 0x1f)/*BITS(5)*/ + 257;
      //--- DROPBITS(5) ---//
      hold >>>= 5;
      bits -= 5;
      //---//
      state.ndist = (hold & 0x1f)/*BITS(5)*/ + 1;
      //--- DROPBITS(5) ---//
      hold >>>= 5;
      bits -= 5;
      //---//
      state.ncode = (hold & 0x0f)/*BITS(4)*/ + 4;
      //--- DROPBITS(4) ---//
      hold >>>= 4;
      bits -= 4;
      //---//
//#ifndef PKZIP_BUG_WORKAROUND
      if (state.nlen > 286 || state.ndist > 30) {
        strm.msg = 'too many length or distance symbols';
        state.mode = BAD;
        break;
      }
//#endif
      //Tracev((stderr, "inflate:       table sizes ok\n"));
      state.have = 0;
      state.mode = LENLENS;
      /* falls through */
    case LENLENS:
      while (state.have < state.ncode) {
        //=== NEEDBITS(3);
        while (bits < 3) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.lens[order[state.have++]] = (hold & 0x07);//BITS(3);
        //--- DROPBITS(3) ---//
        hold >>>= 3;
        bits -= 3;
        //---//
      }
      while (state.have < 19) {
        state.lens[order[state.have++]] = 0;
      }
      // We have separate tables & no pointers. 2 commented lines below not needed.
      //state.next = state.codes;
      //state.lencode = state.next;
      // Switch to use dynamic table
      state.lencode = state.lendyn;
      state.lenbits = 7;

      opts = { bits: state.lenbits };
      ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
      state.lenbits = opts.bits;

      if (ret) {
        strm.msg = 'invalid code lengths set';
        state.mode = BAD;
        break;
      }
      //Tracev((stderr, "inflate:       code lengths ok\n"));
      state.have = 0;
      state.mode = CODELENS;
      /* falls through */
    case CODELENS:
      while (state.have < state.nlen + state.ndist) {
        for (;;) {
          here = state.lencode[hold & ((1 << state.lenbits) - 1)];/*BITS(state.lenbits)*/
          here_bits = here >>> 24;
          here_op = (here >>> 16) & 0xff;
          here_val = here & 0xffff;

          if ((here_bits) <= bits) { break; }
          //--- PULLBYTE() ---//
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
          //---//
        }
        if (here_val < 16) {
          //--- DROPBITS(here.bits) ---//
          hold >>>= here_bits;
          bits -= here_bits;
          //---//
          state.lens[state.have++] = here_val;
        }
        else {
          if (here_val === 16) {
            //=== NEEDBITS(here.bits + 2);
            n = here_bits + 2;
            while (bits < n) {
              if (have === 0) { break inf_leave; }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            //===//
            //--- DROPBITS(here.bits) ---//
            hold >>>= here_bits;
            bits -= here_bits;
            //---//
            if (state.have === 0) {
              strm.msg = 'invalid bit length repeat';
              state.mode = BAD;
              break;
            }
            len = state.lens[state.have - 1];
            copy = 3 + (hold & 0x03);//BITS(2);
            //--- DROPBITS(2) ---//
            hold >>>= 2;
            bits -= 2;
            //---//
          }
          else if (here_val === 17) {
            //=== NEEDBITS(here.bits + 3);
            n = here_bits + 3;
            while (bits < n) {
              if (have === 0) { break inf_leave; }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            //===//
            //--- DROPBITS(here.bits) ---//
            hold >>>= here_bits;
            bits -= here_bits;
            //---//
            len = 0;
            copy = 3 + (hold & 0x07);//BITS(3);
            //--- DROPBITS(3) ---//
            hold >>>= 3;
            bits -= 3;
            //---//
          }
          else {
            //=== NEEDBITS(here.bits + 7);
            n = here_bits + 7;
            while (bits < n) {
              if (have === 0) { break inf_leave; }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            //===//
            //--- DROPBITS(here.bits) ---//
            hold >>>= here_bits;
            bits -= here_bits;
            //---//
            len = 0;
            copy = 11 + (hold & 0x7f);//BITS(7);
            //--- DROPBITS(7) ---//
            hold >>>= 7;
            bits -= 7;
            //---//
          }
          if (state.have + copy > state.nlen + state.ndist) {
            strm.msg = 'invalid bit length repeat';
            state.mode = BAD;
            break;
          }
          while (copy--) {
            state.lens[state.have++] = len;
          }
        }
      }

      /* handle error breaks in while */
      if (state.mode === BAD) { break; }

      /* check for end-of-block code (better have one) */
      if (state.lens[256] === 0) {
        strm.msg = 'invalid code -- missing end-of-block';
        state.mode = BAD;
        break;
      }

      /* build code tables -- note: do not change the lenbits or distbits
         values here (9 and 6) without reading the comments in inftrees.h
         concerning the ENOUGH constants, which depend on those values */
      state.lenbits = 9;

      opts = { bits: state.lenbits };
      ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
      // We have separate tables & no pointers. 2 commented lines below not needed.
      // state.next_index = opts.table_index;
      state.lenbits = opts.bits;
      // state.lencode = state.next;

      if (ret) {
        strm.msg = 'invalid literal/lengths set';
        state.mode = BAD;
        break;
      }

      state.distbits = 6;
      //state.distcode.copy(state.codes);
      // Switch to use dynamic table
      state.distcode = state.distdyn;
      opts = { bits: state.distbits };
      ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
      // We have separate tables & no pointers. 2 commented lines below not needed.
      // state.next_index = opts.table_index;
      state.distbits = opts.bits;
      // state.distcode = state.next;

      if (ret) {
        strm.msg = 'invalid distances set';
        state.mode = BAD;
        break;
      }
      //Tracev((stderr, 'inflate:       codes ok\n'));
      state.mode = LEN_;
      if (flush === Z_TREES) { break inf_leave; }
      /* falls through */
    case LEN_:
      state.mode = LEN;
      /* falls through */
    case LEN:
      if (have >= 6 && left >= 258) {
        //--- RESTORE() ---
        strm.next_out = put;
        strm.avail_out = left;
        strm.next_in = next;
        strm.avail_in = have;
        state.hold = hold;
        state.bits = bits;
        //---
        inflate_fast(strm, _out);
        //--- LOAD() ---
        put = strm.next_out;
        output = strm.output;
        left = strm.avail_out;
        next = strm.next_in;
        input = strm.input;
        have = strm.avail_in;
        hold = state.hold;
        bits = state.bits;
        //---

        if (state.mode === TYPE) {
          state.back = -1;
        }
        break;
      }
      state.back = 0;
      for (;;) {
        here = state.lencode[hold & ((1 << state.lenbits) - 1)];  /*BITS(state.lenbits)*/
        here_bits = here >>> 24;
        here_op = (here >>> 16) & 0xff;
        here_val = here & 0xffff;

        if (here_bits <= bits) { break; }
        //--- PULLBYTE() ---//
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
        //---//
      }
      if (here_op && (here_op & 0xf0) === 0) {
        last_bits = here_bits;
        last_op = here_op;
        last_val = here_val;
        for (;;) {
          here = state.lencode[last_val +
                  ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];
          here_bits = here >>> 24;
          here_op = (here >>> 16) & 0xff;
          here_val = here & 0xffff;

          if ((last_bits + here_bits) <= bits) { break; }
          //--- PULLBYTE() ---//
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
          //---//
        }
        //--- DROPBITS(last.bits) ---//
        hold >>>= last_bits;
        bits -= last_bits;
        //---//
        state.back += last_bits;
      }
      //--- DROPBITS(here.bits) ---//
      hold >>>= here_bits;
      bits -= here_bits;
      //---//
      state.back += here_bits;
      state.length = here_val;
      if (here_op === 0) {
        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
        //        "inflate:         literal '%c'\n" :
        //        "inflate:         literal 0x%02x\n", here.val));
        state.mode = LIT;
        break;
      }
      if (here_op & 32) {
        //Tracevv((stderr, "inflate:         end of block\n"));
        state.back = -1;
        state.mode = TYPE;
        break;
      }
      if (here_op & 64) {
        strm.msg = 'invalid literal/length code';
        state.mode = BAD;
        break;
      }
      state.extra = here_op & 15;
      state.mode = LENEXT;
      /* falls through */
    case LENEXT:
      if (state.extra) {
        //=== NEEDBITS(state.extra);
        n = state.extra;
        while (bits < n) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.length += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;
        //--- DROPBITS(state.extra) ---//
        hold >>>= state.extra;
        bits -= state.extra;
        //---//
        state.back += state.extra;
      }
      //Tracevv((stderr, "inflate:         length %u\n", state.length));
      state.was = state.length;
      state.mode = DIST;
      /* falls through */
    case DIST:
      for (;;) {
        here = state.distcode[hold & ((1 << state.distbits) - 1)];/*BITS(state.distbits)*/
        here_bits = here >>> 24;
        here_op = (here >>> 16) & 0xff;
        here_val = here & 0xffff;

        if ((here_bits) <= bits) { break; }
        //--- PULLBYTE() ---//
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
        //---//
      }
      if ((here_op & 0xf0) === 0) {
        last_bits = here_bits;
        last_op = here_op;
        last_val = here_val;
        for (;;) {
          here = state.distcode[last_val +
                  ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];
          here_bits = here >>> 24;
          here_op = (here >>> 16) & 0xff;
          here_val = here & 0xffff;

          if ((last_bits + here_bits) <= bits) { break; }
          //--- PULLBYTE() ---//
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
          //---//
        }
        //--- DROPBITS(last.bits) ---//
        hold >>>= last_bits;
        bits -= last_bits;
        //---//
        state.back += last_bits;
      }
      //--- DROPBITS(here.bits) ---//
      hold >>>= here_bits;
      bits -= here_bits;
      //---//
      state.back += here_bits;
      if (here_op & 64) {
        strm.msg = 'invalid distance code';
        state.mode = BAD;
        break;
      }
      state.offset = here_val;
      state.extra = (here_op) & 15;
      state.mode = DISTEXT;
      /* falls through */
    case DISTEXT:
      if (state.extra) {
        //=== NEEDBITS(state.extra);
        n = state.extra;
        while (bits < n) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.offset += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;
        //--- DROPBITS(state.extra) ---//
        hold >>>= state.extra;
        bits -= state.extra;
        //---//
        state.back += state.extra;
      }
//#ifdef INFLATE_STRICT
      if (state.offset > state.dmax) {
        strm.msg = 'invalid distance too far back';
        state.mode = BAD;
        break;
      }
//#endif
      //Tracevv((stderr, "inflate:         distance %u\n", state.offset));
      state.mode = MATCH;
      /* falls through */
    case MATCH:
      if (left === 0) { break inf_leave; }
      copy = _out - left;
      if (state.offset > copy) {         /* copy from window */
        copy = state.offset - copy;
        if (copy > state.whave) {
          if (state.sane) {
            strm.msg = 'invalid distance too far back';
            state.mode = BAD;
            break;
          }
// (!) This block is disabled in zlib defailts,
// don't enable it for binary compatibility
//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
//          Trace((stderr, "inflate.c too far\n"));
//          copy -= state.whave;
//          if (copy > state.length) { copy = state.length; }
//          if (copy > left) { copy = left; }
//          left -= copy;
//          state.length -= copy;
//          do {
//            output[put++] = 0;
//          } while (--copy);
//          if (state.length === 0) { state.mode = LEN; }
//          break;
//#endif
        }
        if (copy > state.wnext) {
          copy -= state.wnext;
          from = state.wsize - copy;
        }
        else {
          from = state.wnext - copy;
        }
        if (copy > state.length) { copy = state.length; }
        from_source = state.window;
      }
      else {                              /* copy from output */
        from_source = output;
        from = put - state.offset;
        copy = state.length;
      }
      if (copy > left) { copy = left; }
      left -= copy;
      state.length -= copy;
      do {
        output[put++] = from_source[from++];
      } while (--copy);
      if (state.length === 0) { state.mode = LEN; }
      break;
    case LIT:
      if (left === 0) { break inf_leave; }
      output[put++] = state.length;
      left--;
      state.mode = LEN;
      break;
    case CHECK:
      if (state.wrap) {
        //=== NEEDBITS(32);
        while (bits < 32) {
          if (have === 0) { break inf_leave; }
          have--;
          // Use '|' insdead of '+' to make sure that result is signed
          hold |= input[next++] << bits;
          bits += 8;
        }
        //===//
        _out -= left;
        strm.total_out += _out;
        state.total += _out;
        if (_out) {
          strm.adler = state.check =
              /*UPDATE(state.check, put - _out, _out);*/
              (state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out));

        }
        _out = left;
        // NB: crc32 stored as signed 32-bit int, zswap32 returns signed too
        if ((state.flags ? hold : zswap32(hold)) !== state.check) {
          strm.msg = 'incorrect data check';
          state.mode = BAD;
          break;
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        //Tracev((stderr, "inflate:   check matches trailer\n"));
      }
      state.mode = LENGTH;
      /* falls through */
    case LENGTH:
      if (state.wrap && state.flags) {
        //=== NEEDBITS(32);
        while (bits < 32) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if (hold !== (state.total & 0xffffffff)) {
          strm.msg = 'incorrect length check';
          state.mode = BAD;
          break;
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        //Tracev((stderr, "inflate:   length matches trailer\n"));
      }
      state.mode = DONE;
      /* falls through */
    case DONE:
      ret = Z_STREAM_END;
      break inf_leave;
    case BAD:
      ret = Z_DATA_ERROR;
      break inf_leave;
    case MEM:
      return Z_MEM_ERROR;
    case SYNC:
      /* falls through */
    default:
      return Z_STREAM_ERROR;
    }
  }

  // inf_leave <- here is real place for "goto inf_leave", emulated via "break inf_leave"

  /*
     Return from inflate(), updating the total counts and the check value.
     If there was no progress during the inflate() call, return a buffer
     error.  Call updatewindow() to create and/or update the window state.
     Note: a memory error from inflate() is non-recoverable.
   */

  //--- RESTORE() ---
  strm.next_out = put;
  strm.avail_out = left;
  strm.next_in = next;
  strm.avail_in = have;
  state.hold = hold;
  state.bits = bits;
  //---

  if (state.wsize || (_out !== strm.avail_out && state.mode < BAD &&
                      (state.mode < CHECK || flush !== Z_FINISH))) {
    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
      state.mode = MEM;
      return Z_MEM_ERROR;
    }
  }
  _in -= strm.avail_in;
  _out -= strm.avail_out;
  strm.total_in += _in;
  strm.total_out += _out;
  state.total += _out;
  if (state.wrap && _out) {
    strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
      (state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out));
  }
  strm.data_type = state.bits + (state.last ? 64 : 0) +
                    (state.mode === TYPE ? 128 : 0) +
                    (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
  if (((_in === 0 && _out === 0) || flush === Z_FINISH) && ret === Z_OK) {
    ret = Z_BUF_ERROR;
  }
  return ret;
}

function inflateEnd(strm) {

  if (!strm || !strm.state /*|| strm->zfree == (free_func)0*/) {
    return Z_STREAM_ERROR;
  }

  var state = strm.state;
  if (state.window) {
    state.window = null;
  }
  strm.state = null;
  return Z_OK;
}

function inflateGetHeader(strm, head) {
  var state;

  /* check state */
  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  state = strm.state;
  if ((state.wrap & 2) === 0) { return Z_STREAM_ERROR; }

  /* save header structure */
  state.head = head;
  head.done = false;
  return Z_OK;
}

function inflateSetDictionary(strm, dictionary) {
  var dictLength = dictionary.length;

  var state;
  var dictid;
  var ret;

  /* check state */
  if (!strm /* == Z_NULL */ || !strm.state /* == Z_NULL */) { return Z_STREAM_ERROR; }
  state = strm.state;

  if (state.wrap !== 0 && state.mode !== DICT) {
    return Z_STREAM_ERROR;
  }

  /* check for correct dictionary identifier */
  if (state.mode === DICT) {
    dictid = 1; /* adler32(0, null, 0)*/
    /* dictid = adler32(dictid, dictionary, dictLength); */
    dictid = adler32(dictid, dictionary, dictLength, 0);
    if (dictid !== state.check) {
      return Z_DATA_ERROR;
    }
  }
  /* copy dictionary to window using updatewindow(), which will amend the
   existing dictionary if appropriate */
  ret = updatewindow(strm, dictionary, dictLength, dictLength);
  if (ret) {
    state.mode = MEM;
    return Z_MEM_ERROR;
  }
  state.havedict = 1;
  // Tracev((stderr, "inflate:   dictionary set\n"));
  return Z_OK;
}

exports.inflateReset = inflateReset;
exports.inflateReset2 = inflateReset2;
exports.inflateResetKeep = inflateResetKeep;
exports.inflateInit = inflateInit;
exports.inflateInit2 = inflateInit2;
exports.inflate = inflate;
exports.inflateEnd = inflateEnd;
exports.inflateGetHeader = inflateGetHeader;
exports.inflateSetDictionary = inflateSetDictionary;
exports.inflateInfo = 'pako inflate (from Nodeca project)';

/* Not implemented
exports.inflateCopy = inflateCopy;
exports.inflateGetDictionary = inflateGetDictionary;
exports.inflateMark = inflateMark;
exports.inflatePrime = inflatePrime;
exports.inflateSync = inflateSync;
exports.inflateSyncPoint = inflateSyncPoint;
exports.inflateUndermine = inflateUndermine;
*/


/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// Note: adler32 takes 12% for level 0 and 2% for level 6.
// It doesn't worth to make additional optimizationa as in original.
// Small size is preferable.

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

function adler32(adler, buf, len, pos) {
  var s1 = (adler & 0xffff) |0,
      s2 = ((adler >>> 16) & 0xffff) |0,
      n = 0;

  while (len !== 0) {
    // Set limit ~ twice less than 5552, to keep
    // s2 in 31-bits, because we force signed ints.
    // in other case %= will fail.
    n = len > 2000 ? 2000 : len;
    len -= n;

    do {
      s1 = (s1 + buf[pos++]) |0;
      s2 = (s2 + s1) |0;
    } while (--n);

    s1 %= 65521;
    s2 %= 65521;
  }

  return (s1 | (s2 << 16)) |0;
}


module.exports = adler32;


/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// Note: we can't get significant speed boost here.
// So write code to minimize size - no pregenerated tables
// and array tools dependencies.

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

// Use ordinary array, since untyped makes no boost here
function makeTable() {
  var c, table = [];

  for (var n = 0; n < 256; n++) {
    c = n;
    for (var k = 0; k < 8; k++) {
      c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));
    }
    table[n] = c;
  }

  return table;
}

// Create table on load. Just 255 signed longs. Not a problem.
var crcTable = makeTable();


function crc32(crc, buf, len, pos) {
  var t = crcTable,
      end = pos + len;

  crc ^= -1;

  for (var i = pos; i < end; i++) {
    crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];
  }

  return (crc ^ (-1)); // >>> 0;
}


module.exports = crc32;


/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

// See state defs from inflate.js
var BAD = 30;       /* got a data error -- remain here until reset */
var TYPE = 12;      /* i: waiting for type bits, including last-flag bit */

/*
   Decode literal, length, and distance codes and write out the resulting
   literal and match bytes until either not enough input or output is
   available, an end-of-block is encountered, or a data error is encountered.
   When large enough input and output buffers are supplied to inflate(), for
   example, a 16K input buffer and a 64K output buffer, more than 95% of the
   inflate execution time is spent in this routine.

   Entry assumptions:

        state.mode === LEN
        strm.avail_in >= 6
        strm.avail_out >= 258
        start >= strm.avail_out
        state.bits < 8

   On return, state.mode is one of:

        LEN -- ran out of enough output space or enough available input
        TYPE -- reached end of block code, inflate() to interpret next block
        BAD -- error in block data

   Notes:

    - The maximum input bits used by a length/distance pair is 15 bits for the
      length code, 5 bits for the length extra, 15 bits for the distance code,
      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.
      Therefore if strm.avail_in >= 6, then there is enough input to avoid
      checking for available input while decoding.

    - The maximum bytes that a single length/distance pair can output is 258
      bytes, which is the maximum length that can be coded.  inflate_fast()
      requires strm.avail_out >= 258 for each loop to avoid checking for
      output space.
 */
module.exports = function inflate_fast(strm, start) {
  var state;
  var _in;                    /* local strm.input */
  var last;                   /* have enough input while in < last */
  var _out;                   /* local strm.output */
  var beg;                    /* inflate()'s initial strm.output */
  var end;                    /* while out < end, enough space available */
//#ifdef INFLATE_STRICT
  var dmax;                   /* maximum distance from zlib header */
//#endif
  var wsize;                  /* window size or zero if not using window */
  var whave;                  /* valid bytes in the window */
  var wnext;                  /* window write index */
  // Use `s_window` instead `window`, avoid conflict with instrumentation tools
  var s_window;               /* allocated sliding window, if wsize != 0 */
  var hold;                   /* local strm.hold */
  var bits;                   /* local strm.bits */
  var lcode;                  /* local strm.lencode */
  var dcode;                  /* local strm.distcode */
  var lmask;                  /* mask for first level of length codes */
  var dmask;                  /* mask for first level of distance codes */
  var here;                   /* retrieved table entry */
  var op;                     /* code bits, operation, extra bits, or */
                              /*  window position, window bytes to copy */
  var len;                    /* match length, unused bytes */
  var dist;                   /* match distance */
  var from;                   /* where to copy match from */
  var from_source;


  var input, output; // JS specific, because we have no pointers

  /* copy state to local variables */
  state = strm.state;
  //here = state.here;
  _in = strm.next_in;
  input = strm.input;
  last = _in + (strm.avail_in - 5);
  _out = strm.next_out;
  output = strm.output;
  beg = _out - (start - strm.avail_out);
  end = _out + (strm.avail_out - 257);
//#ifdef INFLATE_STRICT
  dmax = state.dmax;
//#endif
  wsize = state.wsize;
  whave = state.whave;
  wnext = state.wnext;
  s_window = state.window;
  hold = state.hold;
  bits = state.bits;
  lcode = state.lencode;
  dcode = state.distcode;
  lmask = (1 << state.lenbits) - 1;
  dmask = (1 << state.distbits) - 1;


  /* decode literals and length/distances until end-of-block or not enough
     input data or output space */

  top:
  do {
    if (bits < 15) {
      hold += input[_in++] << bits;
      bits += 8;
      hold += input[_in++] << bits;
      bits += 8;
    }

    here = lcode[hold & lmask];

    dolen:
    for (;;) { // Goto emulation
      op = here >>> 24/*here.bits*/;
      hold >>>= op;
      bits -= op;
      op = (here >>> 16) & 0xff/*here.op*/;
      if (op === 0) {                          /* literal */
        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
        //        "inflate:         literal '%c'\n" :
        //        "inflate:         literal 0x%02x\n", here.val));
        output[_out++] = here & 0xffff/*here.val*/;
      }
      else if (op & 16) {                     /* length base */
        len = here & 0xffff/*here.val*/;
        op &= 15;                           /* number of extra bits */
        if (op) {
          if (bits < op) {
            hold += input[_in++] << bits;
            bits += 8;
          }
          len += hold & ((1 << op) - 1);
          hold >>>= op;
          bits -= op;
        }
        //Tracevv((stderr, "inflate:         length %u\n", len));
        if (bits < 15) {
          hold += input[_in++] << bits;
          bits += 8;
          hold += input[_in++] << bits;
          bits += 8;
        }
        here = dcode[hold & dmask];

        dodist:
        for (;;) { // goto emulation
          op = here >>> 24/*here.bits*/;
          hold >>>= op;
          bits -= op;
          op = (here >>> 16) & 0xff/*here.op*/;

          if (op & 16) {                      /* distance base */
            dist = here & 0xffff/*here.val*/;
            op &= 15;                       /* number of extra bits */
            if (bits < op) {
              hold += input[_in++] << bits;
              bits += 8;
              if (bits < op) {
                hold += input[_in++] << bits;
                bits += 8;
              }
            }
            dist += hold & ((1 << op) - 1);
//#ifdef INFLATE_STRICT
            if (dist > dmax) {
              strm.msg = 'invalid distance too far back';
              state.mode = BAD;
              break top;
            }
//#endif
            hold >>>= op;
            bits -= op;
            //Tracevv((stderr, "inflate:         distance %u\n", dist));
            op = _out - beg;                /* max distance in output */
            if (dist > op) {                /* see if copy from window */
              op = dist - op;               /* distance back in window */
              if (op > whave) {
                if (state.sane) {
                  strm.msg = 'invalid distance too far back';
                  state.mode = BAD;
                  break top;
                }

// (!) This block is disabled in zlib defailts,
// don't enable it for binary compatibility
//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
//                if (len <= op - whave) {
//                  do {
//                    output[_out++] = 0;
//                  } while (--len);
//                  continue top;
//                }
//                len -= op - whave;
//                do {
//                  output[_out++] = 0;
//                } while (--op > whave);
//                if (op === 0) {
//                  from = _out - dist;
//                  do {
//                    output[_out++] = output[from++];
//                  } while (--len);
//                  continue top;
//                }
//#endif
              }
              from = 0; // window index
              from_source = s_window;
              if (wnext === 0) {           /* very common case */
                from += wsize - op;
                if (op < len) {         /* some from window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = _out - dist;  /* rest from output */
                  from_source = output;
                }
              }
              else if (wnext < op) {      /* wrap around window */
                from += wsize + wnext - op;
                op -= wnext;
                if (op < len) {         /* some from end of window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = 0;
                  if (wnext < len) {  /* some from start of window */
                    op = wnext;
                    len -= op;
                    do {
                      output[_out++] = s_window[from++];
                    } while (--op);
                    from = _out - dist;      /* rest from output */
                    from_source = output;
                  }
                }
              }
              else {                      /* contiguous in window */
                from += wnext - op;
                if (op < len) {         /* some from window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = _out - dist;  /* rest from output */
                  from_source = output;
                }
              }
              while (len > 2) {
                output[_out++] = from_source[from++];
                output[_out++] = from_source[from++];
                output[_out++] = from_source[from++];
                len -= 3;
              }
              if (len) {
                output[_out++] = from_source[from++];
                if (len > 1) {
                  output[_out++] = from_source[from++];
                }
              }
            }
            else {
              from = _out - dist;          /* copy direct from output */
              do {                        /* minimum length is three */
                output[_out++] = output[from++];
                output[_out++] = output[from++];
                output[_out++] = output[from++];
                len -= 3;
              } while (len > 2);
              if (len) {
                output[_out++] = output[from++];
                if (len > 1) {
                  output[_out++] = output[from++];
                }
              }
            }
          }
          else if ((op & 64) === 0) {          /* 2nd level distance code */
            here = dcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
            continue dodist;
          }
          else {
            strm.msg = 'invalid distance code';
            state.mode = BAD;
            break top;
          }

          break; // need to emulate goto via "continue"
        }
      }
      else if ((op & 64) === 0) {              /* 2nd level length code */
        here = lcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
        continue dolen;
      }
      else if (op & 32) {                     /* end-of-block */
        //Tracevv((stderr, "inflate:         end of block\n"));
        state.mode = TYPE;
        break top;
      }
      else {
        strm.msg = 'invalid literal/length code';
        state.mode = BAD;
        break top;
      }

      break; // need to emulate goto via "continue"
    }
  } while (_in < last && _out < end);

  /* return unused bytes (on entry, bits < 8, so in won't go too far back) */
  len = bits >> 3;
  _in -= len;
  bits -= len << 3;
  hold &= (1 << bits) - 1;

  /* update state and return */
  strm.next_in = _in;
  strm.next_out = _out;
  strm.avail_in = (_in < last ? 5 + (last - _in) : 5 - (_in - last));
  strm.avail_out = (_out < end ? 257 + (end - _out) : 257 - (_out - end));
  state.hold = hold;
  state.bits = bits;
  return;
};


/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

var utils = __webpack_require__(8);

var MAXBITS = 15;
var ENOUGH_LENS = 852;
var ENOUGH_DISTS = 592;
//var ENOUGH = (ENOUGH_LENS+ENOUGH_DISTS);

var CODES = 0;
var LENS = 1;
var DISTS = 2;

var lbase = [ /* Length codes 257..285 base */
  3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
  35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0
];

var lext = [ /* Length codes 257..285 extra */
  16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,
  19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78
];

var dbase = [ /* Distance codes 0..29 base */
  1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
  257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
  8193, 12289, 16385, 24577, 0, 0
];

var dext = [ /* Distance codes 0..29 extra */
  16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,
  23, 23, 24, 24, 25, 25, 26, 26, 27, 27,
  28, 28, 29, 29, 64, 64
];

module.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts)
{
  var bits = opts.bits;
      //here = opts.here; /* table entry for duplication */

  var len = 0;               /* a code's length in bits */
  var sym = 0;               /* index of code symbols */
  var min = 0, max = 0;          /* minimum and maximum code lengths */
  var root = 0;              /* number of index bits for root table */
  var curr = 0;              /* number of index bits for current table */
  var drop = 0;              /* code bits to drop for sub-table */
  var left = 0;                   /* number of prefix codes available */
  var used = 0;              /* code entries in table used */
  var huff = 0;              /* Huffman code */
  var incr;              /* for incrementing code, index */
  var fill;              /* index for replicating entries */
  var low;               /* low bits for current root entry */
  var mask;              /* mask for low root bits */
  var next;             /* next available space in table */
  var base = null;     /* base value table to use */
  var base_index = 0;
//  var shoextra;    /* extra bits table to use */
  var end;                    /* use base and extra for symbol > end */
  var count = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];    /* number of codes of each length */
  var offs = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];     /* offsets in table for each length */
  var extra = null;
  var extra_index = 0;

  var here_bits, here_op, here_val;

  /*
   Process a set of code lengths to create a canonical Huffman code.  The
   code lengths are lens[0..codes-1].  Each length corresponds to the
   symbols 0..codes-1.  The Huffman code is generated by first sorting the
   symbols by length from short to long, and retaining the symbol order
   for codes with equal lengths.  Then the code starts with all zero bits
   for the first code of the shortest length, and the codes are integer
   increments for the same length, and zeros are appended as the length
   increases.  For the deflate format, these bits are stored backwards
   from their more natural integer increment ordering, and so when the
   decoding tables are built in the large loop below, the integer codes
   are incremented backwards.

   This routine assumes, but does not check, that all of the entries in
   lens[] are in the range 0..MAXBITS.  The caller must assure this.
   1..MAXBITS is interpreted as that code length.  zero means that that
   symbol does not occur in this code.

   The codes are sorted by computing a count of codes for each length,
   creating from that a table of starting indices for each length in the
   sorted table, and then entering the symbols in order in the sorted
   table.  The sorted table is work[], with that space being provided by
   the caller.

   The length counts are used for other purposes as well, i.e. finding
   the minimum and maximum length codes, determining if there are any
   codes at all, checking for a valid set of lengths, and looking ahead
   at length counts to determine sub-table sizes when building the
   decoding tables.
   */

  /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
  for (len = 0; len <= MAXBITS; len++) {
    count[len] = 0;
  }
  for (sym = 0; sym < codes; sym++) {
    count[lens[lens_index + sym]]++;
  }

  /* bound code lengths, force root to be within code lengths */
  root = bits;
  for (max = MAXBITS; max >= 1; max--) {
    if (count[max] !== 0) { break; }
  }
  if (root > max) {
    root = max;
  }
  if (max === 0) {                     /* no symbols to code at all */
    //table.op[opts.table_index] = 64;  //here.op = (var char)64;    /* invalid code marker */
    //table.bits[opts.table_index] = 1;   //here.bits = (var char)1;
    //table.val[opts.table_index++] = 0;   //here.val = (var short)0;
    table[table_index++] = (1 << 24) | (64 << 16) | 0;


    //table.op[opts.table_index] = 64;
    //table.bits[opts.table_index] = 1;
    //table.val[opts.table_index++] = 0;
    table[table_index++] = (1 << 24) | (64 << 16) | 0;

    opts.bits = 1;
    return 0;     /* no symbols, but wait for decoding to report error */
  }
  for (min = 1; min < max; min++) {
    if (count[min] !== 0) { break; }
  }
  if (root < min) {
    root = min;
  }

  /* check for an over-subscribed or incomplete set of lengths */
  left = 1;
  for (len = 1; len <= MAXBITS; len++) {
    left <<= 1;
    left -= count[len];
    if (left < 0) {
      return -1;
    }        /* over-subscribed */
  }
  if (left > 0 && (type === CODES || max !== 1)) {
    return -1;                      /* incomplete set */
  }

  /* generate offsets into symbol table for each length for sorting */
  offs[1] = 0;
  for (len = 1; len < MAXBITS; len++) {
    offs[len + 1] = offs[len] + count[len];
  }

  /* sort symbols by length, by symbol order within each length */
  for (sym = 0; sym < codes; sym++) {
    if (lens[lens_index + sym] !== 0) {
      work[offs[lens[lens_index + sym]]++] = sym;
    }
  }

  /*
   Create and fill in decoding tables.  In this loop, the table being
   filled is at next and has curr index bits.  The code being used is huff
   with length len.  That code is converted to an index by dropping drop
   bits off of the bottom.  For codes where len is less than drop + curr,
   those top drop + curr - len bits are incremented through all values to
   fill the table with replicated entries.

   root is the number of index bits for the root table.  When len exceeds
   root, sub-tables are created pointed to by the root entry with an index
   of the low root bits of huff.  This is saved in low to check for when a
   new sub-table should be started.  drop is zero when the root table is
   being filled, and drop is root when sub-tables are being filled.

   When a new sub-table is needed, it is necessary to look ahead in the
   code lengths to determine what size sub-table is needed.  The length
   counts are used for this, and so count[] is decremented as codes are
   entered in the tables.

   used keeps track of how many table entries have been allocated from the
   provided *table space.  It is checked for LENS and DIST tables against
   the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in
   the initial root table size constants.  See the comments in inftrees.h
   for more information.

   sym increments through all symbols, and the loop terminates when
   all codes of length max, i.e. all codes, have been processed.  This
   routine permits incomplete codes, so another loop after this one fills
   in the rest of the decoding tables with invalid code markers.
   */

  /* set up for code type */
  // poor man optimization - use if-else instead of switch,
  // to avoid deopts in old v8
  if (type === CODES) {
    base = extra = work;    /* dummy value--not used */
    end = 19;

  } else if (type === LENS) {
    base = lbase;
    base_index -= 257;
    extra = lext;
    extra_index -= 257;
    end = 256;

  } else {                    /* DISTS */
    base = dbase;
    extra = dext;
    end = -1;
  }

  /* initialize opts for loop */
  huff = 0;                   /* starting code */
  sym = 0;                    /* starting code symbol */
  len = min;                  /* starting code length */
  next = table_index;              /* current table to fill in */
  curr = root;                /* current table index bits */
  drop = 0;                   /* current bits to drop from code for index */
  low = -1;                   /* trigger new sub-table when len > root */
  used = 1 << root;          /* use root table entries */
  mask = used - 1;            /* mask for comparing low */

  /* check available table space */
  if ((type === LENS && used > ENOUGH_LENS) ||
    (type === DISTS && used > ENOUGH_DISTS)) {
    return 1;
  }

  /* process all codes and make table entries */
  for (;;) {
    /* create table entry */
    here_bits = len - drop;
    if (work[sym] < end) {
      here_op = 0;
      here_val = work[sym];
    }
    else if (work[sym] > end) {
      here_op = extra[extra_index + work[sym]];
      here_val = base[base_index + work[sym]];
    }
    else {
      here_op = 32 + 64;         /* end of block */
      here_val = 0;
    }

    /* replicate for those indices with low len bits equal to huff */
    incr = 1 << (len - drop);
    fill = 1 << curr;
    min = fill;                 /* save offset to next table */
    do {
      fill -= incr;
      table[next + (huff >> drop) + fill] = (here_bits << 24) | (here_op << 16) | here_val |0;
    } while (fill !== 0);

    /* backwards increment the len-bit code huff */
    incr = 1 << (len - 1);
    while (huff & incr) {
      incr >>= 1;
    }
    if (incr !== 0) {
      huff &= incr - 1;
      huff += incr;
    } else {
      huff = 0;
    }

    /* go to next symbol, update count, len */
    sym++;
    if (--count[len] === 0) {
      if (len === max) { break; }
      len = lens[lens_index + work[sym]];
    }

    /* create new sub-table if needed */
    if (len > root && (huff & mask) !== low) {
      /* if first time, transition to sub-tables */
      if (drop === 0) {
        drop = root;
      }

      /* increment past last table */
      next += min;            /* here min is 1 << curr */

      /* determine length of next table */
      curr = len - drop;
      left = 1 << curr;
      while (curr + drop < max) {
        left -= count[curr + drop];
        if (left <= 0) { break; }
        curr++;
        left <<= 1;
      }

      /* check for enough space */
      used += 1 << curr;
      if ((type === LENS && used > ENOUGH_LENS) ||
        (type === DISTS && used > ENOUGH_DISTS)) {
        return 1;
      }

      /* point entry in root table to sub-table */
      low = huff & mask;
      /*table.op[low] = curr;
      table.bits[low] = root;
      table.val[low] = next - opts.table_index;*/
      table[low] = (root << 24) | (curr << 16) | (next - table_index) |0;
    }
  }

  /* fill in remaining table entry if code is incomplete (guaranteed to have
   at most one remaining entry, since if the code is incomplete, the
   maximum code length that was allowed to get this far is one bit) */
  if (huff !== 0) {
    //table.op[next + huff] = 64;            /* invalid code marker */
    //table.bits[next + huff] = len - drop;
    //table.val[next + huff] = 0;
    table[next + huff] = ((len - drop) << 24) | (64 << 16) |0;
  }

  /* set return parameters */
  //opts.table_index += used;
  opts.bits = root;
  return 0;
};


/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// String encode/decode helpers



var utils = __webpack_require__(8);


// Quick check if we can use fast array to bin string conversion
//
// - apply(Array) can fail on Android 2.2
// - apply(Uint8Array) can fail on iOS 5.1 Safary
//
var STR_APPLY_OK = true;
var STR_APPLY_UIA_OK = true;

try { String.fromCharCode.apply(null, [ 0 ]); } catch (__) { STR_APPLY_OK = false; }
try { String.fromCharCode.apply(null, new Uint8Array(1)); } catch (__) { STR_APPLY_UIA_OK = false; }


// Table with utf8 lengths (calculated by first byte of sequence)
// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,
// because max possible codepoint is 0x10ffff
var _utf8len = new utils.Buf8(256);
for (var q = 0; q < 256; q++) {
  _utf8len[q] = (q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1);
}
_utf8len[254] = _utf8len[254] = 1; // Invalid sequence start


// convert string to array (typed, when possible)
exports.string2buf = function (str) {
  var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;

  // count binary size
  for (m_pos = 0; m_pos < str_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 0xfc00) === 0xdc00) {
        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
        m_pos++;
      }
    }
    buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;
  }

  // allocate buffer
  buf = new utils.Buf8(buf_len);

  // convert
  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 0xfc00) === 0xdc00) {
        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
        m_pos++;
      }
    }
    if (c < 0x80) {
      /* one byte */
      buf[i++] = c;
    } else if (c < 0x800) {
      /* two bytes */
      buf[i++] = 0xC0 | (c >>> 6);
      buf[i++] = 0x80 | (c & 0x3f);
    } else if (c < 0x10000) {
      /* three bytes */
      buf[i++] = 0xE0 | (c >>> 12);
      buf[i++] = 0x80 | (c >>> 6 & 0x3f);
      buf[i++] = 0x80 | (c & 0x3f);
    } else {
      /* four bytes */
      buf[i++] = 0xf0 | (c >>> 18);
      buf[i++] = 0x80 | (c >>> 12 & 0x3f);
      buf[i++] = 0x80 | (c >>> 6 & 0x3f);
      buf[i++] = 0x80 | (c & 0x3f);
    }
  }

  return buf;
};

// Helper (used in 2 places)
function buf2binstring(buf, len) {
  // use fallback for big arrays to avoid stack overflow
  if (len < 65537) {
    if ((buf.subarray && STR_APPLY_UIA_OK) || (!buf.subarray && STR_APPLY_OK)) {
      return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));
    }
  }

  var result = '';
  for (var i = 0; i < len; i++) {
    result += String.fromCharCode(buf[i]);
  }
  return result;
}


// Convert byte array to binary string
exports.buf2binstring = function (buf) {
  return buf2binstring(buf, buf.length);
};


// Convert binary string (typed, when possible)
exports.binstring2buf = function (str) {
  var buf = new utils.Buf8(str.length);
  for (var i = 0, len = buf.length; i < len; i++) {
    buf[i] = str.charCodeAt(i);
  }
  return buf;
};


// convert array to string
exports.buf2string = function (buf, max) {
  var i, out, c, c_len;
  var len = max || buf.length;

  // Reserve max possible length (2 words per char)
  // NB: by unknown reasons, Array is significantly faster for
  //     String.fromCharCode.apply than Uint16Array.
  var utf16buf = new Array(len * 2);

  for (out = 0, i = 0; i < len;) {
    c = buf[i++];
    // quick process ascii
    if (c < 0x80) { utf16buf[out++] = c; continue; }

    c_len = _utf8len[c];
    // skip 5 & 6 byte codes
    if (c_len > 4) { utf16buf[out++] = 0xfffd; i += c_len - 1; continue; }

    // apply mask on first byte
    c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;
    // join the rest
    while (c_len > 1 && i < len) {
      c = (c << 6) | (buf[i++] & 0x3f);
      c_len--;
    }

    // terminated by end of string?
    if (c_len > 1) { utf16buf[out++] = 0xfffd; continue; }

    if (c < 0x10000) {
      utf16buf[out++] = c;
    } else {
      c -= 0x10000;
      utf16buf[out++] = 0xd800 | ((c >> 10) & 0x3ff);
      utf16buf[out++] = 0xdc00 | (c & 0x3ff);
    }
  }

  return buf2binstring(utf16buf, out);
};


// Calculate max possible position in utf8 buffer,
// that will not break sequence. If that's not possible
// - (very small limits) return max size as is.
//
// buf[] - utf8 bytes array
// max   - length limit (mandatory);
exports.utf8border = function (buf, max) {
  var pos;

  max = max || buf.length;
  if (max > buf.length) { max = buf.length; }

  // go back from last position, until start of sequence found
  pos = max - 1;
  while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) { pos--; }

  // Fuckup - very small and broken sequence,
  // return max, because we should return something anyway.
  if (pos < 0) { return max; }

  // If we came to start of buffer - that means vuffer is too small,
  // return max too.
  if (pos === 0) { return max; }

  return (pos + _utf8len[buf[pos]] > max) ? pos : max;
};


/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

module.exports = {

  /* Allowed flush values; see deflate() and inflate() below for details */
  Z_NO_FLUSH:         0,
  Z_PARTIAL_FLUSH:    1,
  Z_SYNC_FLUSH:       2,
  Z_FULL_FLUSH:       3,
  Z_FINISH:           4,
  Z_BLOCK:            5,
  Z_TREES:            6,

  /* Return codes for the compression/decompression functions. Negative values
  * are errors, positive values are used for special but normal events.
  */
  Z_OK:               0,
  Z_STREAM_END:       1,
  Z_NEED_DICT:        2,
  Z_ERRNO:           -1,
  Z_STREAM_ERROR:    -2,
  Z_DATA_ERROR:      -3,
  //Z_MEM_ERROR:     -4,
  Z_BUF_ERROR:       -5,
  //Z_VERSION_ERROR: -6,

  /* compression levels */
  Z_NO_COMPRESSION:         0,
  Z_BEST_SPEED:             1,
  Z_BEST_COMPRESSION:       9,
  Z_DEFAULT_COMPRESSION:   -1,


  Z_FILTERED:               1,
  Z_HUFFMAN_ONLY:           2,
  Z_RLE:                    3,
  Z_FIXED:                  4,
  Z_DEFAULT_STRATEGY:       0,

  /* Possible values of the data_type field (though see inflate()) */
  Z_BINARY:                 0,
  Z_TEXT:                   1,
  //Z_ASCII:                1, // = Z_TEXT (deprecated)
  Z_UNKNOWN:                2,

  /* The deflate compression method */
  Z_DEFLATED:               8
  //Z_NULL:                 null // Use -1 or null inline, depending on var type
};


/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

module.exports = {
  2:      'need dictionary',     /* Z_NEED_DICT       2  */
  1:      'stream end',          /* Z_STREAM_END      1  */
  0:      '',                    /* Z_OK              0  */
  '-1':   'file error',          /* Z_ERRNO         (-1) */
  '-2':   'stream error',        /* Z_STREAM_ERROR  (-2) */
  '-3':   'data error',          /* Z_DATA_ERROR    (-3) */
  '-4':   'insufficient memory', /* Z_MEM_ERROR     (-4) */
  '-5':   'buffer error',        /* Z_BUF_ERROR     (-5) */
  '-6':   'incompatible version' /* Z_VERSION_ERROR (-6) */
};


/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

function ZStream() {
  /* next input byte */
  this.input = null; // JS specific, because we have no pointers
  this.next_in = 0;
  /* number of bytes available at input */
  this.avail_in = 0;
  /* total number of input bytes read so far */
  this.total_in = 0;
  /* next output byte should be put there */
  this.output = null; // JS specific, because we have no pointers
  this.next_out = 0;
  /* remaining free space at output */
  this.avail_out = 0;
  /* total number of bytes output so far */
  this.total_out = 0;
  /* last error message, NULL if no error */
  this.msg = ''/*Z_NULL*/;
  /* not visible by applications */
  this.state = null;
  /* best guess about the data type: binary or text */
  this.data_type = 2/*Z_UNKNOWN*/;
  /* adler32 value of the uncompressed data */
  this.adler = 0;
}

module.exports = ZStream;


/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

function GZheader() {
  /* true if compressed data believed to be text */
  this.text       = 0;
  /* modification time */
  this.time       = 0;
  /* extra flags (not used when writing a gzip file) */
  this.xflags     = 0;
  /* operating system */
  this.os         = 0;
  /* pointer to extra field or Z_NULL if none */
  this.extra      = null;
  /* extra field length (valid if extra != Z_NULL) */
  this.extra_len  = 0; // Actually, we don't need it in JS,
                       // but leave for few code modifications

  //
  // Setup limits is not necessary because in js we should not preallocate memory
  // for inflate use constant limit in 65536 bytes
  //

  /* space at extra (only when reading header) */
  // this.extra_max  = 0;
  /* pointer to zero-terminated file name or Z_NULL */
  this.name       = '';
  /* space at name (only when reading header) */
  // this.name_max   = 0;
  /* pointer to zero-terminated comment or Z_NULL */
  this.comment    = '';
  /* space at comment (only when reading header) */
  // this.comm_max   = 0;
  /* true if there was or will be a header crc */
  this.hcrc       = 0;
  /* true when done reading gzip header (not used when writing a gzip file) */
  this.done       = false;
}

module.exports = GZheader;


/***/ })
/******/ ]);
});
//# sourceMappingURL=browserfs.js.map //*/
})
//# sourceURL=file:///home/xyz/Development/endo/node_modules/browserfs/dist/browserfs.js
,
// === functors[94] ===
(function (require, exports, module, __filename, __dirname) { // 'path' module extracted from Node.js v8.11.1 (only the posix part)
// transplited with Babel

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

function assertPath(path) {
  if (typeof path !== 'string') {
    throw new TypeError('Path must be a string. Received ' + JSON.stringify(path));
  }
}

// Resolves . and .. elements in a path with directory names
function normalizeStringPosix(path, allowAboveRoot) {
  var res = '';
  var lastSegmentLength = 0;
  var lastSlash = -1;
  var dots = 0;
  var code;
  for (var i = 0; i <= path.length; ++i) {
    if (i < path.length)
      code = path.charCodeAt(i);
    else if (code === 47 /*/*/)
      break;
    else
      code = 47 /*/*/;
    if (code === 47 /*/*/) {
      if (lastSlash === i - 1 || dots === 1) {
        // NOOP
      } else if (lastSlash !== i - 1 && dots === 2) {
        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 /*.*/ || res.charCodeAt(res.length - 2) !== 46 /*.*/) {
          if (res.length > 2) {
            var lastSlashIndex = res.lastIndexOf('/');
            if (lastSlashIndex !== res.length - 1) {
              if (lastSlashIndex === -1) {
                res = '';
                lastSegmentLength = 0;
              } else {
                res = res.slice(0, lastSlashIndex);
                lastSegmentLength = res.length - 1 - res.lastIndexOf('/');
              }
              lastSlash = i;
              dots = 0;
              continue;
            }
          } else if (res.length === 2 || res.length === 1) {
            res = '';
            lastSegmentLength = 0;
            lastSlash = i;
            dots = 0;
            continue;
          }
        }
        if (allowAboveRoot) {
          if (res.length > 0)
            res += '/..';
          else
            res = '..';
          lastSegmentLength = 2;
        }
      } else {
        if (res.length > 0)
          res += '/' + path.slice(lastSlash + 1, i);
        else
          res = path.slice(lastSlash + 1, i);
        lastSegmentLength = i - lastSlash - 1;
      }
      lastSlash = i;
      dots = 0;
    } else if (code === 46 /*.*/ && dots !== -1) {
      ++dots;
    } else {
      dots = -1;
    }
  }
  return res;
}

function _format(sep, pathObject) {
  var dir = pathObject.dir || pathObject.root;
  var base = pathObject.base || (pathObject.name || '') + (pathObject.ext || '');
  if (!dir) {
    return base;
  }
  if (dir === pathObject.root) {
    return dir + base;
  }
  return dir + sep + base;
}

var posix = {
  // path.resolve([from ...], to)
  resolve: function resolve() {
    var resolvedPath = '';
    var resolvedAbsolute = false;
    var cwd;

    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
      var path;
      if (i >= 0)
        path = arguments[i];
      else {
        if (cwd === undefined)
          cwd = process.cwd();
        path = cwd;
      }

      assertPath(path);

      // Skip empty entries
      if (path.length === 0) {
        continue;
      }

      resolvedPath = path + '/' + resolvedPath;
      resolvedAbsolute = path.charCodeAt(0) === 47 /*/*/;
    }

    // At this point the path should be resolved to a full absolute path, but
    // handle relative paths to be safe (might happen when process.cwd() fails)

    // Normalize the path
    resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);

    if (resolvedAbsolute) {
      if (resolvedPath.length > 0)
        return '/' + resolvedPath;
      else
        return '/';
    } else if (resolvedPath.length > 0) {
      return resolvedPath;
    } else {
      return '.';
    }
  },

  normalize: function normalize(path) {
    assertPath(path);

    if (path.length === 0) return '.';

    var isAbsolute = path.charCodeAt(0) === 47 /*/*/;
    var trailingSeparator = path.charCodeAt(path.length - 1) === 47 /*/*/;

    // Normalize the path
    path = normalizeStringPosix(path, !isAbsolute);

    if (path.length === 0 && !isAbsolute) path = '.';
    if (path.length > 0 && trailingSeparator) path += '/';

    if (isAbsolute) return '/' + path;
    return path;
  },

  isAbsolute: function isAbsolute(path) {
    assertPath(path);
    return path.length > 0 && path.charCodeAt(0) === 47 /*/*/;
  },

  join: function join() {
    if (arguments.length === 0)
      return '.';
    var joined;
    for (var i = 0; i < arguments.length; ++i) {
      var arg = arguments[i];
      assertPath(arg);
      if (arg.length > 0) {
        if (joined === undefined)
          joined = arg;
        else
          joined += '/' + arg;
      }
    }
    if (joined === undefined)
      return '.';
    return posix.normalize(joined);
  },

  relative: function relative(from, to) {
    assertPath(from);
    assertPath(to);

    if (from === to) return '';

    from = posix.resolve(from);
    to = posix.resolve(to);

    if (from === to) return '';

    // Trim any leading backslashes
    var fromStart = 1;
    for (; fromStart < from.length; ++fromStart) {
      if (from.charCodeAt(fromStart) !== 47 /*/*/)
        break;
    }
    var fromEnd = from.length;
    var fromLen = fromEnd - fromStart;

    // Trim any leading backslashes
    var toStart = 1;
    for (; toStart < to.length; ++toStart) {
      if (to.charCodeAt(toStart) !== 47 /*/*/)
        break;
    }
    var toEnd = to.length;
    var toLen = toEnd - toStart;

    // Compare paths to find the longest common path from root
    var length = fromLen < toLen ? fromLen : toLen;
    var lastCommonSep = -1;
    var i = 0;
    for (; i <= length; ++i) {
      if (i === length) {
        if (toLen > length) {
          if (to.charCodeAt(toStart + i) === 47 /*/*/) {
            // We get here if `from` is the exact base path for `to`.
            // For example: from='/foo/bar'; to='/foo/bar/baz'
            return to.slice(toStart + i + 1);
          } else if (i === 0) {
            // We get here if `from` is the root
            // For example: from='/'; to='/foo'
            return to.slice(toStart + i);
          }
        } else if (fromLen > length) {
          if (from.charCodeAt(fromStart + i) === 47 /*/*/) {
            // We get here if `to` is the exact base path for `from`.
            // For example: from='/foo/bar/baz'; to='/foo/bar'
            lastCommonSep = i;
          } else if (i === 0) {
            // We get here if `to` is the root.
            // For example: from='/foo'; to='/'
            lastCommonSep = 0;
          }
        }
        break;
      }
      var fromCode = from.charCodeAt(fromStart + i);
      var toCode = to.charCodeAt(toStart + i);
      if (fromCode !== toCode)
        break;
      else if (fromCode === 47 /*/*/)
        lastCommonSep = i;
    }

    var out = '';
    // Generate the relative path based on the path difference between `to`
    // and `from`
    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
      if (i === fromEnd || from.charCodeAt(i) === 47 /*/*/) {
        if (out.length === 0)
          out += '..';
        else
          out += '/..';
      }
    }

    // Lastly, append the rest of the destination (`to`) path that comes after
    // the common path parts
    if (out.length > 0)
      return out + to.slice(toStart + lastCommonSep);
    else {
      toStart += lastCommonSep;
      if (to.charCodeAt(toStart) === 47 /*/*/)
        ++toStart;
      return to.slice(toStart);
    }
  },

  _makeLong: function _makeLong(path) {
    return path;
  },

  dirname: function dirname(path) {
    assertPath(path);
    if (path.length === 0) return '.';
    var code = path.charCodeAt(0);
    var hasRoot = code === 47 /*/*/;
    var end = -1;
    var matchedSlash = true;
    for (var i = path.length - 1; i >= 1; --i) {
      code = path.charCodeAt(i);
      if (code === 47 /*/*/) {
          if (!matchedSlash) {
            end = i;
            break;
          }
        } else {
        // We saw the first non-path separator
        matchedSlash = false;
      }
    }

    if (end === -1) return hasRoot ? '/' : '.';
    if (hasRoot && end === 1) return '//';
    return path.slice(0, end);
  },

  basename: function basename(path, ext) {
    if (ext !== undefined && typeof ext !== 'string') throw new TypeError('"ext" argument must be a string');
    assertPath(path);

    var start = 0;
    var end = -1;
    var matchedSlash = true;
    var i;

    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {
      if (ext.length === path.length && ext === path) return '';
      var extIdx = ext.length - 1;
      var firstNonSlashEnd = -1;
      for (i = path.length - 1; i >= 0; --i) {
        var code = path.charCodeAt(i);
        if (code === 47 /*/*/) {
            // If we reached a path separator that was not part of a set of path
            // separators at the end of the string, stop now
            if (!matchedSlash) {
              start = i + 1;
              break;
            }
          } else {
          if (firstNonSlashEnd === -1) {
            // We saw the first non-path separator, remember this index in case
            // we need it if the extension ends up not matching
            matchedSlash = false;
            firstNonSlashEnd = i + 1;
          }
          if (extIdx >= 0) {
            // Try to match the explicit extension
            if (code === ext.charCodeAt(extIdx)) {
              if (--extIdx === -1) {
                // We matched the extension, so mark this as the end of our path
                // component
                end = i;
              }
            } else {
              // Extension does not match, so our result is the entire path
              // component
              extIdx = -1;
              end = firstNonSlashEnd;
            }
          }
        }
      }

      if (start === end) end = firstNonSlashEnd;else if (end === -1) end = path.length;
      return path.slice(start, end);
    } else {
      for (i = path.length - 1; i >= 0; --i) {
        if (path.charCodeAt(i) === 47 /*/*/) {
            // If we reached a path separator that was not part of a set of path
            // separators at the end of the string, stop now
            if (!matchedSlash) {
              start = i + 1;
              break;
            }
          } else if (end === -1) {
          // We saw the first non-path separator, mark this as the end of our
          // path component
          matchedSlash = false;
          end = i + 1;
        }
      }

      if (end === -1) return '';
      return path.slice(start, end);
    }
  },

  extname: function extname(path) {
    assertPath(path);
    var startDot = -1;
    var startPart = 0;
    var end = -1;
    var matchedSlash = true;
    // Track the state of characters (if any) we see before our first dot and
    // after any path separator we find
    var preDotState = 0;
    for (var i = path.length - 1; i >= 0; --i) {
      var code = path.charCodeAt(i);
      if (code === 47 /*/*/) {
          // If we reached a path separator that was not part of a set of path
          // separators at the end of the string, stop now
          if (!matchedSlash) {
            startPart = i + 1;
            break;
          }
          continue;
        }
      if (end === -1) {
        // We saw the first non-path separator, mark this as the end of our
        // extension
        matchedSlash = false;
        end = i + 1;
      }
      if (code === 46 /*.*/) {
          // If this is our first dot, mark it as the start of our extension
          if (startDot === -1)
            startDot = i;
          else if (preDotState !== 1)
            preDotState = 1;
      } else if (startDot !== -1) {
        // We saw a non-dot and non-path separator before our dot, so we should
        // have a good chance at having a non-empty extension
        preDotState = -1;
      }
    }

    if (startDot === -1 || end === -1 ||
        // We saw a non-dot character immediately before the dot
        preDotState === 0 ||
        // The (right-most) trimmed path component is exactly '..'
        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
      return '';
    }
    return path.slice(startDot, end);
  },

  format: function format(pathObject) {
    if (pathObject === null || typeof pathObject !== 'object') {
      throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof pathObject);
    }
    return _format('/', pathObject);
  },

  parse: function parse(path) {
    assertPath(path);

    var ret = { root: '', dir: '', base: '', ext: '', name: '' };
    if (path.length === 0) return ret;
    var code = path.charCodeAt(0);
    var isAbsolute = code === 47 /*/*/;
    var start;
    if (isAbsolute) {
      ret.root = '/';
      start = 1;
    } else {
      start = 0;
    }
    var startDot = -1;
    var startPart = 0;
    var end = -1;
    var matchedSlash = true;
    var i = path.length - 1;

    // Track the state of characters (if any) we see before our first dot and
    // after any path separator we find
    var preDotState = 0;

    // Get non-dir info
    for (; i >= start; --i) {
      code = path.charCodeAt(i);
      if (code === 47 /*/*/) {
          // If we reached a path separator that was not part of a set of path
          // separators at the end of the string, stop now
          if (!matchedSlash) {
            startPart = i + 1;
            break;
          }
          continue;
        }
      if (end === -1) {
        // We saw the first non-path separator, mark this as the end of our
        // extension
        matchedSlash = false;
        end = i + 1;
      }
      if (code === 46 /*.*/) {
          // If this is our first dot, mark it as the start of our extension
          if (startDot === -1) startDot = i;else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
        // We saw a non-dot and non-path separator before our dot, so we should
        // have a good chance at having a non-empty extension
        preDotState = -1;
      }
    }

    if (startDot === -1 || end === -1 ||
    // We saw a non-dot character immediately before the dot
    preDotState === 0 ||
    // The (right-most) trimmed path component is exactly '..'
    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
      if (end !== -1) {
        if (startPart === 0 && isAbsolute) ret.base = ret.name = path.slice(1, end);else ret.base = ret.name = path.slice(startPart, end);
      }
    } else {
      if (startPart === 0 && isAbsolute) {
        ret.name = path.slice(1, startDot);
        ret.base = path.slice(1, end);
      } else {
        ret.name = path.slice(startPart, startDot);
        ret.base = path.slice(startPart, end);
      }
      ret.ext = path.slice(startDot, end);
    }

    if (startPart > 0) ret.dir = path.slice(0, startPart - 1);else if (isAbsolute) ret.dir = '/';

    return ret;
  },

  sep: '/',
  delimiter: ':',
  win32: null,
  posix: null
};

posix.posix = posix;

module.exports = posix;
 //*/
})
//# sourceURL=file:///home/xyz/Development/endo/node_modules/path-browserify/index.js
,
// === functors[95] ===
(function (require, exports, module, __filename, __dirname) { const debug = (
  typeof process === 'object' &&
  process.env &&
  process.env.NODE_DEBUG &&
  /\bsemver\b/i.test(process.env.NODE_DEBUG)
) ? (...args) => console.error('SEMVER', ...args)
  : () => {}

module.exports = debug
 //*/
})
//# sourceURL=file:///home/xyz/Development/endo/node_modules/semver/internal/debug.js
,
// === functors[96] ===
(function (require, exports, module, __filename, __dirname) { // Note: this is the semver.org version of the spec that it implements
// Not necessarily the package version of this code.
const SEMVER_SPEC_VERSION = '2.0.0'

const MAX_LENGTH = 256
const MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER ||
/* istanbul ignore next */ 9007199254740991

// Max safe segment length for coercion.
const MAX_SAFE_COMPONENT_LENGTH = 16

// Max safe length for a build identifier. The max length minus 6 characters for
// the shortest version with a build 0.0.0+BUILD.
const MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6

const RELEASE_TYPES = [
  'major',
  'premajor',
  'minor',
  'preminor',
  'patch',
  'prepatch',
  'prerelease',
]

module.exports = {
  MAX_LENGTH,
  MAX_SAFE_COMPONENT_LENGTH,
  MAX_SAFE_BUILD_LENGTH,
  MAX_SAFE_INTEGER,
  RELEASE_TYPES,
  SEMVER_SPEC_VERSION,
  FLAG_INCLUDE_PRERELEASE: 0b001,
  FLAG_LOOSE: 0b010,
}
 //*/
})
//# sourceURL=file:///home/xyz/Development/endo/node_modules/semver/internal/constants.js
,
// === functors[97] ===
(function (require, exports, module, __filename, __dirname) { const {
  MAX_SAFE_COMPONENT_LENGTH,
  MAX_SAFE_BUILD_LENGTH,
  MAX_LENGTH,
} = require('./constants')
const debug = require('./debug')
exports = module.exports = {}

// The actual regexps go on exports.re
const re = exports.re = []
const safeRe = exports.safeRe = []
const src = exports.src = []
const t = exports.t = {}
let R = 0

const LETTERDASHNUMBER = '[a-zA-Z0-9-]'

// Replace some greedy regex tokens to prevent regex dos issues. These regex are
// used internally via the safeRe object since all inputs in this library get
// normalized first to trim and collapse all extra whitespace. The original
// regexes are exported for userland consumption and lower level usage. A
// future breaking change could export the safer regex only with a note that
// all input should have extra whitespace removed.
const safeRegexReplacements = [
  ['\\s', 1],
  ['\\d', MAX_LENGTH],
  [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH],
]

const makeSafeRegex = (value) => {
  for (const [token, max] of safeRegexReplacements) {
    value = value
      .split(`${token}*`).join(`${token}{0,${max}}`)
      .split(`${token}+`).join(`${token}{1,${max}}`)
  }
  return value
}

const createToken = (name, value, isGlobal) => {
  const safe = makeSafeRegex(value)
  const index = R++
  debug(name, index, value)
  t[name] = index
  src[index] = value
  re[index] = new RegExp(value, isGlobal ? 'g' : undefined)
  safeRe[index] = new RegExp(safe, isGlobal ? 'g' : undefined)
}

// The following Regular Expressions can be used for tokenizing,
// validating, and parsing SemVer version strings.

// ## Numeric Identifier
// A single `0`, or a non-zero digit followed by zero or more digits.

createToken('NUMERICIDENTIFIER', '0|[1-9]\\d*')
createToken('NUMERICIDENTIFIERLOOSE', '\\d+')

// ## Non-numeric Identifier
// Zero or more digits, followed by a letter or hyphen, and then zero or
// more letters, digits, or hyphens.

createToken('NONNUMERICIDENTIFIER', `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`)

// ## Main Version
// Three dot-separated numeric identifiers.

createToken('MAINVERSION', `(${src[t.NUMERICIDENTIFIER]})\\.` +
                   `(${src[t.NUMERICIDENTIFIER]})\\.` +
                   `(${src[t.NUMERICIDENTIFIER]})`)

createToken('MAINVERSIONLOOSE', `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` +
                        `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` +
                        `(${src[t.NUMERICIDENTIFIERLOOSE]})`)

// ## Pre-release Version Identifier
// A numeric identifier, or a non-numeric identifier.

createToken('PRERELEASEIDENTIFIER', `(?:${src[t.NUMERICIDENTIFIER]
}|${src[t.NONNUMERICIDENTIFIER]})`)

createToken('PRERELEASEIDENTIFIERLOOSE', `(?:${src[t.NUMERICIDENTIFIERLOOSE]
}|${src[t.NONNUMERICIDENTIFIER]})`)

// ## Pre-release Version
// Hyphen, followed by one or more dot-separated pre-release version
// identifiers.

createToken('PRERELEASE', `(?:-(${src[t.PRERELEASEIDENTIFIER]
}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`)

createToken('PRERELEASELOOSE', `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]
}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`)

// ## Build Metadata Identifier
// Any combination of digits, letters, or hyphens.

createToken('BUILDIDENTIFIER', `${LETTERDASHNUMBER}+`)

// ## Build Metadata
// Plus sign, followed by one or more period-separated build metadata
// identifiers.

createToken('BUILD', `(?:\\+(${src[t.BUILDIDENTIFIER]
}(?:\\.${src[t.BUILDIDENTIFIER]})*))`)

// ## Full Version String
// A main version, followed optionally by a pre-release version and
// build metadata.

// Note that the only major, minor, patch, and pre-release sections of
// the version string are capturing groups.  The build metadata is not a
// capturing group, because it should not ever be used in version
// comparison.

createToken('FULLPLAIN', `v?${src[t.MAINVERSION]
}${src[t.PRERELEASE]}?${
  src[t.BUILD]}?`)

createToken('FULL', `^${src[t.FULLPLAIN]}$`)

// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.
// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty
// common in the npm registry.
createToken('LOOSEPLAIN', `[v=\\s]*${src[t.MAINVERSIONLOOSE]
}${src[t.PRERELEASELOOSE]}?${
  src[t.BUILD]}?`)

createToken('LOOSE', `^${src[t.LOOSEPLAIN]}$`)

createToken('GTLT', '((?:<|>)?=?)')

// Something like "2.*" or "1.2.x".
// Note that "x.x" is a valid xRange identifer, meaning "any version"
// Only the first item is strictly required.
createToken('XRANGEIDENTIFIERLOOSE', `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`)
createToken('XRANGEIDENTIFIER', `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`)

createToken('XRANGEPLAIN', `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})` +
                   `(?:\\.(${src[t.XRANGEIDENTIFIER]})` +
                   `(?:\\.(${src[t.XRANGEIDENTIFIER]})` +
                   `(?:${src[t.PRERELEASE]})?${
                     src[t.BUILD]}?` +
                   `)?)?`)

createToken('XRANGEPLAINLOOSE', `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})` +
                        `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` +
                        `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` +
                        `(?:${src[t.PRERELEASELOOSE]})?${
                          src[t.BUILD]}?` +
                        `)?)?`)

createToken('XRANGE', `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`)
createToken('XRANGELOOSE', `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`)

// Coercion.
// Extract anything that could conceivably be a part of a valid semver
createToken('COERCE', `${'(^|[^\\d])' +
              '(\\d{1,'}${MAX_SAFE_COMPONENT_LENGTH}})` +
              `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` +
              `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` +
              `(?:$|[^\\d])`)
createToken('COERCERTL', src[t.COERCE], true)

// Tilde ranges.
// Meaning is "reasonably at or greater than"
createToken('LONETILDE', '(?:~>?)')

createToken('TILDETRIM', `(\\s*)${src[t.LONETILDE]}\\s+`, true)
exports.tildeTrimReplace = '$1~'

createToken('TILDE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`)
createToken('TILDELOOSE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`)

// Caret ranges.
// Meaning is "at least and backwards compatible with"
createToken('LONECARET', '(?:\\^)')

createToken('CARETTRIM', `(\\s*)${src[t.LONECARET]}\\s+`, true)
exports.caretTrimReplace = '$1^'

createToken('CARET', `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`)
createToken('CARETLOOSE', `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`)

// A simple gt/lt/eq thing, or just "" to indicate "any version"
createToken('COMPARATORLOOSE', `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`)
createToken('COMPARATOR', `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`)

// An expression to strip any whitespace between the gtlt and the thing
// it modifies, so that `> 1.2.3` ==> `>1.2.3`
createToken('COMPARATORTRIM', `(\\s*)${src[t.GTLT]
}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true)
exports.comparatorTrimReplace = '$1$2$3'

// Something like `1.2.3 - 1.2.4`
// Note that these all use the loose form, because they'll be
// checked against either the strict or loose comparator form
// later.
createToken('HYPHENRANGE', `^\\s*(${src[t.XRANGEPLAIN]})` +
                   `\\s+-\\s+` +
                   `(${src[t.XRANGEPLAIN]})` +
                   `\\s*$`)

createToken('HYPHENRANGELOOSE', `^\\s*(${src[t.XRANGEPLAINLOOSE]})` +
                        `\\s+-\\s+` +
                        `(${src[t.XRANGEPLAINLOOSE]})` +
                        `\\s*$`)

// Star ranges basically just allow anything at all.
createToken('STAR', '(<|>)?=?\\s*\\*')
// >=0.0.0 is like a star
createToken('GTE0', '^\\s*>=\\s*0\\.0\\.0\\s*$')
createToken('GTE0PRE', '^\\s*>=\\s*0\\.0\\.0-0\\s*$')
 //*/
})
//# sourceURL=file:///home/xyz/Development/endo/node_modules/semver/internal/re.js
,
// === functors[98] ===
(function (require, exports, module, __filename, __dirname) { // parse out just the options we care about
const looseOption = Object.freeze({ loose: true })
const emptyOpts = Object.freeze({ })
const parseOptions = options => {
  if (!options) {
    return emptyOpts
  }

  if (typeof options !== 'object') {
    return looseOption
  }

  return options
}
module.exports = parseOptions
 //*/
})
//# sourceURL=file:///home/xyz/Development/endo/node_modules/semver/internal/parse-options.js
,
// === functors[99] ===
(function (require, exports, module, __filename, __dirname) { const numeric = /^[0-9]+$/
const compareIdentifiers = (a, b) => {
  const anum = numeric.test(a)
  const bnum = numeric.test(b)

  if (anum && bnum) {
    a = +a
    b = +b
  }

  return a === b ? 0
    : (anum && !bnum) ? -1
    : (bnum && !anum) ? 1
    : a < b ? -1
    : 1
}

const rcompareIdentifiers = (a, b) => compareIdentifiers(b, a)

module.exports = {
  compareIdentifiers,
  rcompareIdentifiers,
}
 //*/
})
//# sourceURL=file:///home/xyz/Development/endo/node_modules/semver/internal/identifiers.js
,
// === functors[100] ===
(function (require, exports, module, __filename, __dirname) { const debug = require('../internal/debug')
const { MAX_LENGTH, MAX_SAFE_INTEGER } = require('../internal/constants')
const { safeRe: re, t } = require('../internal/re')

const parseOptions = require('../internal/parse-options')
const { compareIdentifiers } = require('../internal/identifiers')
class SemVer {
  constructor (version, options) {
    options = parseOptions(options)

    if (version instanceof SemVer) {
      if (version.loose === !!options.loose &&
          version.includePrerelease === !!options.includePrerelease) {
        return version
      } else {
        version = version.version
      }
    } else if (typeof version !== 'string') {
      throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version}".`)
    }

    if (version.length > MAX_LENGTH) {
      throw new TypeError(
        `version is longer than ${MAX_LENGTH} characters`
      )
    }

    debug('SemVer', version, options)
    this.options = options
    this.loose = !!options.loose
    // this isn't actually relevant for versions, but keep it so that we
    // don't run into trouble passing this.options around.
    this.includePrerelease = !!options.includePrerelease

    const m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL])

    if (!m) {
      throw new TypeError(`Invalid Version: ${version}`)
    }

    this.raw = version

    // these are actually numbers
    this.major = +m[1]
    this.minor = +m[2]
    this.patch = +m[3]

    if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
      throw new TypeError('Invalid major version')
    }

    if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
      throw new TypeError('Invalid minor version')
    }

    if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
      throw new TypeError('Invalid patch version')
    }

    // numberify any prerelease numeric ids
    if (!m[4]) {
      this.prerelease = []
    } else {
      this.prerelease = m[4].split('.').map((id) => {
        if (/^[0-9]+$/.test(id)) {
          const num = +id
          if (num >= 0 && num < MAX_SAFE_INTEGER) {
            return num
          }
        }
        return id
      })
    }

    this.build = m[5] ? m[5].split('.') : []
    this.format()
  }

  format () {
    this.version = `${this.major}.${this.minor}.${this.patch}`
    if (this.prerelease.length) {
      this.version += `-${this.prerelease.join('.')}`
    }
    return this.version
  }

  toString () {
    return this.version
  }

  compare (other) {
    debug('SemVer.compare', this.version, this.options, other)
    if (!(other instanceof SemVer)) {
      if (typeof other === 'string' && other === this.version) {
        return 0
      }
      other = new SemVer(other, this.options)
    }

    if (other.version === this.version) {
      return 0
    }

    return this.compareMain(other) || this.comparePre(other)
  }

  compareMain (other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options)
    }

    return (
      compareIdentifiers(this.major, other.major) ||
      compareIdentifiers(this.minor, other.minor) ||
      compareIdentifiers(this.patch, other.patch)
    )
  }

  comparePre (other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options)
    }

    // NOT having a prerelease is > having one
    if (this.prerelease.length && !other.prerelease.length) {
      return -1
    } else if (!this.prerelease.length && other.prerelease.length) {
      return 1
    } else if (!this.prerelease.length && !other.prerelease.length) {
      return 0
    }

    let i = 0
    do {
      const a = this.prerelease[i]
      const b = other.prerelease[i]
      debug('prerelease compare', i, a, b)
      if (a === undefined && b === undefined) {
        return 0
      } else if (b === undefined) {
        return 1
      } else if (a === undefined) {
        return -1
      } else if (a === b) {
        continue
      } else {
        return compareIdentifiers(a, b)
      }
    } while (++i)
  }

  compareBuild (other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options)
    }

    let i = 0
    do {
      const a = this.build[i]
      const b = other.build[i]
      debug('prerelease compare', i, a, b)
      if (a === undefined && b === undefined) {
        return 0
      } else if (b === undefined) {
        return 1
      } else if (a === undefined) {
        return -1
      } else if (a === b) {
        continue
      } else {
        return compareIdentifiers(a, b)
      }
    } while (++i)
  }

  // preminor will bump the version up to the next minor release, and immediately
  // down to pre-release. premajor and prepatch work the same way.
  inc (release, identifier, identifierBase) {
    switch (release) {
      case 'premajor':
        this.prerelease.length = 0
        this.patch = 0
        this.minor = 0
        this.major++
        this.inc('pre', identifier, identifierBase)
        break
      case 'preminor':
        this.prerelease.length = 0
        this.patch = 0
        this.minor++
        this.inc('pre', identifier, identifierBase)
        break
      case 'prepatch':
        // If this is already a prerelease, it will bump to the next version
        // drop any prereleases that might already exist, since they are not
        // relevant at this point.
        this.prerelease.length = 0
        this.inc('patch', identifier, identifierBase)
        this.inc('pre', identifier, identifierBase)
        break
      // If the input is a non-prerelease version, this acts the same as
      // prepatch.
      case 'prerelease':
        if (this.prerelease.length === 0) {
          this.inc('patch', identifier, identifierBase)
        }
        this.inc('pre', identifier, identifierBase)
        break

      case 'major':
        // If this is a pre-major version, bump up to the same major version.
        // Otherwise increment major.
        // 1.0.0-5 bumps to 1.0.0
        // 1.1.0 bumps to 2.0.0
        if (
          this.minor !== 0 ||
          this.patch !== 0 ||
          this.prerelease.length === 0
        ) {
          this.major++
        }
        this.minor = 0
        this.patch = 0
        this.prerelease = []
        break
      case 'minor':
        // If this is a pre-minor version, bump up to the same minor version.
        // Otherwise increment minor.
        // 1.2.0-5 bumps to 1.2.0
        // 1.2.1 bumps to 1.3.0
        if (this.patch !== 0 || this.prerelease.length === 0) {
          this.minor++
        }
        this.patch = 0
        this.prerelease = []
        break
      case 'patch':
        // If this is not a pre-release version, it will increment the patch.
        // If it is a pre-release it will bump up to the same patch version.
        // 1.2.0-5 patches to 1.2.0
        // 1.2.0 patches to 1.2.1
        if (this.prerelease.length === 0) {
          this.patch++
        }
        this.prerelease = []
        break
      // This probably shouldn't be used publicly.
      // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.
      case 'pre': {
        const base = Number(identifierBase) ? 1 : 0

        if (!identifier && identifierBase === false) {
          throw new Error('invalid increment argument: identifier is empty')
        }

        if (this.prerelease.length === 0) {
          this.prerelease = [base]
        } else {
          let i = this.prerelease.length
          while (--i >= 0) {
            if (typeof this.prerelease[i] === 'number') {
              this.prerelease[i]++
              i = -2
            }
          }
          if (i === -1) {
            // didn't increment anything
            if (identifier === this.prerelease.join('.') && identifierBase === false) {
              throw new Error('invalid increment argument: identifier already exists')
            }
            this.prerelease.push(base)
          }
        }
        if (identifier) {
          // 1.2.0-beta.1 bumps to 1.2.0-beta.2,
          // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0
          let prerelease = [identifier, base]
          if (identifierBase === false) {
            prerelease = [identifier]
          }
          if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
            if (isNaN(this.prerelease[1])) {
              this.prerelease = prerelease
            }
          } else {
            this.prerelease = prerelease
          }
        }
        break
      }
      default:
        throw new Error(`invalid increment argument: ${release}`)
    }
    this.raw = this.format()
    if (this.build.length) {
      this.raw += `+${this.build.join('.')}`
    }
    return this
  }
}

module.exports = SemVer
 //*/
})
//# sourceURL=file:///home/xyz/Development/endo/node_modules/semver/classes/semver.js
,
// === functors[101] ===
(function (require, exports, module, __filename, __dirname) { const SemVer = require('../classes/semver')
const compare = (a, b, loose) =>
  new SemVer(a, loose).compare(new SemVer(b, loose))

module.exports = compare
 //*/
})
//# sourceURL=file:///home/xyz/Development/endo/node_modules/semver/functions/compare.js
,
// === functors[102] ===
(function (require, exports, module, __filename, __dirname) { const compare = require('./compare')
const gte = (a, b, loose) => compare(a, b, loose) >= 0
module.exports = gte
 //*/
})
//# sourceURL=file:///home/xyz/Development/endo/node_modules/semver/functions/gte.js
,
// === functors[103] ===
(function (require, exports, module, __filename, __dirname) { 'use strict';
const fs = require('fs');
const path = require('path');
const {promisify} = require('util');
const semverGte = require('semver/functions/gte');

const useNativeRecursiveOption = semverGte(process.version, '10.12.0');

// https://github.com/nodejs/node/issues/8987
// https://github.com/libuv/libuv/pull/1088
const checkPath = pth => {
	if (process.platform === 'win32') {
		const pathHasInvalidWinCharacters = /[<>:"|?*]/.test(pth.replace(path.parse(pth).root, ''));

		if (pathHasInvalidWinCharacters) {
			const error = new Error(`Path contains invalid characters: ${pth}`);
			error.code = 'EINVAL';
			throw error;
		}
	}
};

const processOptions = options => {
	const defaults = {
		mode: 0o777,
		fs
	};

	return {
		...defaults,
		...options
	};
};

const permissionError = pth => {
	// This replicates the exception of `fs.mkdir` with native the
	// `recusive` option when run on an invalid drive under Windows.
	const error = new Error(`operation not permitted, mkdir '${pth}'`);
	error.code = 'EPERM';
	error.errno = -4048;
	error.path = pth;
	error.syscall = 'mkdir';
	return error;
};

const makeDir = async (input, options) => {
	checkPath(input);
	options = processOptions(options);

	const mkdir = promisify(options.fs.mkdir);
	const stat = promisify(options.fs.stat);

	if (useNativeRecursiveOption && options.fs.mkdir === fs.mkdir) {
		const pth = path.resolve(input);

		await mkdir(pth, {
			mode: options.mode,
			recursive: true
		});

		return pth;
	}

	const make = async pth => {
		try {
			await mkdir(pth, options.mode);

			return pth;
		} catch (error) {
			if (error.code === 'EPERM') {
				throw error;
			}

			if (error.code === 'ENOENT') {
				if (path.dirname(pth) === pth) {
					throw permissionError(pth);
				}

				if (error.message.includes('null bytes')) {
					throw error;
				}

				await make(path.dirname(pth));

				return make(pth);
			}

			try {
				const stats = await stat(pth);
				if (!stats.isDirectory()) {
					throw new Error('The path is not a directory');
				}
			} catch {
				throw error;
			}

			return pth;
		}
	};

	return make(path.resolve(input));
};

module.exports = makeDir;

module.exports.sync = (input, options) => {
	checkPath(input);
	options = processOptions(options);

	if (useNativeRecursiveOption && options.fs.mkdirSync === fs.mkdirSync) {
		const pth = path.resolve(input);

		fs.mkdirSync(pth, {
			mode: options.mode,
			recursive: true
		});

		return pth;
	}

	const make = pth => {
		try {
			options.fs.mkdirSync(pth, options.mode);
		} catch (error) {
			if (error.code === 'EPERM') {
				throw error;
			}

			if (error.code === 'ENOENT') {
				if (path.dirname(pth) === pth) {
					throw permissionError(pth);
				}

				if (error.message.includes('null bytes')) {
					throw error;
				}

				make(path.dirname(pth));
				return make(pth);
			}

			try {
				if (!options.fs.statSync(pth).isDirectory()) {
					throw new Error('The path is not a directory');
				}
			} catch {
				throw error;
			}
		}

		return pth;
	};

	return make(path.resolve(input));
};
 //*/
})
//# sourceURL=file:///home/xyz/Development/endo/packages/daemon/node_modules/make-dir/index.js
,
// === functors[104] ===
({   imports: $h‍_imports,   liveVar: $h‍_live,   onceVar: $h‍_once,   importMeta: $h‍____meta, }) => (function () {   $h‍_imports([]);   /// <reference types="ses"/>

/**
 * @template T
 * @callback PromiseExecutor The promise executor
 * @param {(value: import('./types.js').ERef<T>) => void} resolve
 * @param {(reason: any) => void} reject
 */

/**
 * makeReleasingExecutorKit() builds resolve/reject functions which drop references
 * to the resolve/reject functions gathered from an executor to be used with a
 * promise constructor.
 *
 * @template T
 * @returns {Pick<import('./types.js').PromiseKit<T>, 'resolve' | 'reject'> & { executor: PromiseExecutor<T>}}
 */
const        makeReleasingExecutorKit=  ()=>  {
  /** @type {null | undefined | ((value: import('./types.js').ERef<T>) => void)} */
  let internalResolve;
  /** @type {null | undefined | ((reason: unknown) => void)} */
  let internalReject;

  /** @param {import('./types.js').ERef<T>} value */
  const resolve=  (value)=>{
    if( internalResolve) {
      internalResolve(value);
      internalResolve=  null;
      internalReject=  null;
     }else {
      assert(internalResolve===  null);
     }
   };

  /** @param {unknown} reason */
  const reject=  (reason)=>{
    if( internalReject) {
      internalReject(reason);
      internalResolve=  null;
      internalReject=  null;
     }else {
      assert(internalReject===  null);
     }
   };

  const executor=  (res, rej)=>  {
    assert(internalResolve===  undefined&&  internalReject===  undefined);
    internalResolve=  res;
    internalReject=  rej;
   };

  return harden({ resolve, reject, executor});
 };$h‍_once.makeReleasingExecutorKit(makeReleasingExecutorKit);
harden(makeReleasingExecutorKit);
})()
,
// === functors[105] ===
({   imports: $h‍_imports,   liveVar: $h‍_live,   onceVar: $h‍_once,   importMeta: $h‍____meta, }) => (function () {   $h‍_imports([]);Object.defineProperty(isPromise, 'name', {value: "isPromise"});$h‍_once.isPromise(isPromise);   /**
 * Determine if the argument is a Promise.
 *
 * @param {unknown} maybePromise The value to examine
 * @returns {maybePromise is Promise} Whether it is a promise
 */
function        isPromise(maybePromise) {
  return Promise.resolve(maybePromise)===  maybePromise;
 }
harden(isPromise);
})()
,
// === functors[106] ===
({   imports: $h‍_imports,   liveVar: $h‍_live,   onceVar: $h‍_once,   importMeta: $h‍____meta, }) => (function () {   $h‍_imports([]);   
})()
,
// === functors[107] ===
({   imports: $h‍_imports,   liveVar: $h‍_live,   onceVar: $h‍_once,   importMeta: $h‍____meta, }) => (function () {   let makeReleasingExecutorKit,memoRace;$h‍_imports([["./src/promise-executor-kit.js", [["makeReleasingExecutorKit", [$h‍_a => (makeReleasingExecutorKit = $h‍_a)]]]],["./src/memo-race.js", [["memoRace", [$h‍_a => (memoRace = $h‍_a)]]]],["./src/is-promise.js", []],["./src/types.js", []]]);Object.defineProperty(makePromiseKit, 'name', {value: "makePromiseKit"});$h‍_once.makePromiseKit(makePromiseKit);Object.defineProperty(racePromises, 'name', {value: "racePromises"});$h‍_once.racePromises(racePromises);   










/** @type {PromiseConstructor} */
const BestPipelinablePromise=  globalThis.HandledPromise||  Promise;

/**
 * makePromiseKit() builds a Promise object, and returns a record
 * containing the promise itself, as well as separate facets for resolving
 * and rejecting it.
 *
 * @template T
 * @returns {import('./src/types.js').PromiseKit<T>}
 */
function        makePromiseKit() {
  const { resolve, reject, executor}=   makeReleasingExecutorKit();

  const promise=  new BestPipelinablePromise(executor);

  return harden({ promise, resolve, reject});
 }
harden(makePromiseKit);

// NB: Another implementation for Promise.race would be to use the releasing executor,
// However while it would no longer leak the raced promise objects themselves, it would
// still leak reactions on the non-resolved promises contending for the race.

/**
 * Creates a Promise that is resolved or rejected when any of the provided Promises are resolved
 * or rejected.
 *
 * Unlike `Promise.race` it cleans up after itself so a non-resolved value doesn't hold onto
 * the result promise.
 *
 * @template T
 * @param {Iterable<T>} values An iterable of Promises.
 * @returns {Promise<Awaited<T>>} A new Promise.
 */
function        racePromises(values) {
  return harden(memoRace.call(BestPipelinablePromise, values));
 }
harden(racePromises);
})()
,
// === functors[108] ===
({   imports: $h‍_imports,   liveVar: $h‍_live,   onceVar: $h‍_once,   importMeta: $h‍____meta, }) => (function () {   let makeEnvironmentCaptor;$h‍_imports([["@endo/env-options", [["makeEnvironmentCaptor", [$h‍_a => (makeEnvironmentCaptor = $h‍_a)]]]]]);   


const { getEnvironmentOption}=   makeEnvironmentCaptor(globalThis);

// NOTE: We can't import these because they're not in scope before lockdown.
// import { assert, details as X, Fail } from '@agoric/assert';

// WARNING: Global Mutable State!
// This state is communicated to `assert` that makes it available to the
// causal console, which affects the console log output. Normally we
// regard the ability to see console log output as a meta-level privilege
// analogous to the ability to debug. Aside from that, this module should
// not have any observably mutable state.

let hiddenPriorError;
let hiddenCurrentTurn=  0;
let hiddenCurrentEvent=  0;

const DEBUG=  getEnvironmentOption('DEBUG', '');

// Turn on if you seem to be losing error logging at the top of the event loop
const VERBOSE=  DEBUG.split(':').includes('track-turns');

// Track-turns is disabled by default and can be enabled by an environment
// option.
const TRACK_TURNS=  getEnvironmentOption('TRACK_TURNS', 'disabled');
if( TRACK_TURNS!==  'enabled'&&  TRACK_TURNS!==  'disabled') {
  throw TypeError( `unrecognized TRACK_TURNS ${JSON.stringify(TRACK_TURNS)}`);
 }
const ENABLED=  (TRACK_TURNS||  'disabled')===  'enabled';

// We hoist the following functions out of trackTurns() to discourage the
// closures from holding onto 'args' or 'func' longer than necessary,
// which we've seen cause HandledPromise arguments to be retained for
// a surprisingly long time.

const addRejectionNote=  (detailsNote)=>(reason)=>{
  if( reason instanceof Error) {
    assert.note(reason, detailsNote);
   }
  if( VERBOSE) {
    console.log('REJECTED at top of event loop', reason);
   }
 };

const wrapFunction=
  (func, sendingError, X)=>
  (...args)=>  {
    hiddenPriorError=  sendingError;
    hiddenCurrentTurn+=  1;
    hiddenCurrentEvent=  0;
    try {
      let result;
      try {
        result=  func(...args);
       }catch( err) {
        if( err instanceof Error) {
          assert.note(
            err,
            X `Thrown from: ${hiddenPriorError}:${hiddenCurrentTurn}.${hiddenCurrentEvent}`);

         }
        if( VERBOSE) {
          console.log('THROWN to top of event loop', err);
         }
        throw err;
       }
      // Must capture this now, not when the catch triggers.
      const detailsNote=  X `Rejection from: ${hiddenPriorError}:${hiddenCurrentTurn}.${hiddenCurrentEvent}`;
      Promise.resolve(result).catch(addRejectionNote(detailsNote));
      return result;
     }finally {
      hiddenPriorError=  undefined;
     }
   };

/**
 * Given a list of `TurnStarterFn`s, returns a list of `TurnStarterFn`s whose
 * `this`-free call behaviors are not observably different to those that
 * cannot see console output. The only purpose is to cause additional
 * information to appear on the console.
 *
 * The call to `trackTurns` is itself a sending event, that occurs in some call
 * stack in some turn number at some event number within that turn. Each call
 * to any of the returned `TurnStartFn`s is a receiving event that begins a new
 * turn. This sending event caused each of those receiving events.
 *
 * @template {TurnStarterFn[]} T
 * @param {T} funcs
 * @returns {T}
 */
const        trackTurns=  (funcs)=>{
  if( !ENABLED||  typeof globalThis===  'undefined'||  !globalThis.assert) {
    return funcs;
   }
  const { details: X}=   assert;

  hiddenCurrentEvent+=  1;
  const sendingError=  Error(
     `Event: ${hiddenCurrentTurn}.${hiddenCurrentEvent}`);

  if( hiddenPriorError!==  undefined) {
    assert.note(sendingError, X `Caused by: ${hiddenPriorError}`);
   }

  return (/** @type {T} */
    funcs.map((func)=>func&&  wrapFunction(func, sendingError, X)));

 };

/**
 * An optional function that is not this-sensitive, expected to be called at
 * bottom of stack to start a new turn.
 *
 * @typedef {((...args: any[]) => any) | undefined} TurnStarterFn
 */$h‍_once.trackTurns(trackTurns);
})()
,
// === functors[109] ===
({   imports: $h‍_imports,   liveVar: $h‍_live,   onceVar: $h‍_once,   importMeta: $h‍____meta, }) => (function () {   $h‍_imports([]);   const { details: X, quote: q, Fail}=   assert;

const { getOwnPropertyDescriptors, getPrototypeOf, freeze}=   Object;
const { apply, ownKeys}=   Reflect;

const ntypeof=  (specimen)=> specimen===  null?  'null':  typeof specimen;

/**
 * TODO Consolidate with `isObject` that's currently in `@endo/marshal`
 *
 * @param {any} val
 * @returns {boolean}
 */
const isObject=  (val)=>Object(val)===  val;

/**
 * Prioritize symbols as earlier than strings.
 *
 * @param {string|symbol} a
 * @param {string|symbol} b
 * @returns {-1 | 0 | 1}
 */
const compareStringified=  (a, b)=>  {
  if( typeof a===  typeof b) {
    const left=  String(a);
    const right=  String(b);
    // eslint-disable-next-line no-nested-ternary
    return left<  right?  -1:  left>  right?  1:  0;
   }
  if( typeof a===  'symbol') {
    assert(typeof b===  'string');
    return -1;
   }
  assert(typeof a===  'string');
  assert(typeof b===  'symbol');
  return 1;
 };

/**
 * @param {any} val
 * @returns {(string|symbol)[]}
 */
const        getMethodNames=  (val)=>{
  let layer=  val;
  const names=  new Set(); // Set to deduplicate
  while( layer!==  null&&  layer!==  Object.prototype) {
    // be tolerant of non-objects
    const descs=  getOwnPropertyDescriptors(layer);
    for( const name of ownKeys(descs)) {
      // In case a method is overridden by a non-method,
      // test `val[name]` rather than `layer[name]`
      if( typeof val[name]===  'function') {
        names.add(name);
       }
     }
    if( !isObject(val)) {
      break;
     }
    layer=  getPrototypeOf(layer);
   }
  return harden([...names].sort(compareStringified));
 };
// The top level of the eventual send modules can be evaluated before
// ses creates `harden`, and so cannot rely on `harden` at top level.
$h‍_once.getMethodNames(getMethodNames);freeze(getMethodNames);

const        localApplyFunction=  (t, args)=>  {
  typeof t===  'function'||
    assert.fail(
      X `Cannot invoke target as a function; typeof target is ${q(ntypeof(t))}`,
      TypeError);

  return apply(t, undefined, args);
 };$h‍_once.localApplyFunction(localApplyFunction);

const        localApplyMethod=  (t, method, args)=>  {
  if( method===  undefined||  method===  null) {
    // Base case; bottom out to apply functions.
    return localApplyFunction(t, args);
   }
  if( t===  undefined||  t===  null) {
    assert.fail(
      X `Cannot deliver ${q(method)} to target; typeof target is ${q(
        ntypeof(t))
        }`,
      TypeError);

   }
  const fn=  t[method];
  if( fn===  undefined) {
    assert.fail(
      X `target has no method ${q(method)}, has ${q(getMethodNames(t))}`,
      TypeError);

   }
  const ftype=  ntypeof(fn);
  typeof fn===  'function'||
    Fail `invoked method ${q(method)} is not a function; it is a ${q(ftype)}`;
  return apply(fn, t, args);
 };$h‍_once.localApplyMethod(localApplyMethod);

const        localGet=  (t, key)=>  t[key];$h‍_once.localGet(localGet);
})()
,
// === functors[110] ===
({   imports: $h‍_imports,   liveVar: $h‍_live,   onceVar: $h‍_once,   importMeta: $h‍____meta, }) => (function () {   $h‍_imports([]);   /// <reference types="ses" />

/**
 * Create a simple postponedHandler that just postpones until donePostponing is
 * called.
 *
 * @param {import('./types').HandledPromiseConstructor} HandledPromise
 * @returns {[Required<import('./types').Handler<any>>, () => void]} postponedHandler and donePostponing callback.
 */
const        makePostponedHandler=  (HandledPromise)=>{
  /** @type {() => void} */
  let donePostponing;

  const interlockP=  new Promise((resolve)=>{
    donePostponing=  ()=>  resolve(undefined);
   });

  const makePostponedOperation=  (postponedOperation)=>{
    // Just wait until the handler is resolved/rejected.
    return function postpone(x, ...args) {
      // console.log(`forwarding ${postponedOperation} ${args[0]}`);
      return new HandledPromise((resolve, reject)=>  {
        interlockP.
           then((_)=>{
            resolve(HandledPromise[postponedOperation](x, ...args));
           }).
           catch(reject);
       });
     };
   };

  /** @type {Required<import('./types').Handler<any>>} */
  const postponedHandler=  {
    get: makePostponedOperation('get'),
    getSendOnly: makePostponedOperation('getSendOnly'),
    applyFunction: makePostponedOperation('applyFunction'),
    applyFunctionSendOnly: makePostponedOperation('applyFunctionSendOnly'),
    applyMethod: makePostponedOperation('applyMethod'),
    applyMethodSendOnly: makePostponedOperation('applyMethodSendOnly')};


  // @ts-expect-error 2454
  assert(donePostponing);

  return [postponedHandler, donePostponing];
 };$h‍_once.makePostponedHandler(makePostponedHandler);
})()
,
// === functors[111] ===
({   imports: $h‍_imports,   liveVar: $h‍_live,   onceVar: $h‍_once,   importMeta: $h‍____meta, }) => (function () {   let trackTurns,localApplyFunction,localApplyMethod,localGet,getMethodNames,makePostponedHandler;$h‍_imports([["./track-turns.js", [["trackTurns", [$h‍_a => (trackTurns = $h‍_a)]]]],["./local.js", [["localApplyFunction", [$h‍_a => (localApplyFunction = $h‍_a)]],["localApplyMethod", [$h‍_a => (localApplyMethod = $h‍_a)]],["localGet", [$h‍_a => (localGet = $h‍_a)]],["getMethodNames", [$h‍_a => (getMethodNames = $h‍_a)]]]],["./postponed.js", [["makePostponedHandler", [$h‍_a => (makePostponedHandler = $h‍_a)]]]]]);   










const { Fail, details: X, quote: q}=   assert;

const {
  create,
  freeze,
  getOwnPropertyDescriptor,
  getOwnPropertyDescriptors,
  defineProperties,
  getPrototypeOf,
  setPrototypeOf,
  isFrozen,
  is: objectIs}=
    Object;

const { apply, construct, ownKeys}=   Reflect;

const SEND_ONLY_RE=  /^(.*)SendOnly$/;

/**
 * Coerce to an object property (string or symbol).
 *
 * @param {any} specimen
 * @returns {string | symbol}
 */
const coerceToObjectProperty=  (specimen)=>{
  if( typeof specimen===  'symbol') {
    return specimen;
   }
  return String(specimen);
 };

// the following method (makeHandledPromise) is part
// of the shim, and will not be exported by the module once the feature
// becomes a part of standard javascript

/**
 * Create a HandledPromise class to have it support eventual send
 * (wavy-dot) operations.
 *
 * Based heavily on nanoq
 * https://github.com/drses/nanoq/blob/master/src/nanoq.js
 *
 * Original spec for the infix-bang (predecessor to wavy-dot) desugaring:
 * https://web.archive.org/web/20161026162206/http://wiki.ecmascript.org/doku.php?id=strawman:concurrency
 *
 */
const        makeHandledPromise=  ()=>  {
  const presenceToHandler=  new WeakMap();
  /** @type {WeakMap<any, any>} */
  const presenceToPromise=  new WeakMap();
  const promiseToPendingHandler=  new WeakMap();
  const promiseToPresence=  new WeakMap();
  const forwardedPromiseToPromise=  new WeakMap(); // forwarding, union-find-ish

  /**
   * You can imagine a forest of trees in which the roots of each tree is an
   * unresolved HandledPromise or a non-Promise, and each node's parent is the
   * HandledPromise to which it was forwarded.  We maintain that mapping of
   * forwarded HandledPromise to its resolution in forwardedPromiseToPromise.
   *
   * We use something like the description of "Find" with "Path splitting"
   * to propagate changes down to the children efficiently:
   * https://en.wikipedia.org/wiki/Disjoint-set_data_structure
   *
   * @param {*} target Any value.
   * @returns {*} If the target was a HandledPromise, the most-resolved parent
   * of it, otherwise the target.
   */
  const shorten=  (target)=>{
    let p=  target;
    // Find the most-resolved value for p.
    while( forwardedPromiseToPromise.has(p)) {
      p=  forwardedPromiseToPromise.get(p);
     }
    const presence=  promiseToPresence.get(p);
    if( presence) {
      // Presences are final, so it is ok to propagate
      // this upstream.
      while( !objectIs(target, p)) {
        const parent=  forwardedPromiseToPromise.get(target);
        forwardedPromiseToPromise.delete(target);
        promiseToPendingHandler.delete(target);
        promiseToPresence.set(target, presence);
        target=  parent;
       }
     }else {
      // We propagate p and remove all other pending handlers
      // upstream.
      // Note that everything except presences is covered here.
      while( !objectIs(target, p)) {
        const parent=  forwardedPromiseToPromise.get(target);
        forwardedPromiseToPromise.set(target, p);
        promiseToPendingHandler.delete(target);
        target=  parent;
       }
     }
    return target;
   };

  /**
   * This special handler accepts Promises, and forwards
   * handled Promises to their corresponding fulfilledHandler.
   *
   * @type {Required<Handler<any>>}
   */
  let forwardingHandler;
  let handle;

  /**
   * @param {string} handlerName
   * @param {Handler<any>} handler
   * @param {string} operation
   * @param {any} o
   * @param {any[]} opArgs
   * @param {Promise<unknown>} [returnedP]
   * @returns {any}
   */
  const dispatchToHandler=  (
    handlerName,
    handler,
    operation,
    o,
    opArgs,
    returnedP)=>
       {
    let actualOp=  operation;

    const matchSendOnly=  SEND_ONLY_RE.exec(actualOp);

    const makeResult=  (result)=> matchSendOnly?  undefined:  result;

    if( matchSendOnly) {
      // We don't specify the resulting promise if it is sendonly.
      returnedP=  undefined;
     }

    if( matchSendOnly&&  typeof handler[actualOp]!==  'function') {
      // Substitute for sendonly with the corresponding non-sendonly operation.
      actualOp=  matchSendOnly[1];
     }

    // Fast path: just call the actual operation.
    const hfn=  handler[actualOp];
    if( typeof hfn===  'function') {
      const result=  apply(hfn, handler, [o, ...opArgs, returnedP]);
      return makeResult(result);
     }

    if( actualOp===  'applyMethod') {
      // Compose a missing applyMethod by get followed by applyFunction.
      const [prop, args]=  opArgs;
      const getResultP=  handle(
        o,
        'get',
        // The argument to 'get' is a string or symbol.
        [coerceToObjectProperty(prop)],
        undefined);

      return makeResult(handle(getResultP, 'applyFunction', [args], returnedP));
     }

    // BASE CASE: applyFunction bottoms out into applyMethod, if it exists.
    if( actualOp===  'applyFunction') {
      const amfn=  handler.applyMethod;
      if( typeof amfn===  'function') {
        // Downlevel a missing applyFunction to applyMethod with undefined name.
        const [args]=  opArgs;
        const result=  apply(amfn, handler, [o, undefined, [args], returnedP]);
        return makeResult(result);
       }
     }

    throw assert.fail(
      X `${q(handlerName)} is defined but has no methods needed for ${q(
        operation)
        } (has ${q(getMethodNames(handler))})`,
      TypeError);

   };

  /** @typedef {{new <R>(executor: HandledExecutor<R>, unfulfilledHandler?: Handler<Promise<unknown>>): Promise<R>, prototype: Promise<unknown>} & PromiseConstructor & HandledPromiseStaticMethods} HandledPromiseConstructor */
  /** @type {HandledPromiseConstructor} */
  let HandledPromise;

  /**
   * This *needs* to be a `function X` so that we can use it as a constructor.
   *
   * @template R
   * @param {HandledExecutor<R>} executor
   * @param {Handler<Promise<R>>} [pendingHandler]
   * @returns {Promise<R>}
   */
  function baseHandledPromise(executor, pendingHandler=  undefined) {
    new.target||  Fail `must be invoked with "new"`;
    let handledResolve;
    let handledReject;
    let resolved=  false;
    let resolvedTarget=  null;
    let handledP;
    let continueForwarding=  ()=>  { };
    const assertNotYetForwarded=  ()=>  {
      !forwardedPromiseToPromise.has(handledP)||
        assert.fail(X `internal: already forwarded`,TypeError);
     };
    const superExecutor=  (superResolve, superReject)=>  {
      handledResolve=  (value)=>{
        if( resolved) {
          return;
         }
        assertNotYetForwarded();
        value=  shorten(value);
        let targetP;
        if(
          promiseToPendingHandler.has(value)||
          promiseToPresence.has(value))
          {
          targetP=  value;
         }else {
          // We're resolving to a non-promise, so remove our handler.
          promiseToPendingHandler.delete(handledP);
          targetP=  presenceToPromise.get(value);
         }
        // Ensure our data structure is a proper tree (avoid cycles).
        if( targetP&&  !objectIs(targetP, handledP)) {
          forwardedPromiseToPromise.set(handledP, targetP);
         }else {
          forwardedPromiseToPromise.delete(handledP);
         }

        // Remove stale pending handlers, set to canonical form.
        shorten(handledP);

        // Finish the resolution.
        superResolve(value);
        resolved=  true;
        resolvedTarget=  value;

        // We're resolved, so forward any postponed operations to us.
        continueForwarding();
       };
      handledReject=  (reason)=>{
        if( resolved) {
          return;
         }
        harden(reason);
        assertNotYetForwarded();
        promiseToPendingHandler.delete(handledP);
        resolved=  true;
        superReject(reason);
        continueForwarding();
       };
     };
    handledP=  harden(construct(Promise, [superExecutor], new.target));

    if( !pendingHandler) {
      // This is insufficient for actual remote handled Promises
      // (too many round-trips), but is an easy way to create a
      // local handled Promise.
      [pendingHandler, continueForwarding]=
        makePostponedHandler(HandledPromise);
     }

    const validateHandler=  (h)=>{
      Object(h)===  h||
        assert.fail(X `Handler ${h} cannot be a primitive`,TypeError);
     };
    validateHandler(pendingHandler);

    // Until the handled promise is resolved, we use the pendingHandler.
    promiseToPendingHandler.set(handledP, pendingHandler);

    const rejectHandled=  (reason)=>{
      if( resolved) {
        return;
       }
      assertNotYetForwarded();
      handledReject(reason);
     };

    const resolveWithPresence=  (
      presenceHandler=  pendingHandler,
      options=  {})=>
         {
      if( resolved) {
        return resolvedTarget;
       }
      assertNotYetForwarded();
      try {
        // Sanity checks.
        validateHandler(presenceHandler);

        const { proxy: proxyOpts}=   options;
        let presence;
        if( proxyOpts) {
          const {
            handler: proxyHandler,
            target: proxyTarget,
            revokerCallback}=
              proxyOpts;
          if( revokerCallback) {
            // Create a proxy and its revoke function.
            const { proxy, revoke}=   Proxy.revocable(
              proxyTarget,
              proxyHandler);

            presence=  proxy;
            revokerCallback(revoke);
           }else {
            presence=  new Proxy(proxyTarget, proxyHandler);
           }
         }else {
          // Default presence.
          presence=  create(null);
         }

        // Validate and install our mapped target (i.e. presence).
        resolvedTarget=  presence;

        // Create table entries for the presence mapped to the
        // fulfilledHandler.
        presenceToPromise.set(resolvedTarget, handledP);
        promiseToPresence.set(handledP, resolvedTarget);
        presenceToHandler.set(resolvedTarget, presenceHandler);

        // We committed to this presence, so resolve.
        handledResolve(resolvedTarget);
        return resolvedTarget;
       }catch( e) {
        assert.note(e, X `during resolveWithPresence`);
        handledReject(e);
        throw e;
       }
     };

    const resolveHandled=  (target)=>{
      if( resolved) {
        return;
       }
      assertNotYetForwarded();
      try {
        // Resolve the target.
        handledResolve(target);
       }catch( e) {
        handledReject(e);
       }
     };

    // Invoke the callback to let the user resolve/reject.
    executor(resolveHandled, rejectHandled, resolveWithPresence);

    return handledP;
   }

  /**
   * If the promise `p` is safe, then during the evaluation of the
   * expressopns `p.then` and `await p`, `p` cannot mount a reentrancy attack.
   * Unfortunately, due to limitations of the current JavaScript standard,
   * it seems impossible to prevent `p` from mounting a reentrancy attack
   * during the evaluation of `isSafePromise(p)`, and therefore during
   * operations like `HandledPromise.resolve(p)` that call
   * `isSafePromise(p)` synchronously.
   *
   * The `@endo/marshal` package defines a related notion of a passable
   * promise, i.e., one for which which `passStyleOf(p) === 'promise'`. All
   * passable promises are also safe. But not vice versa because the
   * requirements for a promise to be passable are slightly greater. A safe
   * promise must not override `then` or `constructor`. A passable promise
   * must not have any own properties. The requirements are otherwise
   * identical.
   *
   * @param {Promise} p
   * @returns {boolean}
   */
  const isSafePromise=  (p)=>{
    return(
      isFrozen(p)&&
      getPrototypeOf(p)===  Promise.prototype&&
      Promise.resolve(p)===  p&&
      getOwnPropertyDescriptor(p, 'then')===  undefined&&
      getOwnPropertyDescriptor(p, 'constructor')===  undefined);

   };

  /** @type {HandledPromiseStaticMethods & Pick<PromiseConstructor, 'resolve'>} */
  const staticMethods=  {
    get(target, prop) {
      prop=  coerceToObjectProperty(prop);
      return handle(target, 'get', [prop]);
     },
    getSendOnly(target, prop) {
      prop=  coerceToObjectProperty(prop);
      handle(target, 'getSendOnly', [prop]).catch(()=>  { });
     },
    applyFunction(target, args) {
      // Ensure args is an array.
      args=  [...args];
      return handle(target, 'applyFunction', [args]);
     },
    applyFunctionSendOnly(target, args) {
      // Ensure args is an array.
      args=  [...args];
      handle(target, 'applyFunctionSendOnly', [args]).catch(()=>  { });
     },
    applyMethod(target, prop, args) {
      prop=  coerceToObjectProperty(prop);
      // Ensure args is an array.
      args=  [...args];
      return handle(target, 'applyMethod', [prop, args]);
     },
    applyMethodSendOnly(target, prop, args) {
      prop=  coerceToObjectProperty(prop);
      // Ensure args is an array.
      args=  [...args];
      handle(target, 'applyMethodSendOnly', [prop, args]).catch(()=>  { });
     },
    resolve(value) {
      // Resolving a Presence returns the pre-registered handled promise.
      let resolvedPromise=  presenceToPromise.get(/** @type {any} */  value);
      if( !resolvedPromise) {
        resolvedPromise=  Promise.resolve(value);
       }
      // Prevent any proxy trickery.
      harden(resolvedPromise);
      if( isSafePromise(resolvedPromise)) {
        // We can use the `resolvedPromise` directly, since it is guaranteed to
        // have a `then` which is actually `Promise.prototype.then`.
        return resolvedPromise;
       }
      // Assimilate the `resolvedPromise` as an actual frozen Promise, by
      // treating `resolvedPromise` as if it is a non-promise thenable.
      const executeThen=  (resolve, reject)=>
        resolvedPromise.then(resolve, reject);
      return harden(
        Promise.resolve().then(()=>  new HandledPromise(executeThen)));

     }};


  const makeForwarder=  (operation, localImpl)=>  {
    return (o, ...args)=>  {
      // We are in another turn already, and have the naked object.
      const presenceHandler=  presenceToHandler.get(o);
      if( !presenceHandler) {
        return localImpl(o, ...args);
       }
      return dispatchToHandler(
        'presenceHandler',
        presenceHandler,
        operation,
        o,
        args);

     };
   };

  // eslint-disable-next-line prefer-const
  forwardingHandler=  {
    get: makeForwarder('get', localGet),
    getSendOnly: makeForwarder('getSendOnly', localGet),
    applyFunction: makeForwarder('applyFunction', localApplyFunction),
    applyFunctionSendOnly: makeForwarder(
      'applyFunctionSendOnly',
      localApplyFunction),

    applyMethod: makeForwarder('applyMethod', localApplyMethod),
    applyMethodSendOnly: makeForwarder('applyMethodSendOnly', localApplyMethod)};


  handle=  (...handleArgs)=>  {
    // We're in SES mode, so we should harden.
    harden(handleArgs);
    const [_p, operation, opArgs, ...dispatchArgs]=  handleArgs;
    let [p]=  handleArgs;
    const doDispatch=  (handlerName, handler, o)=>
      dispatchToHandler(
        handlerName,
        handler,
        operation,
        o,
        opArgs,
        // eslint-disable-next-line no-use-before-define
        ...(dispatchArgs.length===  0?  [returnedP]:  dispatchArgs));

    const [trackedDoDispatch]=  trackTurns([doDispatch]);
    const returnedP=  new HandledPromise((resolve, reject)=>  {
      // We run in a future turn to prevent synchronous attacks,
      let raceIsOver=  false;

      const win=  (handlerName, handler, o)=>  {
        if( raceIsOver) {
          return;
         }
        try {
          resolve(harden(trackedDoDispatch(handlerName, handler, o)));
         }catch( reason) {
          reject(harden(reason));
         }
        raceIsOver=  true;
       };

      const lose=  (reason)=>{
        if( raceIsOver) {
          return;
         }
        reject(harden(reason));
        raceIsOver=  true;
       };

      // This contestant tries to win with the target's resolution.
      staticMethods.
         resolve(p).
         then((o)=>win('forwardingHandler', forwardingHandler, o)).
         catch(lose);

      // This contestant sleeps a turn, but then tries to win immediately.
      staticMethods.
         resolve().
         then(()=>  {
          p=  shorten(p);
          const pendingHandler=  promiseToPendingHandler.get(p);
          if( pendingHandler) {
            // resolve to the answer from the specific pending handler,
            win('pendingHandler', pendingHandler, p);
           }else if( !p||  typeof p.then!==  'function') {
            // Not a Thenable, so use it.
            win('forwardingHandler', forwardingHandler, p);
           }else if( promiseToPresence.has(p)) {
            // We have the object synchronously, so resolve with it.
            const o=  promiseToPresence.get(p);
            win('forwardingHandler', forwardingHandler, o);
           }
          // If we made it here without winning, then we will wait
          // for the other contestant to win instead.
         }).
         catch(lose);
     });

    // We return a handled promise with the default pending handler.  This
    // prevents a race between the above Promise.resolves and pipelining.
    return harden(returnedP);
   };

  // Add everything needed on the constructor.
  baseHandledPromise.prototype=  Promise.prototype;
  setPrototypeOf(baseHandledPromise, Promise);
  defineProperties(
    baseHandledPromise,
    getOwnPropertyDescriptors(staticMethods));


  // FIXME: This is really ugly to bypass the type system, but it will be better
  // once we use Promise.delegated and don't have any [[Constructor]] behaviours.
  // @ts-expect-error cast
  HandledPromise=  baseHandledPromise;

  // We're a vetted shim which runs before `lockdown` allows
  // `harden(HandledPromise)` to function, but single-level `freeze` is a
  // suitable replacement because all mutable objects reachable afterwards are
  // intrinsics hardened by lockdown.
  freeze(HandledPromise);
  for( const key of ownKeys(HandledPromise)) {
    // prototype is the intrinsic Promise.prototype to be hardened by lockdown.
    if( key!==  'prototype') {
      freeze(HandledPromise[key]);
     }
   }

  return HandledPromise;
 };

/**
 * @template T
 * @typedef {{
 *   get?(p: T, name: PropertyKey, returnedP?: Promise<unknown>): unknown;
 *   getSendOnly?(p: T, name: PropertyKey): void;
 *   applyFunction?(p: T, args: unknown[], returnedP?: Promise<unknown>): unknown;
 *   applyFunctionSendOnly?(p: T, args: unknown[]): void;
 *   applyMethod?(p: T, name: PropertyKey | undefined, args: unknown[], returnedP?: Promise<unknown>): unknown;
 *   applyMethodSendOnly?(p: T, name: PropertyKey | undefined, args: unknown[]): void;
 * }} Handler
 */

/**
 * @template {{}} T
 * @typedef {{
 *   proxy?: {
 *     handler: ProxyHandler<T>;
 *     target: unknown;
 *     revokerCallback?(revoker: () => void): void;
 *   };
 * }} ResolveWithPresenceOptionsBag
 */

/**
 * @template [R = unknown]
 * @typedef {(
 *   resolveHandled: (value?: R) => void,
 *   rejectHandled: (reason?: unknown) => void,
 *   resolveWithPresence: (presenceHandler: Handler<{}>, options?: ResolveWithPresenceOptionsBag<{}>) => object,
 * ) => void} HandledExecutor
 */

/**
 * @template [R = unknown]
 * @typedef {{
 *   resolve(value?: R): void;
 *   reject(reason: unknown): void;
 *   resolveWithPresence(presenceHandler?: Handler<{}>, options?: ResolveWithPresenceOptionsBag<{}>): object;
 * }} Settler
 */

/**
 * @typedef {{
 *   applyFunction(target: unknown, args: unknown[]): Promise<unknown>;
 *   applyFunctionSendOnly(target: unknown, args: unknown[]): void;
 *   applyMethod(target: unknown, prop: PropertyKey | undefined, args: unknown[]): Promise<unknown>;
 *   applyMethodSendOnly(target: unknown, prop: PropertyKey, args: unknown[]): void;
 *   get(target: unknown, prop: PropertyKey): Promise<unknown>;
 *   getSendOnly(target: unknown, prop: PropertyKey): void;
 * }} HandledPromiseStaticMethods
 */

/** @typedef {ReturnType<typeof makeHandledPromise>} HandledPromiseConstructor */$h‍_once.makeHandledPromise(makeHandledPromise);
})()
,
// === functors[112] ===
({   imports: $h‍_imports,   liveVar: $h‍_live,   onceVar: $h‍_once,   importMeta: $h‍____meta, }) => (function () {   let makeHandledPromise;$h‍_imports([["./src/handled-promise.js", [["makeHandledPromise", [$h‍_a => (makeHandledPromise = $h‍_a)]]]]]);   


if( typeof globalThis.HandledPromise===  'undefined') {
  globalThis.HandledPromise=  makeHandledPromise();
 }
})()
,
// === functors[113] ===
({   imports: $h‍_imports,   liveVar: $h‍_live,   onceVar: $h‍_once,   importMeta: $h‍____meta, }) => (function () {   let trackTurns;$h‍_imports([["./track-turns.js", [["trackTurns", [$h‍_a => (trackTurns = $h‍_a)]]]]]);   

const { details: X, quote: q, Fail}=   assert;
const { assign, create}=   Object;

/** @type {ProxyHandler<any>} */
const baseFreezableProxyHandler=  {
  set(_target, _prop, _value) {
    return false;
   },
  isExtensible(_target) {
    return false;
   },
  setPrototypeOf(_target, _value) {
    return false;
   },
  deleteProperty(_target, _prop) {
    return false;
   }};


// E Proxy handlers pretend that any property exists on the target and returns
// a function for their value. While this function is "bound" by context, it is
// meant to be called as a method. For that reason, the returned function
// includes a check that the `this` argument corresponds to the initial
// receiver when the function was retrieved.
// E Proxy handlers also forward direct calls to the target in case the remote
// is a function instead of an object. No such receiver checks are necessary in
// that case.

/**
 * A Proxy handler for E(x).
 *
 * @param {*} x Any value passed to E(x)
 * @param {import('./types').HandledPromiseConstructor} HandledPromise
 * @returns {ProxyHandler} the Proxy handler
 */
const makeEProxyHandler=  (x, HandledPromise)=>
  harden({
    ...baseFreezableProxyHandler,
    get: (_target, p, receiver)=>  {
      return harden(
        {
          // This function purposely checks the `this` value (see above)
          // In order to be `this` sensitive it is defined using concise method
          // syntax rather than as an arrow function. To ensure the function
          // is not constructable, it also avoids the `function` syntax.
          [p](...args) {
            if( this!==  receiver) {
              // Reject the async function call
              return HandledPromise.reject(
                assert.error(
                  X `Unexpected receiver for "${p}" method of E(${q(x)})`));


             }

            return HandledPromise.applyMethod(x, p, args);
           }
          // @ts-expect-error https://github.com/microsoft/TypeScript/issues/50319
}[        p]);

     },
    apply: (_target, _thisArg, argArray=  [])=>  {
      return HandledPromise.applyFunction(x, argArray);
     },
    has: (_target, _p)=>  {
      // We just pretend everything exists.
      return true;
     }});


/**
 * A Proxy handler for E.sendOnly(x)
 * It is a variant on the E(x) Proxy handler.
 *
 * @param {*} x Any value passed to E.sendOnly(x)
 * @param {import('./types').HandledPromiseConstructor} HandledPromise
 * @returns {ProxyHandler} the Proxy handler
 */
const makeESendOnlyProxyHandler=  (x, HandledPromise)=>
  harden({
    ...baseFreezableProxyHandler,
    get: (_target, p, receiver)=>  {
      return harden(
        {
          // This function purposely checks the `this` value (see above)
          // In order to be `this` sensitive it is defined using concise method
          // syntax rather than as an arrow function. To ensure the function
          // is not constructable, it also avoids the `function` syntax.
          [p](...args) {
            // Throw since the function returns nothing
            this===  receiver||
              Fail `Unexpected receiver for "${q(p)}" method of E.sendOnly(${q(
                x)
                })`;
            HandledPromise.applyMethodSendOnly(x, p, args);
            return undefined;
           }
          // @ts-expect-error https://github.com/microsoft/TypeScript/issues/50319
}[        p]);

     },
    apply: (_target, _thisArg, argsArray=  [])=>  {
      HandledPromise.applyFunctionSendOnly(x, argsArray);
      return undefined;
     },
    has: (_target, _p)=>  {
      // We just pretend that everything exists.
      return true;
     }});


/**
 * A Proxy handler for E.get(x)
 * It is a variant on the E(x) Proxy handler.
 *
 * @param {*} x Any value passed to E.get(x)
 * @param {import('./types').HandledPromiseConstructor} HandledPromise
 * @returns {ProxyHandler} the Proxy handler
 */
const makeEGetProxyHandler=  (x, HandledPromise)=>
  harden({
    ...baseFreezableProxyHandler,
    has: (_target, _prop)=>  true,
    get: (_target, prop)=>  HandledPromise.get(x, prop)});


/**
 * @param {import('./types').HandledPromiseConstructor} HandledPromise
 */
const makeE=  (HandledPromise)=>{
  return harden(
    assign(
      /**
       * E(x) returns a proxy on which you can call arbitrary methods. Each of these
       * method calls returns a promise. The method will be invoked on whatever
       * 'x' designates (or resolves to) in a future turn, not this one.
       *
       * @template T
       * @param {T} x target for method/function call
       * @returns {ECallableOrMethods<RemoteFunctions<T>>} method/function call proxy
       */
      (x)=>harden(new Proxy(()=>  { },makeEProxyHandler(x, HandledPromise))),
      {
        /**
         * E.get(x) returns a proxy on which you can get arbitrary properties.
         * Each of these properties returns a promise for the property.  The promise
         * value will be the property fetched from whatever 'x' designates (or
         * resolves to) in a future turn, not this one.
         *
         * @template T
         * @param {T} x target for property get
         * @returns {EGetters<LocalRecord<T>>} property get proxy
         * @readonly
         */
        get: (x)=>
          harden(
            new Proxy(create(null), makeEGetProxyHandler(x, HandledPromise))),


        /**
         * E.resolve(x) converts x to a handled promise. It is
         * shorthand for HandledPromise.resolve(x)
         *
         * @template T
         * @param {T} x value to convert to a handled promise
         * @returns {Promise<Awaited<T>>} handled promise for x
         * @readonly
         */
        resolve: HandledPromise.resolve,

        /**
         * E.sendOnly returns a proxy similar to E, but for which the results
         * are ignored (undefined is returned).
         *
         * @template T
         * @param {T} x target for method/function call
         * @returns {ESendOnlyCallableOrMethods<RemoteFunctions<T>>} method/function call proxy
         * @readonly
         */
        sendOnly: (x)=>
          harden(
            new Proxy(()=>  { },makeESendOnlyProxyHandler(x, HandledPromise))),


        /**
         * E.when(x, res, rej) is equivalent to
         * HandledPromise.resolve(x).then(res, rej)
         *
         * @template T
         * @template [U = T]
         * @param {T|PromiseLike<T>} x value to convert to a handled promise
         * @param {(value: T) => ERef<U>} [onfulfilled]
         * @param {(reason: any) => ERef<U>} [onrejected]
         * @returns {Promise<U>}
         * @readonly
         */
        when: (x, onfulfilled, onrejected)=>
          HandledPromise.resolve(x).then(
            ...trackTurns([onfulfilled, onrejected]))}));




 };

const{default:$c‍_default}={default:makeE};

/** @typedef {ReturnType<makeE>} EProxy */

/**
 * Creates a type that accepts both near and marshalled references that were
 * returned from `Remotable` or `Far`, and also promises for such references.
 *
 * @template Primary The type of the primary reference.
 * @template [Local=DataOnly<Primary>] The local properties of the object.
 * @typedef {ERef<Local & import('./types').RemotableBrand<Local, Primary>>} FarRef
 */

/**
 * `DataOnly<T>` means to return a record type `T2` consisting only of
 * properties that are *not* functions.
 *
 * @template T The type to be filtered.
 * @typedef {Omit<T, FilteredKeys<T, import('./types').Callable>>} DataOnly
 */

/**
 * @see {@link https://github.com/microsoft/TypeScript/issues/31394}
 * @template T
 * @typedef {PromiseLike<T> | T} ERef
 */

/**
 * @template {import('./types').Callable} T
 * @typedef {(
 *   ReturnType<T> extends PromiseLike<infer U>                       // if function returns a promise
 *     ? T                                                            // return the function
 *     : (...args: Parameters<T>) => Promise<Awaited<ReturnType<T>>>  // make it return a promise
 * )} ECallable
 */

/**
 * @template T
 * @typedef {{
 *   readonly [P in keyof T]: T[P] extends import('./types').Callable
 *     ? ECallable<T[P]>
 *     : never;
 * }} EMethods
 */

/**
 * @template T
 * @typedef {{
 *   readonly [P in keyof T]: T[P] extends PromiseLike<infer U>
 *     ? T[P]
 *     : Promise<Awaited<T[P]>>;
 * }} EGetters
 */

/**
 * @template {import('./types').Callable} T
 * @typedef {(...args: Parameters<T>) => Promise<void>} ESendOnlyCallable
 */

/**
 * @template T
 * @typedef {{
 *   readonly [P in keyof T]: T[P] extends import('./types').Callable
 *     ? ESendOnlyCallable<T[P]>
 *     : never;
 * }} ESendOnlyMethods
 */

/**
 * @template T
 * @typedef {(
 *   T extends import('./types').Callable
 *     ? ESendOnlyCallable<T> & ESendOnlyMethods<Required<T>>
 *     : ESendOnlyMethods<Required<T>>
 * )} ESendOnlyCallableOrMethods
 */

/**
 * @template T
 * @typedef {(
 *   T extends import('./types').Callable
 *     ? ECallable<T> & EMethods<Required<T>>
 *     : EMethods<Required<T>>
 * )} ECallableOrMethods
 */

/**
 * Return a union of property names/symbols/numbers P for which the record element T[P]'s type extends U.
 *
 * Given const x = { a: 123, b: 'hello', c: 42, 49: () => {}, 53: 67 },
 *
 * FilteredKeys<typeof x, number> is the type 'a' | 'c' | 53.
 * FilteredKeys<typeof x, string> is the type 'b'.
 * FilteredKeys<typeof x, 42 | 67> is the type 'c' | 53.
 * FilteredKeys<typeof x, boolean> is the type never.
 *
 * @template T
 * @template U
 * @typedef {{ [P in keyof T]: T[P] extends U ? P : never; }[keyof T]} FilteredKeys
 */

/**
 * `PickCallable<T>` means to return a single root callable or a record type
 * consisting only of properties that are functions.
 *
 * @template T
 * @typedef {(
 *   T extends import('./types').Callable
 *     ? (...args: Parameters<T>) => ReturnType<T>                     // a root callable, no methods
 *     : Pick<T, FilteredKeys<T, import('./types').Callable>>          // any callable methods
 * )} PickCallable
 */

/**
 * `RemoteFunctions<T>` means to return the functions and properties that are remotely callable.
 *
 * @template T
 * @typedef {(
 *   T extends import('./types').RemotableBrand<infer L, infer R>     // if a given T is some remote interface R
 *     ? PickCallable<R>                                              // then return the callable properties of R
 *     : Awaited<T> extends import('./types').RemotableBrand<infer L, infer R> // otherwise, if the final resolution of T is some remote interface R
 *     ? PickCallable<R>                                              // then return the callable properties of R
 *     : T extends PromiseLike<infer U>                               // otherwise, if T is a promise
 *     ? Awaited<T>                                                   // then return resolved value T
 *     : T                                                            // otherwise, return T
 * )} RemoteFunctions
 */

/**
 * @template T
 * @typedef {(
 *   T extends import('./types').RemotableBrand<infer L, infer R>
 *     ? L
 *     : Awaited<T> extends import('./types').RemotableBrand<infer L, infer R>
 *     ? L
 *     : T extends PromiseLike<infer U>
 *     ? Awaited<T>
 *     : T
 * )} LocalRecord
 */

/**
 * @template [R = unknown]
 * @typedef {{
 *   promise: Promise<R>;
 *   settler: import('./types').Settler<R>;
 * }} EPromiseKit
 */

/**
 * Type for an object that must only be invoked with E.  It supports a given
 * interface but declares all the functions as asyncable.
 *
 * @template T
 * @typedef {(
 *   T extends import('./types').Callable
 *     ? (...args: Parameters<T>) => ERef<Awaited<EOnly<ReturnType<T>>>>
 *     : T extends Record<PropertyKey, import('./types').Callable>
 *     ? {
 *         [K in keyof T]: T[K] extends import('./types').Callable
 *           ? (...args: Parameters<T[K]>) => ERef<Awaited<EOnly<ReturnType<T[K]>>>>
 *           : T[K];
 *       }
 *     : T
 * )} EOnly
 */$h‍_once.default($c‍_default);
})()
,
// === functors[114] ===
({   imports: $h‍_imports,   liveVar: $h‍_live,   onceVar: $h‍_once,   importMeta: $h‍____meta, }) => (function () {   $h‍_imports([]);   
})()
,
// === functors[115] ===
({   imports: $h‍_imports,   liveVar: $h‍_live,   onceVar: $h‍_once,   importMeta: $h‍____meta, }) => (function () {   let makeE;$h‍_imports([["./E.js", [["default", [$h‍_a => (makeE = $h‍_a)]]]],["./exports.js", []]]);   

const hp=  HandledPromise;$h‍_once.hp(hp);
const        E=  makeE(hp);$h‍_once.E(E);
})()
,
// === functors[116] ===
({   imports: $h‍_imports,   liveVar: $h‍_live,   onceVar: $h‍_once,   importMeta: $h‍____meta, }) => (function () {   $h‍_imports([]);   /// <reference types="ses"/>

/** @typedef {import('./types.js').Checker} Checker */
/** @typedef {import('./types.js').PassStyle} PassStyle */

const { details: X, quote: q}=   assert;
const { isArray}=   Array;
const { prototype: functionPrototype}=   Function;
const {
  getOwnPropertyDescriptor,
  getPrototypeOf,
  hasOwnProperty: objectHasOwnProperty,
  isFrozen,
  prototype: objectPrototype}=
    Object;
const { apply}=   Reflect;
const { toStringTag: toStringTagSymbol}=   Symbol;

const typedArrayPrototype=  getPrototypeOf(Uint8Array.prototype);
const typedArrayToStringTagDesc=  getOwnPropertyDescriptor(
  typedArrayPrototype,
  toStringTagSymbol);

assert(typedArrayToStringTagDesc);
const getTypedArrayToStringTag=  typedArrayToStringTagDesc.get;
assert(typeof getTypedArrayToStringTag===  'function');

const        hasOwnPropertyOf=  (obj, prop)=>
  apply(objectHasOwnProperty, obj, [prop]);$h‍_once.hasOwnPropertyOf(hasOwnPropertyOf);
harden(hasOwnPropertyOf);

const        isObject=  (val)=>Object(val)===  val;$h‍_once.isObject(isObject);
harden(isObject);

/**
 * Duplicates packages/ses/src/make-hardener.js to avoid a dependency.
 *
 * @param {unknown} object
 */
const        isTypedArray=  (object)=>{
  // The object must pass a brand check or toStringTag will return undefined.
  const tag=  apply(getTypedArrayToStringTag, object, []);
  return tag!==  undefined;
 };$h‍_once.isTypedArray(isTypedArray);
harden(isTypedArray);

const        PASS_STYLE=  Symbol.for('passStyle');

/**
 * For a function to be a valid method, it must not be passable.
 * Otherwise, we risk confusing pass-by-copy data carrying
 * far functions with attempts at far objects with methods.
 *
 * TODO HAZARD Because we check this on the way to hardening a remotable,
 * we cannot yet check that `func` is hardened. However, without
 * doing so, it's inheritance might change after the `PASS_STYLE`
 * check below.
 *
 * @param {any} func
 * @returns {boolean}
 */$h‍_once.PASS_STYLE(PASS_STYLE);
const        canBeMethod=  (func)=>
  typeof func===  'function'&&  !(PASS_STYLE in func);$h‍_once.canBeMethod(canBeMethod);
harden(canBeMethod);

/**
 * Below we have a series of predicate functions and their (curried) assertion
 * functions. The semantics of the assertion function is just to assert that
 * the corresponding predicate function would have returned true. But it
 * reproduces the internal tests so failures can give a better error message.
 *
 * @type {Checker}
 */
const        assertChecker=  (cond, details)=>  {
  assert(cond, details);
  return true;
 };$h‍_once.assertChecker(assertChecker);
harden(assertChecker);

/**
 * Checks for the presence and enumerability of an own data property.
 *
 * @param {object} candidate
 * @param {string|number|symbol} propertyName
 * @param {boolean} shouldBeEnumerable
 * @param {Checker} [check]
 * @returns {boolean}
 */
const        checkNormalProperty=  (
  candidate,
  propertyName,
  shouldBeEnumerable,
  check)=>
     {
  const reject=  !!check&&(  (details)=>check(false, details));
  const desc=  getOwnPropertyDescriptor(candidate, propertyName);
  if( desc===  undefined) {
    return(
      reject&&  reject(X `${q(propertyName)} property expected: ${candidate}`));

   }
  return(
    (hasOwnPropertyOf(desc, 'value')||
       reject&&
        reject(
          X `${q(propertyName)} must not be an accessor property: ${candidate}`))&&(

     shouldBeEnumerable?
        desc.enumerable||
         reject&&
          reject(
            X `${q(propertyName)} must be an enumerable property: ${candidate}`):

        !desc.enumerable||
         reject&&
          reject(
            X `${q(
              propertyName)
              } must not be an enumerable property: ${candidate}`)));


 };$h‍_once.checkNormalProperty(checkNormalProperty);
harden(checkNormalProperty);

const        getTag=  (tagRecord)=>tagRecord[Symbol.toStringTag];$h‍_once.getTag(getTag);
harden(getTag);

const        checkPassStyle=  (obj, expectedPassStyle, check)=>  {
  const reject=  !!check&&(  (details)=>check(false, details));
  const actual=  obj[PASS_STYLE];
  return(
    actual===  expectedPassStyle||
     reject&&
      reject(X `Expected ${q(expectedPassStyle)}, not ${q(actual)}: ${obj}`));

 };$h‍_once.checkPassStyle(checkPassStyle);
harden(checkPassStyle);

const makeCheckTagRecord=  (checkProto)=>{
  /**
   * @param {{ [PASS_STYLE]: string }} tagRecord
   * @param {PassStyle} passStyle
   * @param {Checker} [check]
   * @returns {boolean}
   */
  const checkTagRecord=  (tagRecord, passStyle, check)=>  {
    const reject=  !!check&&(  (details)=>check(false, details));
    return(
      (isObject(tagRecord)||
         reject&&
          reject(X `A non-object cannot be a tagRecord: ${tagRecord}`))&&(
       isFrozen(tagRecord)||
         reject&&  reject(X `A tagRecord must be frozen: ${tagRecord}`))&&(
       !isArray(tagRecord)||
         reject&&  reject(X `An array cannot be a tagRecord: ${tagRecord}`))&&
      checkNormalProperty(tagRecord, PASS_STYLE, false, check)&&
      checkPassStyle(tagRecord, passStyle, check)&&
      checkNormalProperty(tagRecord, Symbol.toStringTag, false, check)&&(
       typeof getTag(tagRecord)===  'string'||
         reject&&
          reject(
            X `A [Symbol.toStringTag]-named property must be a string: ${tagRecord}`))&&

      checkProto(tagRecord, getPrototypeOf(tagRecord), check));

   };
  return harden(checkTagRecord);
 };

const        checkTagRecord=  makeCheckTagRecord(
  (val, proto, check)=>
    proto===  objectPrototype||
     !!check&&
      check(false, X `A tagRecord must inherit from Object.prototype: ${val}`));$h‍_once.checkTagRecord(checkTagRecord);

harden(checkTagRecord);

const        checkFunctionTagRecord=  makeCheckTagRecord(
  (val, proto, check)=>
    proto===  functionPrototype||
     proto!==  null&&  getPrototypeOf(proto)===  functionPrototype||
     !!check&&
      check(
        false,
        X `For functions, a tagRecord must inherit from Function.prototype: ${val}`));$h‍_once.checkFunctionTagRecord(checkFunctionTagRecord);


harden(checkFunctionTagRecord);
})()
,
// === functors[117] ===
({   imports: $h‍_imports,   liveVar: $h‍_live,   onceVar: $h‍_once,   importMeta: $h‍____meta, }) => (function () {   let assertChecker,canBeMethod,hasOwnPropertyOf,PASS_STYLE,checkTagRecord,checkFunctionTagRecord,isObject,getTag;$h‍_imports([["./passStyle-helpers.js", [["assertChecker", [$h‍_a => (assertChecker = $h‍_a)]],["canBeMethod", [$h‍_a => (canBeMethod = $h‍_a)]],["hasOwnPropertyOf", [$h‍_a => (hasOwnPropertyOf = $h‍_a)]],["PASS_STYLE", [$h‍_a => (PASS_STYLE = $h‍_a)]],["checkTagRecord", [$h‍_a => (checkTagRecord = $h‍_a)]],["checkFunctionTagRecord", [$h‍_a => (checkFunctionTagRecord = $h‍_a)]],["isObject", [$h‍_a => (isObject = $h‍_a)]],["getTag", [$h‍_a => (getTag = $h‍_a)]]]]]);   












/** @typedef {import('./types.js').Checker} Checker */
/** @typedef {import('./types.js').InterfaceSpec} InterfaceSpec */
/** @typedef {import('./types.js').MarshalGetInterfaceOf} MarshalGetInterfaceOf */
/** @typedef {import('./internal-types.js').PassStyleHelper} PassStyleHelper */
/** @typedef {import('./types.js').RemotableObject} Remotable */

const { details: X, Fail, quote: q}=   assert;
const { ownKeys}=   Reflect;
const { isArray}=   Array;
const {
  getPrototypeOf,
  isFrozen,
  prototype: objectPrototype,
  getOwnPropertyDescriptors}=
    Object;

/**
 * @param {InterfaceSpec} iface
 * @param {Checker} [check]
 */
const checkIface=  (iface, check)=>  {
  const reject=  !!check&&(  (details)=>check(false, details));
  return(
    // TODO other possible ifaces, once we have third party veracity
    (typeof iface===  'string'||
       reject&&
        reject(
          X `For now, interface ${iface} must be a string; unimplemented`))&&(

     iface===  'Remotable'||
      iface.startsWith('Alleged: ')||
      iface.startsWith('DebugName: ')||
       reject&&
        reject(
          X `For now, iface ${q(
            iface)
            } must be "Remotable" or begin with "Alleged: " or "DebugName: "; unimplemented`)));


 };

/**
 * An `iface` must be pure. Right now it must be a string, which is pure.
 * Later we expect to include some other values that qualify as `PureData`,
 * which is a pass-by-copy superstructure ending only in primitives or
 * empty pass-by-copy composites. No remotables, promises, or errors.
 * We *assume* for now that the pass-by-copy superstructure contains no
 * proxies.
 *
 * @param {InterfaceSpec} iface
 */
const        assertIface=  (iface)=>checkIface(iface, assertChecker);$h‍_once.assertIface(assertIface);
harden(assertIface);

/**
 * @param {object | Function} original
 * @param {Checker} [check]
 * @returns {boolean}
 */
const checkRemotableProtoOf=  (original, check)=>  {
  const reject=  !!check&&(  (details)=>check(false, details));
  isObject(original)||
    Fail `Remotables must be objects or functions: ${original}`;

  // A valid remotable object must inherit from a "tag record" -- a
  // plain-object prototype consisting of only
  // a `PASS_STYLE` property with value "remotable" and a suitable `Symbol.toStringTag`
  // property. The remotable could inherit directly from such a tag record, or
  // it could inherit from another valid remotable, that therefore itself
  // inherits directly or indirectly from such a tag record.
  //
  // TODO: It would be nice to typedef this shape, but we can't declare a type
  // with PASS_STYLE from JSDoc.
  //
  // @type {{ [PASS_STYLE]: string,
  //          [Symbol.toStringTag]: string,
  //        }}
  //
  const proto=  getPrototypeOf(original);
  if( proto===  objectPrototype||  proto===  null) {
    return(
      reject&&
      reject(X `Remotables must be explicitly declared: ${q(original)}`));

   }

  if( typeof original===  'object') {
    const protoProto=  getPrototypeOf(proto);
    if( protoProto!==  objectPrototype&&  protoProto!==  null) {
      // eslint-disable-next-line no-use-before-define
      return checkRemotable(proto, check);
     }
    if( !checkTagRecord(proto, 'remotable', check)) {
      return false;
     }
   }else if( typeof original===  'function') {
    if( !checkFunctionTagRecord(proto, 'remotable', check)) {
      return false;
     }
   }

  // Typecasts needed due to https://github.com/microsoft/TypeScript/issues/1863
  const passStyleKey=  /** @type {unknown} */  PASS_STYLE;
  const tagKey=  /** @type {unknown} */  Symbol.toStringTag;
  const {
    // checkTagRecord already verified PASS_STYLE and Symbol.toStringTag own data properties.
    [/** @type {string} */  passStyleKey]:  _passStyleDesc,
    [/** @type {string} */  tagKey]:  { value: iface},
    ...restDescs}=
      getOwnPropertyDescriptors(proto);

  return(
    (ownKeys(restDescs).length===  0||
       reject&&
        reject(
          X `Unexpected properties on Remotable Proto ${ownKeys(restDescs)}`))&&

    checkIface(iface, check));

 };

/**
 * Keep a weak set of confirmed remotables for marshal performance
 * (without which we would incur a redundant verification in
 * getInterfaceOf).
 * We don't remember rejections because they are possible to correct
 * with e.g. `harden`.
 *
 * @type {WeakSet<Remotable>}
 */
const confirmedRemotables=  new WeakSet();

/**
 * @param {Remotable} val
 * @param {Checker} [check]
 * @returns {boolean}
 */
const checkRemotable=  (val, check)=>  {
  if( confirmedRemotables.has(val)) {
    return true;
   }
  const reject=  !!check&&(  (details)=>check(false, details));
  if( !isFrozen(val)) {
    return reject&&  reject(X `cannot serialize non-frozen objects like ${val}`);
   }
  // eslint-disable-next-line no-use-before-define
  if( !RemotableHelper.canBeValid(val, check)) {
    return false;
   }
  const result=  checkRemotableProtoOf(val, check);
  if( result) {
    confirmedRemotables.add(val);
   }
  return result;
 };

/** @type {MarshalGetInterfaceOf} */
const        getInterfaceOf=  (val)=>{
  if(
    !isObject(val)||
    val[PASS_STYLE]!==  'remotable'||
    !checkRemotable(val))
    {
    return undefined;
   }
  return getTag(val);
 };$h‍_once.getInterfaceOf(getInterfaceOf);
harden(getInterfaceOf);

/**
 *
 * @type {PassStyleHelper}
 */
const        RemotableHelper=  harden({
  styleName: 'remotable',

  canBeValid: (candidate, check=  undefined)=>  {
    const reject=  !!check&&(  (details)=>check(false, details));
    const validType=
      (isObject(candidate)||
         reject&&
          reject(X `cannot serialize non-objects as Remotable ${candidate}`))&&(
       !isArray(candidate)||
         reject&&
          reject(X `cannot serialize arrays as Remotable ${candidate}`));
    if( !validType) {
      return false;
     }

    const descs=  getOwnPropertyDescriptors(candidate);
    if( typeof candidate===  'object') {
      // Every own property (regardless of enumerability)
      // must have a function value.
      return ownKeys(descs).every((key)=>{
        return(
          // Typecast needed due to https://github.com/microsoft/TypeScript/issues/1863
          (hasOwnPropertyOf(descs[/** @type {string} */  key],  'value')||
             reject&&
              reject(
                X `cannot serialize Remotables with accessors like ${q(
                  String(key))
                  } in ${candidate}`))&&(

            key===  Symbol.toStringTag&&  checkIface(candidate[key], check)||
             (canBeMethod(candidate[key])||
               reject&&
                reject(
                  X `cannot serialize Remotables with non-methods like ${q(
                    String(key))
                    } in ${candidate}`))&&(

               key!==  PASS_STYLE||
                 reject&&
                  reject(X `A pass-by-remote cannot shadow ${q(PASS_STYLE)}`))));

       });
     }else if( typeof candidate===  'function') {
      // Far functions cannot be methods, and cannot have methods.
      // They must have exactly expected `.name` and `.length` properties
      const {
        name: nameDesc,
        length: lengthDesc,
        // @ts-ignore TS doesn't like symbols as computed indexes??
        [Symbol.toStringTag]: toStringTagDesc,
        ...restDescs}=
          descs;
      const restKeys=  ownKeys(restDescs);
      return(
        ( nameDesc&&  typeof nameDesc.value===  'string'||
           reject&&
            reject(X `Far function name must be a string, in ${candidate}`))&&(
          lengthDesc&&  typeof lengthDesc.value===  'number'||
           reject&&
            reject(
              X `Far function length must be a number, in ${candidate}`))&&(

         toStringTagDesc===  undefined||
           (typeof toStringTagDesc.value===  'string'||
             reject&&
              reject(
                X `Far function @@toStringTag must be a string, in ${candidate}`))&&

            checkIface(toStringTagDesc.value, check))&&(
         restKeys.length===  0||
           reject&&
            reject(
              X `Far functions unexpected properties besides .name and .length ${restKeys}`)));


     }
    return reject&&  reject(X `unrecognized typeof ${candidate}`);
   },

  assertValid: (candidate)=>checkRemotable(candidate, assertChecker),

  every: (_passable, _fn)=>  true});$h‍_once.RemotableHelper(RemotableHelper);
})()
,
// === functors[118] ===
({   imports: $h‍_imports,   liveVar: $h‍_live,   onceVar: $h‍_once,   importMeta: $h‍____meta, }) => (function () {   let assertChecker,PASS_STYLE,assertIface,getInterfaceOf,RemotableHelper;$h‍_imports([["./passStyle-helpers.js", [["assertChecker", [$h‍_a => (assertChecker = $h‍_a)]],["PASS_STYLE", [$h‍_a => (PASS_STYLE = $h‍_a)]]]],["./remotable.js", [["assertIface", [$h‍_a => (assertIface = $h‍_a)]],["getInterfaceOf", [$h‍_a => (getInterfaceOf = $h‍_a)]],["RemotableHelper", [$h‍_a => (RemotableHelper = $h‍_a)]]]]]);   




/** @typedef {import('./types.js').InterfaceSpec} InterfaceSpec */
/** @template L,R @typedef {import('@endo/eventual-send').RemotableBrand<L, R>} RemotableBrand */

const { quote: q, Fail}=   assert;

const { prototype: functionPrototype}=   Function;
const {
  getPrototypeOf,
  setPrototypeOf,
  create,
  isFrozen,
  prototype: objectPrototype}=
    Object;

/**
 * Now that the remotableProto does not provide its own `toString` method,
 * ensure it always inherits from something. The original prototype of
 * `remotable` if there was one, or `Object.prototype` otherwise.
 *
 * @param {object} remotable
 * @param {InterfaceSpec} iface
 * @returns {object}
 */
const makeRemotableProto=  (remotable, iface)=>  {
  let oldProto=  getPrototypeOf(remotable);
  if( typeof remotable===  'object') {
    if( oldProto===  null) {
      oldProto=  objectPrototype;
     }
    oldProto===  objectPrototype||
      Fail `For now, remotables cannot inherit from anything unusual, in ${remotable}`;
   }else if( typeof remotable===  'function') {
    oldProto!==  null||
      Fail `Original function must not inherit from null: ${remotable}`;
    oldProto===  functionPrototype||
      getPrototypeOf(oldProto)===  functionPrototype||
      Fail `Far functions must originally inherit from Function.prototype, in ${remotable}`;
   }else {
    Fail `unrecognized typeof ${remotable}`;
   }
  return harden(
    create(oldProto, {
      [PASS_STYLE]: { value: 'remotable'},
      [Symbol.toStringTag]: { value: iface}}));


 };

const assertCanBeRemotable=  (candidate)=>
  RemotableHelper.canBeValid(candidate, assertChecker);

/**
 * Create and register a Remotable.  After this, getInterfaceOf(remotable)
 * returns iface.
 *
 * // https://github.com/Agoric/agoric-sdk/issues/804
 *
 * @template {{}} T
 * @param {InterfaceSpec} [iface] The interface specification for
 * the remotable. For now, a string iface must be "Remotable" or begin with
 * "Alleged: " or "DebugName: ", to serve as the alleged name. More
 * general ifaces are not yet implemented. This is temporary. We include the
 * "Alleged" or "DebugName" as a reminder that we do not yet have SwingSet
 * or Comms Vat
 * support for ensuring this is according to the vat hosting the object.
 * Currently, Alice can tell Bob about Carol, where VatA (on Alice's behalf)
 * misrepresents Carol's `iface`. VatB and therefore Bob will then see
 * Carol's `iface` as misrepresented by VatA.
 * @param {undefined} [props] Currently may only be undefined.
 * That plan is that own-properties are copied to the remotable
 * @param {T} [remotable] The object used as the remotable
 * @returns {T & RemotableBrand<{}, T>} remotable, modified for debuggability
 */
const        Remotable=  (
  iface=  'Remotable',
  props=  undefined,
  remotable=  /** @type {T} */  {})=>
     {
  assertIface(iface);
  assert(iface);
  // TODO: When iface is richer than just string, we need to get the allegedName
  // in a different way.
  props===  undefined||  Fail `Remotable props not yet implemented ${props}`;

  // Fail fast: check that the unmodified object is able to become a Remotable.
  assertCanBeRemotable(remotable);

  // Ensure that the remotable isn't already marked.
  !(PASS_STYLE in remotable)||
    Fail `Remotable ${remotable} is already marked as a ${q(
      remotable[PASS_STYLE])
      }`;
  // `isFrozen` always returns true with a fake `harden`, but we want that case
  // to succeed anyway. Faking `harden` is only correctness preserving
  // if the code in question contains no bugs that the real `harden` would
  // have caught.
  // @ts-ignore `isFake` purposely not in the type
  harden.isFake||
    // Ensure that the remotable isn't already frozen.
    !isFrozen(remotable)||
    Fail `Remotable ${remotable} is already frozen`;
  const remotableProto=  makeRemotableProto(remotable, iface);

  // Take a static copy of the enumerable own properties as data properties.
  // const propDescs = getOwnPropertyDescriptors({ ...props });
  const mutateHardenAndCheck=  (target)=>{
    // defineProperties(target, propDescs);
    setPrototypeOf(target, remotableProto);
    harden(target);
    assertCanBeRemotable(target);
   };

  // Fail fast: check a fresh remotable to see if our rules fit.
  mutateHardenAndCheck({});

  // Actually finish the new remotable.
  mutateHardenAndCheck(remotable);

  // COMMITTED!
  // We're committed, so keep the interface for future reference.
  assert(iface!==  undefined); // To make TypeScript happy
  return (/** @type {T & RemotableBrand<{}, T>} */ remotable);
 };$h‍_once.Remotable(Remotable);
harden(Remotable);

/**
 * A concise convenience for the most common `Remotable` use.
 *
 * @template {{}} T
 * @param {string} farName This name will be prepended with `Alleged: `
 * for now to form the `Remotable` `iface` argument.
 * @param {T} [remotable] The object used as the remotable
 */
const        Far=  (farName, remotable=  undefined)=>  {
  const r=  remotable===  undefined?  /** @type {T} */  {}:   remotable;
  return Remotable( `Alleged: ${farName}`,undefined, r);
 };$h‍_once.Far(Far);
harden(Far);

/**
 * Coerce `func` to a far function that preserves its call behavior.
 * If it is already a far function, return it. Otherwise make and return a
 * new far function that wraps `func` and forwards calls to it. This
 * works even if `func` is already frozen. `ToFarFunction` is to be used
 * when the function comes from elsewhere under less control. For functions
 * you author in place, better to use `Far` on their function literal directly.
 *
 * @param {string} farName to be used only if `func` is not already a
 * far function.
 * @param {(...args: any[]) => any} func
 */
const        ToFarFunction=  (farName, func)=>  {
  if( getInterfaceOf(func)!==  undefined) {
    return func;
   }
  return Far(farName, (...args)=>  func(...args));
 };$h‍_once.ToFarFunction(ToFarFunction);
harden(ToFarFunction);
})()
,
// === functors[119] ===
({   imports: $h‍_imports,   liveVar: $h‍_live,   onceVar: $h‍_once,   importMeta: $h‍____meta, }) => (function () {   let Far;$h‍_imports([["./make-far.js", [["Far", [$h‍_a => (Far = $h‍_a)]]]]]);   

/**
 * The result iterator has as many elements as the `baseIterator` and
 * have the same termination -- the same completion value or failure
 * reason. But the non-final values are the corresponding non-final
 * values from `baseIterator` as transformed by `func`.
 *
 * @template T,U
 * @param {Iterable<T>} baseIterable
 * @param {(value: T) => U} func
 * @returns {Iterable<U>}
 */
const        mapIterable=  (baseIterable, func)=>
  /** @type {Iterable<U>} */
  Far('mapped iterable', {
    [Symbol.iterator]: ()=>  {
      const baseIterator=  baseIterable[Symbol.iterator]();
      return Far('mapped iterator', {
        next: ()=>  {
          const { value: baseValue, done}=   baseIterator.next();
          const value=  done?  baseValue:  func(baseValue);
          return harden({ value, done});
         }});

     }});$h‍_once.mapIterable(mapIterable);

harden(mapIterable);

/**
 * The result iterator has a subset of the non-final values from the
 * `baseIterator` --- those for which `pred(value)` was truthy. The result
 * has the same termination as the `baseIterator` -- the same completion value
 * or failure reason.
 *
 * @template T
 * @param {Iterable<T>} baseIterable
 * @param {(value: T) => boolean} pred
 * @returns {Iterable<T>}
 */
const        filterIterable=  (baseIterable, pred)=>
  /** @type {Iterable<U>} */
  Far('filtered iterable', {
    [Symbol.iterator]: ()=>  {
      const baseIterator=  baseIterable[Symbol.iterator]();
      return Far('filtered iterator', {
        next: ()=>  {
          for(;;)  {
            const result=  baseIterator.next();
            const { value, done}=   result;
            if( done||  pred(value)) {
              return result;
             }
           }
         }});

     }});$h‍_once.filterIterable(filterIterable);

harden(filterIterable);
})()
,
// === functors[120] ===
({   imports: $h‍_imports,   liveVar: $h‍_live,   onceVar: $h‍_once,   importMeta: $h‍____meta, }) => (function () {   let assertChecker;$h‍_imports([["./passStyle-helpers.js", [["assertChecker", [$h‍_a => (assertChecker = $h‍_a)]]]]]);   



/** @typedef {import('./internal-types.js').PassStyleHelper} PassStyleHelper */
/** @typedef {import('./types.js').Checker} Checker */

const { details: X, Fail}=   assert;
const { getPrototypeOf, getOwnPropertyDescriptors}=   Object;
const { ownKeys}=   Reflect;

// TODO: Maintenance hazard: Coordinate with the list of errors in the SES
// whilelist. Currently, both omit AggregateError, which is now standard. Both
// must eventually include it.
const errorConstructors=  new Map([
  ['Error', Error],
  ['EvalError', EvalError],
  ['RangeError', RangeError],
  ['ReferenceError', ReferenceError],
  ['SyntaxError', SyntaxError],
  ['TypeError', TypeError],
  ['URIError', URIError]]);


const        getErrorConstructor=  (name)=>errorConstructors.get(name);$h‍_once.getErrorConstructor(getErrorConstructor);
harden(getErrorConstructor);

/**
 * @param {unknown} candidate
 * @param {Checker} [check]
 * @returns {boolean}
 */
const checkErrorLike=  (candidate, check=  undefined)=>  {
  const reject=  !!check&&(  (details)=>check(false, details));
  // TODO: Need a better test than instanceof
  return(
    candidate instanceof Error||
     reject&&  reject(X `Error expected: ${candidate}`));

 };
harden(checkErrorLike);

/**
 * Validating error objects are passable raises a tension between security
 * vs preserving diagnostic information. For errors, we need to remember
 * the error itself exists to help us diagnose a bug that's likely more
 * pressing than a validity bug in the error itself. Thus, whenever it is safe
 * to do so, we prefer to let the error-like test succeed and to couch these
 * complaints as notes on the error.
 *
 * To resolve this, such a malformed error object will still pass
 * `isErrorLike` so marshal can use this for top level error to report from,
 * even if it would not actually validate.
 * Instead, the diagnostics that `assertError` would have reported are
 * attached as notes to the malformed error. Thus, a malformed
 * error is passable by itself, but not as part of a passable structure.
 *
 * @param {unknown} candidate
 * @returns {boolean}
 */
const        isErrorLike=  (candidate)=>checkErrorLike(candidate);$h‍_once.isErrorLike(isErrorLike);
harden(isErrorLike);

/**
 * @type {PassStyleHelper}
 */
const        ErrorHelper=  harden({
  styleName: 'error',

  canBeValid: checkErrorLike,

  assertValid: (candidate)=>{
    ErrorHelper.canBeValid(candidate, assertChecker);
    const proto=  getPrototypeOf(candidate);
    const { name}=   proto;
    const EC=  getErrorConstructor(name);
     EC&&  EC.prototype===  proto||
      Fail `Errors must inherit from an error class .prototype ${candidate}`;

    const {
      // TODO Must allow `cause`, `errors`
      message: mDesc,
      stack: stackDesc,
      ...restDescs}=
        getOwnPropertyDescriptors(candidate);
    ownKeys(restDescs).length<  1||
      Fail `Passed Error has extra unpassed properties ${restDescs}`;
    if( mDesc) {
      typeof mDesc.value===  'string'||
        Fail `Passed Error "message" ${mDesc} must be a string-valued data property.`;
      !mDesc.enumerable||
        Fail `Passed Error "message" ${mDesc} must not be enumerable`;
     }
    if( stackDesc) {
      typeof stackDesc.value===  'string'||
        Fail `Passed Error "stack" ${stackDesc} must be a string-valued data property.`;
      !stackDesc.enumerable||
        Fail `Passed Error "stack" ${stackDesc} must not be enumerable`;
     }
    return true;
   }});


/**
 * Return a new passable error that propagates the diagnostic info of the
 * original, and is linked to the original as a note.
 *
 * @param {Error} err
 * @returns {Error}
 */$h‍_once.ErrorHelper(ErrorHelper);
const        toPassableError=  (err)=>{
  const { name, message}=   err;

  const EC=  getErrorConstructor( `${name}`)|| Error;
  const newError=  harden(new EC( `${message}`));
  // Even the cleaned up error copy, if sent to the console, should
  // cause hidden diagnostic information of the original error
  // to be logged.
  assert.note(newError, X `copied from error ${err}`);
  return newError;
 };$h‍_once.toPassableError(toPassableError);
harden(toPassableError);
})()
,
// === functors[121] ===
({   imports: $h‍_imports,   liveVar: $h‍_live,   onceVar: $h‍_once,   importMeta: $h‍____meta, }) => (function () {   $h‍_imports([]);   const { Fail, quote: q}=   assert;
const { ownKeys}=   Reflect;

/**
 * The well known symbols are static symbol values on the `Symbol` constructor.
 */
const wellKnownSymbolNames=  new Map(
  ownKeys(Symbol).
     filter(
      (name)=>typeof name===  'string'&&  typeof Symbol[name]===  'symbol').

     filter((name)=>{
      // @ts-expect-error It doesn't know name cannot be a symbol
      !name.startsWith('@@')||
        Fail `Did not expect Symbol to have a symbol-valued property name starting with "@@" ${q(
          name)
          }`;
      return true;
     })
    // @ts-ignore It doesn't know name cannot be a symbol
.    map((name)=>[Symbol[name],  `@@${name}`]));


/**
 * The passable symbols are the well known symbols (the symbol values
 * of static properties of the `Symbol` constructor) and the registered
 * symbols.
 *
 * @param {any} sym
 * @returns {boolean}
 */
const        isPassableSymbol=  (sym)=>
  typeof sym===  'symbol'&&(
   typeof Symbol.keyFor(sym)===  'string'||  wellKnownSymbolNames.has(sym));$h‍_once.isPassableSymbol(isPassableSymbol);
harden(isPassableSymbol);

const        assertPassableSymbol=  (sym)=>
  isPassableSymbol(sym)||
  Fail `Only registered symbols or well-known symbols are passable: ${q(sym)}`;$h‍_once.assertPassableSymbol(assertPassableSymbol);
harden(assertPassableSymbol);

/**
 * If `sym` is a passable symbol, return a string that uniquely identifies this
 * symbol. If `sym` is a non-passable symbol, return `undefined`.
 *
 * The passable symbols are the well known symbols (the symbol values
 * of static properties of the `Symbol` constructor) and the registered
 * symbols. Since the registration string of a registered symbol can be any
 * string, if we simply used that to identify those symbols, there would not
 * be any remaining strings left over to identify the well-known symbols.
 * Instead, we reserve strings beginning with `"@@"` for purposes of this
 * encoding. We identify a well known symbol such as `Symbol.iterator`
 * by prefixing the property name with `"@@"`, such as `"@@iterator"`.
 * For registered symbols whose name happens to begin with `"@@"`, such
 * as `Symbol.for('@@iterator')` or `Symbol.for('@@foo')`, we identify
 * them by prefixing them with an extra `"@@"`, such as
 * `"@@@@iterator"` or `"@@@@foo"`. (This is the Hilbert Hotel encoding
 * technique.)
 *
 * @param {symbol} sym
 * @returns {string=}
 */
const        nameForPassableSymbol=  (sym)=>{
  const name=  Symbol.keyFor(sym);
  if( name===  undefined) {
    return wellKnownSymbolNames.get(sym);
   }
  if( name.startsWith('@@')) {
    return  `@@${name}`;
   }
  return name;
 };$h‍_once.nameForPassableSymbol(nameForPassableSymbol);
harden(nameForPassableSymbol);

const AtAtPrefixPattern=  /^@@(.*)$/;
harden(AtAtPrefixPattern);

/**
 * If `name` is a string that could have been produced by
 * `nameForPassableSymbol`, return the symbol argument it was produced to
 * represent.
 *
 *    If `name` does not begin with `"@@"`, then just the corresponding
 *      registered symbol, `Symbol.for(name)`.
 *    If `name` is `"@@"` followed by a well known symbol's property name on
 *      `Symbol` such `"@@iterator", return that well known symbol such as
 *      `Symbol.iterator`
 *    If `name` begins with `"@@@@"` it encodes the registered symbol whose
 *      name begins with `"@@"` instead.
 *    Otherwise, if name begins with `"@@"` it may encode a registered symbol
 *      from a future version of JavaScript, but it is not one we can decode
 *      yet, so throw.
 *
 * @param {string} name
 * @returns {symbol=}
 */
const        passableSymbolForName=  (name)=>{
  if( typeof name!==  'string') {
    return undefined;
   }
  const match=  AtAtPrefixPattern.exec(name);
  if( match) {
    const suffix=  match[1];
    if( suffix.startsWith('@@')) {
      return Symbol.for(suffix);
     }else {
      const sym=  Symbol[suffix];
      if( typeof sym===  'symbol') {
        return sym;
       }
      Fail `Reserved for well known symbol ${q(suffix)}: ${q(name)}`;
     }
   }
  return Symbol.for(name);
 };$h‍_once.passableSymbolForName(passableSymbolForName);
harden(passableSymbolForName);
})()
,
// === functors[122] ===
({   imports: $h‍_imports,   liveVar: $h‍_live,   onceVar: $h‍_once,   importMeta: $h‍____meta, }) => (function () {   let assertChecker,checkNormalProperty;$h‍_imports([["./passStyle-helpers.js", [["assertChecker", [$h‍_a => (assertChecker = $h‍_a)]],["checkNormalProperty", [$h‍_a => (checkNormalProperty = $h‍_a)]]]]]);   



const { details: X}=   assert;
const { getPrototypeOf}=   Object;
const { ownKeys}=   Reflect;
const { isArray, prototype: arrayPrototype}=   Array;

/**
 * @param {unknown} candidate
 * @param {import('./types.js').Checker} [check]
 * @returns {boolean}
 */
const canBeValid=  (candidate, check=  undefined)=>
  isArray(candidate)||
   !!check&&  check(false, X `Array expected: ${candidate}`);

/**
 *
 * @type {import('./internal-types.js').PassStyleHelper}
 */
const        CopyArrayHelper=  harden({
  styleName: 'copyArray',

  canBeValid,

  assertValid: (candidate, passStyleOfRecur)=>  {
    canBeValid(candidate, assertChecker);
    getPrototypeOf(candidate)===  arrayPrototype||
      assert.fail(X `Malformed array: ${candidate}`,TypeError);
    // Since we're already ensured candidate is an array, it should not be
    // possible for the following test to fail
    checkNormalProperty(candidate, 'length', false, assertChecker);
    const len=  /** @type {unknown[]} */  candidate. length;
    for( let i=  0; i<  len; i+=  1) {
      checkNormalProperty(candidate, i, true, assertChecker);
     }
    // +1 for the 'length' property itself.
    ownKeys(candidate).length===  len+  1||
      assert.fail(X `Arrays must not have non-indexes: ${candidate}`,TypeError);
    // Recursively validate that each member is passable.
    candidate.every((v)=>!!passStyleOfRecur(v));
   }});$h‍_once.CopyArrayHelper(CopyArrayHelper);
})()
,
// === functors[123] ===
({   imports: $h‍_imports,   liveVar: $h‍_live,   onceVar: $h‍_once,   importMeta: $h‍____meta, }) => (function () {   let assertChecker,canBeMethod,checkNormalProperty;$h‍_imports([["./passStyle-helpers.js", [["assertChecker", [$h‍_a => (assertChecker = $h‍_a)]],["canBeMethod", [$h‍_a => (canBeMethod = $h‍_a)]],["checkNormalProperty", [$h‍_a => (checkNormalProperty = $h‍_a)]]]]]);   







const { details: X}=   assert;
const { ownKeys}=   Reflect;
const { getPrototypeOf, values, prototype: objectPrototype}=   Object;

/**
 *
 * @type {import('./internal-types.js').PassStyleHelper}
 */
const        CopyRecordHelper=  harden({
  styleName: 'copyRecord',

  canBeValid: (candidate, check=  undefined)=>  {
    const reject=  !!check&&(  (details)=>check(false, details));
    if( getPrototypeOf(candidate)!==  objectPrototype) {
      return(
        reject&&
        reject(X `Records must inherit from Object.prototype: ${candidate}`));

     }

    return ownKeys(candidate).every((key)=>{
      return(
        (typeof key===  'string'||
           !!reject&&
            reject(
              X `Records can only have string-named properties: ${candidate}`))&&(

         !canBeMethod(candidate[key])||
           !!reject&&
            reject(
              // TODO: Update message now that there is no such thing as "implicit Remotable".
              X `Records cannot contain non-far functions because they may be methods of an implicit Remotable: ${candidate}`)));


     });
   },

  assertValid: (candidate, passStyleOfRecur)=>  {
    CopyRecordHelper.canBeValid(candidate, assertChecker);
    for( const name of ownKeys(candidate)) {
      checkNormalProperty(candidate, name, true, assertChecker);
     }
    // Recursively validate that each member is passable.
    for( const val of values(candidate)) {
      passStyleOfRecur(val);
     }
   }});$h‍_once.CopyRecordHelper(CopyRecordHelper);
})()
,
// === functors[124] ===
({   imports: $h‍_imports,   liveVar: $h‍_live,   onceVar: $h‍_once,   importMeta: $h‍____meta, }) => (function () {   let assertChecker,checkTagRecord,PASS_STYLE,checkNormalProperty,checkPassStyle;$h‍_imports([["./passStyle-helpers.js", [["assertChecker", [$h‍_a => (assertChecker = $h‍_a)]],["checkTagRecord", [$h‍_a => (checkTagRecord = $h‍_a)]],["PASS_STYLE", [$h‍_a => (PASS_STYLE = $h‍_a)]],["checkNormalProperty", [$h‍_a => (checkNormalProperty = $h‍_a)]],["checkPassStyle", [$h‍_a => (checkPassStyle = $h‍_a)]]]]]);   









const { Fail}=   assert;
const { ownKeys}=   Reflect;
const { getOwnPropertyDescriptors}=   Object;

/**
 *
 * @type {import('./internal-types.js').PassStyleHelper}
 */
const        TaggedHelper=  harden({
  styleName: 'tagged',

  canBeValid: (candidate, check=  undefined)=>
    checkPassStyle(candidate, 'tagged', check),

  assertValid: (candidate, passStyleOfRecur)=>  {
    checkTagRecord(candidate, 'tagged', assertChecker);

    // Typecasts needed due to https://github.com/microsoft/TypeScript/issues/1863
    const passStyleKey=  /** @type {unknown} */  PASS_STYLE;
    const tagKey=  /** @type {unknown} */  Symbol.toStringTag;
    const {
      // checkTagRecord already verified PASS_STYLE and Symbol.toStringTag own data properties.
      [/** @type {string} */  passStyleKey]:  _passStyleDesc,
      [/** @type {string} */  tagKey]:  _labelDesc,
      payload: _payloadDesc, // value checked by recursive walk at the end
      ...restDescs}=
        getOwnPropertyDescriptors(candidate);
    ownKeys(restDescs).length===  0||
      Fail `Unexpected properties on tagged record ${ownKeys(restDescs)}`;

    checkNormalProperty(candidate, 'payload', true, assertChecker);

    // Recursively validate that each member is passable.
    passStyleOfRecur(candidate.payload);
   }});$h‍_once.TaggedHelper(TaggedHelper);
})()
,
// === functors[125] ===
({   imports: $h‍_imports,   liveVar: $h‍_live,   onceVar: $h‍_once,   importMeta: $h‍____meta, }) => (function () {   let isPromise,assertChecker,hasOwnPropertyOf;$h‍_imports([["@endo/promise-kit", [["isPromise", [$h‍_a => (isPromise = $h‍_a)]]]],["./passStyle-helpers.js", [["assertChecker", [$h‍_a => (assertChecker = $h‍_a)]],["hasOwnPropertyOf", [$h‍_a => (hasOwnPropertyOf = $h‍_a)]]]]]);   




/** @typedef {import('./types.js').Checker} Checker */

const { details: X, quote: q}=   assert;
const { isFrozen, getPrototypeOf}=   Object;
const { ownKeys}=   Reflect;

/**
 * @param {Promise} pr The value to examine
 * @param {Checker} check
 * @returns {pr is Promise} Whether it is a safe promise
 */
const checkPromiseOwnKeys=  (pr, check)=>  {
  const reject=  (details)=>check(false, details);
  const keys=  ownKeys(pr);

  if( keys.length===  0) {
    return true;
   }

  const unknownKeys=  keys.filter(
    (key)=>typeof key!==  'symbol'||  !hasOwnPropertyOf(Promise.prototype, key));


  if( unknownKeys.length!==  0) {
    return reject(
      X `${pr} - Must not have any own properties: ${q(unknownKeys)}`);

   }

  /**
   * At the time of this writing, Node's async_hooks contains the
   * following code, which we can also safely tolerate
   *
   * ```js
   * function destroyTracking(promise, parent) {
   * trackPromise(promise, parent);
   *   const asyncId = promise[async_id_symbol];
   *   const destroyed = { destroyed: false };
   *   promise[destroyedSymbol] = destroyed;
   *   registerDestroyHook(promise, asyncId, destroyed);
   * }
   * ```
   *
   * @param {string|symbol} key
   */
  const checkSafeAsyncHooksKey=  (key)=>{
    const val=  pr[key];
    if( val===  undefined||  typeof val===  'number') {
      return true;
     }
    if(
      typeof val===  'object'&&
      val!==  null&&
      isFrozen(val)&&
      getPrototypeOf(val)===  Object.prototype)
      {
      const subKeys=  ownKeys(val);
      if( subKeys.length===  0) {
        return true;
       }

      if(
        subKeys.length===  1&&
        subKeys[0]===  'destroyed'&&
        val.destroyed===  false)
        {
        return true;
       }
     }
    return reject(
      X `Unexpected Node async_hooks additions to promise: ${pr}.${q(
        String(key))
        } is ${val}`);

   };

  return keys.every(checkSafeAsyncHooksKey);
 };

/**
 * Under Hardened JS a promise is "safe" if its `then` method can be called
 * synchronously without giving the promise an opportunity for a
 * reentrancy attack during that call.
 *
 * https://github.com/Agoric/agoric-sdk/issues/9
 * raises the issue of testing that a specimen is a safe promise
 * such that the test also does not give the specimen a
 * reentrancy opportunity. That is well beyond the ambition here.
 * TODO Though if we figure out a nice solution, it might be good to
 * use it here as well.
 *
 * @param {unknown} pr The value to examine
 * @param {Checker} check
 * @returns {pr is Promise} Whether it is a safe promise
 */
const checkSafePromise=  (pr, check)=>  {
  const reject=  (details)=>check(false, details);
  return(
    (isFrozen(pr)||  reject(X `${pr} - Must be frozen`))&&(
     isPromise(pr)||  reject(X `${pr} - Must be a promise`))&&(
     getPrototypeOf(pr)===  Promise.prototype||
      reject(
        X `${pr} - Must inherit from Promise.prototype: ${q(
          getPrototypeOf(pr))
          }`))&&

    checkPromiseOwnKeys(/** @type {Promise} */  pr,  check));

 };
harden(checkSafePromise);

/**
 * Determine if the argument is a Promise.
 *
 * @param {unknown} pr The value to examine
 * @returns {pr is Promise} Whether it is a promise
 */
const        isSafePromise=  (pr)=>checkSafePromise(pr, (x)=>x);$h‍_once.isSafePromise(isSafePromise);
harden(isSafePromise);

const        assertSafePromise=  (pr)=>checkSafePromise(pr, assertChecker);$h‍_once.assertSafePromise(assertSafePromise);
})()
,
// === functors[126] ===
({   imports: $h‍_imports,   liveVar: $h‍_live,   onceVar: $h‍_once,   importMeta: $h‍____meta, }) => (function () {   let isPromise,isObject,isTypedArray,PASS_STYLE,CopyArrayHelper,CopyRecordHelper,TaggedHelper,ErrorHelper,RemotableHelper,assertPassableSymbol,assertSafePromise;$h‍_imports([["@endo/promise-kit", [["isPromise", [$h‍_a => (isPromise = $h‍_a)]]]],["./passStyle-helpers.js", [["isObject", [$h‍_a => (isObject = $h‍_a)]],["isTypedArray", [$h‍_a => (isTypedArray = $h‍_a)]],["PASS_STYLE", [$h‍_a => (PASS_STYLE = $h‍_a)]]]],["./copyArray.js", [["CopyArrayHelper", [$h‍_a => (CopyArrayHelper = $h‍_a)]]]],["./copyRecord.js", [["CopyRecordHelper", [$h‍_a => (CopyRecordHelper = $h‍_a)]]]],["./tagged.js", [["TaggedHelper", [$h‍_a => (TaggedHelper = $h‍_a)]]]],["./error.js", [["ErrorHelper", [$h‍_a => (ErrorHelper = $h‍_a)]]]],["./remotable.js", [["RemotableHelper", [$h‍_a => (RemotableHelper = $h‍_a)]]]],["./symbol.js", [["assertPassableSymbol", [$h‍_a => (assertPassableSymbol = $h‍_a)]]]],["./safe-promise.js", [["assertSafePromise", [$h‍_a => (assertSafePromise = $h‍_a)]]]]]);   















/** @typedef {import('./internal-types.js').PassStyleHelper} PassStyleHelper */
/** @typedef {import('./types.js').Passable} Passable */
/** @typedef {import('./types.js').PassStyle} PassStyle */
/** @typedef {import('./types.js').PassStyleOf} PassStyleOf */
/** @typedef {import('./types.js').PrimitiveStyle} PrimitiveStyle */

/** @typedef {Exclude<PassStyle, PrimitiveStyle | "promise">} HelperPassStyle */

const { details: X, Fail, quote: q}=   assert;
const { ownKeys}=   Reflect;
const { isFrozen}=   Object;

/**
 * @param {PassStyleHelper[]} passStyleHelpers
 * @returns {Record<HelperPassStyle, PassStyleHelper> }
 */

const makeHelperTable=  (passStyleHelpers)=>{
  /** @type {Record<HelperPassStyle, any> & {__proto__: null}} */
  const HelperTable=  {
    __proto__: null,
    copyArray: undefined,
    copyRecord: undefined,
    tagged: undefined,
    error: undefined,
    remotable: undefined};

  for( const helper of passStyleHelpers) {
    const { styleName}=   helper;
    styleName in HelperTable||  Fail `Unrecognized helper: ${q(styleName)}`;
    HelperTable[styleName]===  undefined||
      Fail `conflicting helpers for ${q(styleName)}`;
    HelperTable[styleName]=  helper;
   }
  for( const styleName of ownKeys(HelperTable)) {
    HelperTable[styleName]!==  undefined||
      Fail `missing helper for ${q(styleName)}`;
   }

  return harden(HelperTable);
 };

/**
 * @param {PassStyleHelper[]} passStyleHelpers The passStyleHelpers to register,
 * in priority order.
 * NOTE These must all be "trusted",
 * complete, and non-colliding. `makePassStyleOf` may *assume* that each helper
 * does what it is supposed to do. `makePassStyleOf` is not trying to defend
 * itself against malicious helpers, though it does defend against some
 * accidents.
 * @returns {PassStyleOf}
 */
const makePassStyleOf=  (passStyleHelpers)=>{
  const HelperTable=  makeHelperTable(passStyleHelpers);
  const remotableHelper=  HelperTable.remotable;

  /**
   * Purely for performance. However it is mutable static state, and
   * it does have some observability on proxies. TODO need to assess
   * whether this creates a static communications channel.
   *
   * passStyleOf does a full recursive walk of pass-by-copy
   * structures, in order to validate that they are acyclic. In addition
   * it is used by other algorithms to recursively walk these pass-by-copy
   * structures, so without this cache, these algorithms could be
   * O(N**2) or worse.
   *
   * @type {WeakMap<Passable, PassStyle>}
   */
  const passStyleMemo=  new WeakMap();

  /**
   * @type {PassStyleOf}
   */
  const passStyleOf=  (passable)=>{
    // Even when a WeakSet is correct, when the set has a shorter lifetime
    // than its keys, we prefer a Set due to expected implementation
    // tradeoffs.
    const inProgress=  new Set();

    /**
     * @type {PassStyleOf}
     */
    const passStyleOfRecur=  (inner)=>{
      const innerIsObject=  isObject(inner);
      if( innerIsObject) {
        if( passStyleMemo.has(inner)) {
          // @ts-ignore TypeScript doesn't know that `get` after `has` is safe
          return passStyleMemo.get(inner);
         }
        !inProgress.has(inner)||
          Fail `Pass-by-copy data cannot be cyclic ${inner}`;
        inProgress.add(inner);
       }
      // eslint-disable-next-line no-use-before-define
      const passStyle=  passStyleOfInternal(inner);
      if( innerIsObject) {
        passStyleMemo.set(inner, passStyle);
        inProgress.delete(inner);
       }
      return passStyle;
     };

    /**
     * @type {PassStyleOf}
     */
    const passStyleOfInternal=  (inner)=>{
      const typestr=  typeof inner;
      switch( typestr){
        case 'undefined':
        case 'string':
        case 'boolean':
        case 'number':
        case 'bigint': {
          return typestr;
         }
        case 'symbol': {
          assertPassableSymbol(inner);
          return 'symbol';
         }
        case 'object': {
          if( inner===  null) {
            return 'null';
           }
          if( !isFrozen(inner)) {
            assert.fail(
              // TypedArrays get special treatment in harden()
              // and a corresponding special error message here.
              isTypedArray(inner)?
                  X `Cannot pass mutable typed arrays like ${inner}.`:
                  X `Cannot pass non-frozen objects like ${inner}. Use harden()`);

           }
          if( isPromise(inner)) {
            assertSafePromise(inner);
            return 'promise';
           }
          typeof inner.then!==  'function'||
            Fail `Cannot pass non-promise thenables`;
          const passStyleTag=  inner[PASS_STYLE];
          if( passStyleTag!==  undefined) {
            assert.typeof(passStyleTag, 'string');
            const helper=  HelperTable[passStyleTag];
            helper!==  undefined||
              Fail `Unrecognized PassStyle: ${q(passStyleTag)}`;
            helper.assertValid(inner, passStyleOfRecur);
            return (/** @type {PassStyle} */ passStyleTag);
           }
          for( const helper of passStyleHelpers) {
            if( helper.canBeValid(inner)) {
              helper.assertValid(inner, passStyleOfRecur);
              return helper.styleName;
             }
           }
          remotableHelper.assertValid(inner, passStyleOfRecur);
          return 'remotable';
         }
        case 'function': {
          isFrozen(inner)||
            Fail `Cannot pass non-frozen objects like ${inner}. Use harden()`;
          typeof inner.then!==  'function'||
            Fail `Cannot pass non-promise thenables`;
          remotableHelper.assertValid(inner, passStyleOfRecur);
          return 'remotable';
         }
        default: {
          throw assert.fail(X `Unrecognized typeof ${q(typestr)}`,TypeError);
         }}

     };

    return passStyleOfRecur(passable);
   };
  return harden(passStyleOf);
 };

/**
 * If there is already a `VataData` global containing a `passStyleOf`,
 * then presumably it was endowed for us by liveslots, so we should use
 * and export that one instead. Other software may have left it for us here,
 * but it would require write access to our global, or the ability to
 * provide endowments to our global, both of which seems adequate as a test of
 * whether it is authorized to serve the same role as liveslots.
 *
 * NOTE HAZARD: This use by liveslots does rely on `passStyleOf` being
 * deterministic. If it is not, then in a liveslot-like virtualized
 * environment, it can be used to detect GC.
 *
 * @type {PassStyleOf}
 */
const        passStyleOf=
  // UNTIL https://github.com/endojs/endo/issues/1514
  // Prefer: globalThis?.VatData?.passStyleOf ||
   globalThis&&  globalThis.VatData&&  globalThis.VatData.passStyleOf||
  makePassStyleOf([
    CopyArrayHelper,
    CopyRecordHelper,
    TaggedHelper,
    ErrorHelper,
    RemotableHelper]);$h‍_once.passStyleOf(passStyleOf);


const        assertPassable=  (val)=>{
  passStyleOf(val); // throws if val is not a passable
 };$h‍_once.assertPassable(assertPassable);
harden(assertPassable);
})()
,
// === functors[127] ===
({   imports: $h‍_imports,   liveVar: $h‍_live,   onceVar: $h‍_once,   importMeta: $h‍____meta, }) => (function () {   let PASS_STYLE,assertPassable;$h‍_imports([["./passStyle-helpers.js", [["PASS_STYLE", [$h‍_a => (PASS_STYLE = $h‍_a)]]]],["./passStyleOf.js", [["assertPassable", [$h‍_a => (assertPassable = $h‍_a)]]]]]);   




const { create, prototype: objectPrototype}=   Object;
const { Fail}=   assert;

const        makeTagged=  (tag, payload)=>  {
  typeof tag===  'string'||
    Fail `The tag of a tagged record must be a string: ${tag}`;
  assertPassable(harden(payload));
  return harden(
    create(objectPrototype, {
      [PASS_STYLE]: { value: 'tagged'},
      [Symbol.toStringTag]: { value: tag},
      payload: { value: payload, enumerable: true}}));


 };$h‍_once.makeTagged(makeTagged);
harden(makeTagged);
})()
,
// === functors[128] ===
({   imports: $h‍_imports,   liveVar: $h‍_live,   onceVar: $h‍_once,   importMeta: $h‍____meta, }) => (function () {   let passStyleOf;$h‍_imports([["./passStyleOf.js", [["passStyleOf", [$h‍_a => (passStyleOf = $h‍_a)]]]]]);   

/** @typedef {import('./types.js').Passable} Passable */
/**
 * @template {Passable} [T=Passable]
 * @typedef {import('./types.js').CopyArray<T>} CopyArray
 */
/**
 * @template {Passable} [T=Passable]
 * @typedef {import('./types.js').CopyRecord<T>} CopyRecord
 */
/** @typedef {import('./types.js').RemotableObject} Remotable */

const { Fail, quote: q}=   assert;

/**
 * Check whether the argument is a pass-by-copy array, AKA a "copyArray"
 * in @endo/marshal terms
 *
 * @param {Passable} arr
 * @returns {arr is CopyArray<any>}
 */
const isCopyArray=  (arr)=>passStyleOf(arr)===  'copyArray';$h‍_once.isCopyArray(isCopyArray);
harden(isCopyArray);

/**
 * Check whether the argument is a pass-by-copy record, AKA a
 * "copyRecord" in @endo/marshal terms
 *
 * @param {Passable} record
 * @returns {record is CopyRecord<any>}
 */
const isRecord=  (record)=>passStyleOf(record)===  'copyRecord';$h‍_once.isRecord(isRecord);
harden(isRecord);

/**
 * Check whether the argument is a remotable.
 *
 * @param {Passable} remotable
 * @returns {remotable is Remotable}
 */
const isRemotable=  (remotable)=>passStyleOf(remotable)===  'remotable';$h‍_once.isRemotable(isRemotable);
harden(isRemotable);

/**
 * @callback AssertArray
 * @param {Passable} array
 * @param {string=} optNameOfArray
 * @returns {asserts array is CopyArray<any>}
 */

/** @type {AssertArray} */
const assertCopyArray=  (array, optNameOfArray=  'Alleged array')=>  {
  const passStyle=  passStyleOf(array);
  passStyle===  'copyArray'||
    Fail `${q(optNameOfArray)} ${array} must be a pass-by-copy array, not ${q(
      passStyle)
      }`;
 };$h‍_once.assertCopyArray(assertCopyArray);
harden(assertCopyArray);

/**
 * @callback AssertRecord
 * @param {Passable} record
 * @param {string=} optNameOfRecord
 * @returns {asserts record is CopyRecord<any>}
 */

/** @type {AssertRecord} */
const assertRecord=  (record, optNameOfRecord=  'Alleged record')=>  {
  const passStyle=  passStyleOf(record);
  passStyle===  'copyRecord'||
    Fail `${q(optNameOfRecord)} ${record} must be a pass-by-copy record, not ${q(
      passStyle)
      }`;
 };$h‍_once.assertRecord(assertRecord);
harden(assertRecord);

/**
 * @callback AssertRemotable
 * @param {Passable} remotable
 * @param {string=} optNameOfRemotable
 * @returns {asserts remotable is Remotable}
 */

/** @type {AssertRemotable} */
const assertRemotable=  (
  remotable,
  optNameOfRemotable=  'Alleged remotable')=>
     {
  const passStyle=  passStyleOf(remotable);
  passStyle===  'remotable'||
    Fail `${q(optNameOfRemotable)} ${remotable} must be a remotable, not ${q(
      passStyle)
      }`;
 };$h‍_once.assertRemotable(assertRemotable);
harden(assertRemotable);
})()
,
// === functors[129] ===
({   imports: $h‍_imports,   liveVar: $h‍_live,   onceVar: $h‍_once,   importMeta: $h‍____meta, }) => (function () {   $h‍_imports([]);   
})()
,
// === functors[130] ===
({   imports: $h‍_imports,   liveVar: $h‍_live,   onceVar: $h‍_once,   importMeta: $h‍____meta, }) => (function () {   $h‍_imports([["./src/iter-helpers.js", []],["./src/passStyle-helpers.js", []],["./src/error.js", []],["./src/remotable.js", []],["./src/symbol.js", []],["./src/passStyleOf.js", []],["./src/makeTagged.js", []],["./src/make-far.js", []],["./src/typeGuards.js", []],["./src/types.js", []]]);   
})()
,
// === functors[131] ===
({   imports: $h‍_imports,   liveVar: $h‍_live,   onceVar: $h‍_once,   importMeta: $h‍____meta, }) => (function () {   $h‍_imports([["@endo/eventual-send", []],["@endo/pass-style", []]]);   
})()
,
// === functors[132] ===
({   imports: $h‍_imports,   liveVar: $h‍_live,   onceVar: $h‍_once,   importMeta: $h‍____meta, }) => (function () {   $h‍_imports([]);Object.defineProperty(isNat, 'name', {value: "isNat"});$h‍_once.isNat(isNat);Object.defineProperty(Nat, 'name', {value: "Nat"});$h‍_once.Nat(Nat);   // Copyright (C) 2011 Google Inc.
// Copyright (C) 2018 Agoric
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// @ts-check

/**
 * Is `allegedNum` a number in the [contiguous range of exactly and
 * unambiguously
 * representable](https://esdiscuss.org/topic/more-numeric-constants-please-especially-epsilon#content-14)
 *  natural numbers (non-negative integers)?
 *
 * To qualify `allegedNum` must either be a
 * non-negative `bigint`, or a non-negative `number` representing an integer
 * within range of [integers safely representable in
 * floating point](https://tc39.es/ecma262/#sec-number.issafeinteger).
 *
 * @param {unknown} allegedNum
 * @returns {boolean}
 */
function isNat(allegedNum) {
  if( typeof allegedNum===  'bigint') {
    return allegedNum>=  0;
   }
  if( typeof allegedNum!==  'number') {
    return false;
   }

  return Number.isSafeInteger(allegedNum)&&  allegedNum>=  0;
 }

/**
 * If `allegedNumber` passes the `isNat` test, then return it as a bigint.
 * Otherwise throw an appropriate error.
 *
 * If `allegedNum` is neither a bigint nor a number, `Nat` throws a `TypeError`.
 * Otherwise, if it is not a [safely
 * representable](https://esdiscuss.org/topic/more-numeric-constants-please-especially-epsilon#content-14)
 * non-negative integer, `Nat` throws a `RangeError`.
 * Otherwise, it is converted to a bigint if necessary and returned.
 *
 * @param {unknown} allegedNum
 * @returns {bigint}
 */
function Nat(allegedNum) {
  if( typeof allegedNum===  'bigint') {
    if( allegedNum<  0) {
      throw RangeError( `${allegedNum} is negative`);
     }
    return allegedNum;
   }

  if( typeof allegedNum===  'number') {
    if( !Number.isSafeInteger(allegedNum)) {
      throw RangeError( `${allegedNum} not a safe integer`);
     }
    if( allegedNum<  0) {
      throw RangeError( `${allegedNum} is negative`);
     }
    return BigInt(allegedNum);
   }

  throw TypeError(
     `${allegedNum} is a ${typeof allegedNum} but must be a bigint or a number`);

 }
})()
,
// === functors[133] ===
({   imports: $h‍_imports,   liveVar: $h‍_live,   onceVar: $h‍_once,   importMeta: $h‍____meta, }) => (function () {   let E,isPromise,getTag,isObject,makeTagged,passStyleOf;$h‍_imports([["@endo/eventual-send", [["E", [$h‍_a => (E = $h‍_a)]]]],["@endo/promise-kit", [["isPromise", [$h‍_a => (isPromise = $h‍_a)]]]],["@endo/pass-style", [["getTag", [$h‍_a => (getTag = $h‍_a)]],["isObject", [$h‍_a => (isObject = $h‍_a)]],["makeTagged", [$h‍_a => (makeTagged = $h‍_a)]],["passStyleOf", [$h‍_a => (passStyleOf = $h‍_a)]]]]]);   





/** @typedef {import('@endo/pass-style').Passable} Passable */
/** @template T @typedef {import('@endo/eventual-send').ERef<T>} ERef */

const { details: X, quote: q}=   assert;
const { ownKeys}=   Reflect;
const { fromEntries}=   Object;

/**
 * Given a Passable `val` whose pass-by-copy structure may contain leaf
 * promises, return a promise for a replacement Passable,
 * where that replacement is *deeply fulfilled*, i.e., its
 * pass-by-copy structure does not contain any promises.
 *
 * This is a deep form of `Promise.all` specialized for Passables. For each
 * encountered promise, replace it with the deeply fulfilled form of
 * its fulfillment.
 * If any of the promises reject, then the promise for the replacement
 * rejects. If any of the promises never settle, then the promise for
 * the replacement never settles.
 *
 * If the replacement would not be Passable, i.e., if `val` is not
 * Passable, or if any of the transitive promises fulfill to something
 * that is not Passable, then the returned promise rejects.
 *
 * If `val` or its parts are non-key Passables only *because* they contains
 * promises, the deeply fulfilled forms of val or its parts may be keys. This
 * is for the higher "store" level of abstraction to determine, because it
 * defines the "key" notion in question.
 *
 * // TODO: That higher level is in the process of being migrated from
 * // `@agoric/store` to `@endo/patterns`. Once that is far enough along,
 * // revise the above comment to match.
 * // See https://github.com/endojs/endo/pull/1451
 *
 * @param {Passable} val
 * @returns {Promise<Passable>}
 */
const        deeplyFulfilled=  async(val)=> {
  if( !isObject(val)) {
    return val;
   }
  if( isPromise(val)) {
    return E.when(val, (nonp)=>deeplyFulfilled(nonp));
   }
  const passStyle=  passStyleOf(val);
  switch( passStyle){
    case 'copyRecord': {
      const names=  ownKeys(val);
      const valPs=  names.map((name)=>deeplyFulfilled(val[name]));
      return E.when(Promise.all(valPs), (vals)=>
        harden(fromEntries(vals.map((c, i)=>  [names[i], c]))));

     }
    case 'copyArray': {
      const valPs=  val.map((p)=>deeplyFulfilled(p));
      return E.when(Promise.all(valPs), (vals)=>harden(vals));
     }
    case 'tagged': {
      const tag=  getTag(val);
      return E.when(deeplyFulfilled(val.payload), (payload)=>
        makeTagged(tag, payload));

     }
    case 'remotable': {
      return val;
     }
    case 'error': {
      return val;
     }
    case 'promise': {
      return E.when(val, (nonp)=>deeplyFulfilled(nonp));
     }
    default: {
      throw assert.fail(X `Unexpected passStyle ${q(passStyle)}`,TypeError);
     }}

 };$h‍_once.deeplyFulfilled(deeplyFulfilled);
harden(deeplyFulfilled);
})()
,
// === functors[134] ===
({   imports: $h‍_imports,   liveVar: $h‍_live,   onceVar: $h‍_once,   importMeta: $h‍____meta, }) => (function () {   let passStyleOf,isErrorLike,makeTagged,isObject,getTag,hasOwnPropertyOf,assertPassableSymbol,nameForPassableSymbol,passableSymbolForName;$h‍_imports([["@endo/pass-style", [["passStyleOf", [$h‍_a => (passStyleOf = $h‍_a)]],["isErrorLike", [$h‍_a => (isErrorLike = $h‍_a)]],["makeTagged", [$h‍_a => (makeTagged = $h‍_a)]],["isObject", [$h‍_a => (isObject = $h‍_a)]],["getTag", [$h‍_a => (getTag = $h‍_a)]],["hasOwnPropertyOf", [$h‍_a => (hasOwnPropertyOf = $h‍_a)]],["assertPassableSymbol", [$h‍_a => (assertPassableSymbol = $h‍_a)]],["nameForPassableSymbol", [$h‍_a => (nameForPassableSymbol = $h‍_a)]],["passableSymbolForName", [$h‍_a => (passableSymbolForName = $h‍_a)]]]]]);   



















/** @typedef {import('@endo/pass-style').Passable} Passable */
/** @typedef {import('./types.js').Encoding} Encoding */
/** @typedef {import('@endo/pass-style').Remotable} Remotable */
/** @typedef {import('./types.js').EncodingUnion} EncodingUnion */

const { ownKeys}=   Reflect;
const { isArray}=   Array;
const {
  getOwnPropertyDescriptors,
  defineProperties,
  is,
  entries,
  fromEntries,
  freeze}=
    Object;
const { details: X, Fail, quote: q}=   assert;

/**
 * Special property name that indicates an encoding that needs special
 * decoding.
 */
const QCLASS=  '@qclass';$h‍_once.QCLASS(QCLASS);


/**
 * @param {Encoding} encoded
 * @returns {encoded is EncodingUnion}
 */
const hasQClass=  (encoded)=>hasOwnPropertyOf(encoded, QCLASS);

/**
 * @param {Encoding} encoded
 * @param {string} qclass
 * @returns {boolean}
 */
const qclassMatches=  (encoded, qclass)=>
  isObject(encoded)&&
  !isArray(encoded)&&
  hasQClass(encoded)&&
  encoded[QCLASS]===  qclass;

/**
 * @typedef {object} EncodeToCapDataOptions
 * @property {(
 *   remotable: Remotable,
 *   encodeRecur: (p: Passable) => Encoding
 * ) => Encoding} [encodeRemotableToCapData]
 * @property {(
 *   promise: Promise,
 *   encodeRecur: (p: Passable) => Encoding
 * ) => Encoding} [encodePromiseToCapData]
 * @property {(
 *   error: Error,
 *   encodeRecur: (p: Passable) => Encoding
 * ) => Encoding} [encodeErrorToCapData]
 */

const dontEncodeRemotableToCapData=  (rem)=>Fail `remotable unexpected: ${rem}`;

const dontEncodePromiseToCapData=  (prom)=>Fail `promise unexpected: ${prom}`;

const dontEncodeErrorToCapData=  (err)=>Fail `error object unexpected: ${err}`;

/**
 * @param {EncodeToCapDataOptions} [encodeOptions]
 * @returns {(passable: Passable) => Encoding}
 */
const        makeEncodeToCapData=  (encodeOptions=  {})=>  {
  const {
    encodeRemotableToCapData=  dontEncodeRemotableToCapData,
    encodePromiseToCapData=  dontEncodePromiseToCapData,
    encodeErrorToCapData=  dontEncodeErrorToCapData}=
      encodeOptions;

  /**
   * Must encode `val` into plain JSON data *canonically*, such that
   * `JSON.stringify(encode(v1)) === JSON.stringify(encode(v1))`. For most
   * encodings, the order of properties of each node of the output
   * structure is determined by the algorithm below without special
   * arrangement, usually by being expressed directly as an object literal.
   * The exception is copyRecords, whose natural enumeration order
   * can differ between copyRecords that our distributed object semantics
   * considers to be equivalent.
   * Since, for each copyRecord, we only accept string property names,
   * not symbols, we can canonically sort the names first.
   * JSON.stringify will then visit these in that sorted order.
   *
   * Encoding with a canonical-JSON encoder would also solve this canonicalness
   * problem in a more modular and encapsulated manner. Note that the
   * actual order produced here, though it agrees with canonical-JSON on
   * copyRecord property ordering, differs from canonical-JSON as a whole
   * in that the other record properties are visited in the order in which
   * they are literally written below. TODO perhaps we should indeed switch
   * to a canonical JSON encoder, and not delicately depend on the order
   * in which these object literals are written.
   *
   * Readers must not care about this order anyway. We impose this requirement
   * mainly to reduce non-determinism exposed outside a vat.
   *
   * @param {Passable} passable
   * @returns {Encoding} except that `encodeToCapData` does not generally
   * `harden` this result before returning. Rather, `encodeToCapData` is not
   * directly exposed.
   * What's exposed instead is a wrapper that freezes the output before
   * returning. If this turns out to impede static analysis for `harden` safety,
   * we can always put the (now redundant) hardens back in. They don't hurt.
   */
  const encodeToCapDataRecur=  (passable)=>{
    // First we handle all primitives. Some can be represented directly as
    // JSON, and some must be encoded as [QCLASS] composites.
    const passStyle=  passStyleOf(passable);
    switch( passStyle){
      case 'null':
      case 'boolean':
      case 'string': {
        // pass through to JSON
        return passable;
       }
      case 'undefined': {
        return { [QCLASS]: 'undefined'};
       }
      case 'number': {
        // Special-case numbers with no digit-based representation.
        if( Number.isNaN(passable)) {
          return { [QCLASS]: 'NaN'};
         }else if( passable===  Infinity) {
          return { [QCLASS]: 'Infinity'};
         }else if( passable===  -Infinity) {
          return { [QCLASS]: '-Infinity'};
         }
        // Pass through everything else, replacing -0 with 0.
        return is(passable, -0)?  0:  passable;
       }
      case 'bigint': {
        return {
          [QCLASS]: 'bigint',
          digits: String(passable)};

       }
      case 'symbol': {
        assertPassableSymbol(passable);
        const name=  /** @type {string} */  nameForPassableSymbol(passable);
        return {
          [QCLASS]: 'symbol',
          name};

       }
      case 'copyRecord': {
        if( hasOwnPropertyOf(passable, QCLASS)) {
          // Hilbert hotel
          const { [QCLASS]: qclassValue, ...rest}=   passable;
          /** @type {Encoding} */
          const result=  {
            [QCLASS]: 'hilbert',
            original: encodeToCapDataRecur(qclassValue)};

          if( ownKeys(rest).length>=  1) {
            // We harden the entire capData encoding before we return it.
            // `encodeToCapData` requires that its input be Passable, and
            // therefore hardened.
            // The `freeze` here is needed anyway, because the `rest` is
            // freshly constructed by the `...` above, and we're using it
            // as imput in another call to `encodeToCapData`.
            result.rest=  encodeToCapDataRecur(freeze(rest));
           }
          return result;
         }
        // Currently copyRecord allows only string keys so this will
        // work. If we allow sortable symbol keys, this will need to
        // become more interesting.
        const names=  ownKeys(passable).sort();
        return fromEntries(
          names.map((name)=>[name, encodeToCapDataRecur(passable[name])]));

       }
      case 'copyArray': {
        return passable.map(encodeToCapDataRecur);
       }
      case 'tagged': {
        return {
          [QCLASS]: 'tagged',
          tag: getTag(passable),
          payload: encodeToCapDataRecur(passable.payload)};

       }
      case 'remotable': {
        const encoded=  encodeRemotableToCapData(
          passable,
          encodeToCapDataRecur);

        if( qclassMatches(encoded, 'slot')) {
          return encoded;
         }
        // `throw` is noop since `Fail` throws. But linter confused
        throw Fail `internal: Remotable encoding must be an object with ${q(
          QCLASS)
          } ${q('slot')}: ${encoded}`;
       }
      case 'promise': {
        const encoded=  encodePromiseToCapData(passable, encodeToCapDataRecur);
        if( qclassMatches(encoded, 'slot')) {
          return encoded;
         }
        throw Fail `internal: Promise encoding must be an object with ${q(
          QCLASS,
          'slot')
          }: ${encoded}`;
       }
      case 'error': {
        const encoded=  encodeErrorToCapData(passable, encodeToCapDataRecur);
        if( qclassMatches(encoded, 'error')) {
          return encoded;
         }
        throw Fail `internal: Error encoding must be an object with ${q(
          QCLASS,
          'error')
          }: ${encoded}`;
       }
      default: {
        throw assert.fail(
          X `internal: Unrecognized passStyle ${q(passStyle)}`,
          TypeError);

       }}

   };
  const encodeToCapData=  (passable)=>{
    if( isErrorLike(passable)) {
      // We pull out this special case to accommodate errors that are not
      // valid Passables. For example, because they're not frozen.
      // The special case can only ever apply at the root, and therefore
      // outside the recursion, since an error could only be deeper in
      // a passable structure if it were passable.
      //
      // We pull out this special case because, for these errors, we're much
      // more interested in reporting whatever diagnostic information they
      // carry than we are about reporting problems encountered in reporting
      // this information.
      return harden(encodeErrorToCapData(passable, encodeToCapDataRecur));
     }
    return harden(encodeToCapDataRecur(passable));
   };
  return harden(encodeToCapData);
 };$h‍_once.makeEncodeToCapData(makeEncodeToCapData);
harden(makeEncodeToCapData);

/**
 * @typedef {object} DecodeOptions
 * @property {(
 *   encodedRemotable: Encoding,
 *   decodeRecur: (e: Encoding) => Passable
 * ) => (Promise|Remotable)} [decodeRemotableFromCapData]
 * @property {(
 *   encodedPromise: Encoding,
 *   decodeRecur: (e: Encoding) => Passable
 * ) => (Promise|Remotable)} [decodePromiseFromCapData]
 * @property {(
 *   encodedError: Encoding,
 *   decodeRecur: (e: Encoding) => Passable
 * ) => Error} [decodeErrorFromCapData]
 */

const dontDecodeRemotableOrPromiseFromCapData=  (slotEncoding)=>
  Fail `remotable or promise unexpected: ${slotEncoding}`;
const dontDecodeErrorFromCapData=  (errorEncoding)=>
  Fail `error unexpected: ${errorEncoding}`;

/**
 * The current encoding does not give the decoder enough into to distinguish
 * whether a slot represents a promise or a remotable. As an implementation
 * restriction until this is fixed, if either is provided, both must be
 * provided and they must be the same.
 *
 * This seems like the best starting point to incrementally evolve to an
 * API where these can reliably differ.
 * See https://github.com/Agoric/agoric-sdk/issues/4334
 *
 * @param {DecodeOptions} [decodeOptions]
 * @returns {(encoded: Encoding) => Passable}
 */
const        makeDecodeFromCapData=  (decodeOptions=  {})=>  {
  const {
    decodeRemotableFromCapData=  dontDecodeRemotableOrPromiseFromCapData,
    decodePromiseFromCapData=  dontDecodeRemotableOrPromiseFromCapData,
    decodeErrorFromCapData=  dontDecodeErrorFromCapData}=
      decodeOptions;

  decodeRemotableFromCapData===  decodePromiseFromCapData||
    Fail `An implementation restriction for now: If either decodeRemotableFromCapData or decodePromiseFromCapData is provided, both must be provided and they must be the same: ${q(
      decodeRemotableFromCapData)
      } vs ${q(decodePromiseFromCapData)}`;

  /**
   * `decodeFromCapData` may rely on `jsonEncoded` being the result of a
   * plain call to JSON.parse. However, it *cannot* rely on `jsonEncoded`
   * having been produced by JSON.stringify on the output of `encodeToCapData`
   * above, i.e., `decodeFromCapData` cannot rely on `jsonEncoded` being a
   * valid marshalled representation. Rather, `decodeFromCapData` must
   * validate that.
   *
   * @param {Encoding} jsonEncoded must be hardened
   */
  const decodeFromCapData=  (jsonEncoded)=>{
    if( !isObject(jsonEncoded)) {
      // primitives pass through
      return jsonEncoded;
     }
    if( isArray(jsonEncoded)) {
      return jsonEncoded.map((encodedVal)=>decodeFromCapData(encodedVal));
     }else if( hasQClass(jsonEncoded)) {
      const qclass=  jsonEncoded[QCLASS];
      typeof qclass===  'string'||
        Fail `invalid ${q(QCLASS)} typeof ${q(typeof qclass)}`;
      switch( qclass){
        // Encoding of primitives not handled by JSON
        case 'undefined': {
          return undefined;
         }
        case 'NaN': {
          return NaN;
         }
        case 'Infinity': {
          return Infinity;
         }
        case '-Infinity': {
          return -Infinity;
         }
        case 'bigint': {
          // Using @ts-ignore rather than @ts-expect-error below because
          // with @ts-expect-error I get a red underline in vscode, but
          // without it I get errors from `yarn lint`.
          // @ts-ignore inadequate type inference
          // See https://github.com/endojs/endo/pull/1259#discussion_r954561901
          const { digits}=   jsonEncoded;
          typeof digits===  'string'||
            Fail `invalid digits typeof ${q(typeof digits)}`;
          return BigInt(digits);
         }
        case '@@asyncIterator': {
          // Deprecated qclass. TODO make conditional
          // on environment variable. Eventually remove, but after confident
          // that there are no more supported senders.
          //
          // Using @ts-ignore rather than @ts-expect-error below because
          // with @ts-expect-error I get a red underline in vscode, but
          // without it I get errors from `yarn lint`.
          // @ts-ignore inadequate type inference
          // See https://github.com/endojs/endo/pull/1259#discussion_r954561901
          return Symbol.asyncIterator;
         }
        case 'symbol': {
          // Using @ts-ignore rather than @ts-expect-error below because
          // with @ts-expect-error I get a red underline in vscode, but
          // without it I get errors from `yarn lint`.
          // @ts-ignore inadequate type inference
          // See https://github.com/endojs/endo/pull/1259#discussion_r954561901
          const { name}=   jsonEncoded;
          return passableSymbolForName(name);
         }
        case 'tagged': {
          // Using @ts-ignore rather than @ts-expect-error below because
          // with @ts-expect-error I get a red underline in vscode, but
          // without it I get errors from `yarn lint`.
          // @ts-ignore inadequate type inference
          // See https://github.com/endojs/endo/pull/1259#discussion_r954561901
          const { tag, payload}=   jsonEncoded;
          return makeTagged(tag, decodeFromCapData(payload));
         }
        case 'slot': {
          // See note above about how the current encoding cannot reliably
          // distinguish which we should call, so in the non-default case
          // both must be the same and it doesn't matter which we call.
          const decoded=  decodeRemotableFromCapData(
            jsonEncoded,
            decodeFromCapData);

          // BEWARE: capdata does not check that `decoded` is
          // a promise or a remotable, since that would break some
          // capdata clients. We are deprecating capdata, and these clients
          // will need to update before switching to smallcaps.
          return decoded;
         }
        case 'error': {
          const decoded=  decodeErrorFromCapData(
            jsonEncoded,
            decodeFromCapData);

          if( passStyleOf(decoded)===  'error') {
            return decoded;
           }
          throw Fail `internal: decodeErrorFromCapData option must return an error: ${decoded}`;
         }
        case 'hilbert': {
          // Using @ts-ignore rather than @ts-expect-error below because
          // with @ts-expect-error I get a red underline in vscode, but
          // without it I get errors from `yarn lint`.
          // @ts-ignore inadequate type inference
          // See https://github.com/endojs/endo/pull/1259#discussion_r954561901
          const { original, rest}=   jsonEncoded;
          hasOwnPropertyOf(jsonEncoded, 'original')||
            Fail `Invalid Hilbert Hotel encoding ${jsonEncoded}`;
          // Don't harden since we're not done mutating it
          const result=  { [QCLASS]: decodeFromCapData(original)};
          if( hasOwnPropertyOf(jsonEncoded, 'rest')) {
            const isNonEmptyObject=
              typeof rest===  'object'&&
              rest!==  null&&
              ownKeys(rest).length>=  1;
            if( !isNonEmptyObject) {
              throw Fail `Rest encoding must be a non-empty object: ${rest}`;
             }
            const restObj=  decodeFromCapData(rest);
            // TODO really should assert that `passStyleOf(rest)` is
            // `'copyRecord'` but we'd have to harden it and it is too
            // early to do that.
            !hasOwnPropertyOf(restObj, QCLASS)||
              Fail `Rest must not contain its own definition of ${q(QCLASS)}`;
            defineProperties(result, getOwnPropertyDescriptors(restObj));
           }
          return result;
         }
        // @ts-expect-error This is the error case we're testing for
        case 'ibid': {
          throw Fail `The capData protocol no longer supports ${q(QCLASS)} ${q(
            qclass)
            }`;
         }
        default: {
          throw assert.fail(
            X `unrecognized ${q(QCLASS)} ${q(qclass)}`,
            TypeError);

         }}

     }else {
      assert(typeof jsonEncoded===  'object'&&  jsonEncoded!==  null);
      const decodeEntry=  ([name, encodedVal])=>  {
        typeof name===  'string'||
          Fail `Property ${q(name)} of ${jsonEncoded} must be a string`;
        return [name, decodeFromCapData(encodedVal)];
       };
      const decodedEntries=  entries(jsonEncoded).map(decodeEntry);
      return fromEntries(decodedEntries);
     }
   };
  return harden(decodeFromCapData);
 };$h‍_once.makeDecodeFromCapData(makeDecodeFromCapData);
})()
,
// === functors[135] ===
({   imports: $h‍_imports,   liveVar: $h‍_live,   onceVar: $h‍_once,   importMeta: $h‍____meta, }) => (function () {   let passStyleOf,isErrorLike,makeTagged,getTag,hasOwnPropertyOf,assertPassableSymbol,nameForPassableSymbol,passableSymbolForName;$h‍_imports([["@endo/pass-style", [["passStyleOf", [$h‍_a => (passStyleOf = $h‍_a)]],["isErrorLike", [$h‍_a => (isErrorLike = $h‍_a)]],["makeTagged", [$h‍_a => (makeTagged = $h‍_a)]],["getTag", [$h‍_a => (getTag = $h‍_a)]],["hasOwnPropertyOf", [$h‍_a => (hasOwnPropertyOf = $h‍_a)]],["assertPassableSymbol", [$h‍_a => (assertPassableSymbol = $h‍_a)]],["nameForPassableSymbol", [$h‍_a => (nameForPassableSymbol = $h‍_a)]],["passableSymbolForName", [$h‍_a => (passableSymbolForName = $h‍_a)]]]]]);   


















/** @typedef {import('@endo/pass-style').Passable} Passable */
/** @typedef {import('@endo/pass-style').Remotable} Remotable */
// @typedef {import('./types.js').SmallcapsEncoding} SmallcapsEncoding */
// @typedef {import('./types.js').SmallcapsEncodingUnion} SmallcapsEncodingUnion */
/** @typedef {any} SmallcapsEncoding */
/** @typedef {any} SmallcapsEncodingUnion */

const { ownKeys}=   Reflect;
const { isArray}=   Array;
const { is, entries, fromEntries}=   Object;
const { details: X, Fail, quote: q}=   assert;

const BANG=  '!'.charCodeAt(0);
const DASH=  '-'.charCodeAt(0);

/**
 * An `encodeToSmallcaps` function takes a passable and returns a
 * JSON-representable object (i.e., round-tripping it through
 * `JSON.stringify` and `JSON.parse` with no replacers or revivers
 * returns an equivalent structure except for object identity).
 * We call this representation a Smallcaps Encoding.
 *
 * A `decodeFromSmallcaps` function takes as argument what it
 * *assumes* is the result of a plain `JSON.parse` with no resolver. It then
 * must validate that it is a valid Smallcaps Encoding, and if it is,
 * return a corresponding passable.
 *
 * Smallcaps considers the characters between `!` (ascii code 33, BANG)
 * and `-` (ascii code 45, DASH) to be special prefixes allowing
 * representation of JSON-incompatible data using strings.
 * These characters, in order, are `!"#$%&'()*+,-`
 * Of these, smallcaps currently uses the following:
 *
 *  * `!` - escaped string
 *  * `+` - non-negative bigint
 *  * `-` - negative bigint
 *  * `#` - manifest constant
 *  * `%` - symbol
 *  * `$` - remotable
 *  * `&` - promise
 *
 * All other special characters (`"'()*,`) are reserved for future use.
 *
 * The manifest constants that smallcaps currently uses for values:
 *  * `#undefined`
 *  * `#NaN`
 *  * `#Infinity`
 *  * `#-Infinity`
 *
 * and for property names analogous to capdata @qclass:
 *  * `#tag`
 *  * `#error`
 *
 * All other encoded strings beginning with `#` are reserved for
 * future use.
 *
 * @param {string} encodedStr
 * @returns {boolean}
 */
const startsSpecial=  (encodedStr)=>{
  if( encodedStr===  '') {
    return false;
   }
  // charCodeAt(0) and number compare is a bit faster.
  const code=  encodedStr.charCodeAt(0);
  // eslint-disable-next-line yoda
  return BANG<=  code&&  code<=  DASH;
 };

/**
 * @typedef {object} EncodeToSmallcapsOptions
 * @property {(
 *   remotable: Remotable,
 *   encodeRecur: (p: Passable) => SmallcapsEncoding
 * ) => SmallcapsEncoding} [encodeRemotableToSmallcaps]
 * @property {(
 *   promise: Promise,
 *   encodeRecur: (p: Passable) => SmallcapsEncoding
 * ) => SmallcapsEncoding} [encodePromiseToSmallcaps]
 * @property {(
 *   error: Error,
 *   encodeRecur: (p: Passable) => SmallcapsEncoding
 * ) => SmallcapsEncoding} [encodeErrorToSmallcaps]
 */

const dontEncodeRemotableToSmallcaps=  (rem)=>
  Fail `remotable unexpected: ${rem}`;

const dontEncodePromiseToSmallcaps=  (prom)=>Fail `promise unexpected: ${prom}`;

const dontEncodeErrorToSmallcaps=  (err)=>
  Fail `error object unexpected: ${q(err)}`;

/**
 * @param {EncodeToSmallcapsOptions} [encodeOptions]
 * encodeOptions is actually optional, but not marked as such to work around
 * https://github.com/microsoft/TypeScript/issues/50286
 *
 * @returns {(passable: Passable) => SmallcapsEncoding}
 */
const        makeEncodeToSmallcaps=  (encodeOptions=  {})=>  {
  const {
    encodeRemotableToSmallcaps=  dontEncodeRemotableToSmallcaps,
    encodePromiseToSmallcaps=  dontEncodePromiseToSmallcaps,
    encodeErrorToSmallcaps=  dontEncodeErrorToSmallcaps}=
      encodeOptions;

  const assertEncodedError=  (encoding)=>{
     typeof encoding===  'object'&&  hasOwnPropertyOf(encoding, '#error')||
      Fail `internal: Error encoding must have "#error" property: ${q(
        encoding)
        }`;
    // Assert that the #error property decodes to a string.
    const message=  encoding['#error'];
     typeof message===  'string'&&(
       !startsSpecial(message)||  message.startsWith('!'))||
      Fail `internal: Error encoding must have string message: ${q(message)}`;
   };

  /**
   * Must encode `val` into plain JSON data *canonically*, such that
   * `JSON.stringify(encode(v1)) === JSON.stringify(encode(v1))`. For most
   * encodings, the order of properties of each node of the output
   * structure is determined by the algorithm below without special
   * arrangement, usually by being expressed directly as an object literal.
   * The exception is copyRecords, whose natural enumeration order
   * can differ between copyRecords that our distributed object semantics
   * considers to be equivalent.
   * Since, for each copyRecord, we only accept string property names,
   * not symbols, we can canonically sort the names first.
   * JSON.stringify will then visit these in that sorted order.
   *
   * Encoding with a canonical-JSON encoder would also solve this canonicalness
   * problem in a more modular and encapsulated manner. Note that the
   * actual order produced here, though it agrees with canonical-JSON on
   * copyRecord property ordering, differs from canonical-JSON as a whole
   * in that the other record properties are visited in the order in which
   * they are literally written below. TODO perhaps we should indeed switch
   * to a canonical JSON encoder, and not delicately depend on the order
   * in which these object literals are written.
   *
   * Readers must not care about this order anyway. We impose this requirement
   * mainly to reduce non-determinism exposed outside a vat.
   *
   * @param {Passable} passable
   * @returns {SmallcapsEncoding} except that `encodeToSmallcaps` does not generally
   * `harden` this result before returning. Rather, `encodeToSmallcaps` is not
   * directly exposed.
   * What's exposed instead is a wrapper that freezes the output before
   * returning. If this turns out to impede static analysis for `harden` safety,
   * we can always put the (now redundant) hardens back in. They don't hurt.
   */
  const encodeToSmallcapsRecur=  (passable)=>{
    // First we handle all primitives. Some can be represented directly as
    // JSON, and some must be encoded into smallcaps strings.
    const passStyle=  passStyleOf(passable);
    switch( passStyle){
      case 'null':
      case 'boolean': {
        // pass through to JSON
        return passable;
       }
      case 'string': {
        if( startsSpecial(passable)) {
          // Strings that start with a special char are quoted with `!`.
          // Since `!` is itself a special character, this trivially does
          // the Hilbert hotel. Also, since the special characters are
          // a continuous subrange of ascii, this quoting is sort-order
          // preserving.
          return  `!${passable}`;
         }
        // All other strings pass through to JSON
        return passable;
       }
      case 'undefined': {
        return '#undefined';
       }
      case 'number': {
        // Special-case numbers with no digit-based representation.
        if( Number.isNaN(passable)) {
          return '#NaN';
         }else if( passable===  Infinity) {
          return '#Infinity';
         }else if( passable===  -Infinity) {
          return '#-Infinity';
         }
        // Pass through everything else, replacing -0 with 0.
        return is(passable, -0)?  0:  passable;
       }
      case 'bigint': {
        const str=  String(passable);
        return (/** @type {bigint} */ passable<   0n?  str:   `+${str}`);
       }
      case 'symbol': {
        assertPassableSymbol(passable);
        const name=  /** @type {string} */  nameForPassableSymbol(passable);
        return  `%${name}`;
       }
      case 'copyRecord': {
        // Currently copyRecord allows only string keys so this will
        // work. If we allow sortable symbol keys, this will need to
        // become more interesting.
        const names=  ownKeys(passable).sort();
        return fromEntries(
          names.map((name)=>[
            encodeToSmallcapsRecur(name),
            encodeToSmallcapsRecur(passable[name])]));


       }
      case 'copyArray': {
        return passable.map(encodeToSmallcapsRecur);
       }
      case 'tagged': {
        return {
          '#tag': encodeToSmallcapsRecur(getTag(passable)),
          payload: encodeToSmallcapsRecur(passable.payload)};

       }
      case 'remotable': {
        const result=  encodeRemotableToSmallcaps(
          passable,
          encodeToSmallcapsRecur);

        if( typeof result===  'string'&&  result.startsWith('$')) {
          return result;
         }
        // `throw` is noop since `Fail` throws. But linter confused
        throw Fail `internal: Remotable encoding must start with "$": ${result}`;
       }
      case 'promise': {
        const result=  encodePromiseToSmallcaps(
          passable,
          encodeToSmallcapsRecur);

        if( typeof result===  'string'&&  result.startsWith('&')) {
          return result;
         }
        throw Fail `internal: Promise encoding must start with "&": ${result}`;
       }
      case 'error': {
        const result=  encodeErrorToSmallcaps(passable, encodeToSmallcapsRecur);
        assertEncodedError(result);
        return result;
       }
      default: {
        throw assert.fail(
          X `internal: Unrecognized passStyle ${q(passStyle)}`,
          TypeError);

       }}

   };
  const encodeToSmallcaps=  (passable)=>{
    if( isErrorLike(passable)) {
      // We pull out this special case to accommodate errors that are not
      // valid Passables. For example, because they're not frozen.
      // The special case can only ever apply at the root, and therefore
      // outside the recursion, since an error could only be deeper in
      // a passable structure if it were passable.
      //
      // We pull out this special case because, for these errors, we're much
      // more interested in reporting whatever diagnostic information they
      // carry than we are about reporting problems encountered in reporting
      // this information.
      const result=  harden(
        encodeErrorToSmallcaps(passable, encodeToSmallcapsRecur));

      assertEncodedError(result);
      return result;
     }
    return harden(encodeToSmallcapsRecur(passable));
   };
  return harden(encodeToSmallcaps);
 };$h‍_once.makeEncodeToSmallcaps(makeEncodeToSmallcaps);
harden(makeEncodeToSmallcaps);

/**
 * @typedef {object} DecodeFromSmallcapsOptions
 * @property {(
 *   encodedRemotable: SmallcapsEncoding,
 *   decodeRecur: (e :SmallcapsEncoding) => Passable
 * ) => Remotable} [decodeRemotableFromSmallcaps]
 * @property {(
 *   encodedPromise: SmallcapsEncoding,
 *   decodeRecur: (e :SmallcapsEncoding) => Passable
 * ) => Promise} [decodePromiseFromSmallcaps]
 * @property {(
 *   encodedError: SmallcapsEncoding,
 *   decodeRecur: (e :SmallcapsEncoding) => Passable
 * ) => Error} [decodeErrorFromSmallcaps]
 */

const dontDecodeRemotableFromSmallcaps=  (encoding)=>
  Fail `remotable unexpected: ${encoding}`;
const dontDecodePromiseFromSmallcaps=  (encoding)=>
  Fail `promise unexpected: ${encoding}`;
const dontDecodeErrorFromSmallcaps=  (encoding)=>
  Fail `error unexpected: ${q(encoding)}`;

/**
 * @param {DecodeFromSmallcapsOptions} [decodeOptions]
 * @returns {(encoded: SmallcapsEncoding) => Passable}
 */
const        makeDecodeFromSmallcaps=  (decodeOptions=  {})=>  {
  const {
    decodeRemotableFromSmallcaps=  dontDecodeRemotableFromSmallcaps,
    decodePromiseFromSmallcaps=  dontDecodePromiseFromSmallcaps,
    decodeErrorFromSmallcaps=  dontDecodeErrorFromSmallcaps}=
      decodeOptions;

  /**
   * `decodeFromSmallcaps` may rely on `encoding` being the result of a
   * plain call to JSON.parse. However, it *cannot* rely on `encoding`
   * having been produced by JSON.stringify on the output of `encodeToSmallcaps`
   * above, i.e., `decodeFromSmallcaps` cannot rely on `encoding` being a
   * valid marshalled representation. Rather, `decodeFromSmallcaps` must
   * validate that.
   *
   * @param {SmallcapsEncoding} encoding must be hardened
   */
  const decodeFromSmallcaps=  (encoding)=>{
    switch( typeof encoding){
      case 'boolean':
      case 'number': {
        return encoding;
       }
      case 'string': {
        if( !startsSpecial(encoding)) {
          return encoding;
         }
        const c=  encoding.charAt(0);
        switch( c){
          case '!': {
            // un-hilbert-ify the string
            return encoding.slice(1);
           }
          case '%': {
            return passableSymbolForName(encoding.slice(1));
           }
          case '#': {
            switch( encoding){
              case '#undefined': {
                return undefined;
               }
              case '#NaN': {
                return NaN;
               }
              case '#Infinity': {
                return Infinity;
               }
              case '#-Infinity': {
                return -Infinity;
               }
              default: {
                throw assert.fail(
                  X `unknown constant "${q(encoding)}"`,
                  TypeError);

               }}

           }
          case '+':
          case '-': {
            return BigInt(encoding);
           }
          case '$': {
            const result=  decodeRemotableFromSmallcaps(
              encoding,
              decodeFromSmallcaps);

            if( passStyleOf(result)!==  'remotable') {
              Fail `internal: decodeRemotableFromSmallcaps option must return a remotable: ${result}`;
             }
            return result;
           }
          case '&': {
            const result=  decodePromiseFromSmallcaps(
              encoding,
              decodeFromSmallcaps);

            if( passStyleOf(result)!==  'promise') {
              Fail `internal: decodePromiseFromSmallcaps option must return a promise: ${result}`;
             }
            return result;
           }
          default: {
            throw Fail `Special char ${q(
              c)
              } reserved for future use: ${encoding}`;
           }}

       }
      case 'object': {
        if( encoding===  null) {
          return encoding;
         }

        if( isArray(encoding)) {
          return encoding.map((val)=>decodeFromSmallcaps(val));
         }

        if( hasOwnPropertyOf(encoding, '#tag')) {
          const { '#tag': tag, payload, ...rest}=   encoding;
          typeof tag===  'string'||
            Fail `Value of "#tag", the tag, must be a string: ${encoding}`;
          ownKeys(rest).length===  0||
            Fail `#tag record unexpected properties: ${q(ownKeys(rest))}`;
          return makeTagged(
            decodeFromSmallcaps(tag),
            decodeFromSmallcaps(payload));

         }

        if( hasOwnPropertyOf(encoding, '#error')) {
          const result=  decodeErrorFromSmallcaps(
            encoding,
            decodeFromSmallcaps);

          passStyleOf(result)===  'error'||
            Fail `internal: decodeErrorFromSmallcaps option must return an error: ${result}`;
          return result;
         }

        const decodeEntry=  ([encodedName, encodedVal])=>  {
          typeof encodedName===  'string'||
            Fail `Property name ${q(
              encodedName)
              } of ${encoding} must be a string`;
          !encodedName.startsWith('#')||
            Fail `Unrecognized record type ${q(encodedName)}: ${encoding}`;
          const name=  decodeFromSmallcaps(encodedName);
          typeof name===  'string'||
            Fail `Decoded property name ${name} from ${encoding} must be a string`;
          return [name, decodeFromSmallcaps(encodedVal)];
         };
        const decodedEntries=  entries(encoding).map(decodeEntry);
        return fromEntries(decodedEntries);
       }
      default: {
        throw assert.fail(
          X `internal: unrecognized JSON typeof ${q(
            typeof encoding)
            }: ${encoding}`,
          TypeError);

       }}

   };
  return harden(decodeFromSmallcaps);
 };$h‍_once.makeDecodeFromSmallcaps(makeDecodeFromSmallcaps);
})()
,
// === functors[136] ===
({   imports: $h‍_imports,   liveVar: $h‍_live,   onceVar: $h‍_once,   importMeta: $h‍____meta, }) => (function () {   let Nat,assertPassable,getInterfaceOf,getErrorConstructor,hasOwnPropertyOf,QCLASS,makeEncodeToCapData,makeDecodeFromCapData,makeDecodeFromSmallcaps,makeEncodeToSmallcaps;$h‍_imports([["@endo/nat", [["Nat", [$h‍_a => (Nat = $h‍_a)]]]],["@endo/pass-style", [["assertPassable", [$h‍_a => (assertPassable = $h‍_a)]],["getInterfaceOf", [$h‍_a => (getInterfaceOf = $h‍_a)]],["getErrorConstructor", [$h‍_a => (getErrorConstructor = $h‍_a)]],["hasOwnPropertyOf", [$h‍_a => (hasOwnPropertyOf = $h‍_a)]]]],["./encodeToCapData.js", [["QCLASS", [$h‍_a => (QCLASS = $h‍_a)]],["makeEncodeToCapData", [$h‍_a => (makeEncodeToCapData = $h‍_a)]],["makeDecodeFromCapData", [$h‍_a => (makeDecodeFromCapData = $h‍_a)]]]],["./encodeToSmallcaps.js", [["makeDecodeFromSmallcaps", [$h‍_a => (makeDecodeFromSmallcaps = $h‍_a)]],["makeEncodeToSmallcaps", [$h‍_a => (makeEncodeToSmallcaps = $h‍_a)]]]]]);   



















/** @typedef {import('./types.js').MakeMarshalOptions} MakeMarshalOptions */
/** @template Slot @typedef {import('./types.js').ConvertSlotToVal<Slot>} ConvertSlotToVal */
/** @template Slot @typedef {import('./types.js').ConvertValToSlot<Slot>} ConvertValToSlot */
/** @template Slot @typedef {import('./types.js').ToCapData<Slot>} ToCapData */
/** @template Slot @typedef {import('./types.js').FromCapData<Slot>} FromCapData */
/** @typedef {import('@endo/pass-style').Passable} Passable */
/** @typedef {import('@endo/pass-style').InterfaceSpec} InterfaceSpec */
/** @typedef {import('./types.js').Encoding} Encoding */
/** @typedef {import('@endo/pass-style').RemotableObject} Remotable */

const { isArray}=   Array;
const { details: X, Fail, quote: q}=   assert;
const { ownKeys}=   Reflect;

/** @type {ConvertValToSlot<any>} */
const defaultValToSlotFn=  (x)=>x;
/** @type {ConvertSlotToVal<any>} */
const defaultSlotToValFn=  (x, _)=>  x;

/**
 * @template Slot
 * @param {ConvertValToSlot<Slot>} [convertValToSlot]
 * @param {ConvertSlotToVal<Slot>} [convertSlotToVal]
 * @param {MakeMarshalOptions} options
 */
const        makeMarshal=  (
  convertValToSlot=  defaultValToSlotFn,
  convertSlotToVal=  defaultSlotToValFn,
  {
    errorTagging=  'on',
    marshalName=  'anon-marshal',
    // TODO Temporary hack.
    // See https://github.com/Agoric/agoric-sdk/issues/2780
    errorIdNum=  10000,
    // We prefer that the caller instead log to somewhere hidden
    // to be revealed when correlating with the received error.
    marshalSaveError=  (err)=>
      console.log('Temporary logging of sent error', err),
    // Default to 'capdata' because it was implemented first.
    // Sometimes, ontogeny does recapitulate phylogeny ;)
    serializeBodyFormat=  'capdata'}=
      {})=>
     {
  assert.typeof(marshalName, 'string');
  errorTagging===  'on'||
    errorTagging===  'off'||
    Fail `The errorTagging option can only be "on" or "off" ${errorTagging}`;
  const nextErrorId=  ()=>  {
    errorIdNum+=  1;
    return  `error:${marshalName}#${errorIdNum}`;
   };

  /**
   * @type {ToCapData<Slot>}
   */
  const toCapData=  (root)=>{
    const slots=  [];
    // maps val (promise or remotable) to index of slots[]
    const slotMap=  new Map();

    /**
     * @param {Remotable | Promise} passable
     * @returns {{index: number, repeat: boolean}}
     */
    const encodeSlotCommon=  (passable)=>{
      let index=  slotMap.get(passable);
      if( index!==  undefined) {
        // TODO assert that it's the same iface as before
        assert.typeof(index, 'number');
        return harden({ index, repeat: true});
       }

      index=  slots.length;
      const slot=  convertValToSlot(passable);
      slots.push(slot);
      slotMap.set(passable, index);
      return harden({ index, repeat: false});
     };

    /**
     * Even if an Error is not actually passable, we'd rather send
     * it anyway because the diagnostic info carried by the error
     * is more valuable than diagnosing why the error isn't
     * passable. See comments in isErrorLike.
     *
     * @param {Error} err
     * @param {(p: Passable) => unknown} encodeRecur
     * @returns {{errorId?: string, message: string, name: string}}
     */
    const encodeErrorCommon=  (err, encodeRecur)=>  {
      const message=  encodeRecur( `${err.message}`);
      assert.typeof(message, 'string');
      const name=  encodeRecur( `${err.name}`);
      assert.typeof(name, 'string');
      // Must encode `cause`, `errors`.
      // nested non-passable errors must be ok from here.
      if( errorTagging===  'on') {
        // We deliberately do not share the stack, but it would
        // be useful to log the stack locally so someone who has
        // privileged access to the throwing Vat can correlate
        // the problem with the remote Vat that gets this
        // summary. If we do that, we could allocate some random
        // identifier and include it in the message, to help
        // with the correlation.
        const errorId=  encodeRecur(nextErrorId());
        assert.typeof(errorId, 'string');
        assert.note(err, X `Sent as ${errorId}`);
        marshalSaveError(err);
        return harden({ errorId, message, name});
       }else {
        return harden({ message, name});
       }
     };

    if( serializeBodyFormat===  'capdata') {
      /**
       * @param {Passable} passable
       * @param {InterfaceSpec} [iface]
       * @returns {Encoding}
       */
      const encodeSlotToCapData=  (passable, iface=  undefined)=>  {
        const { index, repeat}=   encodeSlotCommon(passable);

        if( repeat===  true||  iface===  undefined) {
          return harden({ [QCLASS]: 'slot', index});
         }else {
          return harden({ [QCLASS]: 'slot', iface, index});
         }
       };

      const encodeRemotableToCapData=  (val, _encodeRecur)=>
        encodeSlotToCapData(val, getInterfaceOf(val));

      const encodePromiseToCapData=  (promise, _encodeRecur)=>
        encodeSlotToCapData(promise);

      /**
       * Even if an Error is not actually passable, we'd rather send
       * it anyway because the diagnostic info carried by the error
       * is more valuable than diagnosing why the error isn't
       * passable. See comments in isErrorLike.
       *
       * @param {Error} err
       * @param {(p: Passable) => Encoding} encodeRecur
       * @returns {Encoding}
       */
      const encodeErrorToCapData=  (err, encodeRecur)=>  {
        const errData=  encodeErrorCommon(err, encodeRecur);
        return harden({ [QCLASS]: 'error', ...errData});
       };

      const encodeToCapData=  makeEncodeToCapData({
        encodeRemotableToCapData,
        encodePromiseToCapData,
        encodeErrorToCapData});


      const encoded=  encodeToCapData(root);
      const body=  JSON.stringify(encoded);
      return harden({
        body,
        slots});

     }else if( serializeBodyFormat===  'smallcaps') {
      /**
       * @param {string} prefix
       * @param {Passable} passable
       * @param {InterfaceSpec} [iface]
       * @returns {string}
       */
      const encodeSlotToSmallcaps=  (prefix, passable, iface=  undefined)=>  {
        const { index, repeat}=   encodeSlotCommon(passable);

        // TODO explore removing this special case
        if( repeat===  true||  iface===  undefined) {
          return  `${prefix}${index}`;
         }
        return  `${prefix}${index}.${iface}`;
       };

      const encodeRemotableToSmallcaps=  (remotable, _encodeRecur)=>
        encodeSlotToSmallcaps('$', remotable, getInterfaceOf(remotable));

      const encodePromiseToSmallcaps=  (promise, _encodeRecur)=>
        encodeSlotToSmallcaps('&', promise);

      const encodeErrorToSmallcaps=  (err, encodeRecur)=>  {
        const errData=  encodeErrorCommon(err, encodeRecur);
        const { message, ...rest}=   errData;
        return harden({ '#error': message, ...rest});
       };

      const encodeToSmallcaps=  makeEncodeToSmallcaps({
        encodeRemotableToSmallcaps,
        encodePromiseToSmallcaps,
        encodeErrorToSmallcaps});


      const encoded=  encodeToSmallcaps(root);
      const smallcapsBody=  JSON.stringify(encoded);
      return harden({
        // Valid JSON cannot begin with a '#', so this is a valid signal
        // indicating smallcaps format.
        body:  `#${smallcapsBody}`,
        slots});

     }else {
      // The `throw` is a noop since `Fail` throws. Added for confused linters.
      throw Fail `Unrecognized serializeBodyFormat: ${q(serializeBodyFormat)}`;
     }
   };

  const makeFullRevive=  (slots)=>{
    /** @type {Map<number, Passable>} */
    const valMap=  new Map();

    /**
     * @param {{iface?: string, index: number}} slotData
     * @returns {Remotable | Promise}
     */
    const decodeSlotCommon=  (slotData)=>{
      const { iface=  undefined, index, ...rest}=   slotData;
      ownKeys(rest).length===  0||
        Fail `unexpected encoded slot properties ${q(ownKeys(rest))}`;
      if( valMap.has(index)) {
        return valMap.get(index);
       }
      // TODO SECURITY HAZARD: must enfoce that remotable vs promise
      // is according to the encoded string.
      const slot=  slots[Number(Nat(index))];
      const val=  convertSlotToVal(slot, iface);
      valMap.set(index, val);
      return val;
     };

    /**
     * @param {{errorId?: string, message: string, name: string}} errData
     * @param {(e: unknown) => Passable} decodeRecur
     * @returns {Error}
     */
    const decodeErrorCommon=  (errData, decodeRecur)=>  {
      const { errorId=  undefined, message, name, ...rest}=   errData;
      ownKeys(rest).length===  0||
        Fail `unexpected encoded error properties ${q(ownKeys(rest))}`;
      // TODO Must decode `cause` and `errors` properties
      // capData does not transform strings. The calls to `decodeRecur`
      // are for reuse by other encodings that do, such as smallcaps.
      const dName=  decodeRecur(name);
      const dMessage=  decodeRecur(message);
      const dErrorId=  errorId&&  decodeRecur(errorId);
      typeof dName===  'string'||
        Fail `invalid error name typeof ${q(typeof dName)}`;
      typeof dMessage===  'string'||
        Fail `invalid error message typeof ${q(typeof dMessage)}`;
      const EC=  getErrorConstructor(dName)||  Error;
      // errorId is a late addition so be tolerant of its absence.
      const errorName=
        dErrorId===  undefined?
             `Remote${EC.name}`:
             `Remote${EC.name}(${dErrorId})`;
      const error=  assert.error(dMessage, EC, { errorName});
      return harden(error);
     };

    // The current encoding does not give the decoder enough into to distinguish
    // whether a slot represents a promise or a remotable. As an implementation
    // restriction until this is fixed, if either is provided, both must be
    // provided and they must be the same.
    // See https://github.com/Agoric/agoric-sdk/issues/4334
    const decodeRemotableOrPromiseFromCapData=  (rawTree, _decodeRecur)=>  {
      const { [QCLASS]: _, ...slotData}=   rawTree;
      return decodeSlotCommon(slotData);
     };

    const decodeErrorFromCapData=  (rawTree, decodeRecur)=>  {
      const { [QCLASS]: _, ...errData}=   rawTree;
      return decodeErrorCommon(errData, decodeRecur);
     };

    const reviveFromCapData=  makeDecodeFromCapData({
      decodeRemotableFromCapData: decodeRemotableOrPromiseFromCapData,
      decodePromiseFromCapData: decodeRemotableOrPromiseFromCapData,
      decodeErrorFromCapData});


    const makeDecodeSlotFromSmallcaps=  (prefix)=>{
      /**
       * @param {string} stringEncoding
       * @param {(e: unknown) => Passable} _decodeRecur
       * @returns {Remotable | Promise}
       */
      return (stringEncoding, _decodeRecur)=>  {
        assert(stringEncoding.startsWith(prefix));
        // slots: $slotIndex.iface or $slotIndex
        const i=  stringEncoding.indexOf('.');
        const index=  Number(stringEncoding.slice(1, i<  0?  undefined:  i));
        // i < 0 means there was no iface included.
        const iface=  i<  0?  undefined:  stringEncoding.slice(i+  1);
        return decodeSlotCommon({ iface, index});
       };
     };
    const decodeRemotableFromSmallcaps=  makeDecodeSlotFromSmallcaps('$');
    const decodePromiseFromSmallcaps=  makeDecodeSlotFromSmallcaps('&');

    const decodeErrorFromSmallcaps=  (encoding, decodeRecur)=>  {
      const { '#error': message, ...restErrData}=   encoding;
      !hasOwnPropertyOf(restErrData, 'message')||
        Fail `unexpected encoded error property ${q('message')}`;
      return decodeErrorCommon({ message, ...restErrData},  decodeRecur);
     };

    const reviveFromSmallcaps=  makeDecodeFromSmallcaps({
      decodeRemotableFromSmallcaps,
      decodePromiseFromSmallcaps,
      decodeErrorFromSmallcaps});


    return harden({ reviveFromCapData, reviveFromSmallcaps});
   };

  /**
   * @type {FromCapData<Slot>}
   */
  const fromCapData=  (data)=>{
    const { body, slots}=   data;
    typeof body===  'string'||
      Fail `unserialize() given non-capdata (.body is ${body}, not string)`;
    isArray(data.slots)||
      Fail `unserialize() given non-capdata (.slots are not Array)`;
    const { reviveFromCapData, reviveFromSmallcaps}=   makeFullRevive(slots);
    let result;
    // JSON cannot begin with a '#', so this is an unambiguous signal.
    if( body.startsWith('#')) {
      const smallcapsBody=  body.slice(1);
      const encoding=  harden(JSON.parse(smallcapsBody));
      result=  harden(reviveFromSmallcaps(encoding));
     }else {
      const rawTree=  harden(JSON.parse(body));
      result=  harden(reviveFromCapData(rawTree));
     }
    // See https://github.com/Agoric/agoric-sdk/issues/4337
    // which should be considered fixed once we've completed the switch
    // to smallcaps.
    assertPassable(result);
    return result;
   };

  return harden({
    toCapData,
    fromCapData,

    // for backwards compatibility
    /** @deprecated use toCapData */
    serialize: toCapData,
    /** @deprecated use fromCapData */
    unserialize: fromCapData});

 };$h‍_once.makeMarshal(makeMarshal);
})()
,
// === functors[137] ===
({   imports: $h‍_imports,   liveVar: $h‍_live,   onceVar: $h‍_once,   importMeta: $h‍____meta, }) => (function () {   let makeMarshal;$h‍_imports([["./marshal.js", [["makeMarshal", [$h‍_a => (makeMarshal = $h‍_a)]]]]]);   



/** @typedef {import('@endo/pass-style').Passable} Passable */

const { Fail}=   assert;

/** @type {import('./types.js').ConvertValToSlot<any>} */
const doNotConvertValToSlot=  (val)=>
  Fail `Marshal's stringify rejects presences and promises ${val}`;

/** @type {import('./types.js').ConvertSlotToVal<any>} */
const doNotConvertSlotToVal=  (slot, _iface)=>
  Fail `Marshal's parse must not encode any slots ${slot}`;

const badArrayHandler=  harden({
  get: (_target, name, _receiver)=>  {
    if( name===  'length') {
      return 0;
     }
    // `throw` is noop since `Fail` throws. But linter confused
    throw Fail `Marshal's parse must not encode any slot positions ${name}`;
   }});


const badArray=  harden(new Proxy(harden([]), badArrayHandler));

const { serialize, unserialize}=   makeMarshal(
  doNotConvertValToSlot,
  doNotConvertSlotToVal,
  {
    errorTagging: 'off',
    // TODO fix tests to works with smallcaps.
    serializeBodyFormat: 'capdata'});



/**
 * @param {Passable} val
 * @returns {string}
 */
const stringify=  (val)=>serialize(val).body;$h‍_once.stringify(stringify);
harden(stringify);

/**
 * @param {string} str
 * @returns {Passable}
 */
const parse=  (str)=>
  unserialize(
    harden({
      body: str,
      slots: badArray}));$h‍_once.parse(parse);


harden(parse);
})()
,
// === functors[138] ===
({   imports: $h‍_imports,   liveVar: $h‍_live,   onceVar: $h‍_once,   importMeta: $h‍____meta, }) => (function () {   let Nat,getErrorConstructor,isObject,passableSymbolForName,QCLASS;$h‍_imports([["@endo/nat", [["Nat", [$h‍_a => (Nat = $h‍_a)]]]],["@endo/pass-style", [["getErrorConstructor", [$h‍_a => (getErrorConstructor = $h‍_a)]],["isObject", [$h‍_a => (isObject = $h‍_a)]],["passableSymbolForName", [$h‍_a => (passableSymbolForName = $h‍_a)]]]],["./encodeToCapData.js", [["QCLASS", [$h‍_a => (QCLASS = $h‍_a)]]]]]);   









/** @typedef {import('./types.js').Encoding} Encoding */
/** @template T @typedef {import('./types.js').CapData<T>} CapData */

const { ownKeys}=   Reflect;
const { isArray}=   Array;
const { stringify: quote}=   JSON;
const { quote: q, details: X, Fail}=   assert;

/**
 * @typedef {object} Indenter
 * @property {(openBracket: string) => number} open
 * @property {() => number} line
 * @property {(token: string) => number} next
 * @property {(closeBracket: string) => number} close
 * @property {() => string} done
 */

/**
 * Generous whitespace for readability
 *
 * @returns {Indenter}
 */
const makeYesIndenter=  ()=>  {
  const strings=  [];
  let level=  0;
  let needSpace=  false;
  const line=  ()=>  {
    needSpace=  false;
    return strings.push('\n', '  '.repeat(level));
   };
  return harden({
    open: (openBracket)=>{
      level+=  1;
      if( needSpace) {
        strings.push(' ');
       }
      needSpace=  false;
      return strings.push(openBracket);
     },
    line,
    next: (token)=>{
      if( needSpace&&  token!==  ',') {
        strings.push(' ');
       }
      needSpace=  true;
      return strings.push(token);
     },
    close: (closeBracket)=>{
      assert(level>=  1);
      level-=  1;
      line();
      return strings.push(closeBracket);
     },
    done: ()=>  {
      assert.equal(level, 0);
      return strings.join('');
     }});

 };

/**
 * If the last character of one token together with the first character
 * of the next token matches this pattern, then the two tokens must be
 * separated by whitespace to preserve their meaning. Otherwise the
 * whitespace in unnecessary.
 *
 * The `<!` and `->` cases prevent the accidental formation of an
 * html-like comment. I don't think the double angle brackets are actually
 * needed but I haven't thought about it enough to remove them.
 */
const badPairPattern=  /^(?:\w\w|<<|>>|\+\+|--|<!|->)$/;

/**
 * Minimum whitespace needed to preseve meaning.
 *
 * @returns {Indenter}
 */
const makeNoIndenter=  ()=>  {
  /** @type {string[]} */
  const strings=  [];
  return harden({
    open: (openBracket)=>strings.push(openBracket),
    line: ()=>  strings.length,
    next: (token)=>{
      if( strings.length>=  1) {
        const last=  strings[strings.length-  1];
        // eslint-disable-next-line @endo/restrict-comparison-operands -- error
        if( last.length>=  1&&  token.length>=  1) {
          const pair=   `${last[last.length- 1] }${token[0]}`;
          if( badPairPattern.test(pair)) {
            strings.push(' ');
           }
         }
       }
      return strings.push(token);
     },
    close: (closeBracket)=>{
      if( strings.length>=  1&&  strings[strings.length-  1]===  ',') {
        strings.pop();
       }
      return strings.push(closeBracket);
     },
    done: ()=>  strings.join('')});

 };

const identPattern=  /^[a-zA-Z]\w*$/;
harden(identPattern);
const AtAtPrefixPattern=  /^@@(.*)$/;
harden(AtAtPrefixPattern);

/**
 * @param {Encoding} encoding
 * @param {boolean=} shouldIndent
 * @param {any[]} [slots]
 * @returns {string}
 */
const decodeToJustin=  (encoding, shouldIndent=  false, slots=  [])=>  {
  /**
   * The first pass does some input validation.
   * Its control flow should mirror `recur` as closely as possible
   * and the two should be maintained together. They must visit everything
   * in the same order.
   *
   * TODO now that ibids are gone, we should fold this back together into
   * one validating pass.
   *
   * @param {Encoding} rawTree
   * @returns {void}
   */
  const prepare=  (rawTree)=>{
    if( !isObject(rawTree)) {
      return;
     }
    // Assertions of the above to narrow the type.
    assert.typeof(rawTree, 'object');
    assert(rawTree!==  null);
    if( QCLASS in rawTree) {
      const qclass=  rawTree[QCLASS];
      typeof qclass===  'string'||
        Fail `invalid qclass typeof ${q(typeof qclass)}`;
      assert(!isArray(rawTree));
      switch( rawTree['@qclass']){
        case 'undefined':
        case 'NaN':
        case 'Infinity':
        case '-Infinity': {
          return;
         }
        case 'bigint': {
          const { digits}=   rawTree;
          typeof digits===  'string'||
            Fail `invalid digits typeof ${q(typeof digits)}`;
          return;
         }
        case '@@asyncIterator': {
          return;
         }
        case 'symbol': {
          const { name}=   rawTree;
          assert.typeof(name, 'string');
          const sym=  passableSymbolForName(name);
          assert.typeof(sym, 'symbol');
          return;
         }
        case 'tagged': {
          const { tag, payload}=   rawTree;
          assert.typeof(tag, 'string');
          prepare(payload);
          return;
         }
        case 'slot': {
          const { index, iface}=   rawTree;
          assert.typeof(index, 'number');
          Nat(index);
          if( iface!==  undefined) {
            assert.typeof(iface, 'string');
           }
          return;
         }
        case 'hilbert': {
          const { original, rest}=   rawTree;
          'original'in  rawTree||
            Fail `Invalid Hilbert Hotel encoding ${rawTree}`;
          prepare(original);
          if( 'rest'in  rawTree) {
            if( typeof rest!==  'object') {
              throw Fail `Rest ${rest} encoding must be an object`;
             }
            if( rest===  null) {
              throw Fail `Rest ${rest} encoding must not be null`;
             }
            if( isArray(rest)) {
              throw Fail `Rest ${rest} encoding must not be an array`;
             }
            if( QCLASS in rest) {
              throw Fail `Rest encoding ${rest} must not contain ${q(QCLASS)}`;
             }
            const names=  ownKeys(rest);
            for( const name of names) {
              typeof name===  'string'||
                Fail `Property name ${name} of ${rawTree} must be a string`;
              prepare(rest[name]);
             }
           }
          return;
         }
        case 'error': {
          const { name, message}=   rawTree;
          typeof name===  'string'||
            Fail `invalid error name typeof ${q(typeof name)}`;
          getErrorConstructor(name)!==  undefined||
            Fail `Must be the name of an Error constructor ${name}`;
          typeof message===  'string'||
            Fail `invalid error message typeof ${q(typeof message)}`;
          return;
         }

        default: {
          assert.fail(X `unrecognized ${q(QCLASS)} ${q(qclass)}`,TypeError);
         }}

     }else if( isArray(rawTree)) {
      const { length}=   rawTree;
      for( let i=  0; i<  length; i+=  1) {
        prepare(rawTree[i]);
       }
     }else {
      const names=  ownKeys(rawTree);
      for( const name of names) {
        if( typeof name!==  'string') {
          throw Fail `Property name ${name} of ${rawTree} must be a string`;
         }
        prepare(rawTree[name]);
       }
     }
   };

  const makeIndenter=  shouldIndent?  makeYesIndenter:  makeNoIndenter;
  let out=  makeIndenter();

  /**
   * This is the second pass recursion after the first pass `prepare`.
   * The first pass did some input validation so
   * here we can safely assume everything those things are validated.
   *
   * @param {Encoding} rawTree
   * @returns {number}
   */
  const decode=  (rawTree)=>{
    // eslint-disable-next-line no-use-before-define
    return recur(rawTree);
   };

  const decodeProperty=  (name, value)=>  {
    out.line();
    if( name===  '__proto__') {
      // JavaScript interprets `{__proto__: x, ...}`
      // as making an object inheriting from `x`, whereas
      // in JSON it is simply a property name. Preserve the
      // JSON meaning.
      out.next( `["__proto__"]:`);
     }else if( identPattern.test(name)) {
      out.next( `${name}:`);
     }else {
      out.next( `${quote(name)}:`);
     }
    decode(value);
    out.next(',');
   };

  /**
   * Modeled after `fullRevive` in marshal.js
   *
   * @param {Encoding} rawTree
   * @returns {number}
   */
  const recur=  (rawTree)=>{
    if( !isObject(rawTree)) {
      // primitives get quoted
      return out.next(quote(rawTree));
     }
    // Assertions of the above to narrow the type.
    assert.typeof(rawTree, 'object');
    assert(rawTree!==  null);
    if( QCLASS in rawTree) {
      const qclass=  rawTree[QCLASS];
      assert.typeof(qclass, 'string');
      assert(!isArray(rawTree));
      // Switching on `encoded[QCLASS]` (or anything less direct, like
      // `qclass`) does not discriminate rawTree in typescript@4.2.3 and
      // earlier.
      switch( rawTree['@qclass']){
        // Encoding of primitives not handled by JSON
        case 'undefined':
        case 'NaN':
        case 'Infinity':
        case '-Infinity': {
          // Their qclass is their expression source.
          return out.next(qclass);
         }
        case 'bigint': {
          const { digits}=   rawTree;
          assert.typeof(digits, 'string');
          return out.next( `${BigInt(digits)}n`);
         }
        case '@@asyncIterator': {
          // TODO deprecated. Eventually remove.
          return out.next('Symbol.asyncIterator');
         }
        case 'symbol': {
          const { name}=   rawTree;
          assert.typeof(name, 'string');
          const sym=  passableSymbolForName(name);
          assert.typeof(sym, 'symbol');
          const registeredName=  Symbol.keyFor(sym);
          if( registeredName===  undefined) {
            const match=  AtAtPrefixPattern.exec(name);
            assert(match!==  null);
            const suffix=  match[1];
            assert(Symbol[suffix]===  sym);
            assert(identPattern.test(suffix));
            return out.next( `Symbol.${suffix}`);
           }
          return out.next( `Symbol.for(${quote(registeredName)})`);
         }
        case 'tagged': {
          const { tag, payload}=   rawTree;
          out.next( `makeTagged(${quote(tag)},`);
          decode(payload);
          return out.next(')');
         }

        case 'slot': {
          let { iface}=   rawTree;
          const index=  Number(Nat(rawTree.index));
          const nestedRender=  (arg)=>{
            const oldOut=  out;
            try {
              out=  makeNoIndenter();
              decode(arg);
              return out.done();
             }finally {
              out=  oldOut;
             }
           };
          if( index<  slots.length) {
            const slot=  nestedRender(slots[index]);
            if( iface===  undefined) {
              return out.next( `slotToVal(${slot})`);
             }
            iface=  nestedRender(iface);
            return out.next( `slotToVal(${slot},${iface})`);
           }else if( iface===  undefined) {
            return out.next( `slot(${index})`);
           }
          iface=  nestedRender(iface);
          return out.next( `slot(${index},${iface})`);
         }

        case 'hilbert': {
          const { original, rest}=   rawTree;
          out.open('{');
          decodeProperty(QCLASS, original);
          if( 'rest'in  rawTree) {
            assert.typeof(rest, 'object');
            assert(rest!==  null);
            const names=  ownKeys(rest);
            for( const name of names) {
              if( typeof name!==  'string') {
                throw Fail `Property name ${q(
                  name)
                  } of ${rest} must be a string`;
               }
              decodeProperty(name, rest[name]);
             }
           }
          return out.close('}');
         }

        case 'error': {
          const { name, message}=   rawTree;
          return out.next( `${name}(${quote(message)})`);
         }

        default: {
          throw assert.fail(
            X `unrecognized ${q(QCLASS)} ${q(qclass)}`,
            TypeError);

         }}

     }else if( isArray(rawTree)) {
      const { length}=   rawTree;
      if( length===  0) {
        return out.next('[]');
       }else {
        out.open('[');
        for( let i=  0; i<  length; i+=  1) {
          out.line();
          decode(rawTree[i]);
          out.next(',');
         }
        return out.close(']');
       }
     }else {
      // rawTree is an `EncodingRecord` which only has string keys,
      // but since ownKeys is not generic, it can't propagate that
      const names=  /** @type {string[]} */  ownKeys(rawTree);
      if( names.length===  0) {
        return out.next('{}');
       }else {
        out.open('{');
        for( const name of names) {
          decodeProperty(name, rawTree[name]);
         }
        return out.close('}');
       }
     }
   };
  prepare(encoding);
  decode(encoding);
  return out.done();
 };$h‍_once.decodeToJustin(decodeToJustin);
harden(decodeToJustin);
})()
,
// === functors[139] ===
({   imports: $h‍_imports,   liveVar: $h‍_live,   onceVar: $h‍_once,   importMeta: $h‍____meta, }) => (function () {   let getTag,makeTagged,passStyleOf,assertRecord,isErrorLike,nameForPassableSymbol,passableSymbolForName;$h‍_imports([["@endo/pass-style", [["getTag", [$h‍_a => (getTag = $h‍_a)]],["makeTagged", [$h‍_a => (makeTagged = $h‍_a)]],["passStyleOf", [$h‍_a => (passStyleOf = $h‍_a)]],["assertRecord", [$h‍_a => (assertRecord = $h‍_a)]],["isErrorLike", [$h‍_a => (isErrorLike = $h‍_a)]],["nameForPassableSymbol", [$h‍_a => (nameForPassableSymbol = $h‍_a)]],["passableSymbolForName", [$h‍_a => (passableSymbolForName = $h‍_a)]]]]]);   










/** @typedef {import('@endo/pass-style').PassStyle} PassStyle */
/** @typedef {import('@endo/pass-style').Passable} Passable */
/** @typedef {import('@endo/pass-style').RemotableObject} Remotable */
/**
 * @template {Passable} [T=Passable]
 * @typedef {import('@endo/pass-style').CopyRecord<T>} CopyRecord
 */
/** @typedef {import('./types.js').RankCover} RankCover */

const { quote: q, Fail}=   assert;
const { fromEntries, is}=   Object;
const { ownKeys}=   Reflect;

/**
 * Assuming that `record` is a CopyRecord, we have only
 * string-named own properties. `recordNames` returns those name *reverse*
 * sorted, because that's how records are compared, encoded, and sorted.
 *
 * @template T
 * @param {CopyRecord<T>} record
 * @returns {string[]}
 */
const        recordNames=  (record)=>
  // https://github.com/endojs/endo/pull/1260#discussion_r1003657244
  // compares two ways of reverse sorting, and shows that `.sort().reverse()`
  // is currently faster on Moddable XS, while the other way,
  // `.sort(reverseComparator)`, is faster on v8. We currently care more about
  // XS performance, so we reverse sort using `.sort().reverse()`.
  harden(/** @type {string[]} */  ownKeys(record). sort().reverse());$h‍_once.recordNames(recordNames);
harden(recordNames);

/**
 * Assuming that `record` is a CopyRecord and `names` is `recordNames(record)`,
 * return the corresponding array of property values.
 *
 * @template T
 * @param {CopyRecord<T>} record
 * @param {string[]} names
 * @returns {T[]}
 */
const        recordValues=  (record, names)=>
  harden(names.map((name)=>record[name]));$h‍_once.recordValues(recordValues);
harden(recordValues);

/**
 * @param {unknown} n
 * @param {number} size
 * @returns {string}
 */
const        zeroPad=  (n, size)=>  {
  const nStr=   `${n}`;
  assert(nStr.length<=  size);
  const str=   `00000000000000000000${nStr}`;
  const result=  str.substring(str.length-  size);
  assert(result.length===  size);
  return result;
 };$h‍_once.zeroPad(zeroPad);
harden(zeroPad);

// This is the JavaScript analog to a C union: a way to map between a float as a
// number and the bits that represent the float as a buffer full of bytes.  Note
// that the mutation of static state here makes this invalid Jessie code, but
// doing it this way saves the nugatory and gratuitous allocations that would
// happen every time you do a conversion -- and in practical terms it's safe
// because we put the value in one side and then immediately take it out the
// other; there is no actual state retained in the classic sense and thus no
// re-entrancy issue.
const asNumber=  new Float64Array(1);
const asBits=  new BigUint64Array(asNumber.buffer);

// JavaScript numbers are encoded by outputting the base-16
// representation of the binary value of the underlying IEEE floating point
// representation.  For negative values, all bits of this representation are
// complemented prior to the base-16 conversion, while for positive values, the
// sign bit is complemented.  This ensures both that negative values sort before
// positive values and that negative values sort according to their negative
// magnitude rather than their positive magnitude.  This results in an ASCII
// encoding whose lexicographic sort order is the same as the numeric sort order
// of the corresponding numbers.

// TODO Choose the same canonical NaN encoding that cosmWasm and ewasm chose.
const CanonicalNaNBits=  'fff8000000000000';

/**
 * @param {number} n
 * @returns {string}
 */
const encodeBinary64=  (n)=>{
  // Normalize -0 to 0 and NaN to a canonical encoding
  if( is(n, -0)) {
    n=  0;
   }else if( is(n, NaN)) {
    return  `f${CanonicalNaNBits}`;
   }
  asNumber[0]=  n;
  let bits=  asBits[0];
  if( n<  0) {
    bits^=  0xffffffffffffffffn;
   }else {
    bits^=  0x8000000000000000n;
   }
  return  `f${zeroPad(bits.toString(16),16) }`;
 };

/**
 * @param {string} encoded
 * @returns {number}
 */
const decodeBinary64=  (encoded)=>{
  encoded.startsWith('f')||  Fail `Encoded number expected: ${encoded}`;
  let bits=  BigInt( `0x${encoded.substring(1)}`);
  if( encoded[1]<  '8') {
    bits^=  0xffffffffffffffffn;
   }else {
    bits^=  0x8000000000000000n;
   }
  asBits[0]=  bits;
  const result=  asNumber[0];
  !is(result, -0)||  Fail `Unexpected negative zero: ${encoded}`;
  return result;
 };

/**
 * Encode a JavaScript bigint using a variant of Elias delta coding, with an
 * initial component for the length of the digit count as a unary string, a
 * second component for the decimal digit count, and a third component for the
 * decimal digits preceded by a gratuitous separating colon.
 * To ensure that the lexicographic sort order of encoded values matches the
 * numeric sort order of the corresponding numbers, the characters of the unary
 * prefix are different for negative values (type "n" followed by any number of
 * "#"s [which sort before decimal digits]) vs. positive and zero values (type
 * "p" followed by any number of "~"s [which sort after decimal digits]) and
 * each decimal digit of the encoding for a negative value is replaced with its
 * ten's complement (so that negative values of the same scale sort by
 * *descending* absolute value).
 *
 * @param {bigint} n
 * @returns {string}
 */
const encodeBigInt=  (n)=>{
  const abs=  n<  0n?  -n:  n;
  const nDigits=  abs.toString().length;
  const lDigits=  nDigits.toString().length;
  if( n<  0n) {
    return  `n${
      // A "#" for each digit beyond the first
      // in the decimal *count* of decimal digits.
      '#'.repeat(lDigits-  1)
     }${
      // The ten's complement of the count of digits.
      (10**  lDigits-  nDigits).toString().padStart(lDigits, '0')
     }:${
      // The ten's complement of the digits.
      (10n**  BigInt(nDigits)+  n).toString().padStart(nDigits, '0')
     }`;
   }else {
    return  `p${
      // A "~" for each digit beyond the first
      // in the decimal *count* of decimal digits.
      '~'.repeat(lDigits-  1)
     }${
      // The count of digits.
      nDigits
     }:${
      // The digits.
      n
     }`;
   }
 };

/**
 * @param {string} encoded
 * @returns {bigint}
 */
const decodeBigInt=  (encoded)=>{
  const typePrefix=  encoded.charAt(0); // faster than encoded[0]
  let rem=  encoded.slice(1);
  typePrefix===  'p'||
    typePrefix===  'n'||
    Fail `Encoded bigint expected: ${encoded}`;

  const lDigits=  rem.search(/[0-9]/)+  1;
  lDigits>=  1||  Fail `Digit count expected: ${encoded}`;
  rem=  rem.slice(lDigits-  1);

  rem.length>=  lDigits||  Fail `Complete digit count expected: ${encoded}`;
  const snDigits=  rem.slice(0, lDigits);
  rem=  rem.slice(lDigits);
  /^[0-9]+$/.test(snDigits)||  Fail `Decimal digit count expected: ${encoded}`;
  let nDigits=  parseInt(snDigits, 10);
  if( typePrefix===  'n') {
    // TODO Assert to reject forbidden encodings
    // like "n0:" and "n00:…" and "n91:…" through "n99:…"?
    nDigits=  10**  lDigits-  nDigits;
   }

  rem.startsWith(':')||  Fail `Separator expected: ${encoded}`;
  rem=  rem.slice(1);
  rem.length===  nDigits||
    Fail `Fixed-length digit sequence expected: ${encoded}`;
  let n=  BigInt(rem);
  if( typePrefix===  'n') {
    // TODO Assert to reject forbidden encodings
    // like "n9:0" and "n8:00" and "n8:91" through "n8:99"?
    n=  -(10n**  BigInt(nDigits)-  n);
   }

  return n;
 };

// `'\u0000'` is the terminator after elements.
// `'\u0001'` is the backslash-like escape character, for
// escaping both of these characters.

const encodeArray=  (array, encodePassable)=>  {
  const chars=  ['['];
  for( const element of array) {
    const enc=  encodePassable(element);
    for( const c of enc) {
      if( c===  '\u0000'||  c===  '\u0001') {
        chars.push('\u0001');
       }
      chars.push(c);
     }
    chars.push('\u0000');
   }
  return chars.join('');
 };

/**
 * @param {string} encoded
 * @param {(encoded: string) => Passable} decodePassable
 * @returns {Array}
 */
const decodeArray=  (encoded, decodePassable)=>  {
  encoded.startsWith('[')||  Fail `Encoded array expected: ${encoded}`;
  const elements=  [];
  const elemChars=  [];
  for( let i=  1; i<  encoded.length; i+=  1) {
    const c=  encoded[i];
    if( c===  '\u0000') {
      const encodedElement=  elemChars.join('');
      elemChars.length=  0;
      const element=  decodePassable(encodedElement);
      elements.push(element);
     }else if( c===  '\u0001') {
      i+=  1;
      i<  encoded.length||  Fail `unexpected end of encoding ${encoded}`;
      const c2=  encoded[i];
      c2===  '\u0000'||
        c2===  '\u0001'||
        Fail `Unexpected character after u0001 escape: ${c2}`;
      elemChars.push(c2);
     }else {
      elemChars.push(c);
     }
   }
  elemChars.length===  0||  Fail `encoding terminated early: ${encoded}`;
  return harden(elements);
 };

const encodeRecord=  (record, encodePassable)=>  {
  const names=  recordNames(record);
  const values=  recordValues(record, names);
  return  `(${encodeArray(harden([names,values]), encodePassable) }`;
 };

const decodeRecord=  (encoded, decodePassable)=>  {
  assert(encoded.startsWith('('));
  const keysvals=  decodeArray(encoded.substring(1), decodePassable);
  keysvals.length===  2||  Fail `expected keys,values pair: ${encoded}`;
  const [keys, vals]=  keysvals;

   passStyleOf(keys)===  'copyArray'&&
    passStyleOf(vals)===  'copyArray'&&
    keys.length===  vals.length&&
    keys.every((key)=>typeof key===  'string')||
    Fail `not a valid record encoding: ${encoded}`;
  const mapEntries=  keys.map((key, i)=>  [key, vals[i]]);
  const record=  harden(fromEntries(mapEntries));
  assertRecord(record, 'decoded record');
  return record;
 };

const encodeTagged=  (tagged, encodePassable)=>
   `:${encodeArray(harden([getTag(tagged),tagged.payload]), encodePassable) }`;

const decodeTagged=  (encoded, decodePassable)=>  {
  assert(encoded.startsWith(':'));
  const tagpayload=  decodeArray(encoded.substring(1), decodePassable);
  tagpayload.length===  2||  Fail `expected tag,payload pair: ${encoded}`;
  const [tag, payload]=  tagpayload;
  passStyleOf(tag)===  'string'||
    Fail `not a valid tagged encoding: ${encoded}`;
  return makeTagged(tag, payload);
 };

/**
 * @typedef {object} EncodeOptions
 * @property {(
 *   remotable: Remotable,
 *   encodeRecur: (p: Passable) => string,
 * ) => string} [encodeRemotable]
 * @property {(
 *   promise: Promise,
 *   encodeRecur: (p: Passable) => string,
 * ) => string} [encodePromise]
 * @property {(
 *   error: Error,
 *   encodeRecur: (p: Passable) => string,
 * ) => string} [encodeError]
 */

/**
 * @param {EncodeOptions} [encodeOptions]
 * @returns {(passable: Passable) => string}
 */
const        makeEncodePassable=  (encodeOptions=  {})=>  {
  const {
    encodeRemotable=  (rem, _)=>  Fail `remotable unexpected: ${rem}`,
    encodePromise=  (prom, _)=>  Fail `promise unexpected: ${prom}`,
    encodeError=  (err, _)=>  Fail `error unexpected: ${err}`}=
      encodeOptions;

  const encodePassable=  (passable)=>{
    if( isErrorLike(passable)) {
      return encodeError(passable, encodePassable);
     }
    const passStyle=  passStyleOf(passable);
    switch( passStyle){
      case 'null': {
        return 'v';
       }
      case 'undefined': {
        return 'z';
       }
      case 'number': {
        return encodeBinary64(passable);
       }
      case 'string': {
        return  `s${passable}`;
       }
      case 'boolean': {
        return  `b${passable}`;
       }
      case 'bigint': {
        return encodeBigInt(passable);
       }
      case 'remotable': {
        const result=  encodeRemotable(passable, encodePassable);
        result.startsWith('r')||
          Fail `internal: Remotable encoding must start with "r": ${result}`;
        return result;
       }
      case 'error': {
        const result=  encodeError(passable, encodePassable);
        result.startsWith('!')||
          Fail `internal: Error encoding must start with "!": ${result}`;
        return result;
       }
      case 'promise': {
        const result=  encodePromise(passable, encodePassable);
        result.startsWith('?')||
          Fail `internal: Promise encoding must start with "?": ${result}`;
        return result;
       }
      case 'symbol': {
        return  `y${nameForPassableSymbol(passable)}`;
       }
      case 'copyArray': {
        return encodeArray(passable, encodePassable);
       }
      case 'copyRecord': {
        return encodeRecord(passable, encodePassable);
       }
      case 'tagged': {
        return encodeTagged(passable, encodePassable);
       }
      default: {
        throw Fail `a ${q(passStyle)} cannot be used as a collection passable`;
       }}

   };
  return harden(encodePassable);
 };$h‍_once.makeEncodePassable(makeEncodePassable);
harden(makeEncodePassable);

/**
 * @typedef {object} DecodeOptions
 * @property {(
 *   encodedRemotable: string,
 *   decodeRecur: (e: string) => Passable
 * ) => Remotable} [decodeRemotable]
 * @property {(
 *   encodedPromise: string,
 *   decodeRecur: (e: string) => Passable
 * ) => Promise} [decodePromise]
 * @property {(
 *   encodedError: string,
 *   decodeRecur: (e: string) => Passable
 * ) => Error} [decodeError]
 */

/**
 * @param {DecodeOptions} [decodeOptions]
 * @returns {(encoded: string) => Passable}
 */
const        makeDecodePassable=  (decodeOptions=  {})=>  {
  const {
    decodeRemotable=  (rem, _)=>  Fail `remotable unexpected: ${rem}`,
    decodePromise=  (prom, _)=>  Fail `promise unexpected: ${prom}`,
    decodeError=  (err, _)=>  Fail `error unexpected: ${err}`}=
      decodeOptions;

  const decodePassable=  (encoded)=>{
    switch( encoded.charAt(0)){
      case 'v': {
        return null;
       }
      case 'z': {
        return undefined;
       }
      case 'f': {
        return decodeBinary64(encoded);
       }
      case 's': {
        return encoded.substring(1);
       }
      case 'b': {
        return encoded.substring(1)!==  'false';
       }
      case 'n':
      case 'p': {
        return decodeBigInt(encoded);
       }
      case 'r': {
        return decodeRemotable(encoded, decodePassable);
       }
      case '?': {
        return decodePromise(encoded, decodePassable);
       }
      case '!': {
        return decodeError(encoded, decodePassable);
       }
      case 'y': {
        return passableSymbolForName(encoded.substring(1));
       }
      case '[': {
        return decodeArray(encoded, decodePassable);
       }
      case '(': {
        return decodeRecord(encoded, decodePassable);
       }
      case ':': {
        return decodeTagged(encoded, decodePassable);
       }
      default: {
        throw Fail `invalid database key: ${encoded}`;
       }}

   };
  return harden(decodePassable);
 };$h‍_once.makeDecodePassable(makeDecodePassable);
harden(makeDecodePassable);

const        isEncodedRemotable=  (encoded)=>encoded.charAt(0)===  'r';$h‍_once.isEncodedRemotable(isEncodedRemotable);
harden(isEncodedRemotable);

// /////////////////////////////////////////////////////////////////////////////

/**
 * @type {Record<PassStyle, string>}
 * The single prefix characters to be used for each PassStyle category.
 * `bigint` is a two character string because each of those characters
 * individually is a valid bigint prefix. `n` for "negative" and `p` for
 * "positive". The ordering of these prefixes is the same as the
 * rankOrdering of their respective PassStyles. This table is imported by
 * rankOrder.js for this purpose.
 *
 * In addition, `|` is the remotable->ordinal mapping prefix:
 * This is not used in covers but it is
 * reserved from the same set of strings. Note that the prefix is > any
 * prefix used by any cover so that ordinal mapping keys are always outside
 * the range of valid collection entry keys.
 */
const        passStylePrefixes=  {
  error: '!',
  copyRecord: '(',
  tagged: ':',
  promise: '?',
  copyArray: '[',
  boolean: 'b',
  number: 'f',
  bigint: 'np',
  remotable: 'r',
  string: 's',
  null: 'v',
  symbol: 'y',
  undefined: 'z'};$h‍_once.passStylePrefixes(passStylePrefixes);

Object.setPrototypeOf(passStylePrefixes, null);
harden(passStylePrefixes);
})()
,
// === functors[140] ===
({   imports: $h‍_imports,   liveVar: $h‍_live,   onceVar: $h‍_once,   importMeta: $h‍____meta, }) => (function () {   let getTag,passStyleOf,nameForPassableSymbol,passStylePrefixes,recordNames,recordValues;$h‍_imports([["@endo/pass-style", [["getTag", [$h‍_a => (getTag = $h‍_a)]],["passStyleOf", [$h‍_a => (passStyleOf = $h‍_a)]],["nameForPassableSymbol", [$h‍_a => (nameForPassableSymbol = $h‍_a)]]]],["./encodePassable.js", [["passStylePrefixes", [$h‍_a => (passStylePrefixes = $h‍_a)]],["recordNames", [$h‍_a => (recordNames = $h‍_a)]],["recordValues", [$h‍_a => (recordValues = $h‍_a)]]]]]);   






/** @typedef {import('@endo/pass-style').Passable} Passable */
/** @typedef {import('@endo/pass-style').PassStyle} PassStyle */
/** @typedef {import('./types.js').RankCover} RankCover */
/** @typedef {import('./types.js').RankComparison} RankComparison */
/** @typedef {import('./types.js').RankCompare} RankCompare */
/** @typedef {import('./types.js').FullCompare} FullCompare */

const { Fail, quote: q}=   assert;
const { entries, fromEntries, setPrototypeOf, is}=   Object;

/**
 * @typedef {object} RankComparatorKit
 * @property {RankCompare} comparator
 * @property {RankCompare} antiComparator
 */

/**
 * @typedef {object} FullComparatorKit
 * @property {FullCompare} comparator
 * @property {FullCompare} antiComparator
 */

/**
 * @typedef {[number, number]} IndexCover
 */

/**
 * This is the equality comparison used by JavaScript's Map and Set
 * abstractions, where NaN is the same as NaN and -0 is the same as
 * 0. Marshal serializes -0 as zero, so the semantics of our distributed
 * object system does not distinguish 0 from -0.
 *
 * `sameValueZero` is the EcmaScript spec name for this equality comparison,
 * but TODO we need a better name for the API.
 *
 * @param {any} x
 * @param {any} y
 * @returns {boolean}
 */
const sameValueZero=  (x, y)=>  x===  y||  is(x, y);

const        trivialComparator=  (left, right)=>
  // eslint-disable-next-line no-nested-ternary, @endo/restrict-comparison-operands
  left<  right?  -1:  left===  right?  0:  1;

/**
 * @typedef {Record<PassStyle, { index: number, cover: RankCover }>} PassStyleRanksRecord
 */$h‍_once.trivialComparator(trivialComparator);

const passStyleRanks=  /** @type {PassStyleRanksRecord} */
  fromEntries(
    entries(passStylePrefixes)
      // Sort entries by ascending prefix.
.      sort(([_leftStyle, leftPrefixes], [_rightStyle, rightPrefixes])=>  {
        return trivialComparator(leftPrefixes, rightPrefixes);
       }).
       map(([passStyle, prefixes], index)=>  {
        // Cover all strings that start with any character in `prefixes`,
        // verifying that it is sorted so that is
        // all s such that prefixes.at(0) ≤ s < successor(prefixes.at(-1)).
        prefixes===  [...prefixes].sort().join('')||
          Fail `unsorted prefixes for passStyle ${q(passStyle)}: ${q(prefixes)}`;
        const cover=  [
          prefixes.charAt(0),
          String.fromCharCode(prefixes.charCodeAt(prefixes.length-  1)+  1)];

        return [passStyle, { index, cover}];
       }));


setPrototypeOf(passStyleRanks, null);
harden(passStyleRanks);

/**
 * Associate with each passStyle a RankCover that may be an overestimate,
 * and whose results therefore need to be filtered down. For example, because
 * there is not a smallest or biggest bigint, bound it by `NaN` (the last place
 * number) and `''` (the empty string, which is the first place string). Thus,
 * a range query using this range may include these values, which would then
 * need to be filtered out.
 *
 * @param {PassStyle} passStyle
 * @returns {RankCover}
 */
const        getPassStyleCover=  (passStyle)=>passStyleRanks[passStyle].cover;$h‍_once.getPassStyleCover(getPassStyleCover);
harden(getPassStyleCover);

/**
 * @type {WeakMap<RankCompare,WeakSet<Passable[]>>}
 */
const memoOfSorted=  new WeakMap();

/**
 * @type {WeakMap<RankCompare,RankCompare>}
 */
const comparatorMirrorImages=  new WeakMap();

/**
 * @param {RankCompare=} compareRemotables
 * An option to create a comparator in which an internal order is
 * assigned to remotables. This defaults to a comparator that
 * always returns `0`, meaning that all remotables are tied
 * for the same rank.
 * @returns {RankComparatorKit}
 */
const        makeComparatorKit=  (compareRemotables=  (_x, _y)=>  0)=>  {
  /** @type {RankCompare} */
  const comparator=  (left, right)=>  {
    if( sameValueZero(left, right)) {
      return 0;
     }
    const leftStyle=  passStyleOf(left);
    const rightStyle=  passStyleOf(right);
    if( leftStyle!==  rightStyle) {
      return trivialComparator(
        passStyleRanks[leftStyle].index,
        passStyleRanks[rightStyle].index);

     }
    /* eslint-disable @endo/restrict-comparison-operands --
     * We know `left` and `right` are comparable.
     */
    switch( leftStyle){
      case 'remotable': {
        return compareRemotables(left, right);
       }
      case 'undefined':
      case 'null':
      case 'error':
      case 'promise': {
        // For each of these passStyles, all members of that passStyle are tied
        // for the same rank.
        return 0;
       }
      case 'boolean':
      case 'bigint':
      case 'string': {
        // Within each of these passStyles, the rank ordering agrees with
        // JavaScript's relational operators `<` and `>`.
        if( left<  right) {
          return -1;
         }else {
          assert(left>  right);
          return 1;
         }
       }
      case 'symbol': {
        return comparator(
          nameForPassableSymbol(left),
          nameForPassableSymbol(right));

       }
      case 'number': {
        // `NaN`'s rank is after all other numbers.
        if( Number.isNaN(left)) {
          assert(!Number.isNaN(right));
          return 1;
         }else if( Number.isNaN(right)) {
          return -1;
         }
        // The rank ordering of non-NaN numbers agrees with JavaScript's
        // relational operators '<' and '>'.
        if( left<  right) {
          return -1;
         }else {
          assert(left>  right);
          return 1;
         }
       }
      case 'copyRecord': {
        // Lexicographic by inverse sorted order of property names, then
        // lexicographic by corresponding values in that same inverse
        // order of their property names. Comparing names by themselves first,
        // all records with the exact same set of property names sort next to
        // each other in a rank-sort of copyRecords.

        // The copyRecord invariants enforced by passStyleOf ensure that
        // all the property names are strings. We need the reverse sorted order
        // of these names, which we then compare lexicographically. This ensures
        // that if the names of record X are a subset of the names of record Y,
        // then record X will have an earlier rank and sort to the left of Y.
        const leftNames=  recordNames(left);
        const rightNames=  recordNames(right);

        const result=  comparator(leftNames, rightNames);
        if( result!==  0) {
          return result;
         }
        return comparator(
          recordValues(left, leftNames),
          recordValues(right, rightNames));

       }
      case 'copyArray': {
        // Lexicographic
        const len=  Math.min(left.length, right.length);
        for( let i=  0; i<  len; i+=  1) {
          const result=  comparator(left[i], right[i]);
          if( result!==  0) {
            return result;
           }
         }
        // If all matching elements were tied, then according to their lengths.
        // If array X is a prefix of array Y, then X has an earlier rank than Y.
        return comparator(left.length, right.length);
       }
      case 'tagged': {
        // Lexicographic by `[Symbol.toStringTag]` then `.payload`.
        const labelComp=  comparator(getTag(left), getTag(right));
        if( labelComp!==  0) {
          return labelComp;
         }
        return comparator(left.payload, right.payload);
       }
      default: {
        throw Fail `Unrecognized passStyle: ${q(leftStyle)}`;
       }}

    /* eslint-enable */
   };

  /** @type {RankCompare} */
  const antiComparator=  (x, y)=>  comparator(y, x);

  memoOfSorted.set(comparator, new WeakSet());
  memoOfSorted.set(antiComparator, new WeakSet());
  comparatorMirrorImages.set(comparator, antiComparator);
  comparatorMirrorImages.set(antiComparator, comparator);

  return harden({ comparator, antiComparator});
 };
/**
 * @param {RankCompare} comparator
 * @returns {RankCompare=}
 */$h‍_once.makeComparatorKit(makeComparatorKit);
const        comparatorMirrorImage=  (comparator)=>
  comparatorMirrorImages.get(comparator);

/**
 * @param {Passable[]} passables
 * @param {RankCompare} compare
 * @returns {boolean}
 */$h‍_once.comparatorMirrorImage(comparatorMirrorImage);
const        isRankSorted=  (passables, compare)=>  {
  const subMemoOfSorted=  memoOfSorted.get(compare);
  assert(subMemoOfSorted!==  undefined);
  if( subMemoOfSorted.has(passables)) {
    return true;
   }
  assert(passStyleOf(passables)===  'copyArray');
  for( let i=  1; i<  passables.length; i+=  1) {
    if( compare(passables[i-  1], passables[i])>=  1) {
      return false;
     }
   }
  subMemoOfSorted.add(passables);
  return true;
 };$h‍_once.isRankSorted(isRankSorted);
harden(isRankSorted);

/**
 * @param {Passable[]} sorted
 * @param {RankCompare} compare
 */
const        assertRankSorted=  (sorted, compare)=>
  isRankSorted(sorted, compare)||
  // TODO assert on bug could lead to infinite recursion. Fix.
  // eslint-disable-next-line no-use-before-define
  Fail `Must be rank sorted: ${sorted} vs ${sortByRank(sorted,compare) }`;$h‍_once.assertRankSorted(assertRankSorted);
harden(assertRankSorted);

/**
 * TODO SECURITY BUG: https://github.com/Agoric/agoric-sdk/issues/4260
 * sortByRank currently uses `Array.prototype.sort` directly, and
 * so only works correctly when given a `compare` function that considers
 * `undefined` strictly bigger (`>`) than everything else. This is
 * because `Array.prototype.sort` bizarrely moves all `undefined`s to
 * the end of the array regardless, without consulting the `compare`
 * function. This is a genuine bug for us NOW because sometimes we sort
 * in reverse order by passing a reversed rank comparison function.
 *
 * @param {Iterable<Passable>} passables
 * @param {RankCompare} compare
 * @returns {Passable[]}
 */
const        sortByRank=  (passables, compare)=>  {
  if( Array.isArray(passables)) {
    harden(passables);
    // Calling isRankSorted gives it a chance to get memoized for
    // this `compare` function even if it was already memoized for a different
    // `compare` function.
    if( isRankSorted(passables, compare)) {
      return passables;
     }
   }
  const unsorted=  [...passables];
  unsorted.forEach(harden);
  const sorted=  harden(unsorted.sort(compare));
  const subMemoOfSorted=  memoOfSorted.get(compare);
  assert(subMemoOfSorted!==  undefined);
  subMemoOfSorted.add(sorted);
  return sorted;
 };$h‍_once.sortByRank(sortByRank);
harden(sortByRank);

/**
 * See
 * https://en.wikipedia.org/wiki/Binary_search_algorithm#Procedure_for_finding_the_leftmost_element
 *
 * @param {Passable[]} sorted
 * @param {RankCompare} compare
 * @param {Passable} key
 * @param {("leftMost" | "rightMost")=} bias
 * @returns {number}
 */
const rankSearch=  (sorted, compare, key, bias=  'leftMost')=>  {
  assertRankSorted(sorted, compare);
  let left=  0;
  let right=  sorted.length;
  while( left<  right) {
    const m=  Math.floor((left+  right)/  2);
    const comp=  compare(sorted[m], key);
    if( comp<=  -1||   comp===  0&&  bias===  'rightMost')  {
      left=  m+  1;
     }else {
      assert(comp>=  1||   comp===  0&&  bias===  'leftMost');
      right=  m;
     }
   }
  return bias===  'leftMost'?  left:  right-  1;
 };

/**
 * @param {Passable[]} sorted
 * @param {RankCompare} compare
 * @param {RankCover} rankCover
 * @returns {IndexCover}
 */
const        getIndexCover=  (sorted, compare, [leftKey, rightKey])=>  {
  assertRankSorted(sorted, compare);
  const leftIndex=  rankSearch(sorted, compare, leftKey, 'leftMost');
  const rightIndex=  rankSearch(sorted, compare, rightKey, 'rightMost');
  return [leftIndex, rightIndex];
 };$h‍_once.getIndexCover(getIndexCover);
harden(getIndexCover);

/** @type {RankCover} */
const        FullRankCover=  harden(['', '{']);

/**
 * @param {Passable[]} sorted
 * @param {IndexCover} indexCover
 * @returns {Iterable<[number, Passable]>}
 */$h‍_once.FullRankCover(FullRankCover);
const        coveredEntries=  (sorted, [leftIndex, rightIndex])=>  {
  /** @type {Iterable<[number, Passable]>} */
  const iterable=  harden({
    [Symbol.iterator]: ()=>  {
      let i=  leftIndex;
      return harden({
        next: ()=>  {
          if( i<=  rightIndex) {
            const element=  sorted[i];
            i+=  1;
            return harden({ value: [i, element], done: false});
           }else {
            return harden({ value: undefined, done: true});
           }
         }});

     }});

  return iterable;
 };$h‍_once.coveredEntries(coveredEntries);
harden(coveredEntries);

/**
 * @param {RankCompare} compare
 * @param {Passable} a
 * @param {Passable} b
 * @returns {Passable}
 */
const maxRank=  (compare, a, b)=>   compare(a, b)>=  0?  a:  b;

/**
 * @param {RankCompare} compare
 * @param {Passable} a
 * @param {Passable} b
 * @returns {Passable}
 */
const minRank=  (compare, a, b)=>   compare(a, b)<=  0?  a:  b;

/**
 * @param {RankCompare} compare
 * @param {RankCover[]} covers
 * @returns {RankCover}
 */
const        unionRankCovers=  (compare, covers)=>  {
  /**
   * @param {RankCover} a
   * @param {RankCover} b
   * @returns {RankCover}
   */
  const unionRankCoverPair=  ([leftA, rightA], [leftB, rightB])=>  [
    minRank(compare, leftA, leftB),
    maxRank(compare, rightA, rightB)];

  return covers.reduce(unionRankCoverPair, ['{', '']);
 };$h‍_once.unionRankCovers(unionRankCovers);
harden(unionRankCovers);

/**
 * @param {RankCompare} compare
 * @param {RankCover[]} covers
 * @returns {RankCover}
 */
const        intersectRankCovers=  (compare, covers)=>  {
  /**
   * @param {RankCover} a
   * @param {RankCover} b
   * @returns {RankCover}
   */
  const intersectRankCoverPair=  ([leftA, rightA], [leftB, rightB])=>  [
    maxRank(compare, leftA, leftB),
    minRank(compare, rightA, rightB)];

  return covers.reduce(intersectRankCoverPair, ['', '{']);
 };$h‍_once.intersectRankCovers(intersectRankCovers);

const        { comparator: compareRank, antiComparator: compareAntiRank}=
  makeComparatorKit();

/**
 * Create a comparator kit in which remotables are fully ordered
 * by the order in which they are first seen by *this* comparator kit.
 * BEWARE: This is observable mutable state, so such a comparator kit
 * should never be shared among subsystems that should not be able
 * to communicate.
 *
 * Note that this order does not meet the requirements for store
 * ordering, since it has no memory of deleted keys.
 *
 * These full order comparator kit is strictly more precise that the
 * rank order comparator kits above. As a result, any array which is
 * sorted by such a full order will pass the isRankSorted test with
 * a corresponding rank order.
 *
 * An array which is sorted by a *fresh* full order comparator, i.e.,
 * one that has not yet seen any remotables, will of course remain
 * sorted by according to *that* full order comparator. An array *of
 * scalars* sorted by a fresh full order will remain sorted even
 * according to a new fresh full order comparator, since it will see
 * the remotables in the same order again. Unfortunately, this is
 * not true of arrays of passables in general.
 *
 * @param {boolean=} longLived
 * @returns {FullComparatorKit}
 */$h‍_once.compareRank(compareRank);$h‍_once.compareAntiRank(compareAntiRank);
const        makeFullOrderComparatorKit=  (longLived=  false)=>  {
  let numSeen=  0;
  // When dynamically created with short lifetimes (the default) a WeakMap
  // would perform poorly, and the leak created by a Map only lasts as long
  // as the Map.
  const MapConstructor=  longLived?  WeakMap:  Map;
  const seen=  new MapConstructor();
  const tag=  (r)=>{
    if( seen.has(r)) {
      return seen.get(r);
     }
    numSeen+=  1;
    seen.set(r, numSeen);
    return numSeen;
   };
  const compareRemotables=  (x, y)=>  compareRank(tag(x), tag(y));
  return makeComparatorKit(compareRemotables);
 };$h‍_once.makeFullOrderComparatorKit(makeFullOrderComparatorKit);
harden(makeFullOrderComparatorKit);
})()
,
// === functors[141] ===
({   imports: $h‍_imports,   liveVar: $h‍_live,   onceVar: $h‍_once,   importMeta: $h‍____meta, }) => (function () {   $h‍_imports([]);   
})()
,
// === functors[142] ===
({   imports: $h‍_imports,   liveVar: $h‍_live,   onceVar: $h‍_once,   importMeta: $h‍____meta, }) => (function () {   $h‍_imports([["./src/deeplyFulfilled.js", []],["./src/encodeToCapData.js", []],["./src/marshal.js", []],["./src/marshal-stringify.js", []],["./src/marshal-justin.js", []],["./src/encodePassable.js", []],["./src/rankOrder.js", []],["./src/types.js", []],["@endo/pass-style", []]]);   
})()
,
// === functors[143] ===
({   imports: $h‍_imports,   liveVar: $h‍_live,   onceVar: $h‍_once,   importMeta: $h‍____meta, }) => (function () {   $h‍_imports([]);   /** @typedef {string} CapTPSlot */

/**
 * @typedef {object} TrapImpl
 * @property {(target: any, args: Array<any>) => any} applyFunction function
 * application
 * @property {(
 *   target: any,
 *   method: string | symbol | number,
 *   args: Array<any>
 * ) => any} applyMethod method invocation, which is an atomic lookup of method
 * and apply
 * @property {(target: any, prop: string | symbol | number) => any} get property
 * lookup
 */

/**
 * @typedef {[boolean, import('@endo/marshal').CapData<CapTPSlot>]} TrapCompletion The head of the pair
 * is the `isRejected` value indicating whether the sync call was an exception,
 * and tail of the pair is the serialized fulfillment value or rejection reason.
 * (The fulfillment value is a non-thenable.  The rejection reason is normally
 * an error.)
 */

/**
 * @typedef TrapRequest the argument to TrapGuest
 * @property {keyof TrapImpl} trapMethod the TrapImpl method that was called
 * @property {CapTPSlot} slot the target slot
 * @property {Array<any>} trapArgs arguments to the TrapImpl method
 * @property {() => Required<Iterator<void, void, any>>} startTrap start the
 * trap process on the trapHost, and drive the other side.
 */

/**
 * @callback TrapGuest Use out-of-band communications to synchronously return a
 * TrapCompletion value indicating the final results of a Trap call.
 * @param {TrapRequest} req
 * @returns {TrapCompletion}
 */

/**
 * @callback TrapHost start the process of transferring the Trap request's
 * results
 * @param {TrapCompletion} completion
 * @returns {AsyncIterator<void, void, any> | undefined} If an AsyncIterator is
 * returned, it will satisfy a future guest IterationObserver.
 */

/** @typedef {import('./ts-types.js').Trap} Trap */

/**
 * @template T
 * @typedef {import('./ts-types').TrapHandler<T>} TrapHandler
 */
})()
,
// === functors[144] ===
({   imports: $h‍_imports,   liveVar: $h‍_live,   onceVar: $h‍_once,   importMeta: $h‍____meta, }) => (function () {   $h‍_imports([["./types.js", []]]);   



/**
 * Default implementation of Trap for near objects.
 *
 * @type {TrapImpl}
 */
const        nearTrapImpl=  harden({
  applyFunction(target, args) {
    return target(...args);
   },
  applyMethod(target, prop, args) {
    return target[prop](...args);
   },
  get(target, prop) {
    return target[prop];
   }});


/** @type {ProxyHandler<any>} */$h‍_once.nearTrapImpl(nearTrapImpl);
const baseFreezableProxyHandler=  {
  set(_target, _prop, _value) {
    return false;
   },
  isExtensible(_target) {
    return false;
   },
  setPrototypeOf(_target, _value) {
    return false;
   },
  deleteProperty(_target, _prop) {
    return false;
   }};


/**
 * A Proxy handler for Trap(x)
 *
 * @param {*} x Any value passed to Trap(x)
 * @param {TrapImpl} trapImpl
 * @returns {ProxyHandler}
 */
const TrapProxyHandler=  (x, trapImpl)=>  {
  return harden({
    ...baseFreezableProxyHandler,
    get(_target, p, _receiver) {
      return (...args)=>  trapImpl.applyMethod(x, p, args);
     },
    apply(_target, _thisArg, argArray=  []) {
      return trapImpl.applyFunction(x, argArray);
     },
    has(_target, _p) {
      // TODO: has property is not yet transferrable over captp.
      return true;
     }});

 };

/**
 * @param {TrapImpl} trapImpl
 * @returns {Trap}
 */
const        makeTrap=  (trapImpl)=>{
  const Trap=  (x)=>{
    const handler=  TrapProxyHandler(x, trapImpl);
    return harden(new Proxy(()=>  { },handler));
   };

  const makeTrapGetterProxy=  (x)=>{
    const handler=  harden({
      ...baseFreezableProxyHandler,
      has(_target, _prop) {
        // TODO: has property is not yet transferrable over captp.
        return true;
       },
      get(_target, prop) {
        return trapImpl.get(x, prop);
       }});

    return new Proxy(Object.create(null), handler);
   };
  Trap.get=  makeTrapGetterProxy;

  return harden(Trap);
 };$h‍_once.makeTrap(makeTrap);
})()
,
// === functors[145] ===
({   imports: $h‍_imports,   liveVar: $h‍_live,   onceVar: $h‍_once,   importMeta: $h‍____meta, }) => (function () {   let Far,isObject;$h‍_imports([["@endo/marshal", [["Far", [$h‍_a => (Far = $h‍_a)]],["isObject", [$h‍_a => (isObject = $h‍_a)]]]]]);   


// @ts-check
const { WeakRef, FinalizationRegistry}=   globalThis;

/**
 * @template K
 * @template {object} V
 * @typedef {Pick<Map<K, V>, 'get' | 'has' | 'delete'> &
 *  {
 *   set: (key: K, value: V) => void,
 *   clearWithoutFinalizing: () => void,
 *   getSize: () => number,
 * }} FinalizingMap
 */

/**
 *
 * Elsewhere this is known as a "Weak Value Map". Whereas a std JS WeakMap
 * is weak on its keys, this map is weak on its values. It does not retain these
 * values strongly. If a given value disappears, then the entries for it
 * disappear from every weak-value-map that holds it as a value.
 *
 * Just as a WeakMap only allows gc-able values as keys, a weak-value-map
 * only allows gc-able values as values.
 *
 * Unlike a WeakMap, a weak-value-map unavoidably exposes the non-determinism of
 * gc to its clients. Thus, both the ability to create one, as well as each
 * created one, must be treated as dangerous capabilities that must be closely
 * held. A program with access to these can read side channels though gc that do
 * not* rely on the ability to measure duration. This is a separate, and bad,
 * timing-independent side channel.
 *
 * This non-determinism also enables code to escape deterministic replay. In a
 * blockchain context, this could cause validators to differ from each other,
 * preventing consensus, and thus preventing chain progress.
 *
 * JS standards weakrefs have been carefully designed so that operations which
 * `deref()` a weakref cause that weakref to remain stable for the remainder of
 * that turn. The operations below guaranteed to do this derefing are `has`,
 * `get`, `set`, `delete`. Note that neither `clearWithoutFinalizing` nor
 * `getSize` are guaranteed to deref. Thus, a call to `map.getSize()` may
 * reflect values that might still be collected later in the same turn.
 *
 * @template K
 * @template {object} V
 * @param {(key: K) => void} [finalizer]
 * @param {object} [opts]
 * @param {boolean} [opts.weakValues]
 * @returns {FinalizingMap<K, V> &
 *  import('@endo/eventual-send').RemotableBrand<{}, FinalizingMap<K, V>>
 * }
 */
const        makeFinalizingMap=  (finalizer, opts)=>  {
  const { weakValues=  false}=   opts||  {};
  if( !weakValues||  !WeakRef||  !FinalizationRegistry) {
    /** @type Map<K, V> */
    const keyToVal=  new Map();
    return Far('fakeFinalizingMap', {
      clearWithoutFinalizing: keyToVal.clear.bind(keyToVal),
      get: keyToVal.get.bind(keyToVal),
      has: keyToVal.has.bind(keyToVal),
      set: (key, val)=>  {
        keyToVal.set(key, val);
       },
      delete: keyToVal.delete.bind(keyToVal),
      getSize: ()=>  keyToVal.size});

   }
  /** @type Map<K, WeakRef<any>> */
  const keyToRef=  new Map();
  const registry=  new FinalizationRegistry((key)=>{
    // Because this will delete the current binding of `key`, we need to
    // be sure that it is not called because a previous binding was collected.
    // We do this with the `unregister` in `set` below, assuming that
    // `unregister` *immediately* suppresses the finalization of the thing
    // it unregisters. TODO If this is not actually guaranteed, i.e., if
    // finalizations that have, say, already been scheduled might still
    // happen after they've been unregistered, we will need to revisit this.
    // eslint-disable-next-line no-use-before-define
    finalizingMap.delete(key);
   });
  const finalizingMap=  Far('finalizingMap', {
    /**
     * `clearWithoutFinalizing` does not `deref` anything, and so does not
     * suppress collection of the weakly-pointed-to values until the end of the
     * turn.  Because `clearWithoutFinalizing` immediately removes all entries
     * from this map, this possible collection is not observable using only this
     * map instance.  But it is observable via other uses of WeakRef or
     * FinalizationGroup, including other map instances made by this
     * `makeFinalizingMap`.
     */
    clearWithoutFinalizing: ()=>  {
      for( const ref of keyToRef.values()) {
        registry.unregister(ref);
       }
      keyToRef.clear();
     },
    // Does deref, and thus does guarantee stability of the value until the
    // end of the turn.
    // UNTIL https://github.com/endojs/endo/issues/1514
    // Prefer: get: key => keyToRef.get(key)?.deref(),
    get: (key)=>{
      const wr=  keyToRef.get(key);
      if( !wr) {
        return wr;
       }
      return wr.deref();
     },
    has: (key)=>finalizingMap.get(key)!==  undefined,
    // Does deref, and thus does guarantee stability of both old and new values
    // until the end of the turn.
    set: (key, ref)=>  {
      assert(isObject(ref));
      finalizingMap.delete(key);
      const newWR=  new WeakRef(ref);
      keyToRef.set(key, newWR);
      registry.register(ref, key, newWR);
     },
    delete: (key)=>{
      const wr=  keyToRef.get(key);
      if( !wr) {
        return false;
       }

      registry.unregister(wr);
      keyToRef.delete(key);

      // Our semantics are to finalize upon explicit `delete`, `set` (which
      // calls `delete`) or garbage collection (which also calls `delete`).
      // `clearWithoutFinalizing` is exempt.
      if( finalizer) {
        finalizer(key);
       }
      return true;
     },
    getSize: ()=>  keyToRef.size});

  return finalizingMap;
 };$h‍_once.makeFinalizingMap(makeFinalizingMap);
})()
,
// === functors[146] ===
({   imports: $h‍_imports,   liveVar: $h‍_live,   onceVar: $h‍_once,   importMeta: $h‍____meta, }) => (function () {   let Remotable,Far,makeMarshal,QCLASS,E,HandledPromise,isPromise,makePromiseKit,makeTrap,makeFinalizingMap;$h‍_imports([["@endo/marshal", [["Remotable", [$h‍_a => (Remotable = $h‍_a)]],["Far", [$h‍_a => (Far = $h‍_a)]],["makeMarshal", [$h‍_a => (makeMarshal = $h‍_a)]],["QCLASS", [$h‍_a => (QCLASS = $h‍_a)]]]],["@endo/eventual-send", [["E", [$h‍_a => (E = $h‍_a),$h‍_live["E"]]],["HandledPromise", [$h‍_a => (HandledPromise = $h‍_a)]]]],["@endo/promise-kit", [["isPromise", [$h‍_a => (isPromise = $h‍_a)]],["makePromiseKit", [$h‍_a => (makePromiseKit = $h‍_a)]]]],["./trap.js", [["makeTrap", [$h‍_a => (makeTrap = $h‍_a)]]]],["./types.js", []],["./finalize.js", [["makeFinalizingMap", [$h‍_a => (makeFinalizingMap = $h‍_a)]]]]]);   




















const { details: X, Fail}=   assert;

const WELL_KNOWN_SLOT_PROPERTIES=  harden(['answerID', 'questionID', 'target']);

/**
 * @param {any} maybeThenable
 * @returns {boolean}
 */
const isThenable=  (maybeThenable)=>
  maybeThenable&&  typeof maybeThenable.then===  'function';

/**
 * Reverse slot direction.
 *
 * Reversed to prevent namespace collisions between slots we
 * allocate and the ones the other side allocates.  If we allocate
 * a slot, serialize it to the other side, and they send it back to
 * us, we need to reference just our own slot, not one from their
 * side.
 *
 * @param {CapTPSlot} slot
 * @returns {CapTPSlot} slot with direction reversed
 */
const reverseSlot=  (slot)=>{
  const otherDir=  slot[1]===  '+'?  '-':  '+';
  const revslot=   `${slot[0]}${otherDir}${slot.slice(2)}`;
  return revslot;
 };

/**
 * @typedef {object} CapTPOptions the options to makeCapTP
 * @property {(val: unknown, slot: CapTPSlot) => void} [exportHook]
 * @property {(val: unknown, slot: CapTPSlot) => void} [importHook]
 * @property {(err: any) => void} [onReject]
 * @property {number} [epoch] an integer tag to attach to all messages in order to
 * assist in ignoring earlier defunct instance's messages
 * @property {TrapGuest} [trapGuest] if specified, enable this CapTP (guest) to
 * use Trap(target) to block while the recipient (host) resolves and
 * communicates the response to the message
 * @property {TrapHost} [trapHost] if specified, enable this CapTP (host) to serve
 * objects marked with makeTrapHandler to synchronous clients (guests)
 * @property {boolean} [gcImports] if true, aggressively garbage collect imports
 */

/**
 * Create a CapTP connection.
 *
 * @param {string} ourId our name for the current side
 * @param {(obj: Record<string, any>) => void} rawSend send a JSONable packet
 * @param {any} bootstrapObj the object to export to the other side
 * @param {CapTPOptions} opts options to the connection
 */
const        makeCapTP=  (
  ourId,
  rawSend,
  bootstrapObj=  undefined,
  opts=  {})=>
     {
  /** @type {Record<string, number>} */
  const sendStats=  {};
  /** @type {Record<string, number>} */
  const recvStats=  {};

  const gcStats=  {
    DROPPED: 0};

  const getStats=  ()=>
    harden({
      send: { ...sendStats},
      recv: { ...recvStats},
      gc: { ...gcStats}});


  const {
    onReject=  (err)=>console.error('CapTP', ourId, 'exception:', err),
    epoch=  0,
    exportHook,
    importHook,
    trapGuest,
    trapHost,
    gcImports=  false}=
      opts;

  // It's a hazard to have trapGuest and trapHost both enabled, as we may
  // encounter deadlock.  Without a lot more bookkeeping, we can't detect it for
  // more general networks of CapTPs, but we are conservative for at least this
  // one case.
  !(trapHost&&  trapGuest)||
    Fail `CapTP ${ourId} can only be one of either trapGuest or trapHost`;

  const disconnectReason=  (id)=>
    Error( `${JSON.stringify(id)} connection closed`);

  /** @type {Map<string, Promise<IteratorResult<void, void>>>} */
  const trapIteratorResultP=  new Map();
  /** @type {Map<string, AsyncIterator<void, void, any>>} */
  const trapIterator=  new Map();

  /** @type {any} */
  let unplug=  false;
  const quietReject=  (reason=  undefined, returnIt=  true)=>  {
    if( (unplug===  false||  reason!==  unplug)&&  reason!==  undefined) {
      onReject(reason);
     }
    if( !returnIt) {
      return Promise.resolve();
     }

    // Silence the unhandled rejection warning, but don't affect
    // the user's handlers.
    const p=  Promise.reject(reason);
    p.catch((_)=>{ });
    return p;
   };

  /**
   * @template T
   * @param {Map<T, number>} specimenToRefCount
   * @param {(specimen: T) => boolean} predicate
   */
  const makeRefCounter=  (specimenToRefCount, predicate)=>  {
    /** @type {Set<T>} */
    const seen=  new Set();

    return harden({
      add(specimen) {
        if( predicate(specimen)) {
          seen.add(specimen);
         }
        return specimen;
       },
      commit() {
        // Increment the reference count for each seen specimen.
        for( const specimen of seen.keys()) {
          const numRefs=  specimenToRefCount.get(specimen)||  0;
          specimenToRefCount.set(specimen, numRefs+  1);
         }
        seen.clear();
       },
      abort() {
        seen.clear();
       }});

   };

  /** @type {Map<CapTPSlot, number>} */
  const slotToNumRefs=  new Map();

  const recvSlot=  makeRefCounter(
    slotToNumRefs,
    (slot)=>typeof slot===  'string'&&  slot[1]===  '-');


  const sendSlot=  makeRefCounter(
    slotToNumRefs,
    (slot)=>typeof slot===  'string'&&  slot[1]===  '+');


  /**
   * @param {Record<string, any>} obj
   */
  const send=  (obj)=>{
    sendStats[obj.type]=  (sendStats[obj.type]||  0)+  1;

    for( const prop of WELL_KNOWN_SLOT_PROPERTIES) {
      sendSlot.add(obj[prop]);
     }
    sendSlot.commit();

    // Don't throw here if unplugged, just don't send.
    if( unplug!==  false) {
      return;
     }

    // Actually send the message, in the next turn.
    rawSend(obj);
   };

  /**
   * convertValToSlot and convertSlotToVal both perform side effects,
   * populating the c-lists (imports/exports/questions/answers) upon
   * marshalling/unmarshalling.  As we traverse the datastructure representing
   * the message, we discover what we need to import/export and send relevant
   * messages across the wire.
   */
  const { serialize, unserialize}=   makeMarshal(
    // eslint-disable-next-line no-use-before-define
    convertValToSlot,
    // eslint-disable-next-line no-use-before-define
    convertSlotToVal,
    {
      marshalName:  `captp:${ourId}`,
      // TODO Temporary hack.
      // See https://github.com/Agoric/agoric-sdk/issues/2780
      errorIdNum: 20000,
      // TODO: fix captp to be compatible with smallcaps
      serializeBodyFormat: 'capdata'});



  /** @type {WeakMap<any, CapTPSlot>} */
  const valToSlot=  new WeakMap(); // exports looked up by val
  /** @type {Map<CapTPSlot, any>} */
  const slotToExported=  new Map();
  const slotToImported=  makeFinalizingMap(
    /**
     * @param {CapTPSlot} slotID
     */
    (slotID)=>{
      // We drop all the references we know about at once, since GC told us we
      // don't need them anymore.
      const decRefs=  slotToNumRefs.get(slotID)||  0;
      slotToNumRefs.delete(slotID);
      send({ type: 'CTP_DROP', slotID, decRefs, epoch});
     },
    { weakValues: gcImports});

  const exportedTrapHandlers=  new WeakSet();

  // Used to construct slot names for promises/non-promises.
  // In this version of CapTP we use strings for export/import slot names.
  // prefixed with 'p' if promises and 'o' otherwise;
  let lastPromiseID=  0;
  let lastExportID=  0;
  // Since we decide the ids for questions, we use this to increment the
  // question key

  /** @type {Map<CapTPSlot, Settler<unknown>>} */
  const settlers=  new Map();
  /** @type {Map<string, any>} */
  const answers=  new Map(); // chosen by our peer

  /**
   * Called at marshalling time.  Either retrieves an existing export, or if
   * not yet exported, records this exported object.  If a promise, sets up a
   * promise listener to inform the other side when the promise is
   * fulfilled/broken.
   *
   * @type {import('@endo/marshal').ConvertValToSlot<CapTPSlot>}
   */
  function convertValToSlot(val) {
    if( !valToSlot.has(val)) {
      /**
       * new export
       *
       * @type {CapTPSlot}
       */
      let slot;
      if( isPromise(val)) {
        // This is a promise, so we're going to increment the lastPromiseId
        // and use that to construct the slot name.  Promise slots are prefaced
        // with 'p+'.
        lastPromiseID+=  1;
        slot=   `p+${lastPromiseID}`;
        const promiseID=  reverseSlot(slot);
        if( exportHook) {
          exportHook(val, slot);
         }
        // Set up promise listener to inform other side when this promise
        // is fulfilled/broken
        const rejected=  (reason)=>
          send({
            type: 'CTP_RESOLVE',
            promiseID,
            rej: serialize(harden(reason))});

        E.when(
          val,
          (result)=>
            send({
              type: 'CTP_RESOLVE',
              promiseID,
              res: serialize(harden(result))}),

          rejected
          // Propagate internal errors as rejections.
).        catch(rejected);
       }else {
        // Since this isn't a promise, we instead increment the lastExportId and
        // use that to construct the slot name.  Non-promises are prefaced with
        // 'o+' for normal objects, or `t+` for syncable.
        const exportID=  lastExportID+  1;
        if( exportedTrapHandlers.has(val)) {
          slot=   `t+${exportID}`;
         }else {
          slot=   `o+${exportID}`;
         }
        if( exportHook) {
          exportHook(val, slot);
         }
        lastExportID=  exportID;
       }

      // Now record the export in both valToSlot and slotToVal so we can look it
      // up from either the value or the slot name later.
      valToSlot.set(val, slot);
      slotToExported.set(slot, val);
     }
    // At this point, the value is guaranteed to be exported, so return the
    // associated slot number.
    const slot=  valToSlot.get(val);
    assert.typeof(slot, 'string');

    return sendSlot.add(slot);
   }

  const IS_REMOTE_PUMPKIN=  harden({});
  /**
   * @type {import('@endo/marshal').ConvertSlotToVal<CapTPSlot>}
   */
  const assertValIsLocal=  (val)=>{
    const slot=  valToSlot.get(val);
    if( slot&&  slot[1]===  '-') {
      throw IS_REMOTE_PUMPKIN;
     }
   };

  const { serialize: assertOnlyLocal}=   makeMarshal(assertValIsLocal);
  const isOnlyLocal=  (specimen)=>{
    // Try marshalling the object, but throw on references to remote objects.
    try {
      assertOnlyLocal(harden(specimen));
      return true;
     }catch( e) {
      if( e===  IS_REMOTE_PUMPKIN) {
        return false;
       }
      throw e;
     }
   };

  /**
   * Generate a new question in the questions table and set up a new
   * remote handled promise.
   *
   * @returns {[CapTPSlot, Promise]}
   */
  const makeQuestion=  ()=>  {
    lastPromiseID+=  1;
    const slotID=   `q-${lastPromiseID}`;

    // eslint-disable-next-line no-use-before-define
    const { promise, settler}=   makeRemoteKit(slotID);
    settlers.set(slotID, settler);

    // To fix #2846:
    // We return 'p' to the handler, and the eventual resolution of 'p' will
    // be used to resolve the caller's Promise, but the caller never sees 'p'
    // itself. The caller got back their Promise before the handler ever got
    // invoked, and thus before queueMessage was called. If that caller
    // passes the Promise they received as argument or return value, we want
    // it to serialize as resultVPID. And if someone passes resultVPID to
    // them, we want the user-level code to get back that Promise, not 'p'.
    valToSlot.set(promise, slotID);
    slotToImported.set(slotID, promise);

    return [sendSlot.add(slotID), promise];
   };

  /**
   * @template [T=unknown]
   * @param {string} target
   * @returns {RemoteKit<T>}
   * Make a remote promise for `target` (an id in the questions table)
   */
  const makeRemoteKit=  (target)=>{
    /**
     * This handler is set up such that it will transform both
     * attribute access and method invocation of this remote promise
     * as also being questions / remote handled promises
     *
     * @type {import('@endo/eventual-send').EHandler<{}>}
     */
    const handler=  {
      get(_o, prop) {
        if( unplug!==  false) {
          return quietReject(unplug);
         }
        const [questionID, promise]=  makeQuestion();
        send({
          type: 'CTP_CALL',
          epoch,
          questionID,
          target,
          method: serialize(harden([prop]))});

        return promise;
       },
      applyFunction(_o, args) {
        if( unplug!==  false) {
          return quietReject(unplug);
         }
        const [questionID, promise]=  makeQuestion();
        send({
          type: 'CTP_CALL',
          epoch,
          questionID,
          target,
          method: serialize(harden([null, args]))});

        return promise;
       },
      applyMethod(_o, prop, args) {
        if( unplug!==  false) {
          return quietReject(unplug);
         }
        // Support: o~.[prop](...args) remote method invocation
        const [questionID, promise]=  makeQuestion();
        send({
          type: 'CTP_CALL',
          epoch,
          questionID,
          target,
          method: serialize(harden([prop, args]))});

        return promise;
       }};


    /** @type {Settler<T> | undefined} */
    let settler;

    /** @type {import('@endo/eventual-send').HandledExecutor<T>} */
    const executor=  (resolve, reject, resolveWithPresence)=>  {
      const s=  Far('settler', {
        resolve,
        reject,
        resolveWithPresence: ()=>  resolveWithPresence(handler)});

      settler=  s;
     };

    const promise=  new HandledPromise(executor, handler);
    assert(settler);

    // Silence the unhandled rejection warning, but don't affect
    // the user's handlers.
    promise.catch((e)=>quietReject(e, false));

    return harden({ promise, settler});
   };

  /**
   * Set up import
   *
   * @type {import('@endo/marshal').ConvertSlotToVal<CapTPSlot>}
   */
  function convertSlotToVal(theirSlot, iface=  undefined) {
    let val;
    const slot=  reverseSlot(theirSlot);

    if( slot[1]===  '+') {
      slotToExported.has(slot)||  Fail `Unknown export ${slot}`;
      return slotToExported.get(slot);
     }
    if( !slotToImported.has(slot)) {
      // Make a new handled promise for the slot.
      const { promise, settler}=   makeRemoteKit(slot);
      if( slot[0]===  'o'||  slot[0]===  't') {
        if( iface===  undefined) {
          iface=   `Alleged: Presence ${ourId} ${slot}`;
         }
        // A new remote presence
        // Use Remotable rather than Far to make a remote from a presence
        val=  Remotable(iface, undefined, settler.resolveWithPresence());
        if( importHook) {
          importHook(val, slot);
         }
       }else {
        val=  promise;
        if( importHook) {
          importHook(val, slot);
         }
        // A new promise
        settlers.set(slot, settler);
       }
      slotToImported.set(slot, val);
      valToSlot.set(val, slot);
     }

    // If we imported this slot, mark it as one our peer exported.
    return slotToImported.get(recvSlot.add(slot));
   }

  // Message handler used for CapTP dispatcher
  const handler=  {
    // Remote is asking for bootstrap object
    CTP_BOOTSTRAP(obj) {
      const { questionID}=   obj;
      const bootstrap=
        typeof bootstrapObj===  'function'?  bootstrapObj(obj):  bootstrapObj;
      E.when(bootstrap, (bs)=>{
        // console.log('sending bootstrap', bs);
        answers.set(questionID, bs);
        send({
          type: 'CTP_RETURN',
          epoch,
          answerID: questionID,
          result: serialize(bs)});

       });
     },
    CTP_DROP(obj) {
      const { slotID, decRefs=  0}=   obj;
      // Ensure we are decrementing one of our exports.
      slotID[1]===  '-'||  Fail `Cannot drop non-exported ${slotID}`;
      const slot=  reverseSlot(slotID);

      const numRefs=  slotToNumRefs.get(slot)||  0;
      const toDecr=  Number(decRefs);
      if( numRefs>  toDecr) {
        slotToNumRefs.set(slot, numRefs-  toDecr);
       }else {
        // We are dropping the last known reference to this slot.
        gcStats.DROPPED+=  1;
        slotToNumRefs.delete(slot);
        slotToExported.delete(slot);
        answers.delete(slot);
       }
     },
    // Remote is invoking a method or retrieving a property.
    CTP_CALL(obj) {
      // questionId: Remote promise (for promise pipelining) this call is
      //   to fulfill
      // target: Slot id of the target to be invoked.  Checks against
      //   answers first; otherwise goes through unserializer
      const { questionID, target, trap}=   obj;

      const [prop, args]=  unserialize(obj.method);
      let val;
      if( answers.has(target)) {
        val=  answers.get(target);
       }else {
        val=  unserialize({
          body: JSON.stringify({
            [QCLASS]: 'slot',
            index: 0}),

          slots: [target]});

       }

      /** @type {(isReject: boolean, value: any) => void} */
      let processResult=  (isReject, value)=>  {
        // Serialize the result.
        let serial;
        try {
          serial=  serialize(harden(value));
         }catch( error) {
          // Promote serialization errors to rejections.
          isReject=  true;
          serial=  serialize(harden(error));
         }

        send({
          type: 'CTP_RETURN',
          epoch,
          answerID: questionID,
          [isReject?  'exception':  'result']: serial});

       };
      if( trap) {
        exportedTrapHandlers.has(val)||
          Fail `Refused Trap(${val}) because target was not registered with makeTrapHandler`;
        assert.typeof(
          trapHost,
          'function',
          X `CapTP cannot answer Trap(${val}) without a trapHost function`);


        // We need to create a promise for the "isDone" iteration right now to
        // prevent a race with the other side.
        const resultPK=  makePromiseKit();
        trapIteratorResultP.set(questionID, resultPK.promise);

        processResult=  (isReject, value)=>  {
          const serialized=  serialize(harden(value));
          const ait=  trapHost([isReject, serialized]);
          if( !ait) {
            // One-shot, no async iterator.
            resultPK.resolve({ done: true});
            return;
           }

          // We're ready for them to drive the iterator.
          trapIterator.set(questionID, ait);
          resultPK.resolve({ done: false});
         };
       }

      // If `args` is supplied, we're applying a method or function...
      // otherwise this is property access
      let hp;
      if( !args) {
        hp=  HandledPromise.get(val, prop);
       }else if( prop===  null) {
        hp=  HandledPromise.applyFunction(val, args);
       }else {
        hp=  HandledPromise.applyMethod(val, prop, args);
       }

      // Answer with our handled promise
      answers.set(questionID, hp);

      hp
        // Process this handled promise method's result when settled.
.        then(
          (fulfilment)=>processResult(false, fulfilment),
          (reason)=>processResult(true, reason))

        // Propagate internal errors as rejections.
.        catch((reason)=>processResult(true, reason));
     },
    // Have the host serve more of the reply.
    CTP_TRAP_ITERATE: (obj)=>{
      trapHost||  Fail `CTP_TRAP_ITERATE is impossible without a trapHost`;
      const { questionID, serialized}=   obj;

      const resultP=  trapIteratorResultP.get(questionID);
      resultP||  Fail `CTP_TRAP_ITERATE did not expect ${questionID}`;

      const [method, args]=  unserialize(serialized);

      const getNextResultP=  async()=>   {
        const result=  await resultP;

        // Done with this trap iterator.
        const cleanup=  ()=>  {
          trapIterator.delete(questionID);
          trapIteratorResultP.delete(questionID);
          return harden({ done: true});
         };

        // We want to ensure we clean up the iterator in case of any failure.
        try {
          if( !result||  result.done) {
            return cleanup();
           }

          const ait=  trapIterator.get(questionID);
          if( !ait) {
            // The iterator is done, so we're done.
            return cleanup();
           }

          // Drive the next iteration.
          return await ait[method](...args);
         }catch( e) {
          cleanup();
          if( !e) {
            Fail `trapGuest expected trapHost AsyncIterator(${questionID}) to be done, but it wasn't`;
           }
          assert.note(e, X `trapHost AsyncIterator(${questionID}) threw`);
          throw e;
         }
       };

      // Store the next result promise.
      const nextResultP=  getNextResultP();
      trapIteratorResultP.set(questionID, nextResultP);

      // Ensure that our caller handles any rejection.
      return nextResultP.then(()=>  { });
     },
    // Answer to one of our questions.
    CTP_RETURN(obj) {
      const { result, exception, answerID}=   obj;
      const settler=  settlers.get(answerID);
      if( !settler) {
        throw Error(
           `Got an answer to a question we have not asked. (answerID = ${answerID} )`);

       }
      settlers.delete(answerID);
      if( 'exception'in  obj) {
        settler.reject(unserialize(exception));
       }else {
        settler.resolve(unserialize(result));
       }
     },
    // Resolution to an imported promise
    CTP_RESOLVE(obj) {
      const { promiseID, res, rej}=   obj;
      const settler=  settlers.get(promiseID);
      if( !settler) {
        // Not a promise we know about; maybe it was collected?
        throw Error(
           `Got a resolvement of a promise we have not imported. (promiseID = ${promiseID} )`);

       }
      settlers.delete(promiseID);
      if( 'rej'in  obj) {
        settler.reject(unserialize(rej));
       }else {
        settler.resolve(unserialize(res));
       }
     },
    // The other side has signaled something has gone wrong.
    // Pull the plug!
    CTP_DISCONNECT(obj) {
      const { reason=  disconnectReason(ourId)}=   obj;
      if( unplug===  false) {
        // Reject with the original reason.
        quietReject(obj.reason, false);
        unplug=  reason;
        // Deliver the object, even though we're unplugged.
        rawSend(obj);
       }
      // We no longer wish to subscribe to object finalization.
      slotToImported.clearWithoutFinalizing();
      for( const settler of settlers.values()) {
        settler.reject(reason);
       }
     }};


  // Get a reference to the other side's bootstrap object.
  const getBootstrap=  async()=>   {
    if( unplug!==  false) {
      return quietReject(unplug);
     }
    const [questionID, promise]=  makeQuestion();
    send({
      type: 'CTP_BOOTSTRAP',
      epoch,
      questionID});

    return harden(promise);
   };
  harden(handler);

  const validTypes=  new Set(Object.keys(handler));
  for( const t of validTypes.keys()) {
    sendStats[t]=  0;
    recvStats[t]=  0;
   }

  // Return a dispatch function.
  const dispatch=  (obj)=>{
    try {
      validTypes.has(obj.type)||  Fail `unknown message type ${obj.type}`;

      recvStats[obj.type]+=  1;
      if( unplug!==  false) {
        return false;
       }
      const fn=  handler[obj.type];
      if( !fn) {
        return false;
       }

      for( const prop of WELL_KNOWN_SLOT_PROPERTIES) {
        recvSlot.add(obj[prop]);
       }
      fn(obj);
      recvSlot.commit();

      return true;
     }catch( e) {
      recvSlot.abort();
      quietReject(e, false);

      return false;
     }
   };

  // Abort a connection.
  const abort=  (reason=  undefined)=>  {
    dispatch({ type: 'CTP_DISCONNECT', epoch, reason});
   };

  const makeTrapHandler=  (name, obj)=>  {
    const far=  Far(name, obj);
    exportedTrapHandlers.add(far);
    return far;
   };

  // Put together our return value.
  const rets=  {
    abort,
    dispatch,
    getBootstrap,
    getStats,
    isOnlyLocal,
    serialize,
    unserialize,
    makeTrapHandler,
    Trap: /** @type {Trap | undefined} */  undefined};


  if( trapGuest) {
    assert.typeof(trapGuest, 'function', X `opts.trapGuest must be a function`);

    // Create the Trap proxy maker.
    const makeTrapImpl=
      (implMethod)=>
      (val, ...implArgs)=>  {
        Promise.resolve(val)!==  val||
          Fail `Trap(${val}) target cannot be a promise`;

        const slot=  valToSlot.get(val);
        // TypeScript confused about `||` control flow so use `if` instead
        // https://github.com/microsoft/TypeScript/issues/50739
        if( !(slot&&  slot[1]===  '-')) {
          Fail `Trap(${val}) target was not imported`;
         }
        // @ts-expect-error TypeScript confused by `Fail` too?
        slot[0]===  't'||
          Fail `Trap(${val}) imported target was not created with makeTrapHandler`;

        // Send a "trap" message.
        lastPromiseID+=  1;
        const questionID=   `q-${lastPromiseID}`;

        // Encode the "method" parameter of the CTP_CALL.
        let method;
        switch( implMethod){
          case 'get': {
            const [prop]=  implArgs;
            method=  serialize(harden([prop]));
            break;
           }
          case 'applyFunction': {
            const [args]=  implArgs;
            method=  serialize(harden([null, args]));
            break;
           }
          case 'applyMethod': {
            const [prop, args]=  implArgs;
            method=  serialize(harden([prop, args]));
            break;
           }
          default: {
            Fail `Internal error; unrecognized implMethod ${implMethod}`;
           }}


        // Set up the trap call with its identifying information and a way to send
        // messages over the current CapTP data channel.
        const [isException, serialized]=  trapGuest({
          trapMethod: implMethod,
          // @ts-expect-error TypeScript confused by `Fail` too?
          slot,
          trapArgs: implArgs,
          startTrap: ()=>  {
            // Send the call metadata over the connection.
            send({
              type: 'CTP_CALL',
              epoch,
              trap: true, // This is the magic marker.
              questionID,
              target: slot,
              method});


            // Return an IterationObserver.
            const makeIteratorMethod=
              (iteratorMethod, done)=>
              (...args)=>  {
                send({
                  type: 'CTP_TRAP_ITERATE',
                  epoch,
                  questionID,
                  serialized: serialize(harden([iteratorMethod, args]))});

                return harden({ done, value: undefined});
               };
            return harden({
              next: makeIteratorMethod('next', false),
              return: makeIteratorMethod('return', true),
              throw: makeIteratorMethod('throw', true)});

           }});


        const value=  unserialize(serialized);
        !isThenable(value)||
          Fail `Trap(${val}) reply cannot be a Thenable; have ${value}`;

        if( isException) {
          throw value;
         }
        return value;
       };

    /** @type {TrapImpl} */
    const trapImpl=  {
      applyFunction: makeTrapImpl('applyFunction'),
      applyMethod: makeTrapImpl('applyMethod'),
      get: makeTrapImpl('get')};

    harden(trapImpl);

    rets.Trap=  makeTrap(trapImpl);
   }

  return harden(rets);
 };$h‍_once.makeCapTP(makeCapTP);
})()
,
// === functors[147] ===
({   imports: $h‍_imports,   liveVar: $h‍_live,   onceVar: $h‍_once,   importMeta: $h‍____meta, }) => (function () {   let Far,E,makeCapTP,nearTrapImpl,makeFinalizingMap;$h‍_imports([["@endo/marshal", [["Far", [$h‍_a => (Far = $h‍_a)]]]],["./captp.js", [["E", [$h‍_a => (E = $h‍_a),$h‍_live["E"]]],["makeCapTP", [$h‍_a => (makeCapTP = $h‍_a)]]]],["./trap.js", [["nearTrapImpl", [$h‍_a => (nearTrapImpl = $h‍_a)]]]],["./finalize.js", [["makeFinalizingMap", [$h‍_a => (makeFinalizingMap = $h‍_a)]]]]]);   






/**
 * @template T
 * @typedef {import('@endo/eventual-send').ERef<T>} ERef
 */

/**
 * Create an async-isolated channel to an object.
 *
 * @param {string} ourId
 * @param {import('./captp.js').CapTPOptions} [nearOptions]
 * @param {import('./captp.js').CapTPOptions} [farOptions]
 * @returns {{
 *   makeFar<T>(x: T): ERef<T>,
 *   makeNear<T>(x: T): ERef<T>,
 *   makeTrapHandler<T>(x: T): T,
 *   isOnlyNear(x: any): boolean,
 *   isOnlyFar(x: any): boolean,
 *   getNearStats(): any,
 *   getFarStats(): any,
 *   Trap: Trap
 * }}
 */
const        makeLoopback=  (ourId, nearOptions, farOptions)=>  {
  let lastNonce=  0;
  const nonceToRef=  makeFinalizingMap();

  const bootstrap=  Far('refGetter', {
    getRef(nonce) {
      // Find the local ref for the specified nonce.
      const xFar=  nonceToRef.get(nonce);
      nonceToRef.delete(nonce);
      return xFar;
     }});


  const slotBody=  JSON.stringify({
    '@qclass': 'slot',
    index: 0});


  // Create the tunnel.
  const {
    Trap,
    dispatch: nearDispatch,
    getBootstrap: getFarBootstrap,
    getStats: getNearStats,
    isOnlyLocal: isOnlyNear
    // eslint-disable-next-line no-use-before-define
}=    makeCapTP( `near-${ourId}`,(o)=>farDispatch(o), bootstrap, {
    trapGuest: ({ trapMethod, slot, trapArgs})=>   {
      let value;
      let isException=  false;
      try {
        // Cross the boundary to pull out the far object.
        // eslint-disable-next-line no-use-before-define
        const far=  farUnserialize({ body: slotBody, slots: [slot]});
        value=  nearTrapImpl[trapMethod](far, trapArgs[0], trapArgs[1]);
       }catch( e) {
        isException=  true;
        value=  e;
       }
      harden(value);
      // eslint-disable-next-line no-use-before-define
      return [isException, farSerialize(value)];
     },
    ...nearOptions});

  assert(Trap);

  const {
    makeTrapHandler,
    dispatch: farDispatch,
    getBootstrap: getNearBootstrap,
    getStats: getFarStats,
    isOnlyLocal: isOnlyFar,
    unserialize: farUnserialize,
    serialize: farSerialize}=
      makeCapTP( `far-${ourId}`,nearDispatch, bootstrap, farOptions);

  const farGetter=  getFarBootstrap();
  const nearGetter=  getNearBootstrap();

  /**
   * @template T
   * @param {ERef<{ getRef(nonce: number): T }>} refGetter
   */
  const makeRefMaker=
    (refGetter)=>
    /**
     * @param {T} x
     * @returns {Promise<T>}
     */
    async(x)=> {
      lastNonce+=  1;
      const myNonce=  lastNonce;
      const val=  await x;
      nonceToRef.set(myNonce, harden(val));
      return E(refGetter).getRef(myNonce);
     };

  return {
    makeFar: makeRefMaker(farGetter),
    makeNear: makeRefMaker(nearGetter),
    isOnlyNear,
    isOnlyFar,
    getNearStats,
    getFarStats,
    makeTrapHandler,
    Trap};

 };$h‍_once.makeLoopback(makeLoopback);
})()
,
// === functors[148] ===
({   imports: $h‍_imports,   liveVar: $h‍_live,   onceVar: $h‍_once,   importMeta: $h‍____meta, }) => (function () {   $h‍_imports([]);   /// <reference types="ses"/>

const { details: X, Fail}=   assert;

// This is a pathological minimum, but exercised by the unit test.
const        MIN_DATA_BUFFER_LENGTH=  1;

// Calculate how big the transfer buffer needs to be.
$h‍_once.MIN_DATA_BUFFER_LENGTH(MIN_DATA_BUFFER_LENGTH);const TRANSFER_OVERHEAD_LENGTH=
  BigUint64Array.BYTES_PER_ELEMENT+  Int32Array.BYTES_PER_ELEMENT;$h‍_once.TRANSFER_OVERHEAD_LENGTH(TRANSFER_OVERHEAD_LENGTH);
const        MIN_TRANSFER_BUFFER_LENGTH=
  MIN_DATA_BUFFER_LENGTH+  TRANSFER_OVERHEAD_LENGTH;

// These are bit flags for the status element of the transfer buffer.
$h‍_once.MIN_TRANSFER_BUFFER_LENGTH(MIN_TRANSFER_BUFFER_LENGTH);const STATUS_WAITING=1;
const STATUS_FLAG_DONE=  2;
const STATUS_FLAG_REJECT=  4;

/**
 * Return a status buffer, length buffer, and data buffer backed by transferBuffer.
 *
 * @param {SharedArrayBuffer} transferBuffer the backing buffer
 */
const splitTransferBuffer=  (transferBuffer)=>{
  transferBuffer.byteLength>=  MIN_TRANSFER_BUFFER_LENGTH||
    Fail `Transfer buffer of ${transferBuffer.byteLength} bytes is smaller than MIN_TRANSFER_BUFFER_LENGTH ${MIN_TRANSFER_BUFFER_LENGTH}`;
  const lenbuf=  new BigUint64Array(transferBuffer, 0, 1);

  // The documentation says that this needs to be an Int32Array for use with
  // Atomics.notify:
  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Atomics/notify#syntax
  const statusbuf=  new Int32Array(transferBuffer, lenbuf.byteLength, 1);
  const overheadLength=  lenbuf.byteLength+  statusbuf.byteLength;
  assert.equal(
    overheadLength,
    TRANSFER_OVERHEAD_LENGTH,
    X `Internal error; actual overhead ${overheadLength} of bytes is not TRANSFER_OVERHEAD_LENGTH ${TRANSFER_OVERHEAD_LENGTH}`);

  const databuf=  new Uint8Array(transferBuffer, overheadLength);
  databuf.byteLength>=  MIN_DATA_BUFFER_LENGTH||
    Fail `Transfer buffer of size ${transferBuffer.byteLength} only supports ${databuf.byteLength} data bytes; need at least ${MIN_DATA_BUFFER_LENGTH}`;
  return harden({ statusbuf, lenbuf, databuf});
 };

/**
 * Create a trapHost that can be paired with makeAtomicsTrapGuest.
 *
 * This host encodes the transfer buffer and returns it in consecutive slices
 * when the guest iterates over it.
 *
 * @param {SharedArrayBuffer} transferBuffer
 * @returns {TrapHost}
 */
const        makeAtomicsTrapHost=  (transferBuffer)=>{
  const { statusbuf, lenbuf, databuf}=   splitTransferBuffer(transferBuffer);

  const te=  new TextEncoder();

  return async function* trapHost([isReject, serialized]) {
    // Get the complete encoded message buffer.
    const json=  JSON.stringify(serialized);
    const encoded=  te.encode(json);

    // Send chunks in the data transfer buffer.
    let i=  0;
    let done=  false;
    while( !done) {
      // Copy the next slice of the encoded arry to the data buffer.
      const subenc=  encoded.subarray(i, i+  databuf.length);
      databuf.set(subenc);

      // Save the length of the remaining data.
      const remaining=  BigInt(encoded.length-  i);
      lenbuf[0]=  remaining;

      // Calculate the next slice, and whether this is the last one.
      i+=  subenc.length;
      done=  i>=  encoded.length;

      // Find bitflags to represent the rejected and finished state.
      const rejectFlag=  isReject?  STATUS_FLAG_REJECT:  0;
      const doneFlag=  done?  STATUS_FLAG_DONE:  0;

      // Notify our guest for this data buffer.

      // eslint-disable-next-line no-bitwise
      statusbuf[0]=  rejectFlag|  doneFlag;
      Atomics.notify(statusbuf, 0, +Infinity);

      if( !done) {
        // Wait until the next call to `it.next()`.  If the guest calls
        // `it.return()` or `it.throw()`, then this yield will return or throw,
        // terminating the generator function early.
        yield;
       }
     }
   };
 };

/**
 * Create a trapGuest that can be paired with makeAtomicsTrapHost.
 *
 * This guest iterates through the consecutive slices of the JSON-encoded data,
 * then returns it.
 *
 * @param {SharedArrayBuffer} transferBuffer
 * @returns {TrapGuest}
 */$h‍_once.makeAtomicsTrapHost(makeAtomicsTrapHost);
const        makeAtomicsTrapGuest=  (transferBuffer)=>{
  const { statusbuf, lenbuf, databuf}=   splitTransferBuffer(transferBuffer);

  return ({ startTrap})=>   {
    // Start by sending the trap call to the host.
    const it=  startTrap();

    /** @type {Uint8Array | undefined} */
    let encoded;
    let i=  0;
    let done=  false;
    while( !done) {
      // Tell that we are ready for another buffer.
      statusbuf[0]=  STATUS_WAITING;
      const { done: itDone}=   it.next();
      !itDone||  Fail `Internal error; it.next() returned done=${itDone}`;

      // Wait for the host to wake us.
      Atomics.wait(statusbuf, 0, STATUS_WAITING);

      // Determine whether this is the last buffer.
      // eslint-disable-next-line no-bitwise
      done=  (statusbuf[0]&  STATUS_FLAG_DONE)!==  0;

      // Accumulate the encoded buffer.
      const remaining=  Number(lenbuf[0]);
      const datalen=  Math.min(remaining, databuf.byteLength);
      if( !encoded) {
        if( done) {
          // Special case: we are done on first try, so we don't need to copy
          // anything.
          encoded=  databuf.subarray(0, datalen);
          break;
         }
        // Allocate our buffer for the remaining data.
        encoded=  new Uint8Array(remaining);
       }

      // Copy the next buffer.
      encoded.set(databuf.subarray(0, datalen), i);
      i+=  datalen;
     }

    // This throw is harmless if the host iterator has already finished, and
    // if not finished, captp will correctly raise an error.
    //
    // TODO: It would be nice to use an error type, but captp is just too
    // noisy with spurious "Temporary logging of sent error" messages.
    // it.throw(assert.error(X`Trap host has not finished`));
    it.throw(null);

    // eslint-disable-next-line no-bitwise
    const isReject=  !!(statusbuf[0]&  STATUS_FLAG_REJECT);

    // Decode the accumulated encoded buffer.
    const td=  new TextDecoder('utf-8');
    const json=  td.decode(encoded);

    // Parse the JSON data into marshalled form.
    const serialized=  JSON.parse(json);
    return [isReject, serialized];
   };
 };$h‍_once.makeAtomicsTrapGuest(makeAtomicsTrapGuest);
})()
,
// === functors[149] ===
({   imports: $h‍_imports,   liveVar: $h‍_live,   onceVar: $h‍_once,   importMeta: $h‍____meta, }) => (function () {   $h‍_imports([["@endo/nat", []],["@endo/marshal", []],["./captp.js", []],["./loopback.js", []],["./atomics.js", []]]);   
})()
,
// === functors[150] ===
({   imports: $h‍_imports,   liveVar: $h‍_live,   onceVar: $h‍_once,   importMeta: $h‍____meta, }) => (function () {   let E,makePromiseKit;$h‍_imports([["@endo/eventual-send", [["E", [$h‍_a => (E = $h‍_a)]]]],["@endo/promise-kit", [["makePromiseKit", [$h‍_a => (makePromiseKit = $h‍_a)]]]]]);   















/**
 * @template T
 * @typedef {{
 *   resolve(value?: T | Promise<T>): void,
 *   reject(error: Error): void,
 *   promise: Promise<T>
 * }} PromiseKit
 */

// TypeScript ReadOnly semantics are not sufficiently expressive to distinguish
// a value one promises not to alter from a value one must not alter,
// making it useless.
const freeze=  /** @type {<T>(v: T | Readonly<T>) => T} */  Object.freeze;

/**
 * @template T
 * @returns {import('./types.js').AsyncQueue<T>}
 */
const        makeQueue=  ()=>  {
  let { promise: tailPromise, resolve: tailResolve}=   makePromiseKit();
  return {
    put(value) {
      const { resolve, promise}=   makePromiseKit();
      tailResolve(freeze({ value, promise}));
      tailResolve=  resolve;
     },
    get() {
      const promise=  tailPromise.then((next)=>next.value);
      tailPromise=  tailPromise.then((next)=>next.promise);
      return harden(promise);
     }};

 };$h‍_once.makeQueue(makeQueue);
harden(makeQueue);

/**
 * @template TRead
 * @template TWrite
 * @template TReadReturn
 * @template TWriteReturn
 * @param {import('./types.js').AsyncQueue<IteratorResult<TRead, TReadReturn>>} acks
 * @param {import('./types.js').AsyncQueue<IteratorResult<TWrite, TWriteReturn>>} data
 */
const        makeStream=  (acks, data)=>  {
  const stream=  harden({
    /**
     * @param {TWrite} value
     */
    next(value) {
      // Note the shallow freeze since value is not guaranteed to be freezable
      // (typed arrays are not).
      data.put(freeze({ value, done: false}));
      return acks.get();
     },
    /**
     * @param {TWriteReturn} value
     */
    return(value) {
      data.put(freeze({ value, done: true}));
      return acks.get();
     },
    /**
     * @param {Error} error
     */
    throw(error) {
      data.put(harden(Promise.reject(error)));
      return acks.get();
     },
    [Symbol.asyncIterator]() {
      return stream;
     }});

  return stream;
 };$h‍_once.makeStream(makeStream);
harden(makeStream);

// JSDoc TypeScript seems unable to express this particular function's
// entanglement of queues, but the definition in types.d.ts works for the end
// user.
const        makePipe=  ()=>  {
  const data=  makeQueue();
  const acks=  makeQueue();
  const reader=  makeStream(acks, data);
  const writer=  makeStream(data, acks);
  return harden([writer, reader]);
 };$h‍_once.makePipe(makePipe);
harden(makePipe);

/**
 * @template TRead
 * @template TWrite
 * @template TReadReturn
 * @template TWriteReturn
 * @param {import('./types.js').Stream<TWrite, TRead, TWriteReturn, TReadReturn>} writer
 * @param {import('./types.js').Stream<TRead, TWrite, TReadReturn, TWriteReturn>} reader
 * @param {TWrite} primer
 */
const        pump=  async( writer, reader, primer)=>  {
  /** @param {Promise<IteratorResult<TRead, TReadReturn>>} promise */
  const tick=  (promise)=>
    E.when(
      promise,
      (result)=>{
        if( result.done) {
          return writer.return(result.value);
         }else {
          // Behold: mutual recursion.
          // eslint-disable-next-line no-use-before-define
          return tock(writer.next(result.value));
         }
       },
      (/** @type {Error} */ error)=>  {
        return writer.throw(error);
       });

  /** @param {Promise<IteratorResult<TWrite, TWriteReturn>>} promise */
  const tock=  (promise)=>
    E.when(
      promise,
      (result)=>{
        if( result.done) {
          return reader.return(result.value);
         }else {
          return tick(reader.next(result.value));
         }
       },
      (/** @type {Error} */ error)=>  {
        return reader.throw(error);
       });

  await tick(reader.next(primer));
  return undefined;
 };$h‍_once.pump(pump);
harden(pump);

/**
 * @template TRead
 * @template TWrite
 * @template TReturn
 * @param {AsyncGenerator<TRead, TReturn, TWrite>} generator
 * @param {TWrite} primer
 */
const        prime=  (generator, primer)=>  {
  // We capture the first returned promise.
  const first=  generator.next(primer);
  /** @type {IteratorResult<TRead, TReturn>=} */
  let result;
  const primed=  harden({
    /** @param {TWrite} value */
          async next(value){
      if( result===  undefined) {
        result=  await first;
        if( result.done) {
          return result;
         }
       }
      return generator.next(value);
     },
    /** @param {TReturn} value */
          async return(value){
      if( result===  undefined) {
        result=  await first;
        if( result.done) {
          return result;
         }
       }
      return generator.return(value);
     },
    /** @param {Error} error */
          async throw(error){
      if( result===  undefined) {
        result=  await first;
        if( result.done) {
          throw error;
         }
       }
      return generator.throw(error);
     }});

  return primed;
 };$h‍_once.prime(prime);
harden(prime);

/**
 * @template TIn
 * @template TOut
 * @param {import('./types.js').Reader<TIn>} reader
 * @param {(value: TIn) => TOut} transform
 * @returns {import('./types.js').Reader<TOut>}
 */
const        mapReader=  (reader, transform)=>  {
  async function* transformGenerator() {
    for await( const value of reader) {
      yield transform(value);
     }
    return undefined;
   }
  return harden(transformGenerator());
 };$h‍_once.mapReader(mapReader);
harden(mapReader);

/**
 * @template TIn
 * @template TOut
 * @param {import('./types.js').Writer<TOut>} writer
 * @param {(value: TIn) => TOut} transform
 * @returns {import('./types.js').Writer<TIn>}
 */
const        mapWriter=  (writer, transform)=>  {
  const transformedWriter=  harden({
    /**
     * @param {TIn} value
     */
          async next(value){
      return writer.next(transform(value));
     },
    /**
     * @param {Error} error
     */
          async throw(error){
      return writer.throw(error);
     },
    /**
     * @param {undefined} value
     */
          async return(value){
      return writer.return(value);
     },
    [Symbol.asyncIterator]() {
      return transformedWriter;
     }});

  return transformedWriter;
 };$h‍_once.mapWriter(mapWriter);
harden(mapWriter);
})()
,
// === functors[151] ===
({   imports: $h‍_imports,   liveVar: $h‍_live,   onceVar: $h‍_once,   importMeta: $h‍____meta, }) => (function () {   $h‍_imports([]);   // @ts-check
/// <reference types="ses"/>

const COLON=  ':'.charCodeAt(0);
const COMMA=  ','.charCodeAt(0);
const ZERO=  '0'.charCodeAt(0);
const NINE=  '9'.charCodeAt(0);

/**
 * @param {Iterable<Uint8Array> | AsyncIterable<Uint8Array>} input
 * @param {object} opts
 * @param {string} [opts.name]
 * @param {number} [opts.maxMessageLength]
 */
async function* makeNetstringIterator(
  input,
  { name=  '<unknown>', maxMessageLength=  999999999}=   {})
  {
  // eslint-disable-next-line no-bitwise
  const maxPrefixLength=   `${maxMessageLength| 0 }:`.length;

  // byte offset of data consumed so far in the input stream
  let offset=  0;

  // The iterator can be in 2 states: waiting for the length, or waiting for the data
  // - When waiting for the length, the lengthBuffer is an array containing
  //   digits charCodes for the length prefix
  // - When waiting for the data, the dataBuffer is either:
  //   - null to indicate no data has been received yet.
  //   - A newly allocated buffer large enough to accommodate the whole expected data.
  //   In either case, remainingDataLength contains the length of the data to read.
  //   If the whole data is received in one chunk, no copy is made.
  /** @type {number[] | null} */
  let lengthBuffer=  [];
  /** @type {Uint8Array | null} */
  let dataBuffer=  null;
  let remainingDataLength=  -1;

  for await( const chunk of input) {
    let buffer=  chunk;

    while( buffer.length) {
      // Waiting for full length prefix
      if( lengthBuffer) {
        let i=  0;
        while( i<  buffer.length) {
          const c=  buffer[i];
          i+=  1;
          if( c>=  ZERO&&  c<=  NINE) {
            lengthBuffer.push(c);
            if( lengthBuffer.length===  maxPrefixLength) {
              throw Error(
                 `Too long netstring length prefix ${JSON.stringify(
                  String.fromCharCode(...lengthBuffer))
                  }... at offset ${offset} of ${name}`);

             }
           }else if( c===  COLON&&  lengthBuffer.length) {
            lengthBuffer.push(c);
            break;
           }else {
            throw Error(
               `Invalid netstring length prefix ${JSON.stringify(
                String.fromCharCode(...lengthBuffer, c))
                } at offset ${offset} of ${name}`);

           }
         }

        buffer=  buffer.subarray(i);

        if( lengthBuffer[lengthBuffer.length-  1]===  COLON) {
          lengthBuffer.pop();
          const prefix=  String.fromCharCode(...lengthBuffer);
          remainingDataLength=  +prefix;
          if( Number.isNaN(remainingDataLength)) {
            throw Error(
               `Invalid netstring prefix length ${prefix} at offset ${offset} of ${name}`);

           }else if( remainingDataLength>  maxMessageLength) {
            throw Error(
               `Netstring message too big (length ${remainingDataLength}) at offset ${offset} of ${name}`);

           }
          offset+=  lengthBuffer.length+  1;
          lengthBuffer=  null;
         }
       }

      // Waiting for data
      if( !lengthBuffer) {
        if( buffer.length>  remainingDataLength) {
          const remainingData=  buffer.subarray(0, remainingDataLength);
          const data=  dataBuffer?(
               dataBuffer.set(
                remainingData,
                dataBuffer.length-  remainingDataLength),

              dataBuffer):
              remainingData;
          dataBuffer=  null;
          offset+=  data.length;
          if( buffer[remainingDataLength]!==  COMMA) {
            throw Error(
               `Invalid netstring separator "${String.fromCharCode(
                buffer[remainingDataLength])
                } at offset ${offset} of ${name}`);

           }
          offset+=  1;
          buffer=  buffer.subarray(remainingDataLength+  1);
          remainingDataLength=  -1;
          lengthBuffer=  [];
          yield data;
         }else if( buffer.length) {
          if( !dataBuffer&&  buffer.length===  remainingDataLength) {
            dataBuffer=  buffer;
           }else {
            dataBuffer=  dataBuffer||  new Uint8Array(remainingDataLength);
            dataBuffer.set(buffer, dataBuffer.length-  remainingDataLength);
           }
          remainingDataLength-=  buffer.length;
          buffer=  buffer.subarray(buffer.length);
         }
       }
     }
   }

  if( !lengthBuffer) {
    throw Error( `Unexpected dangling message at offset ${offset} of ${name}`);
   }

  return undefined;
 }

/**
 * @param {Iterable<Uint8Array> | AsyncIterable<Uint8Array>} input
 * @param {object} [opts]
 * @param {string} [opts.name]
 * @param {number} [opts.maxMessageLength]
 * @returns {import('@endo/stream').Reader<Uint8Array, undefined>} input
 */
const        makeNetstringReader=  (input, opts)=>  {
  return harden(makeNetstringIterator(input, opts));
 };$h‍_once.makeNetstringReader(makeNetstringReader);
harden(makeNetstringReader);

// Legacy
/**
 * @param {Iterable<Uint8Array> | AsyncIterable<Uint8Array>} input
 * @param {string=} name
 * @param {number=} _capacity
 * @returns {import('@endo/stream').Stream<Uint8Array, undefined>} input
 */
const        netstringReader=  (input, name, _capacity)=>  {
  return harden(
    makeNetstringIterator(input, {
      name}));


 };$h‍_once.netstringReader(netstringReader);
})()
,
// === functors[152] ===
({   imports: $h‍_imports,   liveVar: $h‍_live,   onceVar: $h‍_once,   importMeta: $h‍____meta, }) => (function () {   $h‍_imports([]);   // @ts-check
/// <reference types="ses"/>

const COMMA_BUFFER=  new Uint8Array([','.charCodeAt(0)]);

/** @param {number} length */
const getLengthPrefixCharCodes=  (length)=>
  // eslint-disable-next-line no-bitwise
  [... `${length| 0 }:`].map((char)=>char.charCodeAt(0));

/**
 * Create a writer stream which wraps messages into a netstring encoding and
 * writes them to an output writer stream.
 *
 * This transform can be zero-copy, if the output stream supports consecutive
 * writes without waiting, aka if it can gracefully handle writes if full or
 * closed. In that case the by default off `chunked` mode can be enabled.
 *
 * Accepts the message as an array of buffers in case the producer would like
 * to avoid pre-concatenating them.
 *
 * @param {import('@endo/stream').Writer<Uint8Array, undefined>} output
 * @param {object} opts
 * @param {boolean} [opts.chunked]
 * @returns {import('@endo/stream').Writer<Uint8Array | Uint8Array[], undefined>}
 */
const        makeNetstringWriter=  (output, { chunked=  false}=   {})=>  {
  return harden({
          async next(messageChunks){
      if( !Array.isArray(messageChunks)) {
        messageChunks=  [messageChunks];
       }

      const messageLength=  messageChunks.reduce(
        (acc, { length})=>   acc+  length,
        0);


      const prefix=  getLengthPrefixCharCodes(messageLength);

      if( chunked) {
        return Promise.all([
          output.next(new Uint8Array(prefix)),
          ...messageChunks.map(async(chunk)=> output.next(chunk)),
          output.next(COMMA_BUFFER)]).
           then(([r1, r2, r3])=>(  {
          done: !!(r1.done||  r2.done||  r3.done),
          value: undefined}));

       }else {
        const buffer=  new Uint8Array(prefix.length+  messageLength+  1);
        buffer.set(prefix, 0);
        let i=  prefix.length;
        for( const chunk of messageChunks) {
          buffer.set(chunk, i);
          i+=  chunk.length;
         }
        buffer.set(COMMA_BUFFER, i);

        return output.next(buffer);
       }
     },
          async return(){
      return output.return(undefined);
     },
          async throw(error){
      return output.throw(error);
     },
    [Symbol.asyncIterator]() {
      return this;
     }});

 };$h‍_once.makeNetstringWriter(makeNetstringWriter);
harden(makeNetstringWriter);

// Legacy
const        netstringWriter=  makeNetstringWriter;$h‍_once.netstringWriter(netstringWriter);
})()
,
// === functors[153] ===
({   imports: $h‍_imports,   liveVar: $h‍_live,   onceVar: $h‍_once,   importMeta: $h‍____meta, }) => (function () {   $h‍_imports([["./reader.js", []],["./writer.js", []]]);   
})()
,
// === functors[154] ===
({   imports: $h‍_imports,   liveVar: $h‍_live,   onceVar: $h‍_once,   importMeta: $h‍____meta, }) => (function () {   let makeCapTP,mapWriter,mapReader,makeNetstringReader,makeNetstringWriter;$h‍_imports([["@endo/captp", [["makeCapTP", [$h‍_a => (makeCapTP = $h‍_a)]]]],["@endo/stream", [["mapWriter", [$h‍_a => (mapWriter = $h‍_a)]],["mapReader", [$h‍_a => (mapReader = $h‍_a)]]]],["@endo/netstring", [["makeNetstringReader", [$h‍_a => (makeNetstringReader = $h‍_a)]],["makeNetstringWriter", [$h‍_a => (makeNetstringWriter = $h‍_a)]]]]]);   





const textEncoder=  new TextEncoder();
const textDecoder=  new TextDecoder();

/**
 * @template TBootstrap
 * @param {string} name
 * @param {import('@endo/stream').Stream<unknown, any, unknown, unknown>} writer
 * @param {import('@endo/stream').Stream<any, undefined, undefined, undefined>} reader
 * @param {Promise<void>} cancelled
 * @param {TBootstrap} bootstrap
 */
const        makeMessageCapTP=  (
  name,
  writer,
  reader,
  cancelled,
  bootstrap)=>
     {
  /** @param {any} message */
  const send=  (message)=>{
    return writer.next(message);
   };

  const { dispatch, getBootstrap, abort}=   makeCapTP(name, send, bootstrap);

  const drained=  (async()=>   {
    for await( const message of reader) {
      console.log('captp reader', message);
      dispatch(message);
     }
   })();

  const closed=  cancelled.catch(async()=>   {
    abort();
    await Promise.all([writer.return(undefined), drained]);
   });

  return {
    getBootstrap,
    closed};

 };

/** @param {any} message */$h‍_once.makeMessageCapTP(makeMessageCapTP);
const        messageToBytes=  (message)=>{
  const text=  JSON.stringify(message);
  // console.log('->', text);
  const bytes=  textEncoder.encode(text);
  return bytes;
 };

/** @param {Uint8Array} bytes */$h‍_once.messageToBytes(messageToBytes);
const        bytesToMessage=  (bytes)=>{
  const text=  textDecoder.decode(bytes);
  // console.log('<-', text);
  const message=  JSON.parse(text);
  return message;
 };

/**
 * @template TBootstrap
 * @param {string} name
 * @param {import('@endo/stream').Writer<Uint8Array>} bytesWriter
 * @param {import('@endo/stream').Reader<Uint8Array>} bytesReader
 * @param {Promise<void>} cancelled
 * @param {TBootstrap} bootstrap
 */$h‍_once.bytesToMessage(bytesToMessage);
const        makeNetstringCapTP=  (
  name,
  bytesWriter,
  bytesReader,
  cancelled,
  bootstrap)=>
     {
  const messageWriter=  mapWriter(
    makeNetstringWriter(bytesWriter, { chunked: true}),
    messageToBytes);

  const messageReader=  mapReader(
    makeNetstringReader(bytesReader),
    bytesToMessage);

  return makeMessageCapTP(
    name,
    messageWriter,
    messageReader,
    cancelled,
    bootstrap);

 };$h‍_once.makeNetstringCapTP(makeNetstringCapTP);
})()
,
// === functors[155] ===
({   imports: $h‍_imports,   liveVar: $h‍_live,   onceVar: $h‍_once,   importMeta: $h‍____meta, }) => (function () {   $h‍_imports([]);   // @ts-check

const        padding=  '=';$h‍_once.padding(padding);

const        alphabet64=
  'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

/**
 * The numeric value corresponding to each letter of the alphabet.
 * If an alphabet is named for the Greek letters alpha and beta, then clearly a
 * monodu is named for the corresponding Greek numbers mono and duo.
 *
 * @type {Record<string, number>}
 */$h‍_once.alphabet64(alphabet64);
const        monodu64=  {};$h‍_once.monodu64(monodu64);
for( let i=  0; i<  alphabet64.length; i+=  1) {
  const c=  alphabet64[i];
  monodu64[c]=  i;
 }
})()
,
// === functors[156] ===
({   imports: $h‍_imports,   liveVar: $h‍_live,   onceVar: $h‍_once,   importMeta: $h‍____meta, }) => (function () {   let alphabet64,padding;$h‍_imports([["./common.js", [["alphabet64", [$h‍_a => (alphabet64 = $h‍_a)]],["padding", [$h‍_a => (padding = $h‍_a)]]]]]);   





/**
 * Encodes bytes into a Base64 string, as specified in
 * https://tools.ietf.org/html/rfc4648#section-4
 *
 * XSnap is a JavaScript engine based on Moddable/XS.
 * The algorithm below is orders of magnitude too slow on this VM, but it
 * arranges a native binding on the global object.
 * We use that if it is available instead.
 *
 * @param {Uint8Array} data
 * @returns {string} base64 encoding
 */
const jsEncodeBase64=  (data)=>{
  // A cursory benchmark shows that string concatenation is about 25% faster
  // than building an array and joining it in v8, in 2020, for strings of about
  // 100 long.
  let string=  '';
  let register=  0;
  let quantum=  0;

  for( let i=  0; i<  data.length; i+=  1) {
    const b=  data[i];
    register=   register<<  8|   b;
    quantum+=  8;
    if( quantum===  24) {
      string+=
        alphabet64[ register>>>  18&   0x3f]+
        alphabet64[ register>>>  12&   0x3f]+
        alphabet64[ register>>>  6&   0x3f]+
        alphabet64[ register>>>  0&   0x3f];
      register=  0;
      quantum=  0;
     }
   }

  switch( quantum){
    case 0:
      break;
    case 8:
      string+=
        alphabet64[ register>>>  2&   0x3f]+
        alphabet64[ register<<  4&   0x3f]+
        padding+
        padding;
      break;
    case 16:
      string+=
        alphabet64[ register>>>  10&   0x3f]+
        alphabet64[ register>>>  4&   0x3f]+
        alphabet64[ register<<  2&   0x3f]+
        padding;
      break;
    default:
      throw Error( `internal: bad quantum ${quantum}`);}

  return string;
 };

/** @type {typeof jsEncodeBase64} */
const        encodeBase64=
  globalThis.Base64!==  undefined?  globalThis.Base64.encode:  jsEncodeBase64;$h‍_once.encodeBase64(encodeBase64);
})()
,
// === functors[157] ===
({   imports: $h‍_imports,   liveVar: $h‍_live,   onceVar: $h‍_once,   importMeta: $h‍____meta, }) => (function () {   let monodu64,padding;$h‍_imports([["./common.js", [["monodu64", [$h‍_a => (monodu64 = $h‍_a)]],["padding", [$h‍_a => (padding = $h‍_a)]]]]]);   





/**
 * Decodes a Base64 string into bytes, as specified in
 * https://tools.ietf.org/html/rfc4648#section-4
 *
 * XSnap is a JavaScript engine based on Moddable/XS.
 * The algorithm below is orders of magnitude too slow on this VM, but it
 * arranges a native binding on the global object.
 * We use that if it is available instead.
 *
 * @param {string} string Base64-encoded string
 * @param {string} [name] The name of the string as it will appear in error
 * messages.
 * @returns {Uint8Array} decoded bytes
 */
const jsDecodeBase64=  (string, name=  '<unknown>')=>  {
  const data=  new Uint8Array(Math.ceil( string.length*  4/   3));
  let register=  0;
  let quantum=  0;
  let i=  0; // index in string
  let j=  0; // index in data

  while( i<  string.length&&  string[i]!==  padding) {
    const number=  monodu64[string[i]];
    if( number===  undefined) {
      throw Error( `Invalid base64 character ${string[i]} in string ${name}`);
     }
    register=   register<<  6|   number;
    quantum+=  6;
    if( quantum>=  8) {
      quantum-=  8;
      data[j]=  register>>>  quantum;
      j+=  1;
      register&=  (1<<  quantum)-  1;
     }
    i+=  1;
   }

  while( i<  string.length&&  quantum%  8!==  0) {
    if( string[i]!==  padding) {
      throw Error( `Missing padding at offset ${i} of string ${name}`);
     }
    i+=  1;
    quantum+=  6;
   }

  if( i<  string.length) {
    throw Error(
       `Base64 string has trailing garbage ${string.substr(
        i)
        } in string ${name}`);

   }

  return data.subarray(0, j);
 };

// The XS Base64.decode function is faster, but might return ArrayBuffer (not
// Uint8Array).  Adapt it to our needs.
const adaptDecoder=
  (nativeDecodeBase64)=>
  (...args)=>  {
    const decoded=  nativeDecodeBase64(...args);
    if( decoded instanceof Uint8Array) {
      return decoded;
     }
    return new Uint8Array(decoded);
   };

/** @type {typeof jsDecodeBase64} */
const        decodeBase64=
  globalThis.Base64!==  undefined?
      adaptDecoder(globalThis.Base64.decode):
      jsDecodeBase64;$h‍_once.decodeBase64(decodeBase64);
})()
,
// === functors[158] ===
({   imports: $h‍_imports,   liveVar: $h‍_live,   onceVar: $h‍_once,   importMeta: $h‍____meta, }) => (function () {   $h‍_imports([["./src/encode.js", []]]);   
})()
,
// === functors[159] ===
({   imports: $h‍_imports,   liveVar: $h‍_live,   onceVar: $h‍_once,   importMeta: $h‍____meta, }) => (function () {   let encodeBase64;$h‍_imports([["./encode.js", [["encodeBase64", [$h‍_a => (encodeBase64 = $h‍_a)]]]]]);   

/**
 * @param {string} stringToEncode the binary string to encode
 * @returns {string} an ASCII string containing the base64 representation of `stringToEncode`
 */
const        btoa=  (stringToEncode)=>{
  const bytes=  stringToEncode.split('').map((char)=>{
    const b=  char.charCodeAt(0);
    if( b>  0xff) {
      throw Error( `btoa: character out of range: ${char}`);
     }
    return b;
   });
  const buf=  new Uint8Array(bytes);
  return encodeBase64(buf);
 };$h‍_once.btoa(btoa);
})()
,
// === functors[160] ===
({   imports: $h‍_imports,   liveVar: $h‍_live,   onceVar: $h‍_once,   importMeta: $h‍____meta, }) => (function () {   $h‍_imports([["./src/decode.js", []]]);   
})()
,
// === functors[161] ===
({   imports: $h‍_imports,   liveVar: $h‍_live,   onceVar: $h‍_once,   importMeta: $h‍____meta, }) => (function () {   let decodeBase64;$h‍_imports([["./decode.js", [["decodeBase64", [$h‍_a => (decodeBase64 = $h‍_a)]]]]]);   

/**
 * @param {string} encodedData a binary string containing base64-encoded data
 * @returns {string} an ASCII string containing decoded data from `encodedData`
 */
const        atob=  (encodedData)=>{
  const buf=  decodeBase64(encodedData);
  return String.fromCharCode(...buf);
 };$h‍_once.atob(atob);
})()
,
// === functors[162] ===
({   imports: $h‍_imports,   liveVar: $h‍_live,   onceVar: $h‍_once,   importMeta: $h‍____meta, }) => (function () {   $h‍_imports([["./src/encode.js", []],["./src/decode.js", []],["./btoa.js", []],["./atob.js", []]]);   
})()
,
// === functors[163] ===
({   imports: $h‍_imports,   liveVar: $h‍_live,   onceVar: $h‍_once,   importMeta: $h‍____meta, }) => (function () {   let decodeBase64,mapReader,E;$h‍_imports([["@endo/base64", [["decodeBase64", [$h‍_a => (decodeBase64 = $h‍_a)]]]],["@endo/stream", [["mapReader", [$h‍_a => (mapReader = $h‍_a)]]]],["@endo/far", [["E", [$h‍_a => (E = $h‍_a)]]]]]);   





/**
 * @template TValue
 * @template TReturn
 * @template TNext
 * @param {import('@endo/far').ERef<AsyncIterator<TValue, TReturn, TNext>>} iteratorRef
 */
const        makeRefIterator=  (iteratorRef)=>{
  const iterator=  {
    /** @param {[] | [TNext]} args */
    next: async( ...args)=>  E(iteratorRef).next(...args),
    /** @param {[] | [TReturn]} args */
    return: async( ...args)=>  E(iteratorRef).return(...args),
    /** @param {any} error */
    throw: async(error)=> E(iteratorRef).throw(error),
    [Symbol.asyncIterator]: ()=>  iterator};

  return iterator;
 };

/**
 * @param {import('@endo/far').ERef<AsyncIterator<string>>} readerRef
 * @returns {AsyncIterableIterator<Uint8Array, any>}
 */$h‍_once.makeRefIterator(makeRefIterator);
const        makeRefReader=  (readerRef)=>
  mapReader(makeRefIterator(readerRef), decodeBase64);$h‍_once.makeRefReader(makeRefReader);
})()
,
// === functors[164] ===
({   imports: $h‍_imports,   liveVar: $h‍_live,   onceVar: $h‍_once,   importMeta: $h‍____meta, }) => (function () {   let encodeBase64,mapReader,Far;$h‍_imports([["@endo/base64", [["encodeBase64", [$h‍_a => (encodeBase64 = $h‍_a)]]]],["@endo/stream", [["mapReader", [$h‍_a => (mapReader = $h‍_a)]]]],["@endo/far", [["Far", [$h‍_a => (Far = $h‍_a)]]]]]);   





const        asyncIterate=  (iterable)=>{
  let iterator;
  if( iterable[Symbol.asyncIterator]) {
    iterator=  iterable[Symbol.asyncIterator]();
   }else if( iterable[Symbol.iterator]) {
    iterator=  iterable[Symbol.iterator]();
   }else if( 'next'in  iterable) {
    iterator=  iterable;
   }
  return iterator;
 };$h‍_once.asyncIterate(asyncIterate);

const        makeIteratorRef=  (iterable)=>{
  const iterator=  asyncIterate(iterable);
  return Far('AsyncIterator', {
          async next(){
      return iterator.next();
     },
    /**
     * @param {any} value
     */
          async return(value){
      if( iterator.return!==  undefined) {
        return iterator.return(value);
       }
      return harden({ done: true, value: undefined});
     },
    /**
     * @param {any} error
     */
          async throw(error){
      if( iterator.throw!==  undefined) {
        return iterator.throw(error);
       }
      return harden({ done: true, value: undefined});
     },
    [Symbol.asyncIterator]() {
      return this;
     }});

 };$h‍_once.makeIteratorRef(makeIteratorRef);

const        makeReaderRef=  (readable)=>
  makeIteratorRef(mapReader(asyncIterate(readable), encodeBase64));$h‍_once.makeReaderRef(makeReaderRef);
})()
,
// === functors[165] ===
({   imports: $h‍_imports,   liveVar: $h‍_live,   onceVar: $h‍_once,   importMeta: $h‍____meta, }) => (function () {   $h‍_imports([]);   const { quote: q}=   assert;

const validNamePattern=  /^[a-z][a-z0-9-]{0,127}$/;

/**
 * @param {string} petName
 */
const        assertPetName=  (petName)=>{
  if( typeof petName!==  'string'||  !validNamePattern.test(petName)) {
    throw new Error( `Invalid pet name ${q(petName)}`);
   }
 };$h‍_once.assertPetName(assertPetName);
})()
,
// === functors[166] ===
({   imports: $h‍_imports,   liveVar: $h‍_live,   onceVar: $h‍_once,   importMeta: $h‍____meta, }) => (function () {   let makePromiseKit,makeStream;$h‍_imports([["@endo/promise-kit", [["makePromiseKit", [$h‍_a => (makePromiseKit = $h‍_a)]]]],["@endo/stream", [["makeStream", [$h‍_a => (makeStream = $h‍_a)]]]]]);   


// TypeScript ReadOnly semantics are not sufficiently expressive to distinguish
// a value one promises not to alter from a value one must not alter,
// making it useless.
const freeze=  /** @type {<T>(v: T | Readonly<T>) => T} */  Object.freeze;

/**
 * @template TValue TValue
 * @param {TValue} value
 * @returns {import('./types.js').AsyncQueue<TValue, unknown>}
 */
const        makeNullQueue=  (value)=>
  harden({
    put: ()=>  { },
    get: async()=>   value});$h‍_once.makeNullQueue(makeNullQueue);


const        nullIteratorQueue=  makeNullQueue(
  harden({ value: undefined, done: false}));


/**
 * @template TValue
 */$h‍_once.nullIteratorQueue(nullIteratorQueue);
const        makeChangePubSub=  ()=>  {
  // Request pubsub async queue internals
  let { promise: tailPromise, resolve: tailResolve}=   makePromiseKit();

  const sink=  {
    /**
     * @param {TValue} value
     */
    put: (value)=>{
      const { resolve, promise}=   makePromiseKit();
      tailResolve(freeze({ value, promise}));
      tailResolve=  resolve;
      // Unlike a queue, advance the read head for future subscribers.
      tailPromise=  promise;
     }};


  const makeSpring=  ()=>  {
    // Capture the read head for the next published value.
    let cursor=  tailPromise;
    return {
      get: ()=>  {
        const promise=  cursor.then((next)=>next.value);
        cursor=  cursor.then((next)=>next.promise);
        return harden(promise);
       }};

   };

  return harden({ sink, makeSpring});
 };$h‍_once.makeChangePubSub(makeChangePubSub);
harden(makeChangePubSub);

/**
 * @template TValue
 * @returns {import('./types.js').Topic<TValue>}
 */
const        makeChangeTopic=  ()=>  {
  /** @type {ReturnType<makeChangePubSub<TValue>>} */
  const { sink, makeSpring}=   makeChangePubSub();
  return harden({
    publisher: makeStream(nullIteratorQueue, sink),
    subscribe: ()=>  makeStream(makeSpring(), nullIteratorQueue)});

 };$h‍_once.makeChangeTopic(makeChangeTopic);
harden(makeChangeTopic);
})()
,
// === functors[167] ===
({   imports: $h‍_imports,   liveVar: $h‍_live,   onceVar: $h‍_once,   importMeta: $h‍____meta, }) => (function () {   let Far,assertPetName,makeChangeTopic,makeIteratorRef;$h‍_imports([["@endo/far", [["Far", [$h‍_a => (Far = $h‍_a)]]]],["./pet-name.js", [["assertPetName", [$h‍_a => (assertPetName = $h‍_a)]]]],["./pubsub.js", [["makeChangeTopic", [$h‍_a => (makeChangeTopic = $h‍_a)]]]],["./reader-ref.js", [["makeIteratorRef", [$h‍_a => (makeIteratorRef = $h‍_a)]]]]]);   




const { quote: q}=   assert;

const validIdPattern=  /^[0-9a-f]{128}$/;
const validFormulaPattern=
  /^(?:host|pet-store|(?:readable-blob-sha512|worker-id512|pet-store-id512|eval-id512|import-unsafe-id512|import-bundle-id512|host-id512|guest-id512):[0-9a-f]{128}|web-bundle:[0-9a-f]{32})$/;

/**
 * @param {import('./types.js').DaemonicPowers} powers
 * @param {string} petNameDirectoryPath
 */
const makePetStoreAtPath=  async( powers, petNameDirectoryPath)=>  {
  /** @type {Map<string, string>} */
  const petNames=  new Map();
  /** @type {Map<string, Set<string>>} */
  const formulaIdentifiers=  new Map();
  /** @type {import('./types.js').Topic<unknown>} */
  const changesTopic=  makeChangeTopic();

  /** @param {string} petName */
  const read=  async(petName)=> {
    const petNamePath=  powers.joinPath(petNameDirectoryPath, petName);
    const petNameText=  await powers.readFileText(petNamePath);
    const formulaIdentifier=  petNameText.trim();
    if( !validFormulaPattern.test(formulaIdentifier)) {
      throw new Error(
         `Invalid formula identifier ${q(formulaIdentifier)} for pet name ${q(
          petName)
          }`);

     }
    return formulaIdentifier;
   };

  await powers.makePath(petNameDirectoryPath);

  const fileNames=  await powers.readDirectory(petNameDirectoryPath);
  await Promise.all(
    fileNames.map(async(petName)=> {
      assertPetName(petName);
      const formulaIdentifier=  await read(petName);
      petNames.set(petName, formulaIdentifier);
      const formulaPetNames=  formulaIdentifiers.get(formulaIdentifier);
      if( formulaPetNames!==  undefined) {
        formulaPetNames.add(petName);
       }else {
        formulaIdentifiers.set(formulaIdentifier, new Set([petName]));
       }
     }));


  /** @param {string} petName */
  const lookup=  (petName)=>{
    assertPetName(petName);
    return petNames.get(petName);
   };

  /**
   * @param {string} petName
   * @param {string} formulaIdentifier
   */
  const write=  async( petName, formulaIdentifier)=>  {
    assertPetName(petName);
    if( !validFormulaPattern.test(formulaIdentifier)) {
      throw new Error( `Invalid formula identifier ${q(formulaIdentifier)}`);
     }

    petNames.set(petName, formulaIdentifier);

    const formulaPetNames=  formulaIdentifiers.get(formulaIdentifier);
    if( formulaPetNames===  undefined) {
      formulaIdentifiers.set(formulaIdentifier, new Set([petName]));
     }else {
      formulaPetNames.add(petName);
     }

    const petNamePath=  powers.joinPath(petNameDirectoryPath, petName);
    const petNameText=   `${formulaIdentifier}\n`;
    await powers.writeFileText(petNamePath, petNameText);
    changesTopic.publisher.next({ add: petName});
   };

  const list=  ()=>  harden([...petNames.keys()].sort());

  const follow=  async()=>
    makeIteratorRef(
      (async function* currentAndSubsequentNames() {
        const changes=  changesTopic.subscribe();
        for( const name of [...petNames.keys()].sort()) {
          yield { add: name};
         }
        yield* changes;
       })());


  /**
   * @param {string} petName
   */
  const remove=  async(petName)=> {
    assertPetName(petName);
    const formulaIdentifier=  petNames.get(petName);
    if( formulaIdentifier===  undefined) {
      throw new Error(
         `Formula does not exist for pet name ${JSON.stringify(petName)}`);

     }
    if( !validFormulaPattern.test(formulaIdentifier)) {
      throw new Error( `Invalid formula identifier ${q(formulaIdentifier)}`);
     }

    const petNamePath=  powers.joinPath(petNameDirectoryPath, petName);
    await powers.removePath(petNamePath);
    petNames.delete(petName);
    const formulaPetNames=  formulaIdentifiers.get(petName);
    if( formulaPetNames!==  undefined) {
      formulaPetNames.delete(petName);
     }
    changesTopic.publisher.next({ remove: petName});
    // TODO consider retaining a backlog of deleted names for recovery
    // TODO consider tracking historical pet names for formulas
   };

  /**
   * @param {string} fromName
   * @param {string} toName
   */
  const rename=  async( fromName, toName)=>  {
    assertPetName(fromName);
    assertPetName(toName);
    if( fromName===  toName) {
      return;
     }
    const formulaIdentifier=  petNames.get(fromName);
    const overwrittenFormulaIdentifier=  petNames.get(toName);
    if( formulaIdentifier===  undefined) {
      throw new Error(
         `Formula does not exist for pet name ${JSON.stringify(fromName)}`);

     }
    if( !validFormulaPattern.test(formulaIdentifier)) {
      throw new Error( `Invalid formula identifier ${q(formulaIdentifier)}`);
     }
    if(
      overwrittenFormulaIdentifier!==  undefined&&
      !validFormulaPattern.test(overwrittenFormulaIdentifier))
      {
      throw new Error(
         `Invalid formula identifier ${q(overwrittenFormulaIdentifier)}`);

     }

    const fromPath=  powers.joinPath(petNameDirectoryPath, fromName);
    const toPath=  powers.joinPath(petNameDirectoryPath, toName);
    await powers.renamePath(fromPath, toPath);
    petNames.set(toName, formulaIdentifier);
    petNames.delete(fromName);

    // Delete the back-reference for the overwritten pet name if it existed.
    if( overwrittenFormulaIdentifier!==  undefined) {
      const overwrittenFormulaPetNames=  formulaIdentifiers.get(
        overwrittenFormulaIdentifier);

      if( overwrittenFormulaPetNames!==  undefined) {
        overwrittenFormulaPetNames.delete(toName);
       }
     }

    // Change the back-reference for the old pet name.
    const formulaPetNames=  formulaIdentifiers.get(formulaIdentifier);
    if( formulaPetNames!==  undefined) {
      formulaPetNames.delete(fromName);
      formulaPetNames.add(toName);
     }

    changesTopic.publisher.next({ add: toName});
    changesTopic.publisher.next({ remove: fromName});
    // TODO consider retaining a backlog of overwritten names for recovery
   };

  /**
   * @param {string} formulaIdentifier
   */
  const reverseLookup=  (formulaIdentifier)=>{
    if( !validFormulaPattern.test(formulaIdentifier)) {
      throw new Error( `Invalid formula identifier ${q(formulaIdentifier)}`);
     }
    const formulaPetNames=  formulaIdentifiers.get(formulaIdentifier);
    if( formulaPetNames===  undefined) {
      return harden([]);
     }
    return harden([...formulaPetNames]);
   };

  return Far('PetStore', {
    lookup,
    reverseLookup,
    list,
    follow,
    write,
    remove,
    rename});

 };

/**
 * @param {import('./types.js').DaemonicPowers} powers
 * @param {import('./types.js').Locator} locator
 * @param {string} id
 */
const        makeIdentifiedPetStore=  (powers, locator, id)=>  {
  if( !validIdPattern.test(id)) {
    throw new Error( `Invalid identifier for pet store ${q(id)}`);
   }
  const prefix=  id.slice(0, 2);
  const suffix=  id.slice(3);
  const petNameDirectoryPath=  powers.joinPath(
    locator.statePath,
    'pet-store-id512',
    prefix,
    suffix);

  return makePetStoreAtPath(powers, petNameDirectoryPath);
 };

/**
 * @param {import('./types.js').DaemonicPowers} powers
 * @param {import('./types.js').Locator} locator
 * @param {string} name
 */$h‍_once.makeIdentifiedPetStore(makeIdentifiedPetStore);
const        makeOwnPetStore=  (powers, locator, name)=>  {
  const petNameDirectoryPath=  powers.joinPath(locator.statePath, name);
  return makePetStoreAtPath(powers, petNameDirectoryPath);
 };$h‍_once.makeOwnPetStore(makeOwnPetStore);
})()
,
// === functors[168] ===
({   imports: $h‍_imports,   liveVar: $h‍_live,   onceVar: $h‍_once,   importMeta: $h‍____meta, }) => (function () {   let makePromiseKit,makeChangeTopic,makeIteratorRef,assertPetName;$h‍_imports([["@endo/promise-kit", [["makePromiseKit", [$h‍_a => (makePromiseKit = $h‍_a)]]]],["./pubsub.js", [["makeChangeTopic", [$h‍_a => (makeChangeTopic = $h‍_a)]]]],["./reader-ref.js", [["makeIteratorRef", [$h‍_a => (makeIteratorRef = $h‍_a)]]]],["./pet-name.js", [["assertPetName", [$h‍_a => (assertPetName = $h‍_a)]]]]]);   




const { quote: q}=   assert;

const        makeMailboxMaker=  ({
  provideValueForFormulaIdentifier,
  formulaIdentifierForRef})=>
      {
  /** @type {WeakMap<object, import('./types.js').RequestFn>} */
  const partyRequestFunctions=  new WeakMap();
  /** @type {WeakMap<object, import('./types.js').ReceiveFn>} */
  const partyReceiveFunctions=  new WeakMap();

  const makeMailbox=  ({ selfFormulaIdentifier, petStore, specialNames})=>   {
    /** @type {Map<string, Promise<unknown>>} */
    const responses=  new Map();
    /** @type {Map<number, import('./types.js').InternalMessage>} */
    const messages=  new Map();
    /** @type {WeakMap<object, (value: unknown) => void>} */
    const resolvers=  new WeakMap();
    /** @type {WeakMap<object, () => void>} */
    const dismissers=  new WeakMap();
    /** @type {import('./types.js').Topic<import('./types.js').InternalMessage>} */
    const messagesTopic=  makeChangeTopic();
    let nextMessageNumber=  0;

    /**
     * @param {string} petName
     */
    const lookupFormulaIdentifierForName=  (petName)=>{
      if( Object.hasOwn(specialNames, petName)) {
        return specialNames[petName];
       }
      return petStore.lookup(petName);
     };

    /**
     * @param {string} petName
     */
    const lookup=  async(petName)=> {
      const formulaIdentifier=  lookupFormulaIdentifierForName(petName);
      if( formulaIdentifier===  undefined) {
        throw new TypeError( `Unknown pet name: ${q(petName)}`);
       }
      // Behold, recursion:
      // eslint-disable-next-line no-use-before-define
      return provideValueForFormulaIdentifier(formulaIdentifier);
     };

    /**
     * @param {string} formulaIdentifier
     */
    const reverseLookupFormulaIdentifier=  (formulaIdentifier)=>{
      const names=  Array.from(petStore.reverseLookup(formulaIdentifier));
      for( const [specialName, specialFormulaIdentifier]of  Object.entries(
        specialNames))
         {
        if( specialFormulaIdentifier===  formulaIdentifier) {
          names.push(specialName);
         }
       }
      return harden(names);
     };

    /**
     * @param {unknown} presence
     */
    const reverseLookup=  async(presence)=> {
      const formulaIdentifier=  formulaIdentifierForRef.get(await presence);
      if( formulaIdentifier===  undefined) {
        return harden([]);
       }
      return reverseLookupFormulaIdentifier(formulaIdentifier);
     };

    /**
     * @param {import('./types.js').InternalMessage} message
     * @returns {import('./types.js').Message | undefined}
     */
    const dubMessage=  (message)=>{
      if( message.type===  'request') {
        const { who: senderFormulaIdentifier, ...rest}=   message;
        const [senderName]=  reverseLookupFormulaIdentifier(
          senderFormulaIdentifier);

        if( senderName!==  undefined) {
          return { who: senderName, ...rest};
         }
        return undefined;
       }else if( message.type===  'package') {
        const { formulas: _, who: senderFormulaIdentifier, ...rest}=   message;
        const [senderName]=  reverseLookupFormulaIdentifier(
          senderFormulaIdentifier);

        if( senderName!==  undefined) {
          return { who: senderName, ...rest};
         }
        return undefined;
       }
      throw new Error( `panic: Unknown message type ${message.type}`);
     };

    const listMessages=  async()=>
      harden(Array.from(messages.values(), dubMessage));

    const followMessages=  async()=>
      makeIteratorRef(
        (async function* currentAndSubsequentMessages() {
          const subsequentRequests=  messagesTopic.subscribe();
          for( const message of messages.values()) {
            const dubbedMessage=  dubMessage(message);
            if( dubbedMessage!==  undefined) {
              yield dubMessage(message);
             }
           }
          for await( const message of subsequentRequests) {
            const dubbedMessage=  dubMessage(message);
            if( dubbedMessage!==  undefined) {
              yield dubMessage(message);
             }
           }
         })());


    const deliver=  (partialMessage)=>{
      /** @type {import('@endo/promise-kit/src/types.js').PromiseKit<void>} */
      const dismissal=  makePromiseKit();
      const messageNumber=  nextMessageNumber;
      nextMessageNumber+=  1;

      const message=  harden({
        number: messageNumber,
        when: new Date().toISOString(),
        dismissed: dismissal.promise,
        ...partialMessage});


      dismissers.set(message, ()=>  {
        messages.delete(messageNumber);
        dismissal.resolve();
       });

      messages.set(messageNumber, message);
      messagesTopic.publisher.next(message);

      return message;
     };

    /**
     * @param {string} what - user visible description of the desired value
     * @param {string} who
     */
    const requestFormulaIdentifier=  async( what, who)=>  {
      /** @type {import('@endo/promise-kit/src/types.js').PromiseKit<string>} */
      const { promise, resolve}=   makePromiseKit();
      const settled=  promise.then(
        ()=>  'fulfilled',
        ()=>  'rejected');

      const message=  deliver({
        type: /** @type {const} */  'request',
        who,
        what,
        settled});

      resolvers.set(message, resolve);
      return promise;
     };

    /**
     * @param {string} what
     * @param {string} responseName
     * @param {string} senderFormulaIdentifier
     * @param {import('./types.js').PetStore} senderPetStore
     */
    const respond=  async(
      what,
      responseName,
      senderFormulaIdentifier,
      senderPetStore)=>
         {
      if( responseName!==  undefined) {
        /** @type {string | undefined} */
        let formulaIdentifier=  senderPetStore.lookup(responseName);
        if( formulaIdentifier===  undefined) {
          formulaIdentifier=  await requestFormulaIdentifier(
            what,
            senderFormulaIdentifier);

          await senderPetStore.write(responseName, formulaIdentifier);
         }
        // Behold, recursion:
        // eslint-disable-next-line no-use-before-define
        return provideValueForFormulaIdentifier(formulaIdentifier);
       }
      // The reference is not named nor to be named.
      const formulaIdentifier=  await requestFormulaIdentifier(
        what,
        senderFormulaIdentifier);

      // Behold, recursion:
      // eslint-disable-next-line no-use-before-define
      return provideValueForFormulaIdentifier(formulaIdentifier);
     };

    const resolve=  async( messageNumber, resolutionName)=>  {
      assertPetName(resolutionName);
      if(
        typeof messageNumber!==  'number'||
        messageNumber>=  Number.MAX_SAFE_INTEGER)
        {
        throw new Error( `Invalid request number ${q(messageNumber)}`);
       }
      const req=  messages.get(messageNumber);
      const resolveRequest=  resolvers.get(req);
      if( resolveRequest===  undefined) {
        throw new Error( `No pending request for number ${messageNumber}`);
       }
      const formulaIdentifier=  lookupFormulaIdentifierForName(resolutionName);
      if( formulaIdentifier===  undefined) {
        throw new TypeError(
           `No formula exists for the pet name ${q(resolutionName)}`);

       }
      resolveRequest(formulaIdentifier);
     };

    // TODO test reject
    /**
     * @param {number} messageNumber
     * @param {string} [message]
     */
    const reject=  async( messageNumber, message=  'Declined')=>  {
      const req=  messages.get(messageNumber);
      if( req!==  undefined) {
        const resolveRequest=  resolvers.get(req);
        if( resolveRequest===  undefined) {
          throw new Error( `panic: a resolver must exist for every request`);
         }
        resolveRequest(harden(Promise.reject(harden(new Error(message)))));
       }
     };

    /**
     * @param {string} senderFormulaIdentifier
     * @param {Array<string>} strings
     * @param {Array<string>} edgeNames
     * @param {Array<string>} formulaIdentifiers
     */
    const receive=  (
      senderFormulaIdentifier,
      strings,
      edgeNames,
      formulaIdentifiers)=>

      deliver({
        type: /** @type {const} */  'package',
        strings,
        names: edgeNames,
        formulas: formulaIdentifiers,
        who: senderFormulaIdentifier});


    /**
     * @param {string} recipientName
     * @param {Array<string>} strings
     * @param {Array<string>} edgeNames
     * @param {Array<string>} petNames
     */
    const send=  async( recipientName, strings, edgeNames, petNames)=>  {
      const recipientFormulaIdentifier=
        lookupFormulaIdentifierForName(recipientName);
      if( recipientFormulaIdentifier===  undefined) {
        throw new Error( `Unknown pet name for party: ${recipientName}`);
       }
      const recipient=  await provideValueForFormulaIdentifier(
        recipientFormulaIdentifier);

      petNames.forEach(assertPetName);
      edgeNames.forEach(assertPetName);
      if( petNames.length!==  edgeNames.length) {
        throw new Error(
           `Message must have one edge name (${q(
            edgeNames.length)
            }) for every pet name (${q(petNames.length)})`);

       }
      if( strings.length<  petNames.length) {
        throw new Error(
           `Message must have one string before every value delivered`);

       }

      const partyReceive=  partyReceiveFunctions.get(recipient);
      if( partyReceive===  undefined) {
        throw new Error( `panic: Message not deliverable`);
       }
      const formulaIdentifiers=  petNames.map((petName)=>{
        const formulaIdentifier=  lookupFormulaIdentifierForName(petName);
        if( formulaIdentifier===  undefined) {
          throw new Error( `Unknown pet name ${q(petName)}`);
         }
        return formulaIdentifier;
       });
      partyReceive(
        selfFormulaIdentifier,
        strings,
        edgeNames,
        formulaIdentifiers);

     };

    const dismiss=  async(messageNumber)=> {
      if(
        typeof messageNumber!==  'number'||
        messageNumber>=  Number.MAX_SAFE_INTEGER)
        {
        throw new Error( `Invalid request number ${q(messageNumber)}`);
       }
      const message=  messages.get(messageNumber);
      const dismissMessage=  dismissers.get(message);
      if( dismissMessage===  undefined) {
        throw new Error( `No dismissable message for number ${messageNumber}`);
       }
      dismissMessage();
     };

    const adopt=  async( messageNumber, edgeName, petName)=>  {
      assertPetName(edgeName);
      assertPetName(petName);
      if(
        typeof messageNumber!==  'number'||
        messageNumber>=  Number.MAX_SAFE_INTEGER)
        {
        throw new Error( `Invalid message number ${q(messageNumber)}`);
       }
      const message=  messages.get(messageNumber);
      if( message===  undefined) {
        throw new Error( `No such message with number ${q(messageNumber)}`);
       }
      if( message.type!==  'package') {
        throw new Error( `Message must be a package ${q(messageNumber)}`);
       }
      const index=  message.names.lastIndexOf(edgeName);
      if( index===  -1) {
        throw new Error(
           `No reference named ${q(edgeName)} in message ${q(messageNumber)}`);

       }
      const formulaIdentifier=  message.formulas[index];
      if( formulaIdentifier===  undefined) {
        throw new Error(
           `panic: message must contain a formula for every name, including the name ${q(
            edgeName)
            } at ${q(index)}`);

       }
      await petStore.write(petName, formulaIdentifier);
     };

    /**
     * @param {string} recipientName
     * @param {string} what
     * @param {string} responseName
     */
    const request=  async( recipientName, what, responseName)=>  {
      const recipientFormulaIdentifier=
        lookupFormulaIdentifierForName(recipientName);
      if( recipientFormulaIdentifier===  undefined) {
        throw new Error( `Unknown pet name for party: ${recipientName}`);
       }
      const recipient=  /** @type {object} */
        await provideValueForFormulaIdentifier(recipientFormulaIdentifier);


      const deliverToRecipient=  partyRequestFunctions.get(recipient);
      if( deliverToRecipient===  undefined) {
        throw new Error(
           `panic: a receive request function must exist for every party`);

       }
      if( responseName===  undefined) {
        // Behold, recursion:
        // eslint-disable-next-line no-use-before-define
        return deliverToRecipient(
          what,
          responseName,
          selfFormulaIdentifier,
          petStore);

       }
      const responseP=  responses.get(responseName);
      if( responseP!==  undefined) {
        return responseP;
       }
      // Behold, recursion:
      // eslint-disable-next-line
      const newResponseP=  deliverToRecipient(
        what,
        responseName,
        selfFormulaIdentifier,
        petStore);

      responses.set(responseName, newResponseP);
      return newResponseP;
     };

    /**
     * @param {string} fromName
     * @param {string} toName
     */
    const rename=  async( fromName, toName)=>  {
      await petStore.rename(fromName, toName);
      const formulaIdentifier=  responses.get(fromName);
      if( formulaIdentifier!==  undefined) {
        responses.set(toName, formulaIdentifier);
        responses.delete(fromName);
       }
     };

    /**
     * @param {string} petName
     */
    const remove=  async(petName)=> {
      await petStore.remove(petName);
      responses.delete(petName);
     };

    return harden({
      lookup,
      reverseLookup,
      reverseLookupFormulaIdentifier,
      lookupFormulaIdentifierForName,
      followMessages,
      listMessages,
      request,
      respond,
      resolve,
      reject,
      receive,
      send,
      dismiss,
      adopt,
      rename,
      remove});

   };

  return {
    makeMailbox,
    partyRequestFunctions,
    partyReceiveFunctions};

 };$h‍_once.makeMailboxMaker(makeMailboxMaker);
})()
,
// === functors[169] ===
({   imports: $h‍_imports,   liveVar: $h‍_live,   onceVar: $h‍_once,   importMeta: $h‍____meta, }) => (function () {   let Far;$h‍_imports([["@endo/far", [["Far", [$h‍_a => (Far = $h‍_a)]]]]]);   

const        makeGuestMaker=  ({
  provideValueForFormulaIdentifier,
  partyReceiveFunctions,
  partyRequestFunctions,
  makeMailbox})=>
      {
  /**
   * @param {string} guestFormulaIdentifier
   * @param {string} hostFormulaIdentifier
   * @param {string} petStoreFormulaIdentifier
   * @param {string} mainWorkerFormulaIdentifier
   */
  const makeIdentifiedGuest=  async(
    guestFormulaIdentifier,
    hostFormulaIdentifier,
    petStoreFormulaIdentifier,
    mainWorkerFormulaIdentifier)=>
       {
    const petStore=  /** @type {import('./types.js').PetStore} */
      await provideValueForFormulaIdentifier(petStoreFormulaIdentifier);

    const host=  /** @type {object} */
      await provideValueForFormulaIdentifier(hostFormulaIdentifier);


    const deliverToHost=  partyRequestFunctions.get(host);
    if( deliverToHost===  undefined) {
      throw new Error(
         `panic: a host request function must exist for every host`);

     }

    const {
      lookup,
      reverseLookup,
      followMessages,
      listMessages,
      resolve,
      reject,
      dismiss,
      adopt,
      send,
      receive,
      respond,
      request,
      rename,
      remove}=
        makeMailbox({
      petStore,
      selfFormulaIdentifier: guestFormulaIdentifier,
      specialNames: {
        SELF: guestFormulaIdentifier,
        HOST: hostFormulaIdentifier}});



    const { list, follow: followNames}=   petStore;

    /** @type {import('@endo/eventual-send').ERef<import('./types.js').EndoGuest>} */
    const guest=  Far('EndoGuest', {
      lookup,
      reverseLookup,
      request,
      send,
      list,
      followNames,
      followMessages,
      listMessages,
      resolve,
      reject,
      dismiss,
      adopt,
      remove,
      rename});


    partyReceiveFunctions.set(guest, receive);
    partyRequestFunctions.set(guest, respond);

    return guest;
   };

  return makeIdentifiedGuest;
 };$h‍_once.makeGuestMaker(makeGuestMaker);
})()
,
// === functors[170] ===
({   imports: $h‍_imports,   liveVar: $h‍_live,   onceVar: $h‍_once,   importMeta: $h‍____meta, }) => (function () {   let Far,assertPetName;$h‍_imports([["@endo/far", [["Far", [$h‍_a => (Far = $h‍_a)]]]],["./pet-name.js", [["assertPetName", [$h‍_a => (assertPetName = $h‍_a)]]]]]);   


const { quote: q}=   assert;

const        makeHostMaker=  ({
  provideValueForFormulaIdentifier,
  provideValueForFormula,
  provideValueForNumberedFormula,
  partyReceiveFunctions,
  partyRequestFunctions,
  formulaIdentifierForRef,
  storeReaderRef,
  makeSha512,
  randomHex512,
  makeMailbox})=>
      {
  /**
   * @param {string} hostFormulaIdentifier
   * @param {string} storeFormulaIdentifier
   * @param {string} mainWorkerFormulaIdentifier
   */
  const makeIdentifiedHost=  async(
    hostFormulaIdentifier,
    storeFormulaIdentifier,
    mainWorkerFormulaIdentifier)=>
       {
    const petStore=  /** @type {import('./types.js').PetStore} */
      // Behold, recursion:
      // eslint-disable-next-line no-use-before-define
      await provideValueForFormulaIdentifier(storeFormulaIdentifier);


    const {
      lookup,
      reverseLookup,
      lookupFormulaIdentifierForName,
      listMessages,
      followMessages,
      resolve,
      reject,
      respond,
      request,
      receive,
      send,
      dismiss,
      adopt,
      rename,
      remove}=
        makeMailbox({
      petStore,
      selfFormulaIdentifier: hostFormulaIdentifier,
      specialNames: {
        SELF: hostFormulaIdentifier}});



    /**
     * @param {string} petName
     */
    const provideGuest=  async(petName)=> {
      /** @type {string | undefined} */
      let formulaIdentifier;
      if( petName!==  undefined) {
        formulaIdentifier=  lookupFormulaIdentifierForName(petName);
       }
      if( formulaIdentifier===  undefined) {
        const id512=  await randomHex512();
        const guestStoreFormulaIdentifier=   `pet-store-id512:${id512}`;
        /** @type {import('./types.js').GuestFormula} */
        const formula=  {
          type: /* @type {'guest'} */ 'guest',
          host: hostFormulaIdentifier,
          store: guestStoreFormulaIdentifier};

        const { value, formulaIdentifier: guestFormulaIdentifier}=
          // Behold, recursion:
          // eslint-disable-next-line no-use-before-define
          await provideValueForFormula(formula, 'guest-id512');
        if( petName!==  undefined) {
          assertPetName(petName);
          await petStore.write(petName, guestFormulaIdentifier);
         }
        return value;
       }else if( !formulaIdentifier.startsWith('guest-id512:')) {
        throw new Error(
           `Existing pet name does not designate a guest powers capability: ${q(
            petName)
            }`);

       }
      return (/** @type {Promise<import('./types.js').EndoHost>} */
        // Behold, recursion:
        // eslint-disable-next-line no-use-before-define
        provideValueForFormulaIdentifier(formulaIdentifier));

     };

    /**
     * @param {import('@endo/eventual-send').ERef<AsyncIterableIterator<string>>} readerRef
     * @param {string} [petName]
     */
    const store=  async( readerRef, petName)=>  {
      if( petName!==  undefined) {
        assertPetName(petName);
       }

      const formulaIdentifier=  await storeReaderRef(readerRef);

      if( petName!==  undefined) {
        await petStore.write(petName, formulaIdentifier);
       }
     };

    /**
     * @param {string} workerName
     */
    const provideWorker=  async(workerName)=> {
      if( typeof workerName!==  'string') {
        throw new Error('worker name must be string');
       }
      let workerFormulaIdentifier=  lookupFormulaIdentifierForName(workerName);
      if( workerFormulaIdentifier===  undefined) {
        const workerId512=  await randomHex512();
        workerFormulaIdentifier=   `worker-id512:${workerId512}`;
        assertPetName(workerName);
        await petStore.write(workerName, workerFormulaIdentifier);
       }else if( !workerFormulaIdentifier.startsWith('worker-id512:')) {
        throw new Error( `Not a worker ${q(workerName)}`);
       }
      return (/** @type {Promise<import('./types.js').EndoWorker>} */
        // Behold, recursion:
        // eslint-disable-next-line no-use-before-define
        provideValueForFormulaIdentifier(workerFormulaIdentifier));

     };

    /**
     * @param {string | 'MAIN' | 'NEW'} workerName
     */
    const provideWorkerFormulaIdentifier=  async(workerName)=> {
      if( workerName===  'MAIN') {
        return mainWorkerFormulaIdentifier;
       }else if( workerName===  'NEW') {
        const workerId512=  await randomHex512();
        return  `worker-id512:${workerId512}`;
       }
      assertPetName(workerName);
      let workerFormulaIdentifier=  lookupFormulaIdentifierForName(workerName);
      if( workerFormulaIdentifier===  undefined) {
        const workerId512=  await randomHex512();
        workerFormulaIdentifier=   `worker-id512:${workerId512}`;
        assertPetName(workerName);
        await petStore.write(workerName, workerFormulaIdentifier);
       }
      return workerFormulaIdentifier;
     };

    /**
     * @param {string | 'NONE' | 'HOST' | 'ENDO'} partyName
     */
    const providePowersFormulaIdentifier=  async(partyName)=> {
      if( partyName===  'NONE') {
        return 'least-authority';
       }else if( partyName===  'HOST') {
        return 'host';
       }else if( partyName===  'ENDO') {
        return 'endo';
       }
      assertPetName(partyName);
      let guestFormulaIdentifier=  lookupFormulaIdentifierForName(partyName);
      if( guestFormulaIdentifier===  undefined) {
        const guest=  await provideGuest(partyName);
        guestFormulaIdentifier=  formulaIdentifierForRef.get(guest);
        if( guestFormulaIdentifier===  undefined) {
          throw new Error(
             `panic: provideGuest must return an guest with a corresponding formula identifier`);

         }
       }
      return guestFormulaIdentifier;
     };

    /**
     * @param {string | 'MAIN' | 'NEW'} workerName
     * @param {string} source
     * @param {Array<string>} codeNames
     * @param {Array<string>} petNames
     * @param {string} resultName
     */
    const evaluate=  async(
      workerName,
      source,
      codeNames,
      petNames,
      resultName)=>
         {
      const workerFormulaIdentifier=  await provideWorkerFormulaIdentifier(
        workerName);


      if( resultName!==  undefined) {
        assertPetName(resultName);
       }
      if( petNames.length!==  codeNames.length) {
        throw new Error('Evaluator requires one pet name for each code name');
       }

      const formulaIdentifiers=  await Promise.all(
        petNames.map(async( petName, index)=>  {
          if( typeof codeNames[index]!==  'string') {
            throw new Error( `Invalid endowment name: ${q(codeNames[index])}`);
           }
          const formulaIdentifier=  lookupFormulaIdentifierForName(petName);
          if( formulaIdentifier===  undefined) {
            throw new Error( `Unknown pet name ${q(petName)}`);
           }
          return formulaIdentifier;
         }));


      const formula=  {
        /** @type {'eval'} */
        type: 'eval',
        worker: workerFormulaIdentifier,
        source,
        names: codeNames,
        values: formulaIdentifiers};


      // Behold, recursion:
      // eslint-disable-next-line no-use-before-define
      const { formulaIdentifier, value}=   await provideValueForFormula(
        formula,
        'eval-id512');

      if( resultName!==  undefined) {
        await petStore.write(resultName, formulaIdentifier);
       }
      return value;
     };

    /**
     * @param {string | 'NEW' | 'MAIN'} workerName
     * @param {string} importPath
     * @param {string | 'NONE' | 'HOST' | 'ENDO'} powersName
     * @param {string} resultName
     */
    const importUnsafeAndEndow=  async(
      workerName,
      importPath,
      powersName,
      resultName)=>
         {
      console.log('> importUnsafeAndEndow provideWorkerFormulaIdentifier', { workerName, importPath, powersName, resultName});
      const workerFormulaIdentifier=  await provideWorkerFormulaIdentifier(
        workerName);

      console.log('< importUnsafeAndEndow provideWorkerFormulaIdentifier', { workerName, importPath, powersName, resultName});

      console.log('> importUnsafeAndEndow providePowersFormulaIdentifier', { workerName, importPath, powersName, resultName});
      const powersFormulaIdentifier=  await providePowersFormulaIdentifier(
        powersName);

      console.log('< importUnsafeAndEndow providePowersFormulaIdentifier', { workerName, importPath, powersName, resultName});

      const formula=  {
        /** @type {'import-unsafe'} */
        type: 'import-unsafe',
        worker: workerFormulaIdentifier,
        powers: powersFormulaIdentifier,
        importPath};


      console.log('> importUnsafeAndEndow provideValueForFormula', { workerName, importPath, powersName, resultName});
      // Behold, recursion:
      // eslint-disable-next-line no-use-before-define
      const { formulaIdentifier, value}=   await provideValueForFormula(
        formula,
        'import-unsafe-id512');

      console.log('< importUnsafeAndEndow provideValueForFormula', { workerName, importPath, powersName, resultName});
      if( resultName!==  undefined) {
        console.log('> importUnsafeAndEndow petStore.write', { workerName, importPath, powersName, resultName});
        await petStore.write(resultName, formulaIdentifier);
        console.log('< importUnsafeAndEndow petStore.write', { workerName, importPath, powersName, resultName});
       }
      return value;
     };

    /**
     * @param {string | 'MAIN' | 'NEW'} workerName
     * @param {string} bundleName
     * @param {string | 'NONE' | 'HOST' | 'ENDO'} powersName
     * @param {string} resultName
     */
    const importBundleAndEndow=  async(
      workerName,
      bundleName,
      powersName,
      resultName)=>
         {
      const workerFormulaIdentifier=  await provideWorkerFormulaIdentifier(
        workerName);


      const bundleFormulaIdentifier=
        lookupFormulaIdentifierForName(bundleName);
      if( bundleFormulaIdentifier===  undefined) {
        throw new TypeError( `Unknown pet name for bundle: ${bundleName}`);
       }

      const powersFormulaIdentifier=  await providePowersFormulaIdentifier(
        powersName);


      const formula=  {
        /** @type {'import-bundle'} */
        type: 'import-bundle',
        worker: workerFormulaIdentifier,
        powers: powersFormulaIdentifier,
        bundle: bundleFormulaIdentifier};


      // Behold, recursion:
      // eslint-disable-next-line no-use-before-define
      const { value, formulaIdentifier}=   await provideValueForFormula(
        formula,
        'import-bundle-id512');


      if( resultName!==  undefined) {
        await petStore.write(resultName, formulaIdentifier);
       }

      return value;
     };

    /**
     * @param {string} [petName]
     */
    const makeWorker=  async(petName)=> {
      const workerId512=  await randomHex512();
      const formulaIdentifier=   `worker-id512:${workerId512}`;
      if( petName!==  undefined) {
        assertPetName(petName);
        await petStore.write(petName, formulaIdentifier);
       }
      return (/** @type {Promise<import('./types.js').EndoWorker>} */
        // Behold, recursion:
        // eslint-disable-next-line no-use-before-define
        provideValueForFormulaIdentifier(formulaIdentifier));

     };

    /**
     * @param {string} [petName]
     */
    const provideHost=  async(petName)=> {
      /** @type {string | undefined} */
      let formulaIdentifier;
      if( petName!==  undefined) {
        formulaIdentifier=  lookupFormulaIdentifierForName(petName);
       }
      if( formulaIdentifier===  undefined) {
        const id512=  await randomHex512();
        formulaIdentifier=   `host-id512:${id512}`;
        if( petName!==  undefined) {
          assertPetName(petName);
          await petStore.write(petName, formulaIdentifier);
         }
       }else if( !formulaIdentifier.startsWith('host-id512:')) {
        throw new Error(
           `Existing pet name does not designate a host powers capability: ${q(
            petName)
            }`);

       }
      return (/** @type {Promise<import('./types.js').EndoHost>} */
        // Behold, recursion:
        // eslint-disable-next-line no-use-before-define
        provideValueForFormulaIdentifier(formulaIdentifier));

     };

    /**
     * @param {string} webPageName
     * @param {string} bundleName
     * @param {string | 'NONE' | 'HOST' | 'ENDO'} powersName
     */
    const provideWebPage=  async( webPageName, bundleName, powersName)=>  {
      const bundleFormulaIdentifier=
        lookupFormulaIdentifierForName(bundleName);
      if( bundleFormulaIdentifier===  undefined) {
        throw new Error( `Unknown pet name: ${q(bundleName)}`);
       }

      const powersFormulaIdentifier=  await providePowersFormulaIdentifier(
        powersName);


      const digester=  makeSha512();
      digester.updateText(
         `${bundleFormulaIdentifier},${powersFormulaIdentifier}`);

      const formulaNumber=  digester.digestHex().slice(32, 64);

      const formula=  {
        type: 'web-bundle',
        bundle: bundleFormulaIdentifier,
        powers: powersFormulaIdentifier};


      // Behold, recursion:
      // eslint-disable-next-line no-use-before-define
      const { value, formulaIdentifier}=   await provideValueForNumberedFormula(
        'web-bundle',
        formulaNumber,
        formula);


      if( webPageName!==  undefined) {
        assertPetName(webPageName);
        await petStore.write(webPageName, formulaIdentifier);
       }

      return value;
     };

    const { list, follow: followNames}=   petStore;

    /** @type {import('./types.js').EndoHost} */
    const host=  Far('EndoHost', {
      lookup,
      reverseLookup,
      listMessages,
      followMessages,
      resolve,
      reject,
      adopt,
      dismiss,
      request,
      send,
      list,
      followNames,
      remove,
      rename,
      store,
      provideGuest,
      provideHost,
      makeWorker,
      provideWorker,
      evaluate,
      importUnsafeAndEndow,
      importBundleAndEndow,
      provideWebPage});


    partyReceiveFunctions.set(host, receive);
    partyRequestFunctions.set(host, respond);

    return host;
   };

  return makeIdentifiedHost;
 };$h‍_once.makeHostMaker(makeHostMaker);
})()
,
// === functors[171] ===
({   imports: $h‍_imports,   liveVar: $h‍_live,   onceVar: $h‍_once,   importMeta: $h‍____meta, }) => (function () {   let E,mapReader,mapWriter,makeMessageCapTP,messageToBytes,bytesToMessage;$h‍_imports([["@endo/far", [["E", [$h‍_a => (E = $h‍_a)]]]],["@endo/stream", [["mapReader", [$h‍_a => (mapReader = $h‍_a)]],["mapWriter", [$h‍_a => (mapWriter = $h‍_a)]]]],["./connection.js", [["makeMessageCapTP", [$h‍_a => (makeMessageCapTP = $h‍_a)]],["messageToBytes", [$h‍_a => (messageToBytes = $h‍_a)]],["bytesToMessage", [$h‍_a => (bytesToMessage = $h‍_a)]]]]]);   







const { quote: q}=   assert;

const        servePrivatePortHttp=  (
  requestedWebletPort,
  endoBootstrap,
  { servePortHttp, connectionNumbers, cancelled, exitWithError})=>
     {
  /** @type {Set<Promise<void>>} */
  const connectionClosedPromises=  new Set();

  const respond=  async(request)=> {
    if( request.method===  'GET') {
      if( request.url===  '/') {
        return {
          status: 200,
          headers: { 'Content-Type': 'text/html', Charset: 'utf-8'},
          content:  `\
<meta charset="utf-8">
<link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 10 10%22><text y=%228%22 font-size=%228%22>🐈‍⬛</text></svg>">
<body>
  <h1>⏳</h1>
  <script src="bootstrap.js"></script>
</body>`};

       }else if( request.url===  '/bootstrap.js') {
        // TODO readable mutable file formula (with watcher?)
        // Behold, recursion:
        // eslint-disable-next-line no-use-before-define
        const webPageJs=  await E(endoBootstrap).webPageJs();
        return {
          status: 200,
          headers: { 'Content-Type': 'application/javascript'},
          content: webPageJs};

       }
     }
    return {
      status: 404,
      headers: { 'Content-Type': 'text/plain'},
      content:  `Not found: ${request.method} ${request.url}`};

   };

  const started=  servePortHttp({
    port: requestedWebletPort,
    host: '127.0.0.1',
    respond,
    connect(connection, request) {
      // TODO select attenuated bootstrap based on subdomain
      (async()=>   {
        const assignedHttpPort=  await started;
        const {
          reader: frameReader,
          writer: frameWriter,
          closed: connectionClosed}=
            connection;

        const connectionNumber=  connectionNumbers.next();
        console.log(
           `Endo daemon received local web socket connection ${connectionNumber} at ${new Date().toISOString()}`);


        const messageWriter=  mapWriter(frameWriter, messageToBytes);
        const messageReader=  mapReader(frameReader, bytesToMessage);

        const { closed: capTpClosed, getBootstrap}=   makeMessageCapTP(
          'Endo',
          messageWriter,
          messageReader,
          cancelled,
          undefined  // bootstrap
);

        const webBootstrap=  getBootstrap();

        // TODO set up heart monitor
        E.sendOnly(webBootstrap).ping();

        const host=  request.headers.host;
        if( host===  undefined) {
          throw new Error('Host header required');
         }
        const match=
          /^([0-9a-f]{32})\.endo\.localhost:([1-9][0-9]{0,4})$/.exec(host);
        if( match===  null) {
          throw new Error( `Invalid host ${host}`);
         }
        const [_, formulaNumber, portNumber]=  match;
        // eslint-disable-next-line no-use-before-define
        if( assignedHttpPort!==  +portNumber) {
          console.error(
            'Connected browser misreported port number in host header');

          E(webBootstrap).
             reject(
              'Your browser misreported your port number in the host header').

             catch((error)=>{
              console.error(error);
             });
         }else {
          // eslint-disable-next-line no-use-before-define
          E(endoBootstrap).
             importAndEndowInWebPage(webBootstrap, formulaNumber).
             catch((error)=>{
              E.sendOnly(webBootstrap).reject(error.message);
             }).
             catch((error)=>{
              console.error(error);
             });
         }

        const closed=  Promise.race([connectionClosed, capTpClosed]);
        connectionClosedPromises.add(closed);
        closed.finally(()=>  {
          connectionClosedPromises.delete(closed);
          console.log(
             `Endo daemon closed local web socket connection ${connectionNumber} at ${new Date().toISOString()}`);

         });
       })().catch(exitWithError);
     },
    cancelled});


  started.then((assignedHttpPort)=>{
    console.log(
       `Endo daemon listening for HTTP on ${q(
        assignedHttpPort)
        } ${new Date().toISOString()}`);

   });

  const stopped=  cancelled.catch(()=>
    Promise.all(Array.from(connectionClosedPromises)));


  return harden({ started, stopped});
 };$h‍_once.servePrivatePortHttp(servePrivatePortHttp);
})()
,
// === functors[172] ===
({   imports: $h‍_imports,   liveVar: $h‍_live,   onceVar: $h‍_once,   importMeta: $h‍____meta, }) => (function () {   let makeNetstringCapTP;$h‍_imports([["./connection.js", [["makeNetstringCapTP", [$h‍_a => (makeNetstringCapTP = $h‍_a)]]]]]);   

const { quote: q}=   assert;

const        servePrivatePath=  (
  sockPath,
  endoBootstrap,
  { servePath, connectionNumbers, cancelled, exitWithError})=>
     {
  const connectionsP=  servePath({ path: sockPath, cancelled});

  const started=  async()=>   {
    await connectionsP;
    // Resolve a promise in the Endo CLI through the IPC channel:
    console.log(
       `Endo daemon listening for CapTP on ${q(
        sockPath)
        } ${new Date().toISOString()}`);

   };

  const stopped=  (async()=>   {
    /** @type {Set<Promise<void>>} */
    const connectionClosedPromises=  new Set();

    const connections=  await connectionsP;

    for await( const {
      reader,
      writer,
      closed: connectionClosed}of
         connections) {
      (async()=>   {
        const connectionNumber=  connectionNumbers.next();
        console.log(
           `Endo daemon received domain connection ${connectionNumber} at ${new Date().toISOString()}`);


        const { closed: capTpClosed}=   makeNetstringCapTP(
          'Endo',
          writer,
          reader,
          cancelled,
          endoBootstrap);


        const closed=  Promise.race([connectionClosed, capTpClosed]);
        connectionClosedPromises.add(closed);
        closed.finally(()=>  {
          connectionClosedPromises.delete(closed);
          console.log(
             `Endo daemon closed domain connection ${connectionNumber} at ${new Date().toISOString()}`);

         });
       })().catch(exitWithError);
     }

    await Promise.all(Array.from(connectionClosedPromises));
   })();

  return harden({ started, stopped});
 };$h‍_once.servePrivatePath(servePrivatePath);
})()
,
// === functors[173] ===
({   imports: $h‍_imports,   liveVar: $h‍_live,   onceVar: $h‍_once,   importMeta: $h‍____meta, }) => (function () {   let E,Far,makePromiseKit,makeNetstringCapTP,makeRefReader,makeReaderRef,makeOwnPetStore,makeIdentifiedPetStore,makeMailboxMaker,makeGuestMaker,makeHostMaker,servePrivatePortHttp,servePrivatePath;$h‍_imports([["ses", []],["@endo/eventual-send/shim.js", []],["@endo/promise-kit/shim.js", []],["@endo/lockdown/commit.js", []],["@endo/far", [["E", [$h‍_a => (E = $h‍_a)]],["Far", [$h‍_a => (Far = $h‍_a)]]]],["@endo/promise-kit", [["makePromiseKit", [$h‍_a => (makePromiseKit = $h‍_a)]]]],["./connection.js", [["makeNetstringCapTP", [$h‍_a => (makeNetstringCapTP = $h‍_a)]]]],["./ref-reader.js", [["makeRefReader", [$h‍_a => (makeRefReader = $h‍_a)]]]],["./reader-ref.js", [["makeReaderRef", [$h‍_a => (makeReaderRef = $h‍_a)]]]],["./pet-store.js", [["makeOwnPetStore", [$h‍_a => (makeOwnPetStore = $h‍_a)]],["makeIdentifiedPetStore", [$h‍_a => (makeIdentifiedPetStore = $h‍_a)]]]],["./mail.js", [["makeMailboxMaker", [$h‍_a => (makeMailboxMaker = $h‍_a)]]]],["./guest.js", [["makeGuestMaker", [$h‍_a => (makeGuestMaker = $h‍_a)]]]],["./host.js", [["makeHostMaker", [$h‍_a => (makeHostMaker = $h‍_a)]]]],["./serve-private-port-http.js", [["servePrivatePortHttp", [$h‍_a => (servePrivatePortHttp = $h‍_a)]]]],["./serve-private-path.js", [["servePrivatePath", [$h‍_a => (servePrivatePath = $h‍_a)]]]]]);   




















const { quote: q}=   assert;

const zero512=
  '0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000';

const defaultHttpPort=  8920; // Eight Nine Duo Oh: ENDO.

/** @type {import('./types.js').EndoGuest} */
const leastAuthority=  Far('EndoGuest', {
        async request(){
    throw new Error('declined');
   }});


/**
 * @param {import('./types.js').DaemonicPowers} powers
 * @param {import('./types.js').Locator} locator
 * @param {Promise<number>} webletPortP
 * @param {object} args
 * @param {Promise<never>} args.cancelled
 * @param {(error: Error) => void} args.cancel
 * @param {number} args.gracePeriodMs
 * @param {Promise<never>} args.gracePeriodElapsed
 */
const makeEndoBootstrap=  (
  powers,
  locator,
  webletPortP,
  { cancelled, cancel, gracePeriodMs, gracePeriodElapsed})=>
     {
  const { randomHex512, makeSha512}=   powers;

  /** @type {Map<string, unknown>} */
  const valuePromiseForFormulaIdentifier=  new Map();
  // Reverse look-up, for answering "what is my name for this near or far
  // reference", and not for "what is my name for this promise".
  /** @type {WeakMap<object, string>} */
  const formulaIdentifierForRef=  new WeakMap();

  /** @type {WeakMap<object, import('@endo/eventual-send').ERef<import('./worker.js').WorkerBootstrap>>} */
  const workerBootstraps=  new WeakMap();

  /**
   * @param {string} sha512
   */
  const makeSha512ReadableBlob=  (sha512)=>{
    const storageDirectoryPath=  powers.joinPath(
      locator.statePath,
      'store-sha512');

    const storagePath=  powers.joinPath(storageDirectoryPath, sha512);
    const stream=  async()=>   {
      const reader=  powers.makeFileReader(storagePath);
      return makeReaderRef(reader);
     };
    const text=  async()=>   {
      return powers.readFileText(storagePath);
     };
    const json=  async()=>   {
      return JSON.parse(await text());
     };
    return Far( `Readable file with SHA-512 ${sha512.slice(0,8) }...`,{
      sha512: ()=>  sha512,
      stream,
      text,
      json,
      [Symbol.asyncIterator]: stream});

   };

  /**
   * @param {import('@endo/eventual-send').ERef<AsyncIterableIterator<string>>} readerRef
   */
  const storeReaderRef=  async(readerRef)=> {
    const storageDirectoryPath=  powers.joinPath(
      locator.statePath,
      'store-sha512');

    await powers.makePath(storageDirectoryPath);

    // Pump the reader into a temporary file and hash.
    // We use a temporary file to avoid leaving a partially writen object,
    // but also because we won't know the name we will use until we've
    // completed the hash.
    const digester=  powers.makeSha512();
    const storageId512=  await powers.randomHex512();
    const temporaryStoragePath=  powers.joinPath(
      storageDirectoryPath,
      storageId512);

    const writer=  powers.makeFileWriter(temporaryStoragePath);
    for await( const chunk of makeRefReader(readerRef)) {
      await writer.next(chunk);
      digester.update(chunk);
     }
    await writer.return(undefined);
    const sha512=  digester.digestHex();

    // Finish with an atomic rename.
    const storagePath=  powers.joinPath(storageDirectoryPath, sha512);
    await powers.renamePath(temporaryStoragePath, storagePath);

    return  `readable-blob-sha512:${sha512}`;
   };

  /**
   * @param {string} workerId512
   * @param {string} workerFormulaIdentifier
   */
  const makeWorkerBootstrap=  async( workerId512, workerFormulaIdentifier)=>  {
    // TODO validate workerId512, workerFormulaIdentifier
    return Far( `Endo for worker ${workerId512}`,{});
   };

  /**
   * @param {string} workerId512
   */
  const makeIdentifiedWorker=  async(workerId512)=> {
    // TODO validate workerId512
    const workerFormulaIdentifier=   `worker-id512:${workerId512}`;
    const workerCachePath=  powers.joinPath(
      locator.cachePath,
      'worker-id512',
      workerId512);

    const workerStatePath=  powers.joinPath(
      locator.statePath,
      'worker-id512',
      workerId512);

    const workerEphemeralStatePath=  powers.joinPath(
      locator.ephemeralStatePath,
      'worker-id512',
      workerId512);


    await Promise.all([
      powers.makePath(workerStatePath),
      powers.makePath(workerEphemeralStatePath)]);


    const { reject: cancelWorker, promise: workerCancelled}=
      /** @type {import('@endo/promise-kit').PromiseKit<never>} */
        makePromiseKit();

    cancelled.catch(async(error)=> cancelWorker(error));

    const logPath=  powers.joinPath(workerStatePath, 'worker.log');
    const workerPidPath=  powers.joinPath(
      workerEphemeralStatePath,
      'worker.pid');

    const {
      reader,
      writer,
      closed: workerClosed,
      pid: workerPid}=
        await powers.makeWorker(
      workerId512,
      powers.endoWorkerPath,
      logPath,
      workerPidPath,
      locator.sockPath,
      workerStatePath,
      workerEphemeralStatePath,
      workerCachePath,
      workerCancelled);


    console.log(
       `Endo worker started PID ${workerPid} unique identifier ${workerId512}`);


    const { getBootstrap, closed: capTpClosed}=   makeNetstringCapTP(
       `Worker ${workerId512}`,
      writer,
      reader,
      gracePeriodElapsed,
      makeWorkerBootstrap(workerId512, workerFormulaIdentifier));


    const closed=  Promise.race([workerClosed, capTpClosed]).finally(()=>  {
      console.log(
         `Endo worker stopped PID ${workerPid} with unique identifier ${workerId512}`);

     });

    /** @type {import('@endo/eventual-send').ERef<import('./worker.js').WorkerBootstrap>} */
    const workerBootstrap=  getBootstrap();

    const terminate=  async()=>   {
      E.sendOnly(workerBootstrap).terminate();
      const cancelWorkerGracePeriod=  ()=>  {
        throw new Error('Exited gracefully before grace period elapsed');
       };
      const workerGracePeriodCancelled=  Promise.race([
        gracePeriodElapsed,
        closed]).
         then(cancelWorkerGracePeriod, cancelWorkerGracePeriod);
      await powers.
         delay(gracePeriodMs, workerGracePeriodCancelled).
         then(()=>  {
          throw new Error(
             `Worker termination grace period ${gracePeriodMs}ms elapsed`);

         }).
         catch(cancelWorker);
     };

    const worker=  Far('EndoWorker', {
      terminate,

      whenTerminated: ()=>  closed});


    workerBootstraps.set(worker, workerBootstrap);

    return worker;
   };

  /**
   * @param {string} workerFormulaIdentifier
   * @param {string} source
   * @param {Array<string>} codeNames
   * @param {Array<string>} formulaIdentifiers
   */
  const makeValueForEval=  async(
    workerFormulaIdentifier,
    source,
    codeNames,
    formulaIdentifiers)=>
       {
    // Behold, recursion:
    // eslint-disable-next-line no-use-before-define
    const workerFacet=  await provideValueForFormulaIdentifier(
      workerFormulaIdentifier);

    // TODO consider a better mechanism for hiding the private facet.
    // Maybe all these internal functions should return { public, private }
    // duples.
    const workerBootstrap=  workerBootstraps.get(workerFacet);
    assert(workerBootstrap);
    const endowmentValues=  await Promise.all(
      formulaIdentifiers.map((formulaIdentifier)=>
        // Behold, recursion:
        // eslint-disable-next-line no-use-before-define
        provideValueForFormulaIdentifier(formulaIdentifier)));


    return E(workerBootstrap).evaluate(source, codeNames, endowmentValues);
   };

  /**
   * @param {string} workerFormulaIdentifier
   * @param {string} guestFormulaIdentifier
   * @param {string} importPath
   */
  const makeValueForImportUnsafe0=  async(
    workerFormulaIdentifier,
    guestFormulaIdentifier,
    importPath)=>
       {
    // Behold, recursion:
    // eslint-disable-next-line no-use-before-define
    const workerFacet=  await provideValueForFormulaIdentifier(
      workerFormulaIdentifier);

    const workerBootstrap=  workerBootstraps.get(workerFacet);
    assert(workerBootstrap);
    const guestP=  /** @type {Promise<import('./types.js').EndoGuest>} */
      // Behold, recursion:
      // eslint-disable-next-line no-use-before-define
      provideValueForFormulaIdentifier(guestFormulaIdentifier);

    return E(workerBootstrap).importUnsafeAndEndow(importPath, guestP);
   };

  /**
   * @param {string} workerFormulaIdentifier
   * @param {string} guestFormulaIdentifier
   * @param {string} bundleFormulaIdentifier
   */
  const makeValueForImportBundle0=  async(
    workerFormulaIdentifier,
    guestFormulaIdentifier,
    bundleFormulaIdentifier)=>
       {
    // Behold, recursion:
    // eslint-disable-next-line no-use-before-define
    const workerFacet=  await provideValueForFormulaIdentifier(
      workerFormulaIdentifier);

    const workerBootstrap=  workerBootstraps.get(workerFacet);
    assert(workerBootstrap);
    // Behold, recursion:
    // eslint-disable-next-line no-use-before-define
    const readableBundleP=
      /** @type {Promise<import('./types.js').EndoReadable>} */
        // Behold, recursion:
        // eslint-disable-next-line no-use-before-define
        provideValueForFormulaIdentifier(bundleFormulaIdentifier);

    const guestP=  /** @type {Promise<import('./types.js').EndoGuest>} */
      // Behold, recursion:
      // eslint-disable-next-line no-use-before-define
      provideValueForFormulaIdentifier(guestFormulaIdentifier);

    return E(workerBootstrap).importBundleAndEndow(readableBundleP, guestP);
   };

  /**
   * @param {string} formulaIdentifier
   * @param {string} formulaNumber
   * @param {import('./types.js').Formula} formula
   */
  const makeValueForFormula=  async(
    formulaIdentifier,
    formulaNumber,
    formula)=>
       {
    if( formula.type===  'eval') {
      return makeValueForEval(
        formula.worker,
        formula.source,
        formula.names,
        formula.values);

     }else if( formula.type===  'import-unsafe') {
      return makeValueForImportUnsafe0(
        formula.worker,
        formula.powers,
        formula.importPath);

     }else if( formula.type===  'import-bundle') {
      return makeValueForImportBundle0(
        formula.worker,
        formula.powers,
        formula.bundle);

     }else if( formula.type===  'guest') {
      // Behold, recursion:
      // eslint-disable-next-line no-use-before-define
      return makeIdentifiedGuest(
        formulaIdentifier,
        formula.host,
         `pet-store-id512:${formulaNumber}`,
         `worker-id512:${formulaNumber}`);

     }else if( formula.type===  'web-bundle') {
      return harden({
        url:  `http://${formulaNumber}.endo.localhost:${await webletPortP}`,
        // Behold, recursion:
        // eslint-disable-next-line no-use-before-define
        bundle: provideValueForFormulaIdentifier(formula.bundle),
        // Behold, recursion:
        // eslint-disable-next-line no-use-before-define
        powers: provideValueForFormulaIdentifier(formula.powers)});

     }else {
      throw new TypeError( `Invalid formula: ${q(formula)}`);
     }
   };

  /**
   * @param {string} formulaType
   * @param {string} formulaId512
   */
  const makeFormulaPath=  (formulaType, formulaId512)=>  {
    if( formulaId512.length<  3) {
      throw new TypeError(
         `Invalid formula identifier ${q(formulaId512)} for formula of type ${q(
          formulaType)
          }`);

     }
    const head=  formulaId512.slice(0, 2);
    const tail=  formulaId512.slice(3);
    const directory=  powers.joinPath(
      locator.statePath,
      'formulas',
      formulaType,
      head);

    const file=  powers.joinPath(directory,  `${tail}.json`);
    return { directory, file};
   };

  // Persist instructions for revival (this can be collected)
  const writeFormula=  async( formula, formulaType, formulaId512)=>  {
    const { directory, file}=   makeFormulaPath(formulaType, formulaId512);
    // TODO Take care to write atomically with a rename here.
    await powers.makePath(directory);
    await powers.writeFileText(file,  `${q(formula)}\n`);
   };

  /**
   * @param {string} formulaIdentifier
   * @param {string} formulaNumber
   * @param {string} formulaPath
   */
  const makeValueForFormulaAtPath=  async(
    formulaIdentifier,
    formulaNumber,
    formulaPath)=>
       {
    const formulaText=  await powers.readFileText(formulaPath).catch(()=>  {
      // TODO handle EMFILE gracefully
      throw new ReferenceError( `No reference exists at path ${formulaPath}`);
     });
    const formula=  (()=>  {
      try {
        return JSON.parse(formulaText);
       }catch( error) {
        throw new TypeError(
           `Corrupt description for reference in file ${formulaPath}: ${error.message}`);

       }
     })();
    // TODO validate
    return makeValueForFormula(formulaIdentifier, formulaNumber, formula);
   };

  /**
   * @param {string} formulaIdentifier
   */
  const makeValueForFormulaIdentifier=  async(formulaIdentifier)=> {
    const delimiterIndex=  formulaIdentifier.indexOf(':');
    if( delimiterIndex<  0) {
      if( formulaIdentifier===  'pet-store') {
        return makeOwnPetStore(powers, locator, 'pet-store');
       }else if( formulaIdentifier===  'host') {
        // Behold, recursion:
        // eslint-disable-next-line no-use-before-define
        return makeIdentifiedHost(
          formulaIdentifier,
          'pet-store',
           `worker-id512:${zero512}`);

       }else if( formulaIdentifier===  'endo') {
        // Behold, self-referentiality:
        // eslint-disable-next-line no-use-before-define
        return endoBootstrap;
       }else if( formulaIdentifier===  'least-authority') {
        return leastAuthority;
       }else if( formulaIdentifier===  'web-page-js') {
        return makeValueForFormula('web-page-js', zero512, {
          type: /** @type {'import-unsafe'} */  'import-unsafe',
          worker:  `worker-id512:${zero512}`,
          powers: 'host',
          importPath: powers.fileURLToPath(
            new URL('web-page-bundler.js', $h‍____meta.url).href)});


       }
      throw new TypeError(
         `Formula identifier must have a colon: ${q(formulaIdentifier)}`);

     }
    const prefix=  formulaIdentifier.slice(0, delimiterIndex);
    const formulaNumber=  formulaIdentifier.slice(delimiterIndex+  1);
    if( prefix===  'readable-blob-sha512') {
      return makeSha512ReadableBlob(formulaNumber);
     }else if( prefix===  'worker-id512') {
      return makeIdentifiedWorker(formulaNumber);
     }else if( prefix===  'pet-store-id512') {
      return makeIdentifiedPetStore(powers, locator, formulaNumber);
     }else if( prefix===  'host-id512') {
      // Behold, recursion:
      // eslint-disable-next-line no-use-before-define
      return makeIdentifiedHost(
        formulaIdentifier,
         `pet-store-id512:${formulaNumber}`,
         `worker-id512:${formulaNumber}`);

     }else if(
      [
        'eval-id512',
        'import-unsafe-id512',
        'import-bundle-id512',
        'guest-id512',
        'web-bundle'].
        includes(prefix))
      {
      const { file: path}=   makeFormulaPath(prefix, formulaNumber);
      return makeValueForFormulaAtPath(formulaIdentifier, formulaNumber, path);
     }else {
      throw new TypeError(
         `Invalid formula identifier, unrecognized type ${q(formulaIdentifier)}`);

     }
   };

  // The two functions provideValueForFormula and provideValueForFormulaIdentifier
  // share a responsibility for maintaining the memoization tables
  // valuePromiseForFormulaIdentifier and formulaIdentifierForRef, since the
  // former bypasses the latter in order to avoid a round trip with disk.

  const provideValueForNumberedFormula=  async(
    formulaType,
    formulaNumber,
    formula)=>
       {
    const formulaIdentifier=   `${formulaType}:${formulaNumber}`;

    await writeFormula(formula, formulaType, formulaNumber);
    // Behold, recursion:
    // eslint-disable-next-line no-use-before-define
    const promiseForValue=  makeValueForFormula(
      formulaIdentifier,
      formulaNumber,
      formula);


    // Memoize provide.
    valuePromiseForFormulaIdentifier.set(formulaIdentifier, promiseForValue);

    // Prepare an entry for reverse-lookup of formula for presence.
    const value=  await promiseForValue;
    if( typeof value===  'object'&&  value!==  null) {
      formulaIdentifierForRef.set(value, formulaIdentifier);
     }

    return { formulaIdentifier, value};
   };

  /**
   * @param {import('./types.js').Formula} formula
   * @param {string} formulaType
   */
  const provideValueForFormula=  async( formula, formulaType)=>  {
    const formulaNumber=  await powers.randomHex512();
    return provideValueForNumberedFormula(formulaType, formulaNumber, formula);
   };

  /**
   * @param {string} formulaIdentifier
   */
  const provideValueForFormulaIdentifier=  async(formulaIdentifier)=> {
    let promiseForValue=
      valuePromiseForFormulaIdentifier.get(formulaIdentifier);
    if( promiseForValue===  undefined) {
      promiseForValue=  makeValueForFormulaIdentifier(formulaIdentifier);
      valuePromiseForFormulaIdentifier.set(formulaIdentifier, promiseForValue);
     }
    const value=  await promiseForValue;
    if( typeof value===  'object'&&  value!==  null) {
      formulaIdentifierForRef.set(value, formulaIdentifier);
     }
    return value;
   };

  const { makeMailbox, partyReceiveFunctions, partyRequestFunctions}=
    makeMailboxMaker({
      formulaIdentifierForRef,
      provideValueForFormulaIdentifier});


  const makeIdentifiedGuest=  makeGuestMaker({
    provideValueForFormulaIdentifier,
    partyReceiveFunctions,
    partyRequestFunctions,
    makeMailbox});


  const makeIdentifiedHost=  makeHostMaker({
    provideValueForFormulaIdentifier,
    provideValueForFormula,
    provideValueForNumberedFormula,
    formulaIdentifierForRef,
    partyReceiveFunctions,
    partyRequestFunctions,
    storeReaderRef,
    randomHex512,
    makeSha512,
    makeMailbox});


  const endoBootstrap=  Far('Endo private facet', {
    // TODO for user named

    ping: async()=>   'pong',

    terminate: async()=>   {
      cancel(new Error('Termination requested'));
     },

    host: ()=>  provideValueForFormulaIdentifier('host'),

    leastAuthority: ()=>  leastAuthority,

    webPageJs: ()=>  provideValueForFormulaIdentifier('web-page-js'),

    importAndEndowInWebPage: async( webPageP, webPageNumber)=>  {
      const { bundle: bundleBlob, powers: endowedPowers}=
        /** @type {import('./types.js').EndoWebBundle} */
          await provideValueForFormulaIdentifier(
             `web-bundle:${webPageNumber}`).
            catch(()=>  {
            throw new Error('Not found');
           });

      const bundle=  await E(bundleBlob).json();
      await E(webPageP).importBundleAndEndow(bundle, endowedPowers);
     }});


  return endoBootstrap;
 };

/*
 * @param {import('./types.js').DaemonicPowers} powers
 * @param {import('./types.js').Locator} locator
 * @param {number | undefined} pid
 * @param {(error: Error) => void} cancel
 * @param {Promise<never>} cancelled
 */
const        main=  async( powers, locator, pid, cancel, cancelled)=>  {
  console.log( `Endo daemon starting on PID ${pid}`);
  cancelled.catch(()=>  {
    console.log( `Endo daemon stopping on PID ${pid}`);
   });

  const { promise: gracePeriodCancelled, reject: cancelGracePeriod}=
    /** @type {import('@endo/promise-kit').PromiseKit<never>} */
      makePromiseKit();


  // TODO thread through command arguments.
  const gracePeriodMs=  100;

  /** @type {Promise<never>} */
  const gracePeriodElapsed=  cancelled.catch(async(error)=> {
    await powers.delay(gracePeriodMs, gracePeriodCancelled);
    console.log(
       `Endo daemon grace period ${gracePeriodMs}ms elapsed on PID ${pid}`);

    throw error;
   });

  /** @param {Error} error */
  const exitWithError=  (error)=>{
    cancel(error);
    cancelGracePeriod(error);
   };

  const statePathP=  powers.makePath(locator.statePath);
  const ephemeralStatePathP=  powers.makePath(locator.ephemeralStatePath);
  const cachePathP=  powers.makePath(locator.cachePath);
  await Promise.all([statePathP, cachePathP, ephemeralStatePathP]);

  const requestedWebletPortText=  powers.env.ENDO_HTTP_PORT;
  const requestedWebletPort=  requestedWebletPortText?
      Number(requestedWebletPortText):
      defaultHttpPort;

  const { promise: assignedWebletPortP, resolve: assignWebletPort}=
    /** @type {import('@endo/promise-kit').PromiseKit<number>} */
      makePromiseKit();


  const endoBootstrap=  makeEndoBootstrap(
    powers,
    locator,
    assignedWebletPortP,
    {
      cancelled,
      cancel,
      gracePeriodMs,
      gracePeriodElapsed});



  const connectionNumbers=  (function* generateNumbers() {
    let n=  0;
    for(;;)  {
      yield n;
      n+=  1;
     }
   })();

  const { servePath, servePortHttp}=   powers;

  const privatePathService=  servePrivatePath(locator.sockPath, endoBootstrap, {
    servePath,
    connectionNumbers,
    cancelled,
    exitWithError});


  const privateHttpService=  servePrivatePortHttp(
    requestedWebletPort,
    endoBootstrap,
    {
      servePortHttp,
      connectionNumbers,
      cancelled,
      exitWithError});



  assignWebletPort(privateHttpService.started);

  const services=  [privatePathService, privateHttpService];

  await Promise.all(services.map(({ started})=>   started)).then(
    ()=>  {
      powers.informParentWhenReady();
     },
    (error)=>{
      powers.reportErrorToParent(error.message);
      throw error;
     });


  const pidPath=  powers.joinPath(locator.ephemeralStatePath, 'endo.pid');

  await powers.
     readFileText(pidPath).
     then((pidText)=>{
      const oldPid=  Number(pidText);
      powers.kill(oldPid);
     }).
     catch(()=>  { });

  await powers.writeFileText(pidPath,  `${pid}\n`);

  await Promise.all(services.map(({ stopped})=>   stopped));

  cancel(new Error('Terminated normally'));
  cancelGracePeriod(new Error('Terminated normally'));
 };$h‍_once.main(main);
})()
,
// === functors[174] ===
({   imports: $h‍_imports,   liveVar: $h‍_live,   onceVar: $h‍_once,   importMeta: $h‍____meta, }) => (function () {   let mapReader;$h‍_imports([["@endo/stream", [["mapReader", [$h‍_a => (mapReader = $h‍_a)]]]]]);   









const { Fail, quote: q}=   assert;

/**
 * @param {import('stream').Readable} input the source Node.js reader
 * @returns {import('@endo/stream').Reader<Uint8Array>}
 */
const        makeNodeReader=  (input)=>{
  !input.readableObjectMode||
    Fail `Cannot convert Node.js object mode Reader to AsyncIterator<Uint8Array>`;
  input.readableEncoding===  null||
    Fail `Cannot convert Node.js Reader with readableEncoding ${q(
      input.readableEncoding)
      } to a AsyncIterator<Uint8Array>`;

  const iterator=  input[Symbol.asyncIterator]();
  assert(iterator.return);

  // Adapt the AsyncIterator to the more strict interface of a Stream: must
  // have return and throw methods.
  /** @type {import('@endo/stream').Reader<Buffer>} */
  const reader=  {
          async next(){
      return iterator.next();
     },
          async return(){
      assert(iterator.return);
      return iterator.return();
     },
          async throw(error){
      input.destroy(error);
      assert(iterator.return);
      return iterator.return();
     },
    [Symbol.asyncIterator]() {
      return reader;
     }};


  /** @type {import('@endo/stream').Reader<Uint8Array>} */
  return mapReader(reader, (buffer)=>{
    assert(typeof buffer!==  'string');
    return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.length);
   });
 };$h‍_once.makeNodeReader(makeNodeReader);
harden(makeNodeReader);
})()
,
// === functors[175] ===
({   imports: $h‍_imports,   liveVar: $h‍_live,   onceVar: $h‍_once,   importMeta: $h‍____meta, }) => (function () {   $h‍_imports([]);   /* Adapts a Node.js stream to an Writer<Uint8Array>, where a writer stream is
 * modeled as a hybrid async iterator + generator.
 */

// @ts-check
/// <reference types="ses"/>

const { Fail}=   assert;

const sink=  harden(()=>  { });

/**
 * Adapts a Node.js writable stream to a JavaScript
 * async iterator of Uint8Array data chunks.
 * Back pressure emerges from awaiting on the promise
 * returned by `next` before calling `next` again.
 *
 * @param {import('stream').Writable} writer the destination Node.js writer
 * @returns {import('@endo/stream').Writer<Uint8Array>}
 */
const        makeNodeWriter=  (writer)=>{
  !writer.writableObjectMode||
    Fail `Cannot convert Node.js object mode Writer to AsyncIterator<undefined, Uint8Array>`;

  let finalized=  false;
  const finalIteration=  new Promise((resolve, reject)=>  {
    const finalize=  ()=>  {
      // eslint-disable-next-line no-use-before-define
      cleanup();
      resolve(harden({ done: true, value: undefined}));
     };
    const error=  (err)=>{
      // eslint-disable-next-line no-use-before-define
      cleanup();
      reject(err);
     };
    const cleanup=  ()=>  {
      finalized=  true;
      writer.off('error', error);
      writer.off('finish', finalize);
      writer.off('close', finalize);
      // Prevent Node 14 from triggering a global unhandled error if we race
      writer.on('error', sink);
     };
    // Streams should emit either error or finish and then may emit close.
    // So, watching close is redundant but makes us feel safer.
    writer.on('error', error);
    writer.on('finish', finalize);
    writer.on('close', finalize);
   });

  const nonFinalIterationResult=  harden({ done: false, value: undefined});

  /** @type {import('@endo/stream').Writer<Uint8Array>} */
  const nodeWriter=  harden({
    /** @param {Uint8Array} value */
          async next(value){
      !finalized||  Fail `Cannot write into closed Node stream`;

      return Promise.race([
        finalIteration,
        new Promise((resolve, reject)=>  {
          if(
            !writer.write(value, (err)=>{
              if( err) reject(err);
             }))
            {
            writer.once('drain', ()=>  {
              resolve(nonFinalIterationResult);
             });
           }else {
            resolve(nonFinalIterationResult);
           }
         })]);

     },
          async return(){
      writer.end();
      return finalIteration;
     },
    /**
     * @param {Error} error
     */
          async throw(error){
      writer.destroy(error);
      return finalIteration;
     },
    [Symbol.asyncIterator]() {
      return nodeWriter;
     }});

  return nodeWriter;
 };$h‍_once.makeNodeWriter(makeNodeWriter);
harden(makeNodeWriter);
})()
,
// === functors[176] ===
({   imports: $h‍_imports,   liveVar: $h‍_live,   onceVar: $h‍_once,   importMeta: $h‍____meta, }) => (function () {   $h‍_imports([["./reader.js", []],["./writer.js", []]]);   
})()
,
// === functors[177] ===
(function (require, exports, module, __filename, __dirname) { // Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var R = typeof Reflect === 'object' ? Reflect : null
var ReflectApply = R && typeof R.apply === 'function'
  ? R.apply
  : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
  }

var ReflectOwnKeys
if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target)
      .concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
}

function EventEmitter() {
  EventEmitter.init.call(this);
}
module.exports = EventEmitter;
module.exports.once = once;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

function checkListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }
    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function() {

  if (this._events === undefined ||
      this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }
  this._maxListeners = n;
  return this;
};

function _getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
  var doError = (type === 'error');

  var events = this._events;
  if (events !== undefined)
    doError = (doError && events.error === undefined);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];

  if (handler === undefined)
    return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  checkListener(listener);

  events = target._events;
  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type,
                  listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
        prepend ? [listener, existing] : [existing, listener];
      // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }

    // Check for listener leak
    m = _getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax
      var w = new Error('Possible EventEmitter memory leak detected. ' +
                          existing.length + ' ' + String(type) + ' listeners ' +
                          'added. Use emitter.setMaxListeners() to ' +
                          'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0)
      return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      checkListener(listener);

      events = this._events;
      if (events === undefined)
        return this;

      list = events[type];
      if (list === undefined)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener !== undefined)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (events === undefined)
        return this;

      // not listening for removeListener, no need to emit
      if (events.removeListener === undefined) {
        if (arguments.length === 0) {
          this._events = Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== undefined) {
          if (--this._eventsCount === 0)
            this._events = Object.create(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners !== undefined) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (events === undefined)
    return [];

  var evlistener = events[type];
  if (evlistener === undefined)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ?
    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++)
    list[index] = list[index + 1];
  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

function once(emitter, name) {
  return new Promise(function (resolve, reject) {
    function errorListener(err) {
      emitter.removeListener(name, resolver);
      reject(err);
    }

    function resolver() {
      if (typeof emitter.removeListener === 'function') {
        emitter.removeListener('error', errorListener);
      }
      resolve([].slice.call(arguments));
    };

    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
    if (name !== 'error') {
      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
    }
  });
}

function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
  if (typeof emitter.on === 'function') {
    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);
  }
}

function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
  if (typeof emitter.on === 'function') {
    if (flags.once) {
      emitter.once(name, listener);
    } else {
      emitter.on(name, listener);
    }
  } else if (typeof emitter.addEventListener === 'function') {
    // EventTarget does not have `error` event semantics like Node
    // EventEmitters, we do not listen for `error` events here.
    emitter.addEventListener(name, function wrapListener(arg) {
      // IE does not have builtin `{ once: true }` support so we
      // have to do it manually.
      if (flags.once) {
        emitter.removeEventListener(name, wrapListener);
      }
      listener(arg);
    });
  } else {
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
  }
}
 //*/
})
//# sourceURL=file:///home/xyz/Development/endo/node_modules/events/events.js
,
// === functors[178] ===
({   imports: $h‍_imports,   liveVar: $h‍_live,   onceVar: $h‍_once,   importMeta: $h‍____meta, }) => (function () {   let makeQueue;$h‍_imports([["@endo/stream", [["makeQueue", [$h‍_a => (makeQueue = $h‍_a)]]]]]);   

const asyncIterFromQueue=  async function*( queue) {
  while( true) {
    yield await queue.get();
   }
 };

const        makeWebWorkerWriter=  (workerContext)=>{
  let index=  0;
  /** @type {import('@endo/stream').Writer<Uint8Array>} */
  const webWorkerWriter=  harden({
    /** @param {Uint8Array} value */
          async next(value){
      // console.log('worker writer "next"', value, { isInWorker: typeof window === 'undefined' })
      index++;
      workerContext.postMessage({ index, type: 'next', value});
     },
          async return(value){
      // console.log('worker writer "return"', value, { isInWorker: typeof window === 'undefined' })
      index++;
      workerContext.postMessage({ index, type: 'return'});
     },
    /**
     * @param {Error} error
     */
          async throw(value){
      // console.log('worker writer "throw"', value, { isInWorker: typeof window === 'undefined' })
      index++;
      workerContext.postMessage({ index, type: 'throw', value});
     },
    [Symbol.asyncIterator]() {
      return webWorkerWriter;
     }});

  return webWorkerWriter;
 };$h‍_once.makeWebWorkerWriter(makeWebWorkerWriter);

const        makeWebWorkerReader=  (workerContext)=>{

  const queue=  makeQueue();
  // workerContext.addEventListener('message', event => {
  //   queue.put(event.data);
  // })
  // const iterator = asyncIterFromQueue(queue);

  const nextQueue=  makeQueue();
  const returnQueue=  makeQueue();
  const throwQueue=  makeQueue();
  workerContext.addEventListener('message', (event)=>{
    switch( event.data.type){
      case 'next':
        // console.log('worker reader "next"', event.data, { isInWorker: typeof window === 'undefined' })
        queue.put({ value: event.data.value, done: false});
        break;
      case 'return':
        // console.log('worker reader "return"', event.data, { isInWorker: typeof window === 'undefined' })
        queue.put({ value: undefined, done: true});
        break;
      case 'throw':
        // console.log('worker reader "throw"', event.data, { isInWorker: typeof window === 'undefined' })
        queue.put(Promise.reject(event.data.value));
        break;}

   });

  // Adapt the AsyncIterator to the more strict interface of a Stream: must
  // have return and throw methods.
  /** @type {import('@endo/stream').Reader<Buffer>} */
  const reader=  {
          async next(){
      // console.log('> webworker reader next requested', { isInWorker: typeof window === 'undefined' })
      const result=  await queue.get();
      // console.log('< webworker reader next requested', result, { isInWorker: typeof window === 'undefined' })
      return result;
     },
          async return(){
      // console.log('> webworker reader return requested', { isInWorker: typeof window === 'undefined' })
      debugger;
      // const result = await returnQueue.get();
      // console.log('< webworker reader return requested', { isInWorker: typeof window === 'undefined' })
      // return result
     },
          async throw(error){
      // console.log('> webworker reader throw requested', error, { isInWorker: typeof window === 'undefined' })
      // send error over to worker?
      // const result = await throwQueue.get();
      debugger;
      // console.log('< webworker reader throw requested', error, { isInWorker: typeof window === 'undefined' })
      // return result
     },
    [Symbol.asyncIterator]() {
      return reader;
     }};


  return reader;
 };$h‍_once.makeWebWorkerReader(makeWebWorkerReader);
})()
,
// === functors[179] ===
({   imports: $h‍_imports,   liveVar: $h‍_live,   onceVar: $h‍_once,   importMeta: $h‍____meta, }) => (function () {   let makePromiseKit,makePipe,makeNodeReader,makeNodeWriter,EventEmitter,makeWebWorkerReader,makeWebWorkerWriter;$h‍_imports([["@endo/promise-kit", [["makePromiseKit", [$h‍_a => (makePromiseKit = $h‍_a)]]]],["@endo/stream", [["makePipe", [$h‍_a => (makePipe = $h‍_a)]]]],["@endo/stream-node", [["makeNodeReader", [$h‍_a => (makeNodeReader = $h‍_a)]],["makeNodeWriter", [$h‍_a => (makeNodeWriter = $h‍_a)]]]],["events", [["default", [$h‍_a => (EventEmitter = $h‍_a)]]]],["./web-worker-util.js", [["makeWebWorkerReader", [$h‍_a => (makeWebWorkerReader = $h‍_a)]],["makeWebWorkerWriter", [$h‍_a => (makeWebWorkerWriter = $h‍_a)]]]]]);   









const textEncoder=  new TextEncoder();
const medialIterationResult=  harden({ done: false});
const finalIterationResult=  harden({ done: false});

/**
 * @param {object} modules
 * @param {typeof import('ws')} modules.ws
 * @param {typeof import('http')} modules.http
 */
const        makeHttpPowers=  ({ http, ws})=>   {
  // @ts-ignore Not sure why TypeScript gets this wrong.
  const { WebSocketServer}=   ws;
  const { createServer}=   http;

  /**
   * @param {object} args
   * @param {number} args.port
   * @param {string} args.host
   * @param {import('../types.js').HttpRespond} [args.respond]
   * @param {import('../types.js').HttpConnect} [args.connect]
   * @param {Promise<never>} args.cancelled
   */
  const servePortHttp=  async( {
    port,
    host=  '0.0.0.0',
    respond,
    connect,
    cancelled})=>
        {
    const server=  createServer();

    server.on('error', (error)=>{
      console.error(error);
     });

    if( respond) {
      server.on('request', (req, res)=>  {
        (async()=>   {
          if( req.method===  undefined) {
            return;
           }
          if( req.url===  undefined) {
            return;
           }
          const response=  await respond(
            harden({
              method: req.method,
              url: req.url,
              // TODO Node.js headers are a far more detailed type.
              headers: harden(
                /** @type {Record<string, string | Array<string> | undefined>} */
                  req.headers)}));




          res.writeHead(response.status, response.headers);
          if( response.content===  undefined) {
            res.end();
           }else if(
            typeof response.content===  'string'||
            response.content instanceof Uint8Array)
            {
            res.end(response.content);
           }else {
            for await( const chunk of response.content) {
              res.write(chunk);
             }
            res.end();
           }
         })();
       });
     }

    if( connect) {
      const wss=  new WebSocketServer({ server});
      wss.on('connection', (socket, req)=>  {
        const {
          promise: closed,
          resolve: close,
          reject: abort}=
            makePromiseKit();

        closed.finally(()=>  socket.close());

        const [reader, sink]=  makePipe();

        socket.on('message', (bytes, isBinary)=>  {
          if( !isBinary) {
            abort(new Error('expected binary'));
            return;
           }
          // TODO Ignoring back-pressure signal:
          // Unclear whether WebSocketServer accounts for this possibility.
          sink.next(bytes);
         });
        socket.on('close', ()=>  {
          sink.return(undefined);
          socket.close();
          close(finalIterationResult);
         });

        const writer=  {
                async next(bytes){
            socket.send(bytes, { binary: true});
            return Promise.race([closed, medialIterationResult]);
           },
                async return(){
            socket.close();
            return Promise.race([closed, medialIterationResult]);
           },
                async throw(error){
            socket.close();
            abort(error);
            return Promise.race([closed, medialIterationResult]);
           },
          [Symbol.asyncIterator]() {
            return this;
           }};


        connect(
          harden({
            reader,
            writer,
            closed: closed.then(()=>  { })}),

          harden({
            method: req.method,
            url: req.url,
            headers: req.headers}));


       });
     }

    return new Promise((resolve, reject)=>  {
      server.listen(port, host, (error)=>{
        if( error) {
          reject(error);
         }else {
          cancelled.catch(()=>  server.close());
          const address=  server.address();
          if( address===  null||  typeof address===  'string') {
            reject(new Error('expected listener to be assigned a port'));
           }else {
            resolve(address.port);
           }
         }
       });
     });
   };

  return harden({ servePortHttp});
 };

/**
 * @param {object} modules
 * @param {typeof import('crypto')} modules.crypto
 * @param {typeof import('net')} modules.net
 * @param {typeof import('fs')} modules.fs
 * @param {typeof import('path')} modules.path
 * @param {typeof import('child_process')} modules.popen
 * @param {typeof import('url')} modules.url
 * @param {typeof import('ws')} modules.ws
 * @param {typeof import('http')} modules.http
 * @param {Record<string, string | undefined>} modules.env
 * @param {(pid: number) => void} modules.kill
 * @returns {import('../types.js').DaemonicPowers}
 */$h‍_once.makeHttpPowers(makeHttpPowers);
const        makePowers=  ({
  crypto,
  net,
  fs,
  path: fspath,
  popen,
  url,
  http,
  ws,
  kill,
  env})=>
      {
  /** @param {Error} error */
  const sinkError=  (error)=>{
    console.error(error);
   };

  const makeSha512=  ()=>  {
    const digester=  crypto.createHash('sha512');
    return harden({
      update: (chunk)=>digester.update(chunk),
      updateText: (chunk)=>digester.update(textEncoder.encode(chunk)),
      digestHex: ()=>  digester.digest('hex')});

   };

  const randomHex512=  ()=>
    new Promise((resolve, reject)=>
      crypto.randomBytes(64, (err, bytes)=>  {
        if( err) {
          reject(err);
         }else {
          resolve(bytes.toString('hex'));
         }
       }));


  class FakeConnection extends EventEmitter {
                         [Symbol.asyncIterator](){
      return this;
     }
          return(){
      console.log('FakeConnection return');
      return Promise.resolve();
     }
         throw(error){
      console.log('FakeConnection throw', error);
      return Promise.reject(error);
     }
        next(){
      console.log('FakeConnection next');
      return Promise.resolve({ done: true});
     }
                          get readableObjectMode(){
      return false;
     }
                        get readableEncoding(){
      return null;
     }}


  class FakeServer extends EventEmitter {
          listen(path,handler){
      console.log('fake server listen', path);
      handler();
     }}


  const serveListener=  async( listen, cancelled)=>  {
    const [
      /** @type {Reader<import('./types.js').Connection>} */ readFrom,
      /** @type {Writer<import('./types.js').Connection>} */ writeTo]=
        makePipe();

    // const server = net.createServer();
    const server=  new FakeServer();
    globalThis.connect=  ()=>  {
      // const connection = new FakeConnection()
      // server.emit('connection', connection)
      // NOTE: pipe may not be what we want
      const [
        /** @type {Reader<Uint8Array, undefined>} */ leftReader,
        /** @type {Writer<Uint8Array, undefined>} */ rightWriter]=
          makePipe();
      const [
        /** @type {Reader<Uint8Array, undefined>} */ rightReader,
        /** @type {Writer<Uint8Array, undefined>} */ leftWriter]=
          makePipe();

      // const reader = makeNodeReader(conn);
      // const writer = makeNodeWriter(conn);
      // const closed = new Promise(resolve => conn.on('close', resolve));
      const closed=  new Promise(()=>  { });
      // TODO Respect back-pressure signal and avoid accepting new connections.
      void writeTo.next({ reader: rightReader, writer: rightWriter, closed});
      return {
        reader: leftReader,
        writer: leftWriter};

     };

    const { promise: erred, reject: err}=   makePromiseKit();
    server.on('error', (error)=>{
      err(error);
      void writeTo.throw(error);
     });
    server.on('close', ()=>  {
      void writeTo.return(undefined);
     });

    cancelled.catch((error)=>{
      // server.close();
      void writeTo.throw(error);
     });

    const listening=  listen(server);

    await Promise.race([erred, cancelled, listening]);

    // server.on('connection', conn => {
    //   const reader = makeNodeReader(conn);
    //   const writer = makeNodeWriter(conn);
    //   const closed = new Promise(resolve => conn.on('close', resolve));
    //   // TODO Respect back-pressure signal and avoid accepting new connections.
    //   void writeTo.next({ reader, writer, closed });
    // });

    console.info('serveListener');

    return readFrom;
   };

  const servePort=  async( { port, host=  '0.0.0.0', cancelled})=>
    serveListener(
      (server)=>
        new Promise((resolve)=>
          server.listen(port, host, ()=>  resolve(undefined))),

      cancelled);


  const servePath=  async( { path, cancelled})=>
    serveListener(
      (server)=>
        new Promise((resolve)=>
          server.listen({ path},  ()=>  resolve(undefined))),

      cancelled);


  const informParentWhenReady=  ()=>  {
    if( process.send) {
      process.send({ type: 'ready'});
     }
   };

  const reportErrorToParent=  (message)=>{
    if( process.send) {
      process.send({ type: 'error', message});
     }
   };

  /**
   * @param {string} path
   */
  const makeFileReader=  (path)=>{
    const nodeReadStream=  fs.createReadStream(path);
    return makeNodeReader(nodeReadStream);
   };

  /**
   * @param {string} path
   */
  const makeFileWriter=  (path)=>{
    const nodeWriteStream=  fs.createWriteStream(path);
    return makeNodeWriter(nodeWriteStream);
   };

  /**
   * @param {string} path
   * @param {string} text
   */
  const writeFileText=  async( path, text)=>  {
    await fs.promises.writeFile(path, text);
   };

  /**
   * @param {string} path
   */
  const readFileText=  async(path)=> {
    return fs.promises.readFile(path, 'utf-8');
   };

  /**
   * @param {string} path
   */
  const readDirectory=  async(path)=> {
    return fs.promises.readdir(path);
   };

  /**
   * @param {string} path
   */
  const makePath=  async(path)=> {
    await fs.promises.mkdir(path, { recursive: true});
   };

  /**
   * @param {string} path
   */
  const removePath=  async(path)=> {
    return fs.promises.rm(path);
   };

  const renamePath=  async( source, target)=>
    fs.promises.rename(source, target);

  const joinPath=  (...components)=>  fspath.join(...components);

  const delay=  async( ms, cancelled)=>  {
    // Do not attempt to set up a timer if already cancelled.
    await Promise.race([cancelled, undefined]);
    return new Promise((resolve, reject)=>  {
      const handle=  setTimeout(resolve, ms);
      cancelled.catch((error)=>{
        reject(error);
        clearTimeout(handle);
       });
     });
   };

  /**
   * @param {string} id
   * @param {string} path
   * @param {string} logPath
   * @param {string} pidPath
   * @param {string} sockPath
   * @param {string} statePath
   * @param {string} ephemeralStatePath
   * @param {string} cachePath
   * @param {Promise<never>} cancelled
   */
  const makeWorker=  async(
    id,
    path,
    logPath,
    pidPath,
    sockPath,
    statePath,
    ephemeralStatePath,
    cachePath,
    cancelled)=>
       {
    console.info('makeWorker', id, path, logPath, pidPath, sockPath, statePath, ephemeralStatePath, cachePath, cancelled);
    const myWorker=  new Worker('dist-worker-web-bundle.js');
    const workerReadyP=  new Promise((resolve)=>myWorker.addEventListener('message', resolve, { once: true}));

    const reader=  makeWebWorkerReader(myWorker);
    const writer=  makeWebWorkerWriter(myWorker);

    const workerClosed=  new Promise((resolve)=>{ });

    await workerReadyP;
    myWorker.postMessage({
      id,
      sockPath,
      statePath,
      ephemeralStatePath,
      cachePath});


    return {
      reader,
      writer,
      closed: workerClosed,
      pid: 123};


    // const log = fs.openSync(logPath, 'a');
    // const child = popen.fork(
    //   path,
    //   [id, sockPath, statePath, ephemeralStatePath, cachePath],
    //   {
    //     stdio: ['ignore', log, log, 'pipe', 'pipe', 'ipc'],
    //     // @ts-ignore Stale Node.js type definition.
    //     windowsHide: true,
    //   },
    // );
    // const nodeWriter = /** @type {import('stream').Writable} */ (
    //   child.stdio[3]
    // );
    // const nodeReader = /** @type {import('stream').Readable} */ (
    //   child.stdio[4]
    // );
    // assert(nodeWriter);
    // assert(nodeReader);
    // const reader = makeNodeReader(nodeReader);
    // const writer = makeNodeWriter(nodeWriter);

    // const closed = new Promise(resolve => {
    //   child.on('exit', () => resolve(undefined));
    // });

    // await writeFileText(pidPath, `${child.pid}\n`);

    // cancelled.catch(async () => {
    //   child.kill();
    // });

    // return { reader, writer, closed, pid: child.pid };
   };

  const { fileURLToPath}=   url;

  // const endoWorkerPath = fileURLToPath(
  //   new URL('worker-node.js', import.meta.url),
  // );
  const endoWorkerPath=  'FAKE_WORKER_PATH';

  return harden({
    kill: (pid)=>console.log('kill', pid),
    env: { ...env},
    sinkError,
    makeSha512,
    randomHex512,
    servePort,
    servePath,
    informParentWhenReady,
    reportErrorToParent,
    makeFileReader,
    makeFileWriter,
    writeFileText,
    readFileText,
    readDirectory,
    makePath,
    joinPath,
    removePath,
    renamePath,
    delay,
    makeWorker,
    endoWorkerPath,
    // fileURLToPath,

    // ...makeHttpPowers({ http, ws }),
    servePortHttp: async( opts)=>  {
      console.info('servePortHttp (for weblet)', opts);
      return 1;
     }});

 };$h‍_once.makePowers(makePowers);
})()
,
// === functors[180] ===
({   imports: $h‍_imports,   liveVar: $h‍_live,   onceVar: $h‍_once,   importMeta: $h‍____meta, }) => (function () {   let url,Buffer,configure,BFSRequire,makeDirectory,makePromiseKit,daemonMain,makePowers,makeNetstringCapTP,E,Far;$h‍_imports([["./environment.js", []],["ses", []],["@endo/promise-kit/shim.js", []],["@endo/lockdown/commit.js", []],["url", [["default", [$h‍_a => (url = $h‍_a)]]]],["buffer", [["Buffer", [$h‍_a => (Buffer = $h‍_a)]]]],["browserfs", [["configure", [$h‍_a => (configure = $h‍_a)]],["BFSRequire", [$h‍_a => (BFSRequire = $h‍_a)]]]],["make-dir", [["default", [$h‍_a => (makeDirectory = $h‍_a)]]]],["@endo/promise-kit", [["makePromiseKit", [$h‍_a => (makePromiseKit = $h‍_a)]]]],["../daemon.js", [["main", [$h‍_a => (daemonMain = $h‍_a)]]]],["./daemon-web-powers.js", [["makePowers", [$h‍_a => (makePowers = $h‍_a)]]]],["../connection.js", [["makeNetstringCapTP", [$h‍_a => (makeNetstringCapTP = $h‍_a)]]]],["@endo/far", [["E", [$h‍_a => (E = $h‍_a)]],["Far", [$h‍_a => (Far = $h‍_a)]]]]]);   


























// if (process.argv.length < 5) {
//   throw new Error(
//     `daemon.js requires arguments [sockPath] [statePath] [ephemeralStatePath] [cachePath], got ${process.argv.join(
//       ', ',
//     )}`,
//   );
// }

const sockPath=  'DAEMON/sock';
const statePath=  'DAEMON/state';
const ephemeralStatePath=  'DAEMON/ephemeralState';
const cachePath=  'DAEMON/cache';
// const [sockPath, statePath, ephemeralStatePath, cachePath] = []
  // process.argv.slice(2);

/** @type {import('../../index.js').Locator} */
const locator=  {
  sockPath,
  statePath,
  ephemeralStatePath,
  cachePath};


// const { env, kill } = process;
// const env = {};



// const { promise: cancelled, reject: cancel } =
//   /** @type {import('@endo/promise-kit').PromiseKit<never>} */ (
//     makePromiseKit()
//   );

process.once('SIGINT', ()=>  Promise.reject(new Error('SIGINT')));
process.exitCode=  1;

const cb2promise=  (obj, method)=>  (...args)=>
  new Promise((resolve, reject)=>  {
    obj[method](...args, (err, ...rest)=>  {
      if( err) {
        reject(err);
       }else {
        resolve(...rest);
       }
     });
   });

async function main()  {

  // shim fs
  await new Promise((cb)=>configure({ fs: 'LocalStorage'},  cb));
  const fs=  BFSRequire('fs');
  const path=  BFSRequire('path');
  fs.promises=  {
    readFile: cb2promise(fs, 'readFile'),
    writeFile: cb2promise(fs, 'writeFile'),
    readdir: cb2promise(fs, 'readdir'),
    mkdir: cb2promise(fs, 'mkdir'),
    rm: cb2promise(fs, 'rmdir'),
    rename: cb2promise(fs, 'rename')};

  // shim mkdir recursive: true
  const _mkDir=  fs.mkdir;
  fs.mkdir=  (path, options, cb)=>  {
    if( typeof options===  'function') {
      cb=  options;
      options=  undefined;
     }
    if( options&&  options.recursive) {
      makeDirectory(path, {
        fs,
        mode: options.mode}).
         then(()=>  cb(null), cb);
      return;
     }
    _mkDir.call(fs, path, options, cb);
   };

  // shim crypto
  const crypto=  {
    createHash( algorithm) {
      if( algorithm!==  'sha512') {
        throw new Error("Only 'sha512' is supported.");
       }

      let buffer=  new Uint8Array();

      return {
        update(data) {
          const textEncoder=  new TextEncoder();
          const newData=  typeof data===  'string'?  textEncoder.encode(data):  data;
          const combined=  new Uint8Array(buffer.length+  newData.length);
          combined.set(buffer);
          combined.set(newData, buffer.length);
          buffer=  combined;
          return this; // For chaining
         },
              async digest(encoding){
          const hash=  await globalThis.crypto.subtle.digest('SHA-512', buffer);
          if( encoding===  'hex') {
            return Array.from(new Uint8Array(hash)).
               map((byte)=>byte.toString(16).padStart(2, '0')).
               join('');
           }else {
            throw new Error("Only 'hex' encoding is supported.");
           }
         }};

     },
    randomBytes( size, cb) {
      const buffer=  Buffer.alloc(size);
      globalThis.crypto.getRandomValues(buffer);
      if( cb) {
        cb(null, buffer);
       }else {
        return buffer;
       }
     }};


  const cancel=  ()=>  { throw new Error('"cancel" stub called'); };
  const cancelled=  new Promise(()=>  { });

  const powers=  makePowers({
    crypto,
    // net,
    fs,
    path,
    // popen,
    url,
    // http,
    // ws,
    env: globalThis.process.env
    // kill,
});

  // this will happen after the daemon is ready
  setTimeout(async()=>   {
    console.log('ready');
    const { reader, writer}=  globalThis.connect();

    const { getBootstrap, closed}=   makeNetstringCapTP(
      'CAPTP FAKE NAME',
      writer,
      reader,
      cancelled
      // bootstrap, // optional
);
    const bootstrap=  getBootstrap();
    console.log('bootstrap', bootstrap);
    const host=  E(bootstrap).host();
    host.then((host)=>  console.log('host ready', host));

    console.log('x');
    const newGuest=  await E(host).provideGuest('guest-agent');
    console.log(newGuest);

    const powersP=  newGuest;

    // const importUrl = url.pathToFileURL(importPath);
    // const namespace = await import(importUrl);
    // const result = await namespace.main(powersP, ...args);

    // const main = async (powers, ...args) => {
    //   const patient = E(powers).request(
    //     'HOST',
    //     'a pet for analysis',
    //     'patient',
    //   );
    // };

    // await main(powersP, ...[]);

    // const inbox = await E(host).listMessages()
    // console.log({inbox})

//     const counterSource = `
// import { Far } from '@endo/far';

// export const make = () => {
//   let counter = 0;
//   return Far('Counter', {
//     incr() {
//       counter += 1;
//       return counter;
//     },
//   });
// };
// `
//     console.log('writing counter.js');
//     await fs.writeFile('counter.js', counterSource)
//     // endo make counter.js --name counter
//     console.log('> endo make counter.js --name counter');
//     const result = await E(host).importUnsafeAndEndow(
//       'NEW', // default
//       path.resolve('counter.js'),
//       'NONE', // default
//       'counter',
//     )
//     console.log('< endo make counter.js --name counter');

//     console.log(result);

    /**
     * @param {string | 'MAIN' | 'NEW'} workerName
     * @param {string} source
     * @param {Array<string>} codeNames
     * @param {Array<string>} petNames
     * @param {string} resultName
     */
    const result=  await E(host).evaluate(
      'NEW',
       `(15 + 6) * 2`,
      [],
      [],
      'result');

    console.log(result);

    globalThis.E=  E;
    globalThis.host=  host;

   },200);

  await daemonMain(powers, locator, process.pid, cancel, cancelled);
 }

main();
// .then(
//   () => {
//     process.exitCode = 0;
//   },
//   error => {
//     console.error(error);
//   },
// );
})()
,
]; // functors end

  const cell = (name, value = undefined) => {
    const observers = [];
    return Object.freeze({
      get: Object.freeze(() => {
        return value;
      }),
      set: Object.freeze((newValue) => {
        value = newValue;
        for (const observe of observers) {
          observe(value);
        }
      }),
      observe: Object.freeze((observe) => {
        observers.push(observe);
        observe(value);
      }),
      enumerable: true,
    });
  };

  const cells = [
    {
    },
    {
      globalThis: cell("globalThis"),
      Array: cell("Array"),
      Date: cell("Date"),
      FinalizationRegistry: cell("FinalizationRegistry"),
      Float32Array: cell("Float32Array"),
      JSON: cell("JSON"),
      Map: cell("Map"),
      Math: cell("Math"),
      Number: cell("Number"),
      Object: cell("Object"),
      Promise: cell("Promise"),
      Proxy: cell("Proxy"),
      Reflect: cell("Reflect"),
      FERAL_REG_EXP: cell("FERAL_REG_EXP"),
      Set: cell("Set"),
      String: cell("String"),
      Symbol: cell("Symbol"),
      WeakMap: cell("WeakMap"),
      WeakSet: cell("WeakSet"),
      FERAL_ERROR: cell("FERAL_ERROR"),
      RangeError: cell("RangeError"),
      ReferenceError: cell("ReferenceError"),
      SyntaxError: cell("SyntaxError"),
      TypeError: cell("TypeError"),
      assign: cell("assign"),
      create: cell("create"),
      defineProperties: cell("defineProperties"),
      entries: cell("entries"),
      freeze: cell("freeze"),
      getOwnPropertyDescriptor: cell("getOwnPropertyDescriptor"),
      getOwnPropertyDescriptors: cell("getOwnPropertyDescriptors"),
      getOwnPropertyNames: cell("getOwnPropertyNames"),
      getPrototypeOf: cell("getPrototypeOf"),
      is: cell("is"),
      isFrozen: cell("isFrozen"),
      isSealed: cell("isSealed"),
      isExtensible: cell("isExtensible"),
      keys: cell("keys"),
      objectPrototype: cell("objectPrototype"),
      seal: cell("seal"),
      preventExtensions: cell("preventExtensions"),
      setPrototypeOf: cell("setPrototypeOf"),
      values: cell("values"),
      fromEntries: cell("fromEntries"),
      speciesSymbol: cell("speciesSymbol"),
      toStringTagSymbol: cell("toStringTagSymbol"),
      iteratorSymbol: cell("iteratorSymbol"),
      matchAllSymbol: cell("matchAllSymbol"),
      unscopablesSymbol: cell("unscopablesSymbol"),
      symbolKeyFor: cell("symbolKeyFor"),
      symbolFor: cell("symbolFor"),
      isInteger: cell("isInteger"),
      stringifyJson: cell("stringifyJson"),
      defineProperty: cell("defineProperty"),
      apply: cell("apply"),
      construct: cell("construct"),
      reflectGet: cell("reflectGet"),
      reflectGetOwnPropertyDescriptor: cell("reflectGetOwnPropertyDescriptor"),
      reflectHas: cell("reflectHas"),
      reflectIsExtensible: cell("reflectIsExtensible"),
      ownKeys: cell("ownKeys"),
      reflectPreventExtensions: cell("reflectPreventExtensions"),
      reflectSet: cell("reflectSet"),
      isArray: cell("isArray"),
      arrayPrototype: cell("arrayPrototype"),
      mapPrototype: cell("mapPrototype"),
      proxyRevocable: cell("proxyRevocable"),
      regexpPrototype: cell("regexpPrototype"),
      setPrototype: cell("setPrototype"),
      stringPrototype: cell("stringPrototype"),
      weakmapPrototype: cell("weakmapPrototype"),
      weaksetPrototype: cell("weaksetPrototype"),
      functionPrototype: cell("functionPrototype"),
      promisePrototype: cell("promisePrototype"),
      typedArrayPrototype: cell("typedArrayPrototype"),
      uncurryThis: cell("uncurryThis"),
      objectHasOwnProperty: cell("objectHasOwnProperty"),
      arrayFilter: cell("arrayFilter"),
      arrayForEach: cell("arrayForEach"),
      arrayIncludes: cell("arrayIncludes"),
      arrayJoin: cell("arrayJoin"),
      arrayMap: cell("arrayMap"),
      arrayPop: cell("arrayPop"),
      arrayPush: cell("arrayPush"),
      arraySlice: cell("arraySlice"),
      arraySome: cell("arraySome"),
      arraySort: cell("arraySort"),
      iterateArray: cell("iterateArray"),
      mapSet: cell("mapSet"),
      mapGet: cell("mapGet"),
      mapHas: cell("mapHas"),
      mapDelete: cell("mapDelete"),
      mapEntries: cell("mapEntries"),
      iterateMap: cell("iterateMap"),
      setAdd: cell("setAdd"),
      setDelete: cell("setDelete"),
      setForEach: cell("setForEach"),
      setHas: cell("setHas"),
      iterateSet: cell("iterateSet"),
      regexpTest: cell("regexpTest"),
      regexpExec: cell("regexpExec"),
      matchAllRegExp: cell("matchAllRegExp"),
      stringEndsWith: cell("stringEndsWith"),
      stringIncludes: cell("stringIncludes"),
      stringIndexOf: cell("stringIndexOf"),
      stringMatch: cell("stringMatch"),
      stringReplace: cell("stringReplace"),
      stringSearch: cell("stringSearch"),
      stringSlice: cell("stringSlice"),
      stringSplit: cell("stringSplit"),
      stringStartsWith: cell("stringStartsWith"),
      iterateString: cell("iterateString"),
      weakmapDelete: cell("weakmapDelete"),
      weakmapGet: cell("weakmapGet"),
      weakmapHas: cell("weakmapHas"),
      weakmapSet: cell("weakmapSet"),
      weaksetAdd: cell("weaksetAdd"),
      weaksetHas: cell("weaksetHas"),
      functionToString: cell("functionToString"),
      promiseAll: cell("promiseAll"),
      promiseCatch: cell("promiseCatch"),
      promiseThen: cell("promiseThen"),
      finalizationRegistryRegister: cell("finalizationRegistryRegister"),
      finalizationRegistryUnregister: cell("finalizationRegistryUnregister"),
      getConstructorOf: cell("getConstructorOf"),
      immutableObject: cell("immutableObject"),
      isObject: cell("isObject"),
      isError: cell("isError"),
      FERAL_EVAL: cell("FERAL_EVAL"),
      FERAL_FUNCTION: cell("FERAL_FUNCTION"),
      noEvalEvaluate: cell("noEvalEvaluate"),
    },
    {
    },
    {
      makeEnvironmentCaptor: cell("makeEnvironmentCaptor"),
    },
    {
    },
    {
      an: cell("an"),
      bestEffortStringify: cell("bestEffortStringify"),
      enJoin: cell("enJoin"),
    },
    {
    },
    {
    },
    {
      makeLRUCacheMap: cell("makeLRUCacheMap"),
      makeNoteLogArgsArrayKit: cell("makeNoteLogArgsArrayKit"),
    },
    {
      unredactedDetails: cell("unredactedDetails"),
      loggedErrorHandler: cell("loggedErrorHandler"),
      makeAssert: cell("makeAssert"),
      assert: cell("assert"),
    },
    {
      isTypedArray: cell("isTypedArray"),
      makeHardener: cell("makeHardener"),
    },
    {
      constantProperties: cell("constantProperties"),
      universalPropertyNames: cell("universalPropertyNames"),
      initialGlobalPropertyNames: cell("initialGlobalPropertyNames"),
      sharedGlobalPropertyNames: cell("sharedGlobalPropertyNames"),
      uniqueGlobalPropertyNames: cell("uniqueGlobalPropertyNames"),
      NativeErrors: cell("NativeErrors"),
      FunctionInstance: cell("FunctionInstance"),
      AsyncFunctionInstance: cell("AsyncFunctionInstance"),
      isAccessorPermit: cell("isAccessorPermit"),
      permitted: cell("permitted"),
    },
    {
      makeIntrinsicsCollector: cell("makeIntrinsicsCollector"),
      getGlobalIntrinsics: cell("getGlobalIntrinsics"),
    },
    {
      default: cell("default"),
    },
    {
      default: cell("default"),
    },
    {
      default: cell("default"),
    },
    {
      default: cell("default"),
    },
    {
      default: cell("default"),
    },
    {
      minEnablements: cell("minEnablements"),
      moderateEnablements: cell("moderateEnablements"),
      severeEnablements: cell("severeEnablements"),
    },
    {
      default: cell("default"),
    },
    {
      default: cell("default"),
    },
    {
      makeEvalFunction: cell("makeEvalFunction"),
    },
    {
      makeFunctionConstructor: cell("makeFunctionConstructor"),
    },
    {
      setGlobalObjectSymbolUnscopables: cell("setGlobalObjectSymbolUnscopables"),
      setGlobalObjectConstantProperties: cell("setGlobalObjectConstantProperties"),
      setGlobalObjectMutableProperties: cell("setGlobalObjectMutableProperties"),
      setGlobalObjectEvaluators: cell("setGlobalObjectEvaluators"),
    },
    {
      alwaysThrowHandler: cell("alwaysThrowHandler"),
      strictScopeTerminatorHandler: cell("strictScopeTerminatorHandler"),
      strictScopeTerminator: cell("strictScopeTerminator"),
    },
    {
      createSloppyGlobalsScopeTerminator: cell("createSloppyGlobalsScopeTerminator"),
    },
    {
      makeEvalScopeKit: cell("makeEvalScopeKit"),
    },
    {
      getSourceURL: cell("getSourceURL"),
    },
    {
      rejectHtmlComments: cell("rejectHtmlComments"),
      evadeHtmlCommentTest: cell("evadeHtmlCommentTest"),
      rejectImportExpressions: cell("rejectImportExpressions"),
      evadeImportExpressionTest: cell("evadeImportExpressionTest"),
      rejectSomeDirectEvalExpressions: cell("rejectSomeDirectEvalExpressions"),
      mandatoryTransforms: cell("mandatoryTransforms"),
      applyTransforms: cell("applyTransforms"),
      transforms: cell("transforms"),
    },
    {
      isValidIdentifierName: cell("isValidIdentifierName"),
      getScopeConstants: cell("getScopeConstants"),
    },
    {
      makeEvaluate: cell("makeEvaluate"),
    },
    {
      makeSafeEvaluator: cell("makeSafeEvaluator"),
    },
    {
      tameFunctionToString: cell("tameFunctionToString"),
    },
    {
      tameDomains: cell("tameDomains"),
    },
    {
      makeLoggingConsoleKit: cell("makeLoggingConsoleKit"),
      makeCausalConsole: cell("makeCausalConsole"),
      filterConsole: cell("filterConsole"),
      consoleWhitelist: cell("consoleWhitelist"),
    },
    {
      makeRejectionHandlers: cell("makeRejectionHandlers"),
    },
    {
      tameConsole: cell("tameConsole"),
    },
    {
      filterFileName: cell("filterFileName"),
      shortenCallSiteString: cell("shortenCallSiteString"),
      tameV8ErrorConstructor: cell("tameV8ErrorConstructor"),
    },
    {
      default: cell("default"),
    },
    {
      makeAlias: cell("makeAlias"),
      load: cell("load"),
    },
    {
      deferExports: cell("deferExports"),
      getDeferredExports: cell("getDeferredExports"),
    },
    {
      provideCompartmentEvaluator: cell("provideCompartmentEvaluator"),
      compartmentEvaluate: cell("compartmentEvaluate"),
    },
    {
      makeThirdPartyModuleInstance: cell("makeThirdPartyModuleInstance"),
      makeModuleInstance: cell("makeModuleInstance"),
    },
    {
      link: cell("link"),
      instantiate: cell("instantiate"),
    },
    {
      InertCompartment: cell("InertCompartment"),
      CompartmentPrototype: cell("CompartmentPrototype"),
      makeCompartmentConstructor: cell("makeCompartmentConstructor"),
    },
    {
      getAnonymousIntrinsics: cell("getAnonymousIntrinsics"),
    },
    {
      tameHarden: cell("tameHarden"),
    },
    {
      tameSymbolConstructor: cell("tameSymbolConstructor"),
    },
    {
      repairIntrinsics: cell("repairIntrinsics"),
    },
    {
    },
    {
    },
    {
    },
    {
    },
    {
      memoRace: cell("memoRace"),
    },
    {
    },
    {
      default: cell("default"),
    },
    {
      lockdown: cell("lockdown"),
    },
    {
    },
    {
      default: cell("default", {}),
    },
    {
      default: cell("default", {}),
    },
    {
      default: cell("default", {}),
    },
    {
      default: cell("default", {}),
    },
    {
      default: cell("default", {}),
    },
    {
      default: cell("default", {}),
    },
    {
      default: cell("default", {}),
    },
    {
      default: cell("default", {}),
      apply: cell("apply"),
    },
    {
      default: cell("default", {}),
    },
    {
      default: cell("default", {}),
    },
    {
      default: cell("default", {}),
    },
    {
      default: cell("default", {}),
    },
    {
      default: cell("default", {}),
    },
    {
      default: cell("default", {}),
    },
    {
      default: cell("default", {}),
    },
    {
      default: cell("default", {}),
    },
    {
      default: cell("default", {}),
    },
    {
      default: cell("default", {}),
    },
    {
      isArgumentsObject: cell("isArgumentsObject"),
      isGeneratorFunction: cell("isGeneratorFunction"),
      isTypedArray: cell("isTypedArray"),
      isPromise: cell("isPromise"),
      isArrayBufferView: cell("isArrayBufferView"),
      isUint8Array: cell("isUint8Array"),
      isUint8ClampedArray: cell("isUint8ClampedArray"),
      isUint16Array: cell("isUint16Array"),
      isUint32Array: cell("isUint32Array"),
      isInt8Array: cell("isInt8Array"),
      isInt16Array: cell("isInt16Array"),
      isInt32Array: cell("isInt32Array"),
      isFloat32Array: cell("isFloat32Array"),
      isFloat64Array: cell("isFloat64Array"),
      isBigInt64Array: cell("isBigInt64Array"),
      isBigUint64Array: cell("isBigUint64Array"),
      isMap: cell("isMap"),
      isSet: cell("isSet"),
      isWeakMap: cell("isWeakMap"),
      isWeakSet: cell("isWeakSet"),
      isArrayBuffer: cell("isArrayBuffer"),
      isDataView: cell("isDataView"),
      isSharedArrayBuffer: cell("isSharedArrayBuffer"),
      isAsyncFunction: cell("isAsyncFunction"),
      isMapIterator: cell("isMapIterator"),
      isSetIterator: cell("isSetIterator"),
      isGeneratorObject: cell("isGeneratorObject"),
      isWebAssemblyCompiledModule: cell("isWebAssemblyCompiledModule"),
      isNumberObject: cell("isNumberObject"),
      isStringObject: cell("isStringObject"),
      isBooleanObject: cell("isBooleanObject"),
      isBigIntObject: cell("isBigIntObject"),
      isSymbolObject: cell("isSymbolObject"),
      isBoxedPrimitive: cell("isBoxedPrimitive"),
      isAnyArrayBuffer: cell("isAnyArrayBuffer"),
      default: cell("default", {}),
    },
    {
      default: cell("default", {}),
    },
    {
      default: cell("default", {}),
    },
    {
      default: cell("default", {}),
    },
    {
      format: cell("format"),
      deprecate: cell("deprecate"),
      debuglog: cell("debuglog"),
      inspect: cell("inspect"),
      types: cell("types"),
      isArray: cell("isArray"),
      isBoolean: cell("isBoolean"),
      isNull: cell("isNull"),
      isNullOrUndefined: cell("isNullOrUndefined"),
      isNumber: cell("isNumber"),
      isString: cell("isString"),
      isSymbol: cell("isSymbol"),
      isUndefined: cell("isUndefined"),
      isRegExp: cell("isRegExp"),
      isObject: cell("isObject"),
      isDate: cell("isDate"),
      isError: cell("isError"),
      isFunction: cell("isFunction"),
      isPrimitive: cell("isPrimitive"),
      isBuffer: cell("isBuffer"),
      log: cell("log"),
      inherits: cell("inherits"),
      _extend: cell("_extend"),
      promisify: cell("promisify"),
      callbackify: cell("callbackify"),
      default: cell("default", {}),
    },
    {
      default: cell("default", {}),
    },
    {
      default: cell("default", {}),
    },
    {
      default: cell("default", {}),
    },
    {
      default: cell("default", {}),
    },
    {
      arrayToObject: cell("arrayToObject"),
      assign: cell("assign"),
      combine: cell("combine"),
      compact: cell("compact"),
      decode: cell("decode"),
      encode: cell("encode"),
      isBuffer: cell("isBuffer"),
      isRegExp: cell("isRegExp"),
      maybeMap: cell("maybeMap"),
      merge: cell("merge"),
      default: cell("default", {}),
    },
    {
      default: cell("default", {}),
    },
    {
      default: cell("default", {}),
    },
    {
      formats: cell("formats"),
      parse: cell("parse"),
      stringify: cell("stringify"),
      default: cell("default", {}),
    },
    {
      parse: cell("parse"),
      resolve: cell("resolve"),
      resolveObject: cell("resolveObject"),
      format: cell("format"),
      Url: cell("Url"),
      default: cell("default", {}),
    },
    {
      byteLength: cell("byteLength"),
      toByteArray: cell("toByteArray"),
      fromByteArray: cell("fromByteArray"),
      default: cell("default", {}),
    },
    {
      read: cell("read"),
      write: cell("write"),
      default: cell("default", {}),
    },
    {
      Buffer: cell("Buffer"),
      SlowBuffer: cell("SlowBuffer"),
      INSPECT_MAX_BYTES: cell("INSPECT_MAX_BYTES"),
      kMaxLength: cell("kMaxLength"),
      default: cell("default", {}),
    },
    {
      default: cell("default", {}),
      BrowserFS: cell("BrowserFS"),
      isArray: cell("isArray"),
      isBoolean: cell("isBoolean"),
      isNull: cell("isNull"),
      isNullOrUndefined: cell("isNullOrUndefined"),
      isNumber: cell("isNumber"),
      isString: cell("isString"),
      isSymbol: cell("isSymbol"),
      isUndefined: cell("isUndefined"),
      isRegExp: cell("isRegExp"),
      isObject: cell("isObject"),
      isDate: cell("isDate"),
      isError: cell("isError"),
      isFunction: cell("isFunction"),
      isPrimitive: cell("isPrimitive"),
      isBuffer: cell("isBuffer"),
      Buffer: cell("Buffer"),
      SlowBuffer: cell("SlowBuffer"),
      INSPECT_MAX_BYTES: cell("INSPECT_MAX_BYTES"),
      kMaxLength: cell("kMaxLength"),
      assign: cell("assign"),
      shrinkBuf: cell("shrinkBuf"),
      setTyped: cell("setTyped"),
      Buf8: cell("Buf8"),
      Buf16: cell("Buf16"),
      Buf32: cell("Buf32"),
      Stream: cell("Stream"),
      Readable: cell("Readable"),
      Writable: cell("Writable"),
      Duplex: cell("Duplex"),
      Transform: cell("Transform"),
      PassThrough: cell("PassThrough"),
      destroy: cell("destroy"),
      undestroy: cell("undestroy"),
      StringDecoder: cell("StringDecoder"),
      __esModule: cell("__esModule"),
      install: cell("install"),
      registerFileSystem: cell("registerFileSystem"),
      BFSRequire: cell("BFSRequire"),
      initialize: cell("initialize"),
      configure: cell("configure"),
      getFileSystem: cell("getFileSystem"),
      EmscriptenFS: cell("EmscriptenFS"),
      FileSystem: cell("FileSystem"),
      Errors: cell("Errors"),
      setImmediate: cell("setImmediate"),
      byteLength: cell("byteLength"),
      toByteArray: cell("toByteArray"),
      fromByteArray: cell("fromByteArray"),
      read: cell("read"),
      write: cell("write"),
      Inflate: cell("Inflate"),
      inflate: cell("inflate"),
      inflateRaw: cell("inflateRaw"),
      ungzip: cell("ungzip"),
      inflateReset: cell("inflateReset"),
      inflateReset2: cell("inflateReset2"),
      inflateResetKeep: cell("inflateResetKeep"),
      inflateInit: cell("inflateInit"),
      inflateInit2: cell("inflateInit2"),
      inflateEnd: cell("inflateEnd"),
      inflateGetHeader: cell("inflateGetHeader"),
      inflateSetDictionary: cell("inflateSetDictionary"),
      inflateInfo: cell("inflateInfo"),
      string2buf: cell("string2buf"),
      buf2binstring: cell("buf2binstring"),
      binstring2buf: cell("binstring2buf"),
      buf2string: cell("buf2string"),
      utf8border: cell("utf8border"),
    },
    {
      default: cell("default", {}),
    },
    {
      default: cell("default", {}),
    },
    {
      MAX_LENGTH: cell("MAX_LENGTH"),
      MAX_SAFE_COMPONENT_LENGTH: cell("MAX_SAFE_COMPONENT_LENGTH"),
      MAX_SAFE_BUILD_LENGTH: cell("MAX_SAFE_BUILD_LENGTH"),
      MAX_SAFE_INTEGER: cell("MAX_SAFE_INTEGER"),
      RELEASE_TYPES: cell("RELEASE_TYPES"),
      SEMVER_SPEC_VERSION: cell("SEMVER_SPEC_VERSION"),
      default: cell("default", {}),
    },
    {
      re: cell("re"),
      safeRe: cell("safeRe"),
      src: cell("src"),
      t: cell("t"),
      tildeTrimReplace: cell("tildeTrimReplace"),
      caretTrimReplace: cell("caretTrimReplace"),
      comparatorTrimReplace: cell("comparatorTrimReplace"),
      default: cell("default", {}),
    },
    {
      default: cell("default", {}),
    },
    {
      compareIdentifiers: cell("compareIdentifiers"),
      rcompareIdentifiers: cell("rcompareIdentifiers"),
      default: cell("default", {}),
    },
    {
      default: cell("default", {}),
    },
    {
      default: cell("default", {}),
    },
    {
      default: cell("default", {}),
    },
    {
      default: cell("default", {}),
      sync: cell("sync"),
    },
    {
      makeReleasingExecutorKit: cell("makeReleasingExecutorKit"),
    },
    {
      isPromise: cell("isPromise"),
    },
    {
    },
    {
      makePromiseKit: cell("makePromiseKit"),
      racePromises: cell("racePromises"),
    },
    {
      trackTurns: cell("trackTurns"),
    },
    {
      getMethodNames: cell("getMethodNames"),
      localApplyFunction: cell("localApplyFunction"),
      localApplyMethod: cell("localApplyMethod"),
      localGet: cell("localGet"),
    },
    {
      makePostponedHandler: cell("makePostponedHandler"),
    },
    {
      makeHandledPromise: cell("makeHandledPromise"),
    },
    {
    },
    {
      default: cell("default"),
    },
    {
    },
    {
      HandledPromise: cell("HandledPromise"),
      E: cell("E"),
    },
    {
      hasOwnPropertyOf: cell("hasOwnPropertyOf"),
      isObject: cell("isObject"),
      isTypedArray: cell("isTypedArray"),
      PASS_STYLE: cell("PASS_STYLE"),
      canBeMethod: cell("canBeMethod"),
      assertChecker: cell("assertChecker"),
      checkNormalProperty: cell("checkNormalProperty"),
      getTag: cell("getTag"),
      checkPassStyle: cell("checkPassStyle"),
      checkTagRecord: cell("checkTagRecord"),
      checkFunctionTagRecord: cell("checkFunctionTagRecord"),
    },
    {
      assertIface: cell("assertIface"),
      getInterfaceOf: cell("getInterfaceOf"),
      RemotableHelper: cell("RemotableHelper"),
    },
    {
      Remotable: cell("Remotable"),
      Far: cell("Far"),
      ToFarFunction: cell("ToFarFunction"),
    },
    {
      mapIterable: cell("mapIterable"),
      filterIterable: cell("filterIterable"),
    },
    {
      getErrorConstructor: cell("getErrorConstructor"),
      isErrorLike: cell("isErrorLike"),
      ErrorHelper: cell("ErrorHelper"),
      toPassableError: cell("toPassableError"),
    },
    {
      isPassableSymbol: cell("isPassableSymbol"),
      assertPassableSymbol: cell("assertPassableSymbol"),
      nameForPassableSymbol: cell("nameForPassableSymbol"),
      passableSymbolForName: cell("passableSymbolForName"),
    },
    {
      CopyArrayHelper: cell("CopyArrayHelper"),
    },
    {
      CopyRecordHelper: cell("CopyRecordHelper"),
    },
    {
      TaggedHelper: cell("TaggedHelper"),
    },
    {
      isSafePromise: cell("isSafePromise"),
      assertSafePromise: cell("assertSafePromise"),
    },
    {
      passStyleOf: cell("passStyleOf"),
      assertPassable: cell("assertPassable"),
    },
    {
      makeTagged: cell("makeTagged"),
    },
    {
      isCopyArray: cell("isCopyArray"),
      isRecord: cell("isRecord"),
      isRemotable: cell("isRemotable"),
      assertCopyArray: cell("assertCopyArray"),
      assertRecord: cell("assertRecord"),
      assertRemotable: cell("assertRemotable"),
    },
    {
    },
    {
      mapIterable: cell("mapIterable"),
      filterIterable: cell("filterIterable"),
      PASS_STYLE: cell("PASS_STYLE"),
      isObject: cell("isObject"),
      assertChecker: cell("assertChecker"),
      getTag: cell("getTag"),
      hasOwnPropertyOf: cell("hasOwnPropertyOf"),
      getErrorConstructor: cell("getErrorConstructor"),
      toPassableError: cell("toPassableError"),
      isErrorLike: cell("isErrorLike"),
      getInterfaceOf: cell("getInterfaceOf"),
      assertPassableSymbol: cell("assertPassableSymbol"),
      isPassableSymbol: cell("isPassableSymbol"),
      nameForPassableSymbol: cell("nameForPassableSymbol"),
      passableSymbolForName: cell("passableSymbolForName"),
      passStyleOf: cell("passStyleOf"),
      assertPassable: cell("assertPassable"),
      makeTagged: cell("makeTagged"),
      Remotable: cell("Remotable"),
      Far: cell("Far"),
      ToFarFunction: cell("ToFarFunction"),
      assertRecord: cell("assertRecord"),
      assertCopyArray: cell("assertCopyArray"),
      assertRemotable: cell("assertRemotable"),
      isRemotable: cell("isRemotable"),
      isRecord: cell("isRecord"),
      isCopyArray: cell("isCopyArray"),
    },
    {
      E: cell("E"),
      Far: cell("Far"),
      getInterfaceOf: cell("getInterfaceOf"),
      passStyleOf: cell("passStyleOf"),
    },
    {
      isNat: cell("isNat"),
      Nat: cell("Nat"),
    },
    {
      deeplyFulfilled: cell("deeplyFulfilled"),
    },
    {
      QCLASS: cell("QCLASS"),
      makeEncodeToCapData: cell("makeEncodeToCapData"),
      makeDecodeFromCapData: cell("makeDecodeFromCapData"),
    },
    {
      makeEncodeToSmallcaps: cell("makeEncodeToSmallcaps"),
      makeDecodeFromSmallcaps: cell("makeDecodeFromSmallcaps"),
    },
    {
      makeMarshal: cell("makeMarshal"),
    },
    {
      stringify: cell("stringify"),
      parse: cell("parse"),
    },
    {
      decodeToJustin: cell("decodeToJustin"),
    },
    {
      recordNames: cell("recordNames"),
      recordValues: cell("recordValues"),
      zeroPad: cell("zeroPad"),
      makeEncodePassable: cell("makeEncodePassable"),
      makeDecodePassable: cell("makeDecodePassable"),
      isEncodedRemotable: cell("isEncodedRemotable"),
      passStylePrefixes: cell("passStylePrefixes"),
    },
    {
      trivialComparator: cell("trivialComparator"),
      getPassStyleCover: cell("getPassStyleCover"),
      makeComparatorKit: cell("makeComparatorKit"),
      comparatorMirrorImage: cell("comparatorMirrorImage"),
      isRankSorted: cell("isRankSorted"),
      assertRankSorted: cell("assertRankSorted"),
      sortByRank: cell("sortByRank"),
      getIndexCover: cell("getIndexCover"),
      FullRankCover: cell("FullRankCover"),
      coveredEntries: cell("coveredEntries"),
      unionRankCovers: cell("unionRankCovers"),
      intersectRankCovers: cell("intersectRankCovers"),
      compareRank: cell("compareRank"),
      compareAntiRank: cell("compareAntiRank"),
      makeFullOrderComparatorKit: cell("makeFullOrderComparatorKit"),
    },
    {
    },
    {
      deeplyFulfilled: cell("deeplyFulfilled"),
      QCLASS: cell("QCLASS"),
      makeMarshal: cell("makeMarshal"),
      stringify: cell("stringify"),
      parse: cell("parse"),
      decodeToJustin: cell("decodeToJustin"),
      makeEncodePassable: cell("makeEncodePassable"),
      makeDecodePassable: cell("makeDecodePassable"),
      isEncodedRemotable: cell("isEncodedRemotable"),
      zeroPad: cell("zeroPad"),
      recordNames: cell("recordNames"),
      recordValues: cell("recordValues"),
      trivialComparator: cell("trivialComparator"),
      assertRankSorted: cell("assertRankSorted"),
      compareRank: cell("compareRank"),
      isRankSorted: cell("isRankSorted"),
      sortByRank: cell("sortByRank"),
      compareAntiRank: cell("compareAntiRank"),
      makeFullOrderComparatorKit: cell("makeFullOrderComparatorKit"),
      getPassStyleCover: cell("getPassStyleCover"),
      intersectRankCovers: cell("intersectRankCovers"),
      unionRankCovers: cell("unionRankCovers"),
    },
    {
    },
    {
      nearTrapImpl: cell("nearTrapImpl"),
      makeTrap: cell("makeTrap"),
    },
    {
      makeFinalizingMap: cell("makeFinalizingMap"),
    },
    {
      makeCapTP: cell("makeCapTP"),
      E: cell("E"),
    },
    {
      makeLoopback: cell("makeLoopback"),
      E: cell("E"),
    },
    {
      MIN_DATA_BUFFER_LENGTH: cell("MIN_DATA_BUFFER_LENGTH"),
      TRANSFER_OVERHEAD_LENGTH: cell("TRANSFER_OVERHEAD_LENGTH"),
      MIN_TRANSFER_BUFFER_LENGTH: cell("MIN_TRANSFER_BUFFER_LENGTH"),
      makeAtomicsTrapHost: cell("makeAtomicsTrapHost"),
      makeAtomicsTrapGuest: cell("makeAtomicsTrapGuest"),
    },
    {
      Nat: cell("Nat"),
      makeLoopback: cell("makeLoopback"),
    },
    {
      makeQueue: cell("makeQueue"),
      makeStream: cell("makeStream"),
      makePipe: cell("makePipe"),
      pump: cell("pump"),
      prime: cell("prime"),
      mapReader: cell("mapReader"),
      mapWriter: cell("mapWriter"),
    },
    {
      makeNetstringReader: cell("makeNetstringReader"),
      netstringReader: cell("netstringReader"),
    },
    {
      makeNetstringWriter: cell("makeNetstringWriter"),
      netstringWriter: cell("netstringWriter"),
    },
    {
      makeNetstringReader: cell("makeNetstringReader"),
      netstringReader: cell("netstringReader"),
      makeNetstringWriter: cell("makeNetstringWriter"),
      netstringWriter: cell("netstringWriter"),
    },
    {
      makeMessageCapTP: cell("makeMessageCapTP"),
      messageToBytes: cell("messageToBytes"),
      bytesToMessage: cell("bytesToMessage"),
      makeNetstringCapTP: cell("makeNetstringCapTP"),
    },
    {
      padding: cell("padding"),
      alphabet64: cell("alphabet64"),
      monodu64: cell("monodu64"),
    },
    {
      encodeBase64: cell("encodeBase64"),
    },
    {
      decodeBase64: cell("decodeBase64"),
    },
    {
      encodeBase64: cell("encodeBase64"),
    },
    {
      btoa: cell("btoa"),
    },
    {
      decodeBase64: cell("decodeBase64"),
    },
    {
      atob: cell("atob"),
    },
    {
      encodeBase64: cell("encodeBase64"),
      decodeBase64: cell("decodeBase64"),
      btoa: cell("btoa"),
      atob: cell("atob"),
    },
    {
      makeRefIterator: cell("makeRefIterator"),
      makeRefReader: cell("makeRefReader"),
    },
    {
      asyncIterate: cell("asyncIterate"),
      makeIteratorRef: cell("makeIteratorRef"),
      makeReaderRef: cell("makeReaderRef"),
    },
    {
      assertPetName: cell("assertPetName"),
    },
    {
      makeNullQueue: cell("makeNullQueue"),
      nullIteratorQueue: cell("nullIteratorQueue"),
      makeChangePubSub: cell("makeChangePubSub"),
      makeChangeTopic: cell("makeChangeTopic"),
    },
    {
      makeIdentifiedPetStore: cell("makeIdentifiedPetStore"),
      makeOwnPetStore: cell("makeOwnPetStore"),
    },
    {
      makeMailboxMaker: cell("makeMailboxMaker"),
    },
    {
      makeGuestMaker: cell("makeGuestMaker"),
    },
    {
      makeHostMaker: cell("makeHostMaker"),
    },
    {
      servePrivatePortHttp: cell("servePrivatePortHttp"),
    },
    {
      servePrivatePath: cell("servePrivatePath"),
    },
    {
      main: cell("main"),
    },
    {
      makeNodeReader: cell("makeNodeReader"),
    },
    {
      makeNodeWriter: cell("makeNodeWriter"),
    },
    {
      makeNodeReader: cell("makeNodeReader"),
      makeNodeWriter: cell("makeNodeWriter"),
    },
    {
      default: cell("default", {}),
      once: cell("once"),
    },
    {
      makeWebWorkerWriter: cell("makeWebWorkerWriter"),
      makeWebWorkerReader: cell("makeWebWorkerReader"),
    },
    {
      makeHttpPowers: cell("makeHttpPowers"),
      makePowers: cell("makePowers"),
    },
    {
    },
  ];

  Object.defineProperties(cells[4], Object.getOwnPropertyDescriptors(cells[3]));
  Object.defineProperties(cells[56], Object.getOwnPropertyDescriptors(cells[52]));
  Object.defineProperties(cells[57], Object.getOwnPropertyDescriptors(cells[56]));
  Object.defineProperties(cells[107], Object.getOwnPropertyDescriptors(cells[105]));
  Object.defineProperties(cells[107], Object.getOwnPropertyDescriptors(cells[106]));
  Object.defineProperties(cells[115], Object.getOwnPropertyDescriptors(cells[114]));
  Object.defineProperties(cells[130], Object.getOwnPropertyDescriptors(cells[129]));

  Object.defineProperties(cells[130], {"mapIterable": { value: cells[119]["mapIterable"] },"filterIterable": { value: cells[119]["filterIterable"] },"PASS_STYLE": { value: cells[116]["PASS_STYLE"] },"isObject": { value: cells[116]["isObject"] },"assertChecker": { value: cells[116]["assertChecker"] },"getTag": { value: cells[116]["getTag"] },"hasOwnPropertyOf": { value: cells[116]["hasOwnPropertyOf"] },"getErrorConstructor": { value: cells[120]["getErrorConstructor"] },"toPassableError": { value: cells[120]["toPassableError"] },"isErrorLike": { value: cells[120]["isErrorLike"] },"getInterfaceOf": { value: cells[117]["getInterfaceOf"] },"assertPassableSymbol": { value: cells[121]["assertPassableSymbol"] },"isPassableSymbol": { value: cells[121]["isPassableSymbol"] },"nameForPassableSymbol": { value: cells[121]["nameForPassableSymbol"] },"passableSymbolForName": { value: cells[121]["passableSymbolForName"] },"passStyleOf": { value: cells[126]["passStyleOf"] },"assertPassable": { value: cells[126]["assertPassable"] },"makeTagged": { value: cells[127]["makeTagged"] },"Remotable": { value: cells[118]["Remotable"] },"Far": { value: cells[118]["Far"] },"ToFarFunction": { value: cells[118]["ToFarFunction"] },"assertRecord": { value: cells[128]["assertRecord"] },"assertCopyArray": { value: cells[128]["assertCopyArray"] },"assertRemotable": { value: cells[128]["assertRemotable"] },"isRemotable": { value: cells[128]["isRemotable"] },"isRecord": { value: cells[128]["isRecord"] },"isCopyArray": { value: cells[128]["isCopyArray"] } });

  Object.defineProperties(cells[131], {"E": { value: cells[115]["E"] },"Far": { value: cells[130]["Far"] },"getInterfaceOf": { value: cells[130]["getInterfaceOf"] },"passStyleOf": { value: cells[130]["passStyleOf"] } });
  Object.defineProperties(cells[142], Object.getOwnPropertyDescriptors(cells[141]));
  Object.defineProperties(cells[142], Object.getOwnPropertyDescriptors(cells[130]));

  Object.defineProperties(cells[142], {"deeplyFulfilled": { value: cells[133]["deeplyFulfilled"] },"QCLASS": { value: cells[134]["QCLASS"] },"makeMarshal": { value: cells[136]["makeMarshal"] },"stringify": { value: cells[137]["stringify"] },"parse": { value: cells[137]["parse"] },"decodeToJustin": { value: cells[138]["decodeToJustin"] },"makeEncodePassable": { value: cells[139]["makeEncodePassable"] },"makeDecodePassable": { value: cells[139]["makeDecodePassable"] },"isEncodedRemotable": { value: cells[139]["isEncodedRemotable"] },"zeroPad": { value: cells[139]["zeroPad"] },"recordNames": { value: cells[139]["recordNames"] },"recordValues": { value: cells[139]["recordValues"] },"trivialComparator": { value: cells[140]["trivialComparator"] },"assertRankSorted": { value: cells[140]["assertRankSorted"] },"compareRank": { value: cells[140]["compareRank"] },"isRankSorted": { value: cells[140]["isRankSorted"] },"sortByRank": { value: cells[140]["sortByRank"] },"compareAntiRank": { value: cells[140]["compareAntiRank"] },"makeFullOrderComparatorKit": { value: cells[140]["makeFullOrderComparatorKit"] },"getPassStyleCover": { value: cells[140]["getPassStyleCover"] },"intersectRankCovers": { value: cells[140]["intersectRankCovers"] },"unionRankCovers": { value: cells[140]["unionRankCovers"] } });
  Object.defineProperties(cells[149], Object.getOwnPropertyDescriptors(cells[148]));
  Object.defineProperties(cells[149], Object.getOwnPropertyDescriptors(cells[146]));
  Object.defineProperties(cells[149], Object.getOwnPropertyDescriptors(cells[142]));

  Object.defineProperties(cells[149], {"Nat": { value: cells[132]["Nat"] },"makeLoopback": { value: cells[147]["makeLoopback"] } });

  Object.defineProperties(cells[153], {"makeNetstringReader": { value: cells[151]["makeNetstringReader"] },"netstringReader": { value: cells[151]["netstringReader"] },"makeNetstringWriter": { value: cells[152]["makeNetstringWriter"] },"netstringWriter": { value: cells[152]["netstringWriter"] } });

  Object.defineProperties(cells[158], {"encodeBase64": { value: cells[156]["encodeBase64"] } });

  Object.defineProperties(cells[160], {"decodeBase64": { value: cells[157]["decodeBase64"] } });

  Object.defineProperties(cells[162], {"encodeBase64": { value: cells[156]["encodeBase64"] },"decodeBase64": { value: cells[157]["decodeBase64"] },"btoa": { value: cells[159]["btoa"] },"atob": { value: cells[161]["atob"] } });

  Object.defineProperties(cells[176], {"makeNodeReader": { value: cells[174]["makeNodeReader"] },"makeNodeWriter": { value: cells[175]["makeNodeWriter"] } });

  const namespaces = cells.map(cells => Object.freeze(Object.create(null, cells)));

  for (let index = 0; index < namespaces.length; index += 1) {
    cells[index]['*'] = cell('*', namespaces[index]);
  }

function observeImports(map, importName, importIndex) {
  for (const [name, observers] of map.get(importName)) {
    const cell = cells[importIndex][name];
    if (cell === undefined) {
      throw new ReferenceError(`Cannot import name ${name}`);
    }
    for (const observer of observers) {
      cell.observe(observer);
    }
  }
}
function wrapCjsFunctor(num) {
  /* eslint-disable no-undef */
  return ({ imports = {} }) => {
    const cModule = Object.freeze(
      Object.defineProperty({}, 'exports', cells[num].default),
    );
    // TODO: specifier not found handling
    const requireImpl = specifier => cells[imports[specifier]].default.get();
    functors[num](Object.freeze(requireImpl), cModule.exports, cModule);
    Object.keys(cells[num])
      .filter(k => k !== 'default' && k !== '*')
      .map(k => cells[num][k].set(cModule.exports[k]));
  };
  /* eslint-enable no-undef */
}

  functors[0]({
    imports(entries) {
      const map = new Map(entries);
    },
    liveVar: {
    },
    onceVar: {
    },
    importMeta: {},
  });
  functors[1]({
    imports(entries) {
      const map = new Map(entries);
    },
    liveVar: {
    },
    onceVar: {
      universalThis: cells[1].globalThis.set,
      Array: cells[1].Array.set,
      Date: cells[1].Date.set,
      FinalizationRegistry: cells[1].FinalizationRegistry.set,
      Float32Array: cells[1].Float32Array.set,
      JSON: cells[1].JSON.set,
      Map: cells[1].Map.set,
      Math: cells[1].Math.set,
      Number: cells[1].Number.set,
      Object: cells[1].Object.set,
      Promise: cells[1].Promise.set,
      Proxy: cells[1].Proxy.set,
      Reflect: cells[1].Reflect.set,
      FERAL_REG_EXP: cells[1].FERAL_REG_EXP.set,
      Set: cells[1].Set.set,
      String: cells[1].String.set,
      Symbol: cells[1].Symbol.set,
      WeakMap: cells[1].WeakMap.set,
      WeakSet: cells[1].WeakSet.set,
      FERAL_ERROR: cells[1].FERAL_ERROR.set,
      RangeError: cells[1].RangeError.set,
      ReferenceError: cells[1].ReferenceError.set,
      SyntaxError: cells[1].SyntaxError.set,
      TypeError: cells[1].TypeError.set,
      assign: cells[1].assign.set,
      create: cells[1].create.set,
      defineProperties: cells[1].defineProperties.set,
      entries: cells[1].entries.set,
      freeze: cells[1].freeze.set,
      getOwnPropertyDescriptor: cells[1].getOwnPropertyDescriptor.set,
      getOwnPropertyDescriptors: cells[1].getOwnPropertyDescriptors.set,
      getOwnPropertyNames: cells[1].getOwnPropertyNames.set,
      getPrototypeOf: cells[1].getPrototypeOf.set,
      is: cells[1].is.set,
      isFrozen: cells[1].isFrozen.set,
      isSealed: cells[1].isSealed.set,
      isExtensible: cells[1].isExtensible.set,
      keys: cells[1].keys.set,
      objectPrototype: cells[1].objectPrototype.set,
      seal: cells[1].seal.set,
      preventExtensions: cells[1].preventExtensions.set,
      setPrototypeOf: cells[1].setPrototypeOf.set,
      values: cells[1].values.set,
      fromEntries: cells[1].fromEntries.set,
      speciesSymbol: cells[1].speciesSymbol.set,
      toStringTagSymbol: cells[1].toStringTagSymbol.set,
      iteratorSymbol: cells[1].iteratorSymbol.set,
      matchAllSymbol: cells[1].matchAllSymbol.set,
      unscopablesSymbol: cells[1].unscopablesSymbol.set,
      symbolKeyFor: cells[1].symbolKeyFor.set,
      symbolFor: cells[1].symbolFor.set,
      isInteger: cells[1].isInteger.set,
      stringifyJson: cells[1].stringifyJson.set,
      defineProperty: cells[1].defineProperty.set,
      apply: cells[1].apply.set,
      construct: cells[1].construct.set,
      reflectGet: cells[1].reflectGet.set,
      reflectGetOwnPropertyDescriptor: cells[1].reflectGetOwnPropertyDescriptor.set,
      reflectHas: cells[1].reflectHas.set,
      reflectIsExtensible: cells[1].reflectIsExtensible.set,
      ownKeys: cells[1].ownKeys.set,
      reflectPreventExtensions: cells[1].reflectPreventExtensions.set,
      reflectSet: cells[1].reflectSet.set,
      isArray: cells[1].isArray.set,
      arrayPrototype: cells[1].arrayPrototype.set,
      mapPrototype: cells[1].mapPrototype.set,
      proxyRevocable: cells[1].proxyRevocable.set,
      regexpPrototype: cells[1].regexpPrototype.set,
      setPrototype: cells[1].setPrototype.set,
      stringPrototype: cells[1].stringPrototype.set,
      weakmapPrototype: cells[1].weakmapPrototype.set,
      weaksetPrototype: cells[1].weaksetPrototype.set,
      functionPrototype: cells[1].functionPrototype.set,
      promisePrototype: cells[1].promisePrototype.set,
      typedArrayPrototype: cells[1].typedArrayPrototype.set,
      uncurryThis: cells[1].uncurryThis.set,
      objectHasOwnProperty: cells[1].objectHasOwnProperty.set,
      arrayFilter: cells[1].arrayFilter.set,
      arrayForEach: cells[1].arrayForEach.set,
      arrayIncludes: cells[1].arrayIncludes.set,
      arrayJoin: cells[1].arrayJoin.set,
      arrayMap: cells[1].arrayMap.set,
      arrayPop: cells[1].arrayPop.set,
      arrayPush: cells[1].arrayPush.set,
      arraySlice: cells[1].arraySlice.set,
      arraySome: cells[1].arraySome.set,
      arraySort: cells[1].arraySort.set,
      iterateArray: cells[1].iterateArray.set,
      mapSet: cells[1].mapSet.set,
      mapGet: cells[1].mapGet.set,
      mapHas: cells[1].mapHas.set,
      mapDelete: cells[1].mapDelete.set,
      mapEntries: cells[1].mapEntries.set,
      iterateMap: cells[1].iterateMap.set,
      setAdd: cells[1].setAdd.set,
      setDelete: cells[1].setDelete.set,
      setForEach: cells[1].setForEach.set,
      setHas: cells[1].setHas.set,
      iterateSet: cells[1].iterateSet.set,
      regexpTest: cells[1].regexpTest.set,
      regexpExec: cells[1].regexpExec.set,
      matchAllRegExp: cells[1].matchAllRegExp.set,
      stringEndsWith: cells[1].stringEndsWith.set,
      stringIncludes: cells[1].stringIncludes.set,
      stringIndexOf: cells[1].stringIndexOf.set,
      stringMatch: cells[1].stringMatch.set,
      stringReplace: cells[1].stringReplace.set,
      stringSearch: cells[1].stringSearch.set,
      stringSlice: cells[1].stringSlice.set,
      stringSplit: cells[1].stringSplit.set,
      stringStartsWith: cells[1].stringStartsWith.set,
      iterateString: cells[1].iterateString.set,
      weakmapDelete: cells[1].weakmapDelete.set,
      weakmapGet: cells[1].weakmapGet.set,
      weakmapHas: cells[1].weakmapHas.set,
      weakmapSet: cells[1].weakmapSet.set,
      weaksetAdd: cells[1].weaksetAdd.set,
      weaksetHas: cells[1].weaksetHas.set,
      functionToString: cells[1].functionToString.set,
      promiseAll: cells[1].promiseAll.set,
      promiseCatch: cells[1].promiseCatch.set,
      promiseThen: cells[1].promiseThen.set,
      finalizationRegistryRegister: cells[1].finalizationRegistryRegister.set,
      finalizationRegistryUnregister: cells[1].finalizationRegistryUnregister.set,
      getConstructorOf: cells[1].getConstructorOf.set,
      immutableObject: cells[1].immutableObject.set,
      isObject: cells[1].isObject.set,
      isError: cells[1].isError.set,
      FERAL_EVAL: cells[1].FERAL_EVAL.set,
      FERAL_FUNCTION: cells[1].FERAL_FUNCTION.set,
      noEvalEvaluate: cells[1].noEvalEvaluate.set,
    },
    importMeta: {},
  });
  functors[2]({
    imports(entries) {
      const map = new Map(entries);
      observeImports(map, "./commons.js", 1);
    },
    liveVar: {
    },
    onceVar: {
    },
    importMeta: {},
  });
  functors[3]({
    imports(entries) {
      const map = new Map(entries);
    },
    liveVar: {
    },
    onceVar: {
      makeEnvironmentCaptor: cells[3].makeEnvironmentCaptor.set,
    },
    importMeta: {},
  });
  functors[4]({
    imports(entries) {
      const map = new Map(entries);
      observeImports(map, "./src/env-options.js", 3);
    },
    liveVar: {
    },
    onceVar: {
    },
    importMeta: {},
  });
  functors[5]({
    imports(entries) {
      const map = new Map(entries);
      observeImports(map, "../commons.js", 1);
    },
    liveVar: {
    },
    onceVar: {
      an: cells[5].an.set,
      bestEffortStringify: cells[5].bestEffortStringify.set,
      enJoin: cells[5].enJoin.set,
    },
    importMeta: {},
  });
  functors[6]({
    imports(entries) {
      const map = new Map(entries);
    },
    liveVar: {
    },
    onceVar: {
    },
    importMeta: {},
  });
  functors[7]({
    imports(entries) {
      const map = new Map(entries);
    },
    liveVar: {
    },
    onceVar: {
    },
    importMeta: {},
  });
  functors[8]({
    imports(entries) {
      const map = new Map(entries);
      observeImports(map, "./internal-types.js", 7);
    },
    liveVar: {
    },
    onceVar: {
      makeLRUCacheMap: cells[8].makeLRUCacheMap.set,
      makeNoteLogArgsArrayKit: cells[8].makeNoteLogArgsArrayKit.set,
    },
    importMeta: {},
  });
  functors[9]({
    imports(entries) {
      const map = new Map(entries);
      observeImports(map, "../commons.js", 1);
      observeImports(map, "./stringify-utils.js", 5);
      observeImports(map, "./types.js", 6);
      observeImports(map, "./internal-types.js", 7);
      observeImports(map, "./note-log-args.js", 8);
    },
    liveVar: {
    },
    onceVar: {
      unredactedDetails: cells[9].unredactedDetails.set,
      loggedErrorHandler: cells[9].loggedErrorHandler.set,
      makeAssert: cells[9].makeAssert.set,
      assert: cells[9].assert.set,
    },
    importMeta: {},
  });
  functors[10]({
    imports(entries) {
      const map = new Map(entries);
      observeImports(map, "./commons.js", 1);
      observeImports(map, "./error/assert.js", 9);
    },
    liveVar: {
    },
    onceVar: {
      isTypedArray: cells[10].isTypedArray.set,
      makeHardener: cells[10].makeHardener.set,
    },
    importMeta: {},
  });
  functors[11]({
    imports(entries) {
      const map = new Map(entries);
    },
    liveVar: {
    },
    onceVar: {
      constantProperties: cells[11].constantProperties.set,
      universalPropertyNames: cells[11].universalPropertyNames.set,
      initialGlobalPropertyNames: cells[11].initialGlobalPropertyNames.set,
      sharedGlobalPropertyNames: cells[11].sharedGlobalPropertyNames.set,
      uniqueGlobalPropertyNames: cells[11].uniqueGlobalPropertyNames.set,
      NativeErrors: cells[11].NativeErrors.set,
      FunctionInstance: cells[11].FunctionInstance.set,
      AsyncFunctionInstance: cells[11].AsyncFunctionInstance.set,
      isAccessorPermit: cells[11].isAccessorPermit.set,
      permitted: cells[11].permitted.set,
    },
    importMeta: {},
  });
  functors[12]({
    imports(entries) {
      const map = new Map(entries);
      observeImports(map, "./commons.js", 1);
      observeImports(map, "./permits.js", 11);
    },
    liveVar: {
    },
    onceVar: {
      makeIntrinsicsCollector: cells[12].makeIntrinsicsCollector.set,
      getGlobalIntrinsics: cells[12].getGlobalIntrinsics.set,
    },
    importMeta: {},
  });
  functors[13]({
    imports(entries) {
      const map = new Map(entries);
      observeImports(map, "./permits.js", 11);
      observeImports(map, "./commons.js", 1);
    },
    liveVar: {
    },
    onceVar: {
      default: cells[13].default.set,
    },
    importMeta: {},
  });
  functors[14]({
    imports(entries) {
      const map = new Map(entries);
      observeImports(map, "./commons.js", 1);
    },
    liveVar: {
    },
    onceVar: {
      default: cells[14].default.set,
    },
    importMeta: {},
  });
  functors[15]({
    imports(entries) {
      const map = new Map(entries);
      observeImports(map, "./commons.js", 1);
    },
    liveVar: {
    },
    onceVar: {
      default: cells[15].default.set,
    },
    importMeta: {},
  });
  functors[16]({
    imports(entries) {
      const map = new Map(entries);
      observeImports(map, "./commons.js", 1);
    },
    liveVar: {
    },
    onceVar: {
      default: cells[16].default.set,
    },
    importMeta: {},
  });
  functors[17]({
    imports(entries) {
      const map = new Map(entries);
      observeImports(map, "./commons.js", 1);
    },
    liveVar: {
    },
    onceVar: {
      default: cells[17].default.set,
    },
    importMeta: {},
  });
  functors[18]({
    imports(entries) {
      const map = new Map(entries);
    },
    liveVar: {
    },
    onceVar: {
      minEnablements: cells[18].minEnablements.set,
      moderateEnablements: cells[18].moderateEnablements.set,
      severeEnablements: cells[18].severeEnablements.set,
    },
    importMeta: {},
  });
  functors[19]({
    imports(entries) {
      const map = new Map(entries);
      observeImports(map, "./commons.js", 1);
      observeImports(map, "./enablements.js", 18);
    },
    liveVar: {
    },
    onceVar: {
      default: cells[19].default.set,
    },
    importMeta: {},
  });
  functors[20]({
    imports(entries) {
      const map = new Map(entries);
      observeImports(map, "./commons.js", 1);
      observeImports(map, "./error/assert.js", 9);
    },
    liveVar: {
    },
    onceVar: {
      default: cells[20].default.set,
    },
    importMeta: {},
  });
  functors[21]({
    imports(entries) {
      const map = new Map(entries);
    },
    liveVar: {
    },
    onceVar: {
      makeEvalFunction: cells[21].makeEvalFunction.set,
    },
    importMeta: {},
  });
  functors[22]({
    imports(entries) {
      const map = new Map(entries);
      observeImports(map, "./commons.js", 1);
      observeImports(map, "./error/assert.js", 9);
    },
    liveVar: {
    },
    onceVar: {
      makeFunctionConstructor: cells[22].makeFunctionConstructor.set,
    },
    importMeta: {},
  });
  functors[23]({
    imports(entries) {
      const map = new Map(entries);
      observeImports(map, "./commons.js", 1);
      observeImports(map, "./make-eval-function.js", 21);
      observeImports(map, "./make-function-constructor.js", 22);
      observeImports(map, "./permits.js", 11);
    },
    liveVar: {
    },
    onceVar: {
      setGlobalObjectSymbolUnscopables: cells[23].setGlobalObjectSymbolUnscopables.set,
      setGlobalObjectConstantProperties: cells[23].setGlobalObjectConstantProperties.set,
      setGlobalObjectMutableProperties: cells[23].setGlobalObjectMutableProperties.set,
      setGlobalObjectEvaluators: cells[23].setGlobalObjectEvaluators.set,
    },
    importMeta: {},
  });
  functors[24]({
    imports(entries) {
      const map = new Map(entries);
      observeImports(map, "./commons.js", 1);
      observeImports(map, "./error/assert.js", 9);
    },
    liveVar: {
    },
    onceVar: {
      alwaysThrowHandler: cells[24].alwaysThrowHandler.set,
      strictScopeTerminatorHandler: cells[24].strictScopeTerminatorHandler.set,
      strictScopeTerminator: cells[24].strictScopeTerminator.set,
    },
    importMeta: {},
  });
  functors[25]({
    imports(entries) {
      const map = new Map(entries);
      observeImports(map, "./commons.js", 1);
      observeImports(map, "./strict-scope-terminator.js", 24);
    },
    liveVar: {
    },
    onceVar: {
      createSloppyGlobalsScopeTerminator: cells[25].createSloppyGlobalsScopeTerminator.set,
    },
    importMeta: {},
  });
  functors[26]({
    imports(entries) {
      const map = new Map(entries);
      observeImports(map, "./commons.js", 1);
      observeImports(map, "./error/assert.js", 9);
    },
    liveVar: {
    },
    onceVar: {
      makeEvalScopeKit: cells[26].makeEvalScopeKit.set,
    },
    importMeta: {},
  });
  functors[27]({
    imports(entries) {
      const map = new Map(entries);
      observeImports(map, "./commons.js", 1);
    },
    liveVar: {
    },
    onceVar: {
      getSourceURL: cells[27].getSourceURL.set,
    },
    importMeta: {},
  });
  functors[28]({
    imports(entries) {
      const map = new Map(entries);
      observeImports(map, "./commons.js", 1);
      observeImports(map, "./get-source-url.js", 27);
    },
    liveVar: {
    },
    onceVar: {
      rejectHtmlComments: cells[28].rejectHtmlComments.set,
      evadeHtmlCommentTest: cells[28].evadeHtmlCommentTest.set,
      rejectImportExpressions: cells[28].rejectImportExpressions.set,
      evadeImportExpressionTest: cells[28].evadeImportExpressionTest.set,
      rejectSomeDirectEvalExpressions: cells[28].rejectSomeDirectEvalExpressions.set,
      mandatoryTransforms: cells[28].mandatoryTransforms.set,
      applyTransforms: cells[28].applyTransforms.set,
      transforms: cells[28].transforms.set,
    },
    importMeta: {},
  });
  functors[29]({
    imports(entries) {
      const map = new Map(entries);
      observeImports(map, "./commons.js", 1);
    },
    liveVar: {
    },
    onceVar: {
      isValidIdentifierName: cells[29].isValidIdentifierName.set,
      getScopeConstants: cells[29].getScopeConstants.set,
    },
    importMeta: {},
  });
  functors[30]({
    imports(entries) {
      const map = new Map(entries);
      observeImports(map, "./commons.js", 1);
      observeImports(map, "./scope-constants.js", 29);
    },
    liveVar: {
    },
    onceVar: {
      makeEvaluate: cells[30].makeEvaluate.set,
    },
    importMeta: {},
  });
  functors[31]({
    imports(entries) {
      const map = new Map(entries);
      observeImports(map, "./commons.js", 1);
      observeImports(map, "./strict-scope-terminator.js", 24);
      observeImports(map, "./sloppy-globals-scope-terminator.js", 25);
      observeImports(map, "./eval-scope.js", 26);
      observeImports(map, "./transforms.js", 28);
      observeImports(map, "./make-evaluate.js", 30);
      observeImports(map, "./error/assert.js", 9);
    },
    liveVar: {
    },
    onceVar: {
      makeSafeEvaluator: cells[31].makeSafeEvaluator.set,
    },
    importMeta: {},
  });
  functors[32]({
    imports(entries) {
      const map = new Map(entries);
      observeImports(map, "./commons.js", 1);
    },
    liveVar: {
    },
    onceVar: {
      tameFunctionToString: cells[32].tameFunctionToString.set,
    },
    importMeta: {},
  });
  functors[33]({
    imports(entries) {
      const map = new Map(entries);
      observeImports(map, "./commons.js", 1);
    },
    liveVar: {
    },
    onceVar: {
      tameDomains: cells[33].tameDomains.set,
    },
    importMeta: {},
  });
  functors[34]({
    imports(entries) {
      const map = new Map(entries);
      observeImports(map, "../commons.js", 1);
      observeImports(map, "./types.js", 6);
      observeImports(map, "./internal-types.js", 7);
    },
    liveVar: {
    },
    onceVar: {
      makeLoggingConsoleKit: cells[34].makeLoggingConsoleKit.set,
      makeCausalConsole: cells[34].makeCausalConsole.set,
      filterConsole: cells[34].filterConsole.set,
      consoleWhitelist: cells[34].consoleWhitelist.set,
    },
    importMeta: {},
  });
  functors[35]({
    imports(entries) {
      const map = new Map(entries);
      observeImports(map, "../commons.js", 1);
    },
    liveVar: {
    },
    onceVar: {
      makeRejectionHandlers: cells[35].makeRejectionHandlers.set,
    },
    importMeta: {},
  });
  functors[36]({
    imports(entries) {
      const map = new Map(entries);
      observeImports(map, "../commons.js", 1);
      observeImports(map, "./assert.js", 9);
      observeImports(map, "./console.js", 34);
      observeImports(map, "./unhandled-rejection.js", 35);
      observeImports(map, "./types.js", 6);
      observeImports(map, "./internal-types.js", 7);
    },
    liveVar: {
    },
    onceVar: {
      tameConsole: cells[36].tameConsole.set,
    },
    importMeta: {},
  });
  functors[37]({
    imports(entries) {
      const map = new Map(entries);
      observeImports(map, "../commons.js", 1);
    },
    liveVar: {
    },
    onceVar: {
      filterFileName: cells[37].filterFileName.set,
      shortenCallSiteString: cells[37].shortenCallSiteString.set,
      tameV8ErrorConstructor: cells[37].tameV8ErrorConstructor.set,
    },
    importMeta: {},
  });
  functors[38]({
    imports(entries) {
      const map = new Map(entries);
      observeImports(map, "../commons.js", 1);
      observeImports(map, "../permits.js", 11);
      observeImports(map, "./tame-v8-error-constructor.js", 37);
    },
    liveVar: {
    },
    onceVar: {
      default: cells[38].default.set,
    },
    importMeta: {},
  });
  functors[39]({
    imports(entries) {
      const map = new Map(entries);
      observeImports(map, "./commons.js", 1);
      observeImports(map, "./error/assert.js", 9);
    },
    liveVar: {
    },
    onceVar: {
      makeAlias: cells[39].makeAlias.set,
      load: cells[39].load.set,
    },
    importMeta: {},
  });
  functors[40]({
    imports(entries) {
      const map = new Map(entries);
      observeImports(map, "./module-load.js", 39);
      observeImports(map, "./commons.js", 1);
      observeImports(map, "./error/assert.js", 9);
    },
    liveVar: {
    },
    onceVar: {
      deferExports: cells[40].deferExports.set,
      getDeferredExports: cells[40].getDeferredExports.set,
    },
    importMeta: {},
  });
  functors[41]({
    imports(entries) {
      const map = new Map(entries);
      observeImports(map, "./commons.js", 1);
      observeImports(map, "./transforms.js", 28);
      observeImports(map, "./make-safe-evaluator.js", 31);
    },
    liveVar: {
    },
    onceVar: {
      provideCompartmentEvaluator: cells[41].provideCompartmentEvaluator.set,
      compartmentEvaluate: cells[41].compartmentEvaluate.set,
    },
    importMeta: {},
  });
  functors[42]({
    imports(entries) {
      const map = new Map(entries);
      observeImports(map, "./error/assert.js", 9);
      observeImports(map, "./module-proxy.js", 40);
      observeImports(map, "./commons.js", 1);
      observeImports(map, "./compartment-evaluate.js", 41);
    },
    liveVar: {
    },
    onceVar: {
      makeThirdPartyModuleInstance: cells[42].makeThirdPartyModuleInstance.set,
      makeModuleInstance: cells[42].makeModuleInstance.set,
    },
    importMeta: {},
  });
  functors[43]({
    imports(entries) {
      const map = new Map(entries);
      observeImports(map, "./error/assert.js", 9);
      observeImports(map, "./module-instance.js", 42);
      observeImports(map, "./commons.js", 1);
    },
    liveVar: {
    },
    onceVar: {
      link: cells[43].link.set,
      instantiate: cells[43].instantiate.set,
    },
    importMeta: {},
  });
  functors[44]({
    imports(entries) {
      const map = new Map(entries);
      observeImports(map, "./commons.js", 1);
      observeImports(map, "./global-object.js", 23);
      observeImports(map, "./permits.js", 11);
      observeImports(map, "./module-load.js", 39);
      observeImports(map, "./module-link.js", 43);
      observeImports(map, "./module-proxy.js", 40);
      observeImports(map, "./error/assert.js", 9);
      observeImports(map, "./compartment-evaluate.js", 41);
      observeImports(map, "./make-safe-evaluator.js", 31);
    },
    liveVar: {
    },
    onceVar: {
      InertCompartment: cells[44].InertCompartment.set,
      CompartmentPrototype: cells[44].CompartmentPrototype.set,
      makeCompartmentConstructor: cells[44].makeCompartmentConstructor.set,
    },
    importMeta: {},
  });
  functors[45]({
    imports(entries) {
      const map = new Map(entries);
      observeImports(map, "./commons.js", 1);
      observeImports(map, "./compartment.js", 44);
    },
    liveVar: {
    },
    onceVar: {
      getAnonymousIntrinsics: cells[45].getAnonymousIntrinsics.set,
    },
    importMeta: {},
  });
  functors[46]({
    imports(entries) {
      const map = new Map(entries);
      observeImports(map, "./commons.js", 1);
    },
    liveVar: {
    },
    onceVar: {
      tameHarden: cells[46].tameHarden.set,
    },
    importMeta: {},
  });
  functors[47]({
    imports(entries) {
      const map = new Map(entries);
      observeImports(map, "./commons.js", 1);
    },
    liveVar: {
    },
    onceVar: {
      tameSymbolConstructor: cells[47].tameSymbolConstructor.set,
    },
    importMeta: {},
  });
  functors[48]({
    imports(entries) {
      const map = new Map(entries);
      observeImports(map, "@endo/env-options", 4);
      observeImports(map, "./commons.js", 1);
      observeImports(map, "./make-hardener.js", 10);
      observeImports(map, "./intrinsics.js", 12);
      observeImports(map, "./permits-intrinsics.js", 13);
      observeImports(map, "./tame-function-constructors.js", 14);
      observeImports(map, "./tame-date-constructor.js", 15);
      observeImports(map, "./tame-math-object.js", 16);
      observeImports(map, "./tame-regexp-constructor.js", 17);
      observeImports(map, "./enable-property-overrides.js", 19);
      observeImports(map, "./tame-locale-methods.js", 20);
      observeImports(map, "./global-object.js", 23);
      observeImports(map, "./make-safe-evaluator.js", 31);
      observeImports(map, "./permits.js", 11);
      observeImports(map, "./tame-function-tostring.js", 32);
      observeImports(map, "./tame-domains.js", 33);
      observeImports(map, "./error/tame-console.js", 36);
      observeImports(map, "./error/tame-error-constructor.js", 38);
      observeImports(map, "./error/assert.js", 9);
      observeImports(map, "./get-anonymous-intrinsics.js", 45);
      observeImports(map, "./compartment.js", 44);
      observeImports(map, "./tame-harden.js", 46);
      observeImports(map, "./tame-symbol-constructor.js", 47);
    },
    liveVar: {
    },
    onceVar: {
      repairIntrinsics: cells[48].repairIntrinsics.set,
    },
    importMeta: {},
  });
  functors[49]({
    imports(entries) {
      const map = new Map(entries);
      observeImports(map, "./assert-sloppy-mode.js", 2);
      observeImports(map, "./commons.js", 1);
      observeImports(map, "./lockdown.js", 48);
    },
    liveVar: {
    },
    onceVar: {
    },
    importMeta: {},
  });
  functors[50]({
    imports(entries) {
      const map = new Map(entries);
      observeImports(map, "./commons.js", 1);
      observeImports(map, "./compartment.js", 44);
      observeImports(map, "./tame-function-tostring.js", 32);
      observeImports(map, "./intrinsics.js", 12);
    },
    liveVar: {
    },
    onceVar: {
    },
    importMeta: {},
  });
  functors[51]({
    imports(entries) {
      const map = new Map(entries);
      observeImports(map, "./commons.js", 1);
      observeImports(map, "./error/assert.js", 9);
    },
    liveVar: {
    },
    onceVar: {
    },
    importMeta: {},
  });
  functors[52]({
    imports(entries) {
      const map = new Map(entries);
      observeImports(map, "./src/lockdown-shim.js", 49);
      observeImports(map, "./src/compartment-shim.js", 50);
      observeImports(map, "./src/assert-shim.js", 51);
    },
    liveVar: {
    },
    onceVar: {
    },
    importMeta: {},
  });
  functors[53]({
    imports(entries) {
      const map = new Map(entries);
    },
    liveVar: {
    },
    onceVar: {
      race: cells[53].memoRace.set,
    },
    importMeta: {},
  });
  functors[54]({
    imports(entries) {
      const map = new Map(entries);
      observeImports(map, "./src/memo-race.js", 53);
    },
    liveVar: {
    },
    onceVar: {
    },
    importMeta: {},
  });
  functors[55]({
    imports(entries) {
      const map = new Map(entries);
    },
    liveVar: {
    },
    onceVar: {
      default: cells[55].default.set,
    },
    importMeta: {},
  });
  functors[56]({
    imports(entries) {
      const map = new Map(entries);
      observeImports(map, "ses", 52);
      observeImports(map, "./post.js", 55);
    },
    liveVar: {
    },
    onceVar: {
      lockdown: cells[56].lockdown.set,
    },
    importMeta: {},
  });
  functors[57]({
    imports(entries) {
      const map = new Map(entries);
      observeImports(map, "./pre.js", 56);
    },
    liveVar: {
    },
    onceVar: {
    },
    importMeta: {},
  });
  wrapCjsFunctor(58)({imports: {}});
  wrapCjsFunctor(59)({imports: {}});
  wrapCjsFunctor(60)({imports: {"./shams":59}});
  wrapCjsFunctor(61)({imports: {}});
  wrapCjsFunctor(62)({imports: {"./implementation":61}});
  wrapCjsFunctor(63)({imports: {"function-bind":62}});
  wrapCjsFunctor(64)({imports: {"has-symbols":60,"function-bind":62,"has":63}});
  wrapCjsFunctor(65)({imports: {"function-bind":62,"get-intrinsic":64}});
  wrapCjsFunctor(66)({imports: {"get-intrinsic":64,"./":65}});
  wrapCjsFunctor(67)({imports: {"has-symbols/shams":59}});
  wrapCjsFunctor(68)({imports: {"has-tostringtag/shams":67,"call-bind/callBound":66}});
  wrapCjsFunctor(69)({imports: {"has-tostringtag/shams":67}});
  wrapCjsFunctor(70)({imports: {}});
  wrapCjsFunctor(71)({imports: {"is-callable":70}});
  wrapCjsFunctor(72)({imports: {}});
  wrapCjsFunctor(73)({imports: {"get-intrinsic":64}});
  wrapCjsFunctor(74)({imports: {"for-each":71,"available-typed-arrays":72,"call-bind/callBound":66,"has-tostringtag/shams":67,"gopd":73}});
  wrapCjsFunctor(75)({imports: {"for-each":71,"available-typed-arrays":72,"call-bind/callBound":66,"gopd":73,"has-tostringtag/shams":67,"is-typed-array":74}});
  wrapCjsFunctor(76)({imports: {"is-arguments":68,"is-generator-function":69,"which-typed-array":75,"is-typed-array":74}});
  wrapCjsFunctor(77)({imports: {}});
  wrapCjsFunctor(78)({imports: {}});
  wrapCjsFunctor(79)({imports: {"util":80,"./inherits_browser.js":78}});
  wrapCjsFunctor(80)({imports: {"./support/types":76,"./support/isBuffer":77,"inherits":79}});
  wrapCjsFunctor(81)({imports: {"util":80}});
  wrapCjsFunctor(82)({imports: {"./util.inspect":81}});
  wrapCjsFunctor(83)({imports: {"get-intrinsic":64,"call-bind/callBound":66,"object-inspect":82}});
  wrapCjsFunctor(84)({imports: {}});
  wrapCjsFunctor(85)({imports: {"./formats":84}});
  wrapCjsFunctor(86)({imports: {"side-channel":83,"./utils":85,"./formats":84}});
  wrapCjsFunctor(87)({imports: {"./utils":85}});
  wrapCjsFunctor(88)({imports: {"./stringify":86,"./parse":87,"./formats":84}});
  wrapCjsFunctor(89)({imports: {"punycode":58,"qs":88}});
  wrapCjsFunctor(90)({imports: {}});
  wrapCjsFunctor(91)({imports: {}});
  wrapCjsFunctor(92)({imports: {"base64-js":90,"ieee754":91}});
  wrapCjsFunctor(93)({imports: {}});
  wrapCjsFunctor(94)({imports: {}});
  wrapCjsFunctor(95)({imports: {}});
  wrapCjsFunctor(96)({imports: {}});
  wrapCjsFunctor(97)({imports: {"./constants":96,"./debug":95}});
  wrapCjsFunctor(98)({imports: {}});
  wrapCjsFunctor(99)({imports: {}});
  wrapCjsFunctor(100)({imports: {"../internal/debug":95,"../internal/constants":96,"../internal/re":97,"../internal/parse-options":98,"../internal/identifiers":99}});
  wrapCjsFunctor(101)({imports: {"../classes/semver":100}});
  wrapCjsFunctor(102)({imports: {"./compare":101}});
  wrapCjsFunctor(103)({imports: {"fs":80,"path":94,"util":80,"semver/functions/gte":102}});
  functors[104]({
    imports(entries) {
      const map = new Map(entries);
    },
    liveVar: {
    },
    onceVar: {
      makeReleasingExecutorKit: cells[104].makeReleasingExecutorKit.set,
    },
    importMeta: {},
  });
  functors[105]({
    imports(entries) {
      const map = new Map(entries);
    },
    liveVar: {
    },
    onceVar: {
      isPromise: cells[105].isPromise.set,
    },
    importMeta: {},
  });
  functors[106]({
    imports(entries) {
      const map = new Map(entries);
    },
    liveVar: {
    },
    onceVar: {
    },
    importMeta: {},
  });
  functors[107]({
    imports(entries) {
      const map = new Map(entries);
      observeImports(map, "./src/promise-executor-kit.js", 104);
      observeImports(map, "./src/memo-race.js", 53);
      observeImports(map, "./src/is-promise.js", 105);
      observeImports(map, "./src/types.js", 106);
    },
    liveVar: {
    },
    onceVar: {
      makePromiseKit: cells[107].makePromiseKit.set,
      racePromises: cells[107].racePromises.set,
    },
    importMeta: {},
  });
  functors[108]({
    imports(entries) {
      const map = new Map(entries);
      observeImports(map, "@endo/env-options", 4);
    },
    liveVar: {
    },
    onceVar: {
      trackTurns: cells[108].trackTurns.set,
    },
    importMeta: {},
  });
  functors[109]({
    imports(entries) {
      const map = new Map(entries);
    },
    liveVar: {
    },
    onceVar: {
      getMethodNames: cells[109].getMethodNames.set,
      localApplyFunction: cells[109].localApplyFunction.set,
      localApplyMethod: cells[109].localApplyMethod.set,
      localGet: cells[109].localGet.set,
    },
    importMeta: {},
  });
  functors[110]({
    imports(entries) {
      const map = new Map(entries);
    },
    liveVar: {
    },
    onceVar: {
      makePostponedHandler: cells[110].makePostponedHandler.set,
    },
    importMeta: {},
  });
  functors[111]({
    imports(entries) {
      const map = new Map(entries);
      observeImports(map, "./track-turns.js", 108);
      observeImports(map, "./local.js", 109);
      observeImports(map, "./postponed.js", 110);
    },
    liveVar: {
    },
    onceVar: {
      makeHandledPromise: cells[111].makeHandledPromise.set,
    },
    importMeta: {},
  });
  functors[112]({
    imports(entries) {
      const map = new Map(entries);
      observeImports(map, "./src/handled-promise.js", 111);
    },
    liveVar: {
    },
    onceVar: {
    },
    importMeta: {},
  });
  functors[113]({
    imports(entries) {
      const map = new Map(entries);
      observeImports(map, "./track-turns.js", 108);
    },
    liveVar: {
    },
    onceVar: {
      default: cells[113].default.set,
    },
    importMeta: {},
  });
  functors[114]({
    imports(entries) {
      const map = new Map(entries);
    },
    liveVar: {
    },
    onceVar: {
    },
    importMeta: {},
  });
  functors[115]({
    imports(entries) {
      const map = new Map(entries);
      observeImports(map, "./E.js", 113);
      observeImports(map, "./exports.js", 114);
    },
    liveVar: {
    },
    onceVar: {
      hp: cells[115].HandledPromise.set,
      E: cells[115].E.set,
    },
    importMeta: {},
  });
  functors[116]({
    imports(entries) {
      const map = new Map(entries);
    },
    liveVar: {
    },
    onceVar: {
      hasOwnPropertyOf: cells[116].hasOwnPropertyOf.set,
      isObject: cells[116].isObject.set,
      isTypedArray: cells[116].isTypedArray.set,
      PASS_STYLE: cells[116].PASS_STYLE.set,
      canBeMethod: cells[116].canBeMethod.set,
      assertChecker: cells[116].assertChecker.set,
      checkNormalProperty: cells[116].checkNormalProperty.set,
      getTag: cells[116].getTag.set,
      checkPassStyle: cells[116].checkPassStyle.set,
      checkTagRecord: cells[116].checkTagRecord.set,
      checkFunctionTagRecord: cells[116].checkFunctionTagRecord.set,
    },
    importMeta: {},
  });
  functors[117]({
    imports(entries) {
      const map = new Map(entries);
      observeImports(map, "./passStyle-helpers.js", 116);
    },
    liveVar: {
    },
    onceVar: {
      assertIface: cells[117].assertIface.set,
      getInterfaceOf: cells[117].getInterfaceOf.set,
      RemotableHelper: cells[117].RemotableHelper.set,
    },
    importMeta: {},
  });
  functors[118]({
    imports(entries) {
      const map = new Map(entries);
      observeImports(map, "./passStyle-helpers.js", 116);
      observeImports(map, "./remotable.js", 117);
    },
    liveVar: {
    },
    onceVar: {
      Remotable: cells[118].Remotable.set,
      Far: cells[118].Far.set,
      ToFarFunction: cells[118].ToFarFunction.set,
    },
    importMeta: {},
  });
  functors[119]({
    imports(entries) {
      const map = new Map(entries);
      observeImports(map, "./make-far.js", 118);
    },
    liveVar: {
    },
    onceVar: {
      mapIterable: cells[119].mapIterable.set,
      filterIterable: cells[119].filterIterable.set,
    },
    importMeta: {},
  });
  functors[120]({
    imports(entries) {
      const map = new Map(entries);
      observeImports(map, "./passStyle-helpers.js", 116);
    },
    liveVar: {
    },
    onceVar: {
      getErrorConstructor: cells[120].getErrorConstructor.set,
      isErrorLike: cells[120].isErrorLike.set,
      ErrorHelper: cells[120].ErrorHelper.set,
      toPassableError: cells[120].toPassableError.set,
    },
    importMeta: {},
  });
  functors[121]({
    imports(entries) {
      const map = new Map(entries);
    },
    liveVar: {
    },
    onceVar: {
      isPassableSymbol: cells[121].isPassableSymbol.set,
      assertPassableSymbol: cells[121].assertPassableSymbol.set,
      nameForPassableSymbol: cells[121].nameForPassableSymbol.set,
      passableSymbolForName: cells[121].passableSymbolForName.set,
    },
    importMeta: {},
  });
  functors[122]({
    imports(entries) {
      const map = new Map(entries);
      observeImports(map, "./passStyle-helpers.js", 116);
    },
    liveVar: {
    },
    onceVar: {
      CopyArrayHelper: cells[122].CopyArrayHelper.set,
    },
    importMeta: {},
  });
  functors[123]({
    imports(entries) {
      const map = new Map(entries);
      observeImports(map, "./passStyle-helpers.js", 116);
    },
    liveVar: {
    },
    onceVar: {
      CopyRecordHelper: cells[123].CopyRecordHelper.set,
    },
    importMeta: {},
  });
  functors[124]({
    imports(entries) {
      const map = new Map(entries);
      observeImports(map, "./passStyle-helpers.js", 116);
    },
    liveVar: {
    },
    onceVar: {
      TaggedHelper: cells[124].TaggedHelper.set,
    },
    importMeta: {},
  });
  functors[125]({
    imports(entries) {
      const map = new Map(entries);
      observeImports(map, "@endo/promise-kit", 107);
      observeImports(map, "./passStyle-helpers.js", 116);
    },
    liveVar: {
    },
    onceVar: {
      isSafePromise: cells[125].isSafePromise.set,
      assertSafePromise: cells[125].assertSafePromise.set,
    },
    importMeta: {},
  });
  functors[126]({
    imports(entries) {
      const map = new Map(entries);
      observeImports(map, "@endo/promise-kit", 107);
      observeImports(map, "./passStyle-helpers.js", 116);
      observeImports(map, "./copyArray.js", 122);
      observeImports(map, "./copyRecord.js", 123);
      observeImports(map, "./tagged.js", 124);
      observeImports(map, "./error.js", 120);
      observeImports(map, "./remotable.js", 117);
      observeImports(map, "./symbol.js", 121);
      observeImports(map, "./safe-promise.js", 125);
    },
    liveVar: {
    },
    onceVar: {
      passStyleOf: cells[126].passStyleOf.set,
      assertPassable: cells[126].assertPassable.set,
    },
    importMeta: {},
  });
  functors[127]({
    imports(entries) {
      const map = new Map(entries);
      observeImports(map, "./passStyle-helpers.js", 116);
      observeImports(map, "./passStyleOf.js", 126);
    },
    liveVar: {
    },
    onceVar: {
      makeTagged: cells[127].makeTagged.set,
    },
    importMeta: {},
  });
  functors[128]({
    imports(entries) {
      const map = new Map(entries);
      observeImports(map, "./passStyleOf.js", 126);
    },
    liveVar: {
    },
    onceVar: {
      isCopyArray: cells[128].isCopyArray.set,
      isRecord: cells[128].isRecord.set,
      isRemotable: cells[128].isRemotable.set,
      assertCopyArray: cells[128].assertCopyArray.set,
      assertRecord: cells[128].assertRecord.set,
      assertRemotable: cells[128].assertRemotable.set,
    },
    importMeta: {},
  });
  functors[129]({
    imports(entries) {
      const map = new Map(entries);
    },
    liveVar: {
    },
    onceVar: {
    },
    importMeta: {},
  });
  functors[130]({
    imports(entries) {
      const map = new Map(entries);
      observeImports(map, "./src/iter-helpers.js", 119);
      observeImports(map, "./src/passStyle-helpers.js", 116);
      observeImports(map, "./src/error.js", 120);
      observeImports(map, "./src/remotable.js", 117);
      observeImports(map, "./src/symbol.js", 121);
      observeImports(map, "./src/passStyleOf.js", 126);
      observeImports(map, "./src/makeTagged.js", 127);
      observeImports(map, "./src/make-far.js", 118);
      observeImports(map, "./src/typeGuards.js", 128);
      observeImports(map, "./src/types.js", 129);
    },
    liveVar: {
    },
    onceVar: {
    },
    importMeta: {},
  });
  functors[131]({
    imports(entries) {
      const map = new Map(entries);
      observeImports(map, "@endo/eventual-send", 115);
      observeImports(map, "@endo/pass-style", 130);
    },
    liveVar: {
    },
    onceVar: {
    },
    importMeta: {},
  });
  functors[132]({
    imports(entries) {
      const map = new Map(entries);
    },
    liveVar: {
    },
    onceVar: {
      isNat: cells[132].isNat.set,
      Nat: cells[132].Nat.set,
    },
    importMeta: {},
  });
  functors[133]({
    imports(entries) {
      const map = new Map(entries);
      observeImports(map, "@endo/eventual-send", 115);
      observeImports(map, "@endo/promise-kit", 107);
      observeImports(map, "@endo/pass-style", 130);
    },
    liveVar: {
    },
    onceVar: {
      deeplyFulfilled: cells[133].deeplyFulfilled.set,
    },
    importMeta: {},
  });
  functors[134]({
    imports(entries) {
      const map = new Map(entries);
      observeImports(map, "@endo/pass-style", 130);
    },
    liveVar: {
    },
    onceVar: {
      QCLASS: cells[134].QCLASS.set,
      makeEncodeToCapData: cells[134].makeEncodeToCapData.set,
      makeDecodeFromCapData: cells[134].makeDecodeFromCapData.set,
    },
    importMeta: {},
  });
  functors[135]({
    imports(entries) {
      const map = new Map(entries);
      observeImports(map, "@endo/pass-style", 130);
    },
    liveVar: {
    },
    onceVar: {
      makeEncodeToSmallcaps: cells[135].makeEncodeToSmallcaps.set,
      makeDecodeFromSmallcaps: cells[135].makeDecodeFromSmallcaps.set,
    },
    importMeta: {},
  });
  functors[136]({
    imports(entries) {
      const map = new Map(entries);
      observeImports(map, "@endo/nat", 132);
      observeImports(map, "@endo/pass-style", 130);
      observeImports(map, "./encodeToCapData.js", 134);
      observeImports(map, "./encodeToSmallcaps.js", 135);
    },
    liveVar: {
    },
    onceVar: {
      makeMarshal: cells[136].makeMarshal.set,
    },
    importMeta: {},
  });
  functors[137]({
    imports(entries) {
      const map = new Map(entries);
      observeImports(map, "./marshal.js", 136);
    },
    liveVar: {
    },
    onceVar: {
      stringify: cells[137].stringify.set,
      parse: cells[137].parse.set,
    },
    importMeta: {},
  });
  functors[138]({
    imports(entries) {
      const map = new Map(entries);
      observeImports(map, "@endo/nat", 132);
      observeImports(map, "@endo/pass-style", 130);
      observeImports(map, "./encodeToCapData.js", 134);
    },
    liveVar: {
    },
    onceVar: {
      decodeToJustin: cells[138].decodeToJustin.set,
    },
    importMeta: {},
  });
  functors[139]({
    imports(entries) {
      const map = new Map(entries);
      observeImports(map, "@endo/pass-style", 130);
    },
    liveVar: {
    },
    onceVar: {
      recordNames: cells[139].recordNames.set,
      recordValues: cells[139].recordValues.set,
      zeroPad: cells[139].zeroPad.set,
      makeEncodePassable: cells[139].makeEncodePassable.set,
      makeDecodePassable: cells[139].makeDecodePassable.set,
      isEncodedRemotable: cells[139].isEncodedRemotable.set,
      passStylePrefixes: cells[139].passStylePrefixes.set,
    },
    importMeta: {},
  });
  functors[140]({
    imports(entries) {
      const map = new Map(entries);
      observeImports(map, "@endo/pass-style", 130);
      observeImports(map, "./encodePassable.js", 139);
    },
    liveVar: {
    },
    onceVar: {
      trivialComparator: cells[140].trivialComparator.set,
      getPassStyleCover: cells[140].getPassStyleCover.set,
      makeComparatorKit: cells[140].makeComparatorKit.set,
      comparatorMirrorImage: cells[140].comparatorMirrorImage.set,
      isRankSorted: cells[140].isRankSorted.set,
      assertRankSorted: cells[140].assertRankSorted.set,
      sortByRank: cells[140].sortByRank.set,
      getIndexCover: cells[140].getIndexCover.set,
      FullRankCover: cells[140].FullRankCover.set,
      coveredEntries: cells[140].coveredEntries.set,
      unionRankCovers: cells[140].unionRankCovers.set,
      intersectRankCovers: cells[140].intersectRankCovers.set,
      compareRank: cells[140].compareRank.set,
      compareAntiRank: cells[140].compareAntiRank.set,
      makeFullOrderComparatorKit: cells[140].makeFullOrderComparatorKit.set,
    },
    importMeta: {},
  });
  functors[141]({
    imports(entries) {
      const map = new Map(entries);
    },
    liveVar: {
    },
    onceVar: {
    },
    importMeta: {},
  });
  functors[142]({
    imports(entries) {
      const map = new Map(entries);
      observeImports(map, "./src/deeplyFulfilled.js", 133);
      observeImports(map, "./src/encodeToCapData.js", 134);
      observeImports(map, "./src/marshal.js", 136);
      observeImports(map, "./src/marshal-stringify.js", 137);
      observeImports(map, "./src/marshal-justin.js", 138);
      observeImports(map, "./src/encodePassable.js", 139);
      observeImports(map, "./src/rankOrder.js", 140);
      observeImports(map, "./src/types.js", 141);
      observeImports(map, "@endo/pass-style", 130);
    },
    liveVar: {
    },
    onceVar: {
    },
    importMeta: {},
  });
  functors[143]({
    imports(entries) {
      const map = new Map(entries);
    },
    liveVar: {
    },
    onceVar: {
    },
    importMeta: {},
  });
  functors[144]({
    imports(entries) {
      const map = new Map(entries);
      observeImports(map, "./types.js", 143);
    },
    liveVar: {
    },
    onceVar: {
      nearTrapImpl: cells[144].nearTrapImpl.set,
      makeTrap: cells[144].makeTrap.set,
    },
    importMeta: {},
  });
  functors[145]({
    imports(entries) {
      const map = new Map(entries);
      observeImports(map, "@endo/marshal", 142);
    },
    liveVar: {
    },
    onceVar: {
      makeFinalizingMap: cells[145].makeFinalizingMap.set,
    },
    importMeta: {},
  });
  functors[146]({
    imports(entries) {
      const map = new Map(entries);
      observeImports(map, "@endo/marshal", 142);
      observeImports(map, "@endo/eventual-send", 115);
      observeImports(map, "@endo/promise-kit", 107);
      observeImports(map, "./trap.js", 144);
      observeImports(map, "./types.js", 143);
      observeImports(map, "./finalize.js", 145);
    },
    liveVar: {
        E: cells[146].E.set,
  },
    onceVar: {
      makeCapTP: cells[146].makeCapTP.set,
    },
    importMeta: {},
  });
  functors[147]({
    imports(entries) {
      const map = new Map(entries);
      observeImports(map, "@endo/marshal", 142);
      observeImports(map, "./captp.js", 146);
      observeImports(map, "./trap.js", 144);
      observeImports(map, "./finalize.js", 145);
    },
    liveVar: {
        E: cells[147].E.set,
  },
    onceVar: {
      makeLoopback: cells[147].makeLoopback.set,
    },
    importMeta: {},
  });
  functors[148]({
    imports(entries) {
      const map = new Map(entries);
    },
    liveVar: {
    },
    onceVar: {
      MIN_DATA_BUFFER_LENGTH: cells[148].MIN_DATA_BUFFER_LENGTH.set,
      TRANSFER_OVERHEAD_LENGTH: cells[148].TRANSFER_OVERHEAD_LENGTH.set,
      MIN_TRANSFER_BUFFER_LENGTH: cells[148].MIN_TRANSFER_BUFFER_LENGTH.set,
      makeAtomicsTrapHost: cells[148].makeAtomicsTrapHost.set,
      makeAtomicsTrapGuest: cells[148].makeAtomicsTrapGuest.set,
    },
    importMeta: {},
  });
  functors[149]({
    imports(entries) {
      const map = new Map(entries);
      observeImports(map, "@endo/nat", 132);
      observeImports(map, "@endo/marshal", 142);
      observeImports(map, "./captp.js", 146);
      observeImports(map, "./loopback.js", 147);
      observeImports(map, "./atomics.js", 148);
    },
    liveVar: {
    },
    onceVar: {
    },
    importMeta: {},
  });
  functors[150]({
    imports(entries) {
      const map = new Map(entries);
      observeImports(map, "@endo/eventual-send", 115);
      observeImports(map, "@endo/promise-kit", 107);
    },
    liveVar: {
    },
    onceVar: {
      makeQueue: cells[150].makeQueue.set,
      makeStream: cells[150].makeStream.set,
      makePipe: cells[150].makePipe.set,
      pump: cells[150].pump.set,
      prime: cells[150].prime.set,
      mapReader: cells[150].mapReader.set,
      mapWriter: cells[150].mapWriter.set,
    },
    importMeta: {},
  });
  functors[151]({
    imports(entries) {
      const map = new Map(entries);
    },
    liveVar: {
    },
    onceVar: {
      makeNetstringReader: cells[151].makeNetstringReader.set,
      netstringReader: cells[151].netstringReader.set,
    },
    importMeta: {},
  });
  functors[152]({
    imports(entries) {
      const map = new Map(entries);
    },
    liveVar: {
    },
    onceVar: {
      makeNetstringWriter: cells[152].makeNetstringWriter.set,
      netstringWriter: cells[152].netstringWriter.set,
    },
    importMeta: {},
  });
  functors[153]({
    imports(entries) {
      const map = new Map(entries);
      observeImports(map, "./reader.js", 151);
      observeImports(map, "./writer.js", 152);
    },
    liveVar: {
    },
    onceVar: {
    },
    importMeta: {},
  });
  functors[154]({
    imports(entries) {
      const map = new Map(entries);
      observeImports(map, "@endo/captp", 149);
      observeImports(map, "@endo/stream", 150);
      observeImports(map, "@endo/netstring", 153);
    },
    liveVar: {
    },
    onceVar: {
      makeMessageCapTP: cells[154].makeMessageCapTP.set,
      messageToBytes: cells[154].messageToBytes.set,
      bytesToMessage: cells[154].bytesToMessage.set,
      makeNetstringCapTP: cells[154].makeNetstringCapTP.set,
    },
    importMeta: {},
  });
  functors[155]({
    imports(entries) {
      const map = new Map(entries);
    },
    liveVar: {
    },
    onceVar: {
      padding: cells[155].padding.set,
      alphabet64: cells[155].alphabet64.set,
      monodu64: cells[155].monodu64.set,
    },
    importMeta: {},
  });
  functors[156]({
    imports(entries) {
      const map = new Map(entries);
      observeImports(map, "./common.js", 155);
    },
    liveVar: {
    },
    onceVar: {
      encodeBase64: cells[156].encodeBase64.set,
    },
    importMeta: {},
  });
  functors[157]({
    imports(entries) {
      const map = new Map(entries);
      observeImports(map, "./common.js", 155);
    },
    liveVar: {
    },
    onceVar: {
      decodeBase64: cells[157].decodeBase64.set,
    },
    importMeta: {},
  });
  functors[158]({
    imports(entries) {
      const map = new Map(entries);
      observeImports(map, "./src/encode.js", 156);
    },
    liveVar: {
    },
    onceVar: {
    },
    importMeta: {},
  });
  functors[159]({
    imports(entries) {
      const map = new Map(entries);
      observeImports(map, "./encode.js", 158);
    },
    liveVar: {
    },
    onceVar: {
      btoa: cells[159].btoa.set,
    },
    importMeta: {},
  });
  functors[160]({
    imports(entries) {
      const map = new Map(entries);
      observeImports(map, "./src/decode.js", 157);
    },
    liveVar: {
    },
    onceVar: {
    },
    importMeta: {},
  });
  functors[161]({
    imports(entries) {
      const map = new Map(entries);
      observeImports(map, "./decode.js", 160);
    },
    liveVar: {
    },
    onceVar: {
      atob: cells[161].atob.set,
    },
    importMeta: {},
  });
  functors[162]({
    imports(entries) {
      const map = new Map(entries);
      observeImports(map, "./src/encode.js", 156);
      observeImports(map, "./src/decode.js", 157);
      observeImports(map, "./btoa.js", 159);
      observeImports(map, "./atob.js", 161);
    },
    liveVar: {
    },
    onceVar: {
    },
    importMeta: {},
  });
  functors[163]({
    imports(entries) {
      const map = new Map(entries);
      observeImports(map, "@endo/base64", 162);
      observeImports(map, "@endo/stream", 150);
      observeImports(map, "@endo/far", 131);
    },
    liveVar: {
    },
    onceVar: {
      makeRefIterator: cells[163].makeRefIterator.set,
      makeRefReader: cells[163].makeRefReader.set,
    },
    importMeta: {},
  });
  functors[164]({
    imports(entries) {
      const map = new Map(entries);
      observeImports(map, "@endo/base64", 162);
      observeImports(map, "@endo/stream", 150);
      observeImports(map, "@endo/far", 131);
    },
    liveVar: {
    },
    onceVar: {
      asyncIterate: cells[164].asyncIterate.set,
      makeIteratorRef: cells[164].makeIteratorRef.set,
      makeReaderRef: cells[164].makeReaderRef.set,
    },
    importMeta: {},
  });
  functors[165]({
    imports(entries) {
      const map = new Map(entries);
    },
    liveVar: {
    },
    onceVar: {
      assertPetName: cells[165].assertPetName.set,
    },
    importMeta: {},
  });
  functors[166]({
    imports(entries) {
      const map = new Map(entries);
      observeImports(map, "@endo/promise-kit", 107);
      observeImports(map, "@endo/stream", 150);
    },
    liveVar: {
    },
    onceVar: {
      makeNullQueue: cells[166].makeNullQueue.set,
      nullIteratorQueue: cells[166].nullIteratorQueue.set,
      makeChangePubSub: cells[166].makeChangePubSub.set,
      makeChangeTopic: cells[166].makeChangeTopic.set,
    },
    importMeta: {},
  });
  functors[167]({
    imports(entries) {
      const map = new Map(entries);
      observeImports(map, "@endo/far", 131);
      observeImports(map, "./pet-name.js", 165);
      observeImports(map, "./pubsub.js", 166);
      observeImports(map, "./reader-ref.js", 164);
    },
    liveVar: {
    },
    onceVar: {
      makeIdentifiedPetStore: cells[167].makeIdentifiedPetStore.set,
      makeOwnPetStore: cells[167].makeOwnPetStore.set,
    },
    importMeta: {},
  });
  functors[168]({
    imports(entries) {
      const map = new Map(entries);
      observeImports(map, "@endo/promise-kit", 107);
      observeImports(map, "./pubsub.js", 166);
      observeImports(map, "./reader-ref.js", 164);
      observeImports(map, "./pet-name.js", 165);
    },
    liveVar: {
    },
    onceVar: {
      makeMailboxMaker: cells[168].makeMailboxMaker.set,
    },
    importMeta: {},
  });
  functors[169]({
    imports(entries) {
      const map = new Map(entries);
      observeImports(map, "@endo/far", 131);
    },
    liveVar: {
    },
    onceVar: {
      makeGuestMaker: cells[169].makeGuestMaker.set,
    },
    importMeta: {},
  });
  functors[170]({
    imports(entries) {
      const map = new Map(entries);
      observeImports(map, "@endo/far", 131);
      observeImports(map, "./pet-name.js", 165);
    },
    liveVar: {
    },
    onceVar: {
      makeHostMaker: cells[170].makeHostMaker.set,
    },
    importMeta: {},
  });
  functors[171]({
    imports(entries) {
      const map = new Map(entries);
      observeImports(map, "@endo/far", 131);
      observeImports(map, "@endo/stream", 150);
      observeImports(map, "./connection.js", 154);
    },
    liveVar: {
    },
    onceVar: {
      servePrivatePortHttp: cells[171].servePrivatePortHttp.set,
    },
    importMeta: {},
  });
  functors[172]({
    imports(entries) {
      const map = new Map(entries);
      observeImports(map, "./connection.js", 154);
    },
    liveVar: {
    },
    onceVar: {
      servePrivatePath: cells[172].servePrivatePath.set,
    },
    importMeta: {},
  });
  functors[173]({
    imports(entries) {
      const map = new Map(entries);
      observeImports(map, "ses", 52);
      observeImports(map, "@endo/eventual-send/shim.js", 112);
      observeImports(map, "@endo/promise-kit/shim.js", 54);
      observeImports(map, "@endo/lockdown/commit.js", 57);
      observeImports(map, "@endo/far", 131);
      observeImports(map, "@endo/promise-kit", 107);
      observeImports(map, "./connection.js", 154);
      observeImports(map, "./ref-reader.js", 163);
      observeImports(map, "./reader-ref.js", 164);
      observeImports(map, "./pet-store.js", 167);
      observeImports(map, "./mail.js", 168);
      observeImports(map, "./guest.js", 169);
      observeImports(map, "./host.js", 170);
      observeImports(map, "./serve-private-port-http.js", 171);
      observeImports(map, "./serve-private-path.js", 172);
    },
    liveVar: {
    },
    onceVar: {
      main: cells[173].main.set,
    },
    importMeta: {},
  });
  functors[174]({
    imports(entries) {
      const map = new Map(entries);
      observeImports(map, "@endo/stream", 150);
    },
    liveVar: {
    },
    onceVar: {
      makeNodeReader: cells[174].makeNodeReader.set,
    },
    importMeta: {},
  });
  functors[175]({
    imports(entries) {
      const map = new Map(entries);
    },
    liveVar: {
    },
    onceVar: {
      makeNodeWriter: cells[175].makeNodeWriter.set,
    },
    importMeta: {},
  });
  functors[176]({
    imports(entries) {
      const map = new Map(entries);
      observeImports(map, "./reader.js", 174);
      observeImports(map, "./writer.js", 175);
    },
    liveVar: {
    },
    onceVar: {
    },
    importMeta: {},
  });
  wrapCjsFunctor(177)({imports: {}});
  functors[178]({
    imports(entries) {
      const map = new Map(entries);
      observeImports(map, "@endo/stream", 150);
    },
    liveVar: {
    },
    onceVar: {
      makeWebWorkerWriter: cells[178].makeWebWorkerWriter.set,
      makeWebWorkerReader: cells[178].makeWebWorkerReader.set,
    },
    importMeta: {},
  });
  functors[179]({
    imports(entries) {
      const map = new Map(entries);
      observeImports(map, "@endo/promise-kit", 107);
      observeImports(map, "@endo/stream", 150);
      observeImports(map, "@endo/stream-node", 176);
      observeImports(map, "events", 177);
      observeImports(map, "./web-worker-util.js", 178);
    },
    liveVar: {
    },
    onceVar: {
      makeHttpPowers: cells[179].makeHttpPowers.set,
      makePowers: cells[179].makePowers.set,
    },
    importMeta: {},
  });
  functors[180]({
    imports(entries) {
      const map = new Map(entries);
      observeImports(map, "./environment.js", 0);
      observeImports(map, "ses", 52);
      observeImports(map, "@endo/promise-kit/shim.js", 54);
      observeImports(map, "@endo/lockdown/commit.js", 57);
      observeImports(map, "url", 89);
      observeImports(map, "buffer", 92);
      observeImports(map, "browserfs", 93);
      observeImports(map, "make-dir", 103);
      observeImports(map, "@endo/promise-kit", 107);
      observeImports(map, "../daemon.js", 173);
      observeImports(map, "./daemon-web-powers.js", 179);
      observeImports(map, "../connection.js", 154);
      observeImports(map, "@endo/far", 131);
    },
    liveVar: {
    },
    onceVar: {
    },
    importMeta: {},
  });

  return cells[cells.length - 1]['*'].get();
})();
